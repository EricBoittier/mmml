#!/usr/bin/env python3
"""
Example script showing how to load and use preclassified data
generated by fix_and_split_cli.py
"""

import numpy as np
from pathlib import Path


def main():
    """Load and display preclassified data."""
    
    # Path to preclassified data directory
    data_dir = Path(__file__).parent / "preclassified_data"
    
    if not data_dir.exists():
        print(f"‚ùå Preclassified data directory not found: {data_dir}")
        print("\nRun fix_and_split_cli.py first to generate the data:")
        print("  python fix_and_split_cli.py --efd <efd_file> --grid <grid_file> --output-dir ./preclassified_data")
        return
    
    print("="*70)
    print("Loading Preclassified CO2 Data")
    print("="*70)
    
    # Load training data
    print("\nüìÅ Loading training data...")
    train_efd = np.load(data_dir / "energies_forces_dipoles_train.npz")
    train_grid = np.load(data_dir / "grids_esp_train.npz")
    
    # Extract arrays
    R = train_efd['R']        # Atomic coordinates [Angstrom]
    Z = train_efd['Z']        # Atomic numbers
    N = train_efd['N']        # Number of atoms
    E = train_efd['E']        # Energies [eV]
    F = train_efd['F']        # Forces [eV/Angstrom]
    Dxyz = train_efd['Dxyz']  # Dipoles [Debye]
    
    esp = train_grid['esp']              # ESP values [Hartree/e]
    vdw_surface = train_grid['vdw_surface']  # Grid coords [Angstrom]
    
    # Display information
    print(f"\n‚úÖ Successfully loaded {len(R)} training samples")
    
    print("\n" + "="*70)
    print("Dataset Properties")
    print("="*70)
    
    print(f"\nüìä Array Shapes:")
    print(f"  R (coordinates):  {R.shape} [Angstrom]")
    print(f"  Z (atomic nums):  {Z.shape}")
    print(f"  N (num atoms):    {N.shape}")
    print(f"  E (energies):     {E.shape} [eV]")
    print(f"  F (forces):       {F.shape} [eV/Angstrom]")
    print(f"  Dxyz (dipoles):   {Dxyz.shape} [Debye]")
    print(f"  esp (values):     {esp.shape} [Hartree/e]")
    print(f"  vdw_surface:      {vdw_surface.shape} [Angstrom]")
    
    print(f"\nüìà Value Ranges:")
    print(f"  Energies:    [{E.min():.2f}, {E.max():.2f}] eV")
    print(f"  Dipoles:     [{Dxyz.min():.4f}, {Dxyz.max():.4f}] Debye")
    print(f"  ESP values:  [{esp.min():.4f}, {esp.max():.4f}] Hartree/e")
    
    # Analyze first sample
    print("\n" + "="*70)
    print("First Sample Analysis")
    print("="*70)
    
    r0 = R[0]
    z0 = Z[0]
    n0 = N[0]
    valid = z0 > 0
    
    print(f"\nüî¨ Sample 0:")
    print(f"  Number of atoms: {n0}")
    print(f"  Atomic numbers: {z0[valid]}")
    print(f"  Energy: {E[0]:.6f} eV")
    print(f"  Dipole magnitude: {np.linalg.norm(Dxyz[0]):.6f} Debye")
    
    # Calculate bond lengths for CO2
    if n0 == 3 and np.all(z0[valid] == [8, 6, 8]):
        r_valid = r0[valid]
        co1 = np.linalg.norm(r_valid[0] - r_valid[1])
        co2 = np.linalg.norm(r_valid[1] - r_valid[2])
        print(f"  C-O bond 1: {co1:.4f} Angstrom")
        print(f"  C-O bond 2: {co2:.4f} Angstrom")
    
    # Force statistics
    f0 = F[0, :n0, :]
    f_norms = np.linalg.norm(f0, axis=1)
    print(f"  Force magnitudes: {f_norms}")
    print(f"  Mean force: {f_norms.mean():.6f} eV/Angstrom")
    print(f"  Max force:  {f_norms.max():.6f} eV/Angstrom")
    
    # ESP grid info
    grid0 = vdw_surface[0]
    grid_extent = grid0.max(axis=0) - grid0.min(axis=0)
    print(f"  ESP grid points: {len(grid0)}")
    print(f"  Grid extent: [{grid_extent[0]:.2f}, {grid_extent[1]:.2f}, {grid_extent[2]:.2f}] Angstrom")
    print(f"  ESP range: [{esp[0].min():.4f}, {esp[0].max():.4f}] Hartree/e")
    
    # Load validation and test sets
    print("\n" + "="*70)
    print("Other Splits")
    print("="*70)
    
    valid_efd = np.load(data_dir / "energies_forces_dipoles_valid.npz")
    test_efd = np.load(data_dir / "energies_forces_dipoles_test.npz")
    
    print(f"\nüìä Dataset Sizes:")
    print(f"  Training:   {len(train_efd['R'])} samples")
    print(f"  Validation: {len(valid_efd['R'])} samples")
    print(f"  Test:       {len(test_efd['R'])} samples")
    print(f"  Total:      {len(train_efd['R']) + len(valid_efd['R']) + len(test_efd['R'])} samples")
    
    # Load split indices
    split_indices = np.load(data_dir / "split_indices.npz")
    print(f"\nüîÄ Split Indices:")
    print(f"  Train indices: {len(split_indices['train'])} (first 5: {split_indices['train'][:5]})")
    print(f"  Valid indices: {len(split_indices['valid'])} (first 5: {split_indices['valid'][:5]})")
    print(f"  Test indices:  {len(split_indices['test'])} (first 5: {split_indices['test'][:5]})")
    
    print("\n" + "="*70)
    print("‚úÖ All Units are ASE-Standard!")
    print("="*70)
    print("""
  ‚úì Coordinates in Angstroms
  ‚úì Energies in eV
  ‚úì Forces in eV/Angstrom
  ‚úì Dipoles in Debye
  ‚úì ESP grid in physical Angstroms
  
  Ready to use with DCMnet, PhysnetJax, SchNetPack, etc.!
    """)
    
    print("="*70)
    print("Usage Example:")
    print("="*70)
    print("""
# In your training script:
import numpy as np

train_data = np.load('preclassified_data/energies_forces_dipoles_train.npz')
train_grid = np.load('preclassified_data/grids_esp_train.npz')

# Access data - all units are correct!
R = train_data['R']      # Angstroms
E = train_data['E']      # eV
F = train_data['F']      # eV/Angstrom
esp = train_grid['esp']  # Hartree/e

# No unit conversion needed - ready to train!
    """)


if __name__ == "__main__":
    main()

