import {
  __commonJS,
  __export,
  __publicField,
  __toESM,
  require_react
} from "./chunk-WXTH2UMW.js";

// node_modules/lodash/lodash.js
var require_lodash = __commonJS({
  "node_modules/lodash/lodash.js"(exports, module) {
    (function() {
      var undefined2;
      var VERSION2 = "4.17.23";
      var LARGE_ARRAY_SIZE = 200;
      var CORE_ERROR_TEXT = "Unsupported core-js use. Try https://npms.io/search?q=ponyfill.", FUNC_ERROR_TEXT = "Expected a function", INVALID_TEMPL_VAR_ERROR_TEXT = "Invalid `variable` option passed into `_.template`";
      var HASH_UNDEFINED = "__lodash_hash_undefined__";
      var MAX_MEMOIZE_SIZE = 500;
      var PLACEHOLDER = "__lodash_placeholder__";
      var CLONE_DEEP_FLAG = 1, CLONE_FLAT_FLAG = 2, CLONE_SYMBOLS_FLAG = 4;
      var COMPARE_PARTIAL_FLAG = 1, COMPARE_UNORDERED_FLAG = 2;
      var WRAP_BIND_FLAG = 1, WRAP_BIND_KEY_FLAG = 2, WRAP_CURRY_BOUND_FLAG = 4, WRAP_CURRY_FLAG = 8, WRAP_CURRY_RIGHT_FLAG = 16, WRAP_PARTIAL_FLAG = 32, WRAP_PARTIAL_RIGHT_FLAG = 64, WRAP_ARY_FLAG = 128, WRAP_REARG_FLAG = 256, WRAP_FLIP_FLAG = 512;
      var DEFAULT_TRUNC_LENGTH = 30, DEFAULT_TRUNC_OMISSION = "...";
      var HOT_COUNT = 800, HOT_SPAN = 16;
      var LAZY_FILTER_FLAG = 1, LAZY_MAP_FLAG = 2, LAZY_WHILE_FLAG = 3;
      var INFINITY = 1 / 0, MAX_SAFE_INTEGER = 9007199254740991, MAX_INTEGER = 17976931348623157e292, NAN = 0 / 0;
      var MAX_ARRAY_LENGTH = 4294967295, MAX_ARRAY_INDEX = MAX_ARRAY_LENGTH - 1, HALF_MAX_ARRAY_LENGTH = MAX_ARRAY_LENGTH >>> 1;
      var wrapFlags = [
        ["ary", WRAP_ARY_FLAG],
        ["bind", WRAP_BIND_FLAG],
        ["bindKey", WRAP_BIND_KEY_FLAG],
        ["curry", WRAP_CURRY_FLAG],
        ["curryRight", WRAP_CURRY_RIGHT_FLAG],
        ["flip", WRAP_FLIP_FLAG],
        ["partial", WRAP_PARTIAL_FLAG],
        ["partialRight", WRAP_PARTIAL_RIGHT_FLAG],
        ["rearg", WRAP_REARG_FLAG]
      ];
      var argsTag = "[object Arguments]", arrayTag = "[object Array]", asyncTag = "[object AsyncFunction]", boolTag = "[object Boolean]", dateTag = "[object Date]", domExcTag = "[object DOMException]", errorTag = "[object Error]", funcTag = "[object Function]", genTag = "[object GeneratorFunction]", mapTag = "[object Map]", numberTag = "[object Number]", nullTag = "[object Null]", objectTag = "[object Object]", promiseTag = "[object Promise]", proxyTag = "[object Proxy]", regexpTag = "[object RegExp]", setTag = "[object Set]", stringTag = "[object String]", symbolTag = "[object Symbol]", undefinedTag = "[object Undefined]", weakMapTag = "[object WeakMap]", weakSetTag = "[object WeakSet]";
      var arrayBufferTag = "[object ArrayBuffer]", dataViewTag = "[object DataView]", float32Tag = "[object Float32Array]", float64Tag = "[object Float64Array]", int8Tag = "[object Int8Array]", int16Tag = "[object Int16Array]", int32Tag = "[object Int32Array]", uint8Tag = "[object Uint8Array]", uint8ClampedTag = "[object Uint8ClampedArray]", uint16Tag = "[object Uint16Array]", uint32Tag = "[object Uint32Array]";
      var reEmptyStringLeading = /\b__p \+= '';/g, reEmptyStringMiddle = /\b(__p \+=) '' \+/g, reEmptyStringTrailing = /(__e\(.*?\)|\b__t\)) \+\n'';/g;
      var reEscapedHtml = /&(?:amp|lt|gt|quot|#39);/g, reUnescapedHtml = /[&<>"']/g, reHasEscapedHtml = RegExp(reEscapedHtml.source), reHasUnescapedHtml = RegExp(reUnescapedHtml.source);
      var reEscape = /<%-([\s\S]+?)%>/g, reEvaluate = /<%([\s\S]+?)%>/g, reInterpolate = /<%=([\s\S]+?)%>/g;
      var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/, reIsPlainProp = /^\w*$/, rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;
      var reRegExpChar = /[\\^$.*+?()[\]{}|]/g, reHasRegExpChar = RegExp(reRegExpChar.source);
      var reTrimStart = /^\s+/;
      var reWhitespace = /\s/;
      var reWrapComment = /\{(?:\n\/\* \[wrapped with .+\] \*\/)?\n?/, reWrapDetails = /\{\n\/\* \[wrapped with (.+)\] \*/, reSplitDetails = /,? & /;
      var reAsciiWord = /[^\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\x7f]+/g;
      var reForbiddenIdentifierChars = /[()=,{}\[\]\/\s]/;
      var reEscapeChar = /\\(\\)?/g;
      var reEsTemplate = /\$\{([^\\}]*(?:\\.[^\\}]*)*)\}/g;
      var reFlags = /\w*$/;
      var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;
      var reIsBinary = /^0b[01]+$/i;
      var reIsHostCtor = /^\[object .+?Constructor\]$/;
      var reIsOctal = /^0o[0-7]+$/i;
      var reIsUint = /^(?:0|[1-9]\d*)$/;
      var reLatin = /[\xc0-\xd6\xd8-\xf6\xf8-\xff\u0100-\u017f]/g;
      var reNoMatch = /($^)/;
      var reUnescapedString = /['\n\r\u2028\u2029\\]/g;
      var rsAstralRange = "\\ud800-\\udfff", rsComboMarksRange = "\\u0300-\\u036f", reComboHalfMarksRange = "\\ufe20-\\ufe2f", rsComboSymbolsRange = "\\u20d0-\\u20ff", rsComboRange = rsComboMarksRange + reComboHalfMarksRange + rsComboSymbolsRange, rsDingbatRange = "\\u2700-\\u27bf", rsLowerRange = "a-z\\xdf-\\xf6\\xf8-\\xff", rsMathOpRange = "\\xac\\xb1\\xd7\\xf7", rsNonCharRange = "\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\xbf", rsPunctuationRange = "\\u2000-\\u206f", rsSpaceRange = " \\t\\x0b\\f\\xa0\\ufeff\\n\\r\\u2028\\u2029\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000", rsUpperRange = "A-Z\\xc0-\\xd6\\xd8-\\xde", rsVarRange = "\\ufe0e\\ufe0f", rsBreakRange = rsMathOpRange + rsNonCharRange + rsPunctuationRange + rsSpaceRange;
      var rsApos = "['’]", rsAstral = "[" + rsAstralRange + "]", rsBreak = "[" + rsBreakRange + "]", rsCombo = "[" + rsComboRange + "]", rsDigits = "\\d+", rsDingbat = "[" + rsDingbatRange + "]", rsLower = "[" + rsLowerRange + "]", rsMisc = "[^" + rsAstralRange + rsBreakRange + rsDigits + rsDingbatRange + rsLowerRange + rsUpperRange + "]", rsFitz = "\\ud83c[\\udffb-\\udfff]", rsModifier = "(?:" + rsCombo + "|" + rsFitz + ")", rsNonAstral = "[^" + rsAstralRange + "]", rsRegional = "(?:\\ud83c[\\udde6-\\uddff]){2}", rsSurrPair = "[\\ud800-\\udbff][\\udc00-\\udfff]", rsUpper = "[" + rsUpperRange + "]", rsZWJ = "\\u200d";
      var rsMiscLower = "(?:" + rsLower + "|" + rsMisc + ")", rsMiscUpper = "(?:" + rsUpper + "|" + rsMisc + ")", rsOptContrLower = "(?:" + rsApos + "(?:d|ll|m|re|s|t|ve))?", rsOptContrUpper = "(?:" + rsApos + "(?:D|LL|M|RE|S|T|VE))?", reOptMod = rsModifier + "?", rsOptVar = "[" + rsVarRange + "]?", rsOptJoin = "(?:" + rsZWJ + "(?:" + [rsNonAstral, rsRegional, rsSurrPair].join("|") + ")" + rsOptVar + reOptMod + ")*", rsOrdLower = "\\d*(?:1st|2nd|3rd|(?![123])\\dth)(?=\\b|[A-Z_])", rsOrdUpper = "\\d*(?:1ST|2ND|3RD|(?![123])\\dTH)(?=\\b|[a-z_])", rsSeq = rsOptVar + reOptMod + rsOptJoin, rsEmoji = "(?:" + [rsDingbat, rsRegional, rsSurrPair].join("|") + ")" + rsSeq, rsSymbol = "(?:" + [rsNonAstral + rsCombo + "?", rsCombo, rsRegional, rsSurrPair, rsAstral].join("|") + ")";
      var reApos = RegExp(rsApos, "g");
      var reComboMark = RegExp(rsCombo, "g");
      var reUnicode = RegExp(rsFitz + "(?=" + rsFitz + ")|" + rsSymbol + rsSeq, "g");
      var reUnicodeWord = RegExp([
        rsUpper + "?" + rsLower + "+" + rsOptContrLower + "(?=" + [rsBreak, rsUpper, "$"].join("|") + ")",
        rsMiscUpper + "+" + rsOptContrUpper + "(?=" + [rsBreak, rsUpper + rsMiscLower, "$"].join("|") + ")",
        rsUpper + "?" + rsMiscLower + "+" + rsOptContrLower,
        rsUpper + "+" + rsOptContrUpper,
        rsOrdUpper,
        rsOrdLower,
        rsDigits,
        rsEmoji
      ].join("|"), "g");
      var reHasUnicode = RegExp("[" + rsZWJ + rsAstralRange + rsComboRange + rsVarRange + "]");
      var reHasUnicodeWord = /[a-z][A-Z]|[A-Z]{2}[a-z]|[0-9][a-zA-Z]|[a-zA-Z][0-9]|[^a-zA-Z0-9 ]/;
      var contextProps = [
        "Array",
        "Buffer",
        "DataView",
        "Date",
        "Error",
        "Float32Array",
        "Float64Array",
        "Function",
        "Int8Array",
        "Int16Array",
        "Int32Array",
        "Map",
        "Math",
        "Object",
        "Promise",
        "RegExp",
        "Set",
        "String",
        "Symbol",
        "TypeError",
        "Uint8Array",
        "Uint8ClampedArray",
        "Uint16Array",
        "Uint32Array",
        "WeakMap",
        "_",
        "clearTimeout",
        "isFinite",
        "parseInt",
        "setTimeout"
      ];
      var templateCounter = -1;
      var typedArrayTags = {};
      typedArrayTags[float32Tag] = typedArrayTags[float64Tag] = typedArrayTags[int8Tag] = typedArrayTags[int16Tag] = typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] = typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] = typedArrayTags[uint32Tag] = true;
      typedArrayTags[argsTag] = typedArrayTags[arrayTag] = typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] = typedArrayTags[dataViewTag] = typedArrayTags[dateTag] = typedArrayTags[errorTag] = typedArrayTags[funcTag] = typedArrayTags[mapTag] = typedArrayTags[numberTag] = typedArrayTags[objectTag] = typedArrayTags[regexpTag] = typedArrayTags[setTag] = typedArrayTags[stringTag] = typedArrayTags[weakMapTag] = false;
      var cloneableTags = {};
      cloneableTags[argsTag] = cloneableTags[arrayTag] = cloneableTags[arrayBufferTag] = cloneableTags[dataViewTag] = cloneableTags[boolTag] = cloneableTags[dateTag] = cloneableTags[float32Tag] = cloneableTags[float64Tag] = cloneableTags[int8Tag] = cloneableTags[int16Tag] = cloneableTags[int32Tag] = cloneableTags[mapTag] = cloneableTags[numberTag] = cloneableTags[objectTag] = cloneableTags[regexpTag] = cloneableTags[setTag] = cloneableTags[stringTag] = cloneableTags[symbolTag] = cloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] = cloneableTags[uint16Tag] = cloneableTags[uint32Tag] = true;
      cloneableTags[errorTag] = cloneableTags[funcTag] = cloneableTags[weakMapTag] = false;
      var deburredLetters = {
        // Latin-1 Supplement block.
        "À": "A",
        "Á": "A",
        "Â": "A",
        "Ã": "A",
        "Ä": "A",
        "Å": "A",
        "à": "a",
        "á": "a",
        "â": "a",
        "ã": "a",
        "ä": "a",
        "å": "a",
        "Ç": "C",
        "ç": "c",
        "Ð": "D",
        "ð": "d",
        "È": "E",
        "É": "E",
        "Ê": "E",
        "Ë": "E",
        "è": "e",
        "é": "e",
        "ê": "e",
        "ë": "e",
        "Ì": "I",
        "Í": "I",
        "Î": "I",
        "Ï": "I",
        "ì": "i",
        "í": "i",
        "î": "i",
        "ï": "i",
        "Ñ": "N",
        "ñ": "n",
        "Ò": "O",
        "Ó": "O",
        "Ô": "O",
        "Õ": "O",
        "Ö": "O",
        "Ø": "O",
        "ò": "o",
        "ó": "o",
        "ô": "o",
        "õ": "o",
        "ö": "o",
        "ø": "o",
        "Ù": "U",
        "Ú": "U",
        "Û": "U",
        "Ü": "U",
        "ù": "u",
        "ú": "u",
        "û": "u",
        "ü": "u",
        "Ý": "Y",
        "ý": "y",
        "ÿ": "y",
        "Æ": "Ae",
        "æ": "ae",
        "Þ": "Th",
        "þ": "th",
        "ß": "ss",
        // Latin Extended-A block.
        "Ā": "A",
        "Ă": "A",
        "Ą": "A",
        "ā": "a",
        "ă": "a",
        "ą": "a",
        "Ć": "C",
        "Ĉ": "C",
        "Ċ": "C",
        "Č": "C",
        "ć": "c",
        "ĉ": "c",
        "ċ": "c",
        "č": "c",
        "Ď": "D",
        "Đ": "D",
        "ď": "d",
        "đ": "d",
        "Ē": "E",
        "Ĕ": "E",
        "Ė": "E",
        "Ę": "E",
        "Ě": "E",
        "ē": "e",
        "ĕ": "e",
        "ė": "e",
        "ę": "e",
        "ě": "e",
        "Ĝ": "G",
        "Ğ": "G",
        "Ġ": "G",
        "Ģ": "G",
        "ĝ": "g",
        "ğ": "g",
        "ġ": "g",
        "ģ": "g",
        "Ĥ": "H",
        "Ħ": "H",
        "ĥ": "h",
        "ħ": "h",
        "Ĩ": "I",
        "Ī": "I",
        "Ĭ": "I",
        "Į": "I",
        "İ": "I",
        "ĩ": "i",
        "ī": "i",
        "ĭ": "i",
        "į": "i",
        "ı": "i",
        "Ĵ": "J",
        "ĵ": "j",
        "Ķ": "K",
        "ķ": "k",
        "ĸ": "k",
        "Ĺ": "L",
        "Ļ": "L",
        "Ľ": "L",
        "Ŀ": "L",
        "Ł": "L",
        "ĺ": "l",
        "ļ": "l",
        "ľ": "l",
        "ŀ": "l",
        "ł": "l",
        "Ń": "N",
        "Ņ": "N",
        "Ň": "N",
        "Ŋ": "N",
        "ń": "n",
        "ņ": "n",
        "ň": "n",
        "ŋ": "n",
        "Ō": "O",
        "Ŏ": "O",
        "Ő": "O",
        "ō": "o",
        "ŏ": "o",
        "ő": "o",
        "Ŕ": "R",
        "Ŗ": "R",
        "Ř": "R",
        "ŕ": "r",
        "ŗ": "r",
        "ř": "r",
        "Ś": "S",
        "Ŝ": "S",
        "Ş": "S",
        "Š": "S",
        "ś": "s",
        "ŝ": "s",
        "ş": "s",
        "š": "s",
        "Ţ": "T",
        "Ť": "T",
        "Ŧ": "T",
        "ţ": "t",
        "ť": "t",
        "ŧ": "t",
        "Ũ": "U",
        "Ū": "U",
        "Ŭ": "U",
        "Ů": "U",
        "Ű": "U",
        "Ų": "U",
        "ũ": "u",
        "ū": "u",
        "ŭ": "u",
        "ů": "u",
        "ű": "u",
        "ų": "u",
        "Ŵ": "W",
        "ŵ": "w",
        "Ŷ": "Y",
        "ŷ": "y",
        "Ÿ": "Y",
        "Ź": "Z",
        "Ż": "Z",
        "Ž": "Z",
        "ź": "z",
        "ż": "z",
        "ž": "z",
        "Ĳ": "IJ",
        "ĳ": "ij",
        "Œ": "Oe",
        "œ": "oe",
        "ŉ": "'n",
        "ſ": "s"
      };
      var htmlEscapes = {
        "&": "&amp;",
        "<": "&lt;",
        ">": "&gt;",
        '"': "&quot;",
        "'": "&#39;"
      };
      var htmlUnescapes = {
        "&amp;": "&",
        "&lt;": "<",
        "&gt;": ">",
        "&quot;": '"',
        "&#39;": "'"
      };
      var stringEscapes = {
        "\\": "\\",
        "'": "'",
        "\n": "n",
        "\r": "r",
        "\u2028": "u2028",
        "\u2029": "u2029"
      };
      var freeParseFloat = parseFloat, freeParseInt = parseInt;
      var freeGlobal = typeof global == "object" && global && global.Object === Object && global;
      var freeSelf = typeof self == "object" && self && self.Object === Object && self;
      var root = freeGlobal || freeSelf || Function("return this")();
      var freeExports = typeof exports == "object" && exports && !exports.nodeType && exports;
      var freeModule = freeExports && typeof module == "object" && module && !module.nodeType && module;
      var moduleExports = freeModule && freeModule.exports === freeExports;
      var freeProcess = moduleExports && freeGlobal.process;
      var nodeUtil = function() {
        try {
          var types = freeModule && freeModule.require && freeModule.require("util").types;
          if (types) {
            return types;
          }
          return freeProcess && freeProcess.binding && freeProcess.binding("util");
        } catch (e2) {
        }
      }();
      var nodeIsArrayBuffer = nodeUtil && nodeUtil.isArrayBuffer, nodeIsDate = nodeUtil && nodeUtil.isDate, nodeIsMap = nodeUtil && nodeUtil.isMap, nodeIsRegExp = nodeUtil && nodeUtil.isRegExp, nodeIsSet = nodeUtil && nodeUtil.isSet, nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;
      function apply(func, thisArg, args) {
        switch (args.length) {
          case 0:
            return func.call(thisArg);
          case 1:
            return func.call(thisArg, args[0]);
          case 2:
            return func.call(thisArg, args[0], args[1]);
          case 3:
            return func.call(thisArg, args[0], args[1], args[2]);
        }
        return func.apply(thisArg, args);
      }
      function arrayAggregator(array, setter, iteratee, accumulator) {
        var index = -1, length = array == null ? 0 : array.length;
        while (++index < length) {
          var value = array[index];
          setter(accumulator, value, iteratee(value), array);
        }
        return accumulator;
      }
      function arrayEach(array, iteratee) {
        var index = -1, length = array == null ? 0 : array.length;
        while (++index < length) {
          if (iteratee(array[index], index, array) === false) {
            break;
          }
        }
        return array;
      }
      function arrayEachRight(array, iteratee) {
        var length = array == null ? 0 : array.length;
        while (length--) {
          if (iteratee(array[length], length, array) === false) {
            break;
          }
        }
        return array;
      }
      function arrayEvery(array, predicate) {
        var index = -1, length = array == null ? 0 : array.length;
        while (++index < length) {
          if (!predicate(array[index], index, array)) {
            return false;
          }
        }
        return true;
      }
      function arrayFilter(array, predicate) {
        var index = -1, length = array == null ? 0 : array.length, resIndex = 0, result = [];
        while (++index < length) {
          var value = array[index];
          if (predicate(value, index, array)) {
            result[resIndex++] = value;
          }
        }
        return result;
      }
      function arrayIncludes(array, value) {
        var length = array == null ? 0 : array.length;
        return !!length && baseIndexOf(array, value, 0) > -1;
      }
      function arrayIncludesWith(array, value, comparator) {
        var index = -1, length = array == null ? 0 : array.length;
        while (++index < length) {
          if (comparator(value, array[index])) {
            return true;
          }
        }
        return false;
      }
      function arrayMap(array, iteratee) {
        var index = -1, length = array == null ? 0 : array.length, result = Array(length);
        while (++index < length) {
          result[index] = iteratee(array[index], index, array);
        }
        return result;
      }
      function arrayPush(array, values) {
        var index = -1, length = values.length, offset = array.length;
        while (++index < length) {
          array[offset + index] = values[index];
        }
        return array;
      }
      function arrayReduce(array, iteratee, accumulator, initAccum) {
        var index = -1, length = array == null ? 0 : array.length;
        if (initAccum && length) {
          accumulator = array[++index];
        }
        while (++index < length) {
          accumulator = iteratee(accumulator, array[index], index, array);
        }
        return accumulator;
      }
      function arrayReduceRight(array, iteratee, accumulator, initAccum) {
        var length = array == null ? 0 : array.length;
        if (initAccum && length) {
          accumulator = array[--length];
        }
        while (length--) {
          accumulator = iteratee(accumulator, array[length], length, array);
        }
        return accumulator;
      }
      function arraySome(array, predicate) {
        var index = -1, length = array == null ? 0 : array.length;
        while (++index < length) {
          if (predicate(array[index], index, array)) {
            return true;
          }
        }
        return false;
      }
      var asciiSize = baseProperty("length");
      function asciiToArray(string) {
        return string.split("");
      }
      function asciiWords(string) {
        return string.match(reAsciiWord) || [];
      }
      function baseFindKey(collection, predicate, eachFunc) {
        var result;
        eachFunc(collection, function(value, key, collection2) {
          if (predicate(value, key, collection2)) {
            result = key;
            return false;
          }
        });
        return result;
      }
      function baseFindIndex(array, predicate, fromIndex, fromRight) {
        var length = array.length, index = fromIndex + (fromRight ? 1 : -1);
        while (fromRight ? index-- : ++index < length) {
          if (predicate(array[index], index, array)) {
            return index;
          }
        }
        return -1;
      }
      function baseIndexOf(array, value, fromIndex) {
        return value === value ? strictIndexOf(array, value, fromIndex) : baseFindIndex(array, baseIsNaN, fromIndex);
      }
      function baseIndexOfWith(array, value, fromIndex, comparator) {
        var index = fromIndex - 1, length = array.length;
        while (++index < length) {
          if (comparator(array[index], value)) {
            return index;
          }
        }
        return -1;
      }
      function baseIsNaN(value) {
        return value !== value;
      }
      function baseMean(array, iteratee) {
        var length = array == null ? 0 : array.length;
        return length ? baseSum(array, iteratee) / length : NAN;
      }
      function baseProperty(key) {
        return function(object) {
          return object == null ? undefined2 : object[key];
        };
      }
      function basePropertyOf(object) {
        return function(key) {
          return object == null ? undefined2 : object[key];
        };
      }
      function baseReduce(collection, iteratee, accumulator, initAccum, eachFunc) {
        eachFunc(collection, function(value, index, collection2) {
          accumulator = initAccum ? (initAccum = false, value) : iteratee(accumulator, value, index, collection2);
        });
        return accumulator;
      }
      function baseSortBy(array, comparer) {
        var length = array.length;
        array.sort(comparer);
        while (length--) {
          array[length] = array[length].value;
        }
        return array;
      }
      function baseSum(array, iteratee) {
        var result, index = -1, length = array.length;
        while (++index < length) {
          var current = iteratee(array[index]);
          if (current !== undefined2) {
            result = result === undefined2 ? current : result + current;
          }
        }
        return result;
      }
      function baseTimes(n, iteratee) {
        var index = -1, result = Array(n);
        while (++index < n) {
          result[index] = iteratee(index);
        }
        return result;
      }
      function baseToPairs(object, props) {
        return arrayMap(props, function(key) {
          return [key, object[key]];
        });
      }
      function baseTrim(string) {
        return string ? string.slice(0, trimmedEndIndex(string) + 1).replace(reTrimStart, "") : string;
      }
      function baseUnary(func) {
        return function(value) {
          return func(value);
        };
      }
      function baseValues(object, props) {
        return arrayMap(props, function(key) {
          return object[key];
        });
      }
      function cacheHas(cache, key) {
        return cache.has(key);
      }
      function charsStartIndex(strSymbols, chrSymbols) {
        var index = -1, length = strSymbols.length;
        while (++index < length && baseIndexOf(chrSymbols, strSymbols[index], 0) > -1) {
        }
        return index;
      }
      function charsEndIndex(strSymbols, chrSymbols) {
        var index = strSymbols.length;
        while (index-- && baseIndexOf(chrSymbols, strSymbols[index], 0) > -1) {
        }
        return index;
      }
      function countHolders(array, placeholder) {
        var length = array.length, result = 0;
        while (length--) {
          if (array[length] === placeholder) {
            ++result;
          }
        }
        return result;
      }
      var deburrLetter = basePropertyOf(deburredLetters);
      var escapeHtmlChar = basePropertyOf(htmlEscapes);
      function escapeStringChar(chr) {
        return "\\" + stringEscapes[chr];
      }
      function getValue(object, key) {
        return object == null ? undefined2 : object[key];
      }
      function hasUnicode(string) {
        return reHasUnicode.test(string);
      }
      function hasUnicodeWord(string) {
        return reHasUnicodeWord.test(string);
      }
      function iteratorToArray(iterator) {
        var data, result = [];
        while (!(data = iterator.next()).done) {
          result.push(data.value);
        }
        return result;
      }
      function mapToArray(map) {
        var index = -1, result = Array(map.size);
        map.forEach(function(value, key) {
          result[++index] = [key, value];
        });
        return result;
      }
      function overArg(func, transform) {
        return function(arg) {
          return func(transform(arg));
        };
      }
      function replaceHolders(array, placeholder) {
        var index = -1, length = array.length, resIndex = 0, result = [];
        while (++index < length) {
          var value = array[index];
          if (value === placeholder || value === PLACEHOLDER) {
            array[index] = PLACEHOLDER;
            result[resIndex++] = index;
          }
        }
        return result;
      }
      function setToArray(set) {
        var index = -1, result = Array(set.size);
        set.forEach(function(value) {
          result[++index] = value;
        });
        return result;
      }
      function setToPairs(set) {
        var index = -1, result = Array(set.size);
        set.forEach(function(value) {
          result[++index] = [value, value];
        });
        return result;
      }
      function strictIndexOf(array, value, fromIndex) {
        var index = fromIndex - 1, length = array.length;
        while (++index < length) {
          if (array[index] === value) {
            return index;
          }
        }
        return -1;
      }
      function strictLastIndexOf(array, value, fromIndex) {
        var index = fromIndex + 1;
        while (index--) {
          if (array[index] === value) {
            return index;
          }
        }
        return index;
      }
      function stringSize(string) {
        return hasUnicode(string) ? unicodeSize(string) : asciiSize(string);
      }
      function stringToArray(string) {
        return hasUnicode(string) ? unicodeToArray(string) : asciiToArray(string);
      }
      function trimmedEndIndex(string) {
        var index = string.length;
        while (index-- && reWhitespace.test(string.charAt(index))) {
        }
        return index;
      }
      var unescapeHtmlChar = basePropertyOf(htmlUnescapes);
      function unicodeSize(string) {
        var result = reUnicode.lastIndex = 0;
        while (reUnicode.test(string)) {
          ++result;
        }
        return result;
      }
      function unicodeToArray(string) {
        return string.match(reUnicode) || [];
      }
      function unicodeWords(string) {
        return string.match(reUnicodeWord) || [];
      }
      var runInContext = function runInContext2(context) {
        context = context == null ? root : _.defaults(root.Object(), context, _.pick(root, contextProps));
        var Array2 = context.Array, Date2 = context.Date, Error2 = context.Error, Function2 = context.Function, Math2 = context.Math, Object2 = context.Object, RegExp2 = context.RegExp, String2 = context.String, TypeError2 = context.TypeError;
        var arrayProto = Array2.prototype, funcProto = Function2.prototype, objectProto = Object2.prototype;
        var coreJsData = context["__core-js_shared__"];
        var funcToString = funcProto.toString;
        var hasOwnProperty = objectProto.hasOwnProperty;
        var idCounter = 0;
        var maskSrcKey = function() {
          var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || "");
          return uid ? "Symbol(src)_1." + uid : "";
        }();
        var nativeObjectToString = objectProto.toString;
        var objectCtorString = funcToString.call(Object2);
        var oldDash = root._;
        var reIsNative = RegExp2(
          "^" + funcToString.call(hasOwnProperty).replace(reRegExpChar, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
        );
        var Buffer = moduleExports ? context.Buffer : undefined2, Symbol2 = context.Symbol, Uint8Array2 = context.Uint8Array, allocUnsafe = Buffer ? Buffer.allocUnsafe : undefined2, getPrototype = overArg(Object2.getPrototypeOf, Object2), objectCreate = Object2.create, propertyIsEnumerable = objectProto.propertyIsEnumerable, splice = arrayProto.splice, spreadableSymbol = Symbol2 ? Symbol2.isConcatSpreadable : undefined2, symIterator = Symbol2 ? Symbol2.iterator : undefined2, symToStringTag = Symbol2 ? Symbol2.toStringTag : undefined2;
        var defineProperty = function() {
          try {
            var func = getNative(Object2, "defineProperty");
            func({}, "", {});
            return func;
          } catch (e2) {
          }
        }();
        var ctxClearTimeout = context.clearTimeout !== root.clearTimeout && context.clearTimeout, ctxNow = Date2 && Date2.now !== root.Date.now && Date2.now, ctxSetTimeout = context.setTimeout !== root.setTimeout && context.setTimeout;
        var nativeCeil = Math2.ceil, nativeFloor = Math2.floor, nativeGetSymbols = Object2.getOwnPropertySymbols, nativeIsBuffer = Buffer ? Buffer.isBuffer : undefined2, nativeIsFinite = context.isFinite, nativeJoin = arrayProto.join, nativeKeys = overArg(Object2.keys, Object2), nativeMax = Math2.max, nativeMin = Math2.min, nativeNow = Date2.now, nativeParseInt = context.parseInt, nativeRandom = Math2.random, nativeReverse = arrayProto.reverse;
        var DataView2 = getNative(context, "DataView"), Map2 = getNative(context, "Map"), Promise2 = getNative(context, "Promise"), Set2 = getNative(context, "Set"), WeakMap2 = getNative(context, "WeakMap"), nativeCreate = getNative(Object2, "create");
        var metaMap = WeakMap2 && new WeakMap2();
        var realNames = {};
        var dataViewCtorString = toSource(DataView2), mapCtorString = toSource(Map2), promiseCtorString = toSource(Promise2), setCtorString = toSource(Set2), weakMapCtorString = toSource(WeakMap2);
        var symbolProto = Symbol2 ? Symbol2.prototype : undefined2, symbolValueOf = symbolProto ? symbolProto.valueOf : undefined2, symbolToString = symbolProto ? symbolProto.toString : undefined2;
        function lodash(value) {
          if (isObjectLike(value) && !isArray(value) && !(value instanceof LazyWrapper)) {
            if (value instanceof LodashWrapper) {
              return value;
            }
            if (hasOwnProperty.call(value, "__wrapped__")) {
              return wrapperClone(value);
            }
          }
          return new LodashWrapper(value);
        }
        var baseCreate = /* @__PURE__ */ function() {
          function object() {
          }
          return function(proto) {
            if (!isObject(proto)) {
              return {};
            }
            if (objectCreate) {
              return objectCreate(proto);
            }
            object.prototype = proto;
            var result2 = new object();
            object.prototype = undefined2;
            return result2;
          };
        }();
        function baseLodash() {
        }
        function LodashWrapper(value, chainAll) {
          this.__wrapped__ = value;
          this.__actions__ = [];
          this.__chain__ = !!chainAll;
          this.__index__ = 0;
          this.__values__ = undefined2;
        }
        lodash.templateSettings = {
          /**
           * Used to detect `data` property values to be HTML-escaped.
           *
           * @memberOf _.templateSettings
           * @type {RegExp}
           */
          "escape": reEscape,
          /**
           * Used to detect code to be evaluated.
           *
           * @memberOf _.templateSettings
           * @type {RegExp}
           */
          "evaluate": reEvaluate,
          /**
           * Used to detect `data` property values to inject.
           *
           * @memberOf _.templateSettings
           * @type {RegExp}
           */
          "interpolate": reInterpolate,
          /**
           * Used to reference the data object in the template text.
           *
           * @memberOf _.templateSettings
           * @type {string}
           */
          "variable": "",
          /**
           * Used to import variables into the compiled template.
           *
           * @memberOf _.templateSettings
           * @type {Object}
           */
          "imports": {
            /**
             * A reference to the `lodash` function.
             *
             * @memberOf _.templateSettings.imports
             * @type {Function}
             */
            "_": lodash
          }
        };
        lodash.prototype = baseLodash.prototype;
        lodash.prototype.constructor = lodash;
        LodashWrapper.prototype = baseCreate(baseLodash.prototype);
        LodashWrapper.prototype.constructor = LodashWrapper;
        function LazyWrapper(value) {
          this.__wrapped__ = value;
          this.__actions__ = [];
          this.__dir__ = 1;
          this.__filtered__ = false;
          this.__iteratees__ = [];
          this.__takeCount__ = MAX_ARRAY_LENGTH;
          this.__views__ = [];
        }
        function lazyClone() {
          var result2 = new LazyWrapper(this.__wrapped__);
          result2.__actions__ = copyArray2(this.__actions__);
          result2.__dir__ = this.__dir__;
          result2.__filtered__ = this.__filtered__;
          result2.__iteratees__ = copyArray2(this.__iteratees__);
          result2.__takeCount__ = this.__takeCount__;
          result2.__views__ = copyArray2(this.__views__);
          return result2;
        }
        function lazyReverse() {
          if (this.__filtered__) {
            var result2 = new LazyWrapper(this);
            result2.__dir__ = -1;
            result2.__filtered__ = true;
          } else {
            result2 = this.clone();
            result2.__dir__ *= -1;
          }
          return result2;
        }
        function lazyValue() {
          var array = this.__wrapped__.value(), dir = this.__dir__, isArr = isArray(array), isRight = dir < 0, arrLength = isArr ? array.length : 0, view = getView(0, arrLength, this.__views__), start = view.start, end = view.end, length = end - start, index = isRight ? end : start - 1, iteratees = this.__iteratees__, iterLength = iteratees.length, resIndex = 0, takeCount = nativeMin(length, this.__takeCount__);
          if (!isArr || !isRight && arrLength == length && takeCount == length) {
            return baseWrapperValue(array, this.__actions__);
          }
          var result2 = [];
          outer:
            while (length-- && resIndex < takeCount) {
              index += dir;
              var iterIndex = -1, value = array[index];
              while (++iterIndex < iterLength) {
                var data = iteratees[iterIndex], iteratee2 = data.iteratee, type = data.type, computed = iteratee2(value);
                if (type == LAZY_MAP_FLAG) {
                  value = computed;
                } else if (!computed) {
                  if (type == LAZY_FILTER_FLAG) {
                    continue outer;
                  } else {
                    break outer;
                  }
                }
              }
              result2[resIndex++] = value;
            }
          return result2;
        }
        LazyWrapper.prototype = baseCreate(baseLodash.prototype);
        LazyWrapper.prototype.constructor = LazyWrapper;
        function Hash(entries) {
          var index = -1, length = entries == null ? 0 : entries.length;
          this.clear();
          while (++index < length) {
            var entry = entries[index];
            this.set(entry[0], entry[1]);
          }
        }
        function hashClear() {
          this.__data__ = nativeCreate ? nativeCreate(null) : {};
          this.size = 0;
        }
        function hashDelete(key) {
          var result2 = this.has(key) && delete this.__data__[key];
          this.size -= result2 ? 1 : 0;
          return result2;
        }
        function hashGet(key) {
          var data = this.__data__;
          if (nativeCreate) {
            var result2 = data[key];
            return result2 === HASH_UNDEFINED ? undefined2 : result2;
          }
          return hasOwnProperty.call(data, key) ? data[key] : undefined2;
        }
        function hashHas(key) {
          var data = this.__data__;
          return nativeCreate ? data[key] !== undefined2 : hasOwnProperty.call(data, key);
        }
        function hashSet(key, value) {
          var data = this.__data__;
          this.size += this.has(key) ? 0 : 1;
          data[key] = nativeCreate && value === undefined2 ? HASH_UNDEFINED : value;
          return this;
        }
        Hash.prototype.clear = hashClear;
        Hash.prototype["delete"] = hashDelete;
        Hash.prototype.get = hashGet;
        Hash.prototype.has = hashHas;
        Hash.prototype.set = hashSet;
        function ListCache(entries) {
          var index = -1, length = entries == null ? 0 : entries.length;
          this.clear();
          while (++index < length) {
            var entry = entries[index];
            this.set(entry[0], entry[1]);
          }
        }
        function listCacheClear() {
          this.__data__ = [];
          this.size = 0;
        }
        function listCacheDelete(key) {
          var data = this.__data__, index = assocIndexOf(data, key);
          if (index < 0) {
            return false;
          }
          var lastIndex = data.length - 1;
          if (index == lastIndex) {
            data.pop();
          } else {
            splice.call(data, index, 1);
          }
          --this.size;
          return true;
        }
        function listCacheGet(key) {
          var data = this.__data__, index = assocIndexOf(data, key);
          return index < 0 ? undefined2 : data[index][1];
        }
        function listCacheHas(key) {
          return assocIndexOf(this.__data__, key) > -1;
        }
        function listCacheSet(key, value) {
          var data = this.__data__, index = assocIndexOf(data, key);
          if (index < 0) {
            ++this.size;
            data.push([key, value]);
          } else {
            data[index][1] = value;
          }
          return this;
        }
        ListCache.prototype.clear = listCacheClear;
        ListCache.prototype["delete"] = listCacheDelete;
        ListCache.prototype.get = listCacheGet;
        ListCache.prototype.has = listCacheHas;
        ListCache.prototype.set = listCacheSet;
        function MapCache(entries) {
          var index = -1, length = entries == null ? 0 : entries.length;
          this.clear();
          while (++index < length) {
            var entry = entries[index];
            this.set(entry[0], entry[1]);
          }
        }
        function mapCacheClear() {
          this.size = 0;
          this.__data__ = {
            "hash": new Hash(),
            "map": new (Map2 || ListCache)(),
            "string": new Hash()
          };
        }
        function mapCacheDelete(key) {
          var result2 = getMapData(this, key)["delete"](key);
          this.size -= result2 ? 1 : 0;
          return result2;
        }
        function mapCacheGet(key) {
          return getMapData(this, key).get(key);
        }
        function mapCacheHas(key) {
          return getMapData(this, key).has(key);
        }
        function mapCacheSet(key, value) {
          var data = getMapData(this, key), size2 = data.size;
          data.set(key, value);
          this.size += data.size == size2 ? 0 : 1;
          return this;
        }
        MapCache.prototype.clear = mapCacheClear;
        MapCache.prototype["delete"] = mapCacheDelete;
        MapCache.prototype.get = mapCacheGet;
        MapCache.prototype.has = mapCacheHas;
        MapCache.prototype.set = mapCacheSet;
        function SetCache(values2) {
          var index = -1, length = values2 == null ? 0 : values2.length;
          this.__data__ = new MapCache();
          while (++index < length) {
            this.add(values2[index]);
          }
        }
        function setCacheAdd(value) {
          this.__data__.set(value, HASH_UNDEFINED);
          return this;
        }
        function setCacheHas(value) {
          return this.__data__.has(value);
        }
        SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
        SetCache.prototype.has = setCacheHas;
        function Stack(entries) {
          var data = this.__data__ = new ListCache(entries);
          this.size = data.size;
        }
        function stackClear() {
          this.__data__ = new ListCache();
          this.size = 0;
        }
        function stackDelete(key) {
          var data = this.__data__, result2 = data["delete"](key);
          this.size = data.size;
          return result2;
        }
        function stackGet(key) {
          return this.__data__.get(key);
        }
        function stackHas(key) {
          return this.__data__.has(key);
        }
        function stackSet(key, value) {
          var data = this.__data__;
          if (data instanceof ListCache) {
            var pairs = data.__data__;
            if (!Map2 || pairs.length < LARGE_ARRAY_SIZE - 1) {
              pairs.push([key, value]);
              this.size = ++data.size;
              return this;
            }
            data = this.__data__ = new MapCache(pairs);
          }
          data.set(key, value);
          this.size = data.size;
          return this;
        }
        Stack.prototype.clear = stackClear;
        Stack.prototype["delete"] = stackDelete;
        Stack.prototype.get = stackGet;
        Stack.prototype.has = stackHas;
        Stack.prototype.set = stackSet;
        function arrayLikeKeys(value, inherited) {
          var isArr = isArray(value), isArg = !isArr && isArguments(value), isBuff = !isArr && !isArg && isBuffer(value), isType = !isArr && !isArg && !isBuff && isTypedArray2(value), skipIndexes = isArr || isArg || isBuff || isType, result2 = skipIndexes ? baseTimes(value.length, String2) : [], length = result2.length;
          for (var key in value) {
            if ((inherited || hasOwnProperty.call(value, key)) && !(skipIndexes && // Safari 9 has enumerable `arguments.length` in strict mode.
            (key == "length" || // Node.js 0.10 has enumerable non-index properties on buffers.
            isBuff && (key == "offset" || key == "parent") || // PhantomJS 2 has enumerable non-index properties on typed arrays.
            isType && (key == "buffer" || key == "byteLength" || key == "byteOffset") || // Skip index properties.
            isIndex(key, length)))) {
              result2.push(key);
            }
          }
          return result2;
        }
        function arraySample(array) {
          var length = array.length;
          return length ? array[baseRandom(0, length - 1)] : undefined2;
        }
        function arraySampleSize(array, n) {
          return shuffleSelf(copyArray2(array), baseClamp(n, 0, array.length));
        }
        function arrayShuffle(array) {
          return shuffleSelf(copyArray2(array));
        }
        function assignMergeValue(object, key, value) {
          if (value !== undefined2 && !eq(object[key], value) || value === undefined2 && !(key in object)) {
            baseAssignValue(object, key, value);
          }
        }
        function assignValue(object, key, value) {
          var objValue = object[key];
          if (!(hasOwnProperty.call(object, key) && eq(objValue, value)) || value === undefined2 && !(key in object)) {
            baseAssignValue(object, key, value);
          }
        }
        function assocIndexOf(array, key) {
          var length = array.length;
          while (length--) {
            if (eq(array[length][0], key)) {
              return length;
            }
          }
          return -1;
        }
        function baseAggregator(collection, setter, iteratee2, accumulator) {
          baseEach(collection, function(value, key, collection2) {
            setter(accumulator, value, iteratee2(value), collection2);
          });
          return accumulator;
        }
        function baseAssign(object, source) {
          return object && copyObject(source, keys(source), object);
        }
        function baseAssignIn(object, source) {
          return object && copyObject(source, keysIn(source), object);
        }
        function baseAssignValue(object, key, value) {
          if (key == "__proto__" && defineProperty) {
            defineProperty(object, key, {
              "configurable": true,
              "enumerable": true,
              "value": value,
              "writable": true
            });
          } else {
            object[key] = value;
          }
        }
        function baseAt(object, paths) {
          var index = -1, length = paths.length, result2 = Array2(length), skip = object == null;
          while (++index < length) {
            result2[index] = skip ? undefined2 : get(object, paths[index]);
          }
          return result2;
        }
        function baseClamp(number, lower, upper) {
          if (number === number) {
            if (upper !== undefined2) {
              number = number <= upper ? number : upper;
            }
            if (lower !== undefined2) {
              number = number >= lower ? number : lower;
            }
          }
          return number;
        }
        function baseClone(value, bitmask, customizer, key, object, stack) {
          var result2, isDeep = bitmask & CLONE_DEEP_FLAG, isFlat = bitmask & CLONE_FLAT_FLAG, isFull = bitmask & CLONE_SYMBOLS_FLAG;
          if (customizer) {
            result2 = object ? customizer(value, key, object, stack) : customizer(value);
          }
          if (result2 !== undefined2) {
            return result2;
          }
          if (!isObject(value)) {
            return value;
          }
          var isArr = isArray(value);
          if (isArr) {
            result2 = initCloneArray(value);
            if (!isDeep) {
              return copyArray2(value, result2);
            }
          } else {
            var tag = getTag(value), isFunc = tag == funcTag || tag == genTag;
            if (isBuffer(value)) {
              return cloneBuffer(value, isDeep);
            }
            if (tag == objectTag || tag == argsTag || isFunc && !object) {
              result2 = isFlat || isFunc ? {} : initCloneObject(value);
              if (!isDeep) {
                return isFlat ? copySymbolsIn(value, baseAssignIn(result2, value)) : copySymbols(value, baseAssign(result2, value));
              }
            } else {
              if (!cloneableTags[tag]) {
                return object ? value : {};
              }
              result2 = initCloneByTag(value, tag, isDeep);
            }
          }
          stack || (stack = new Stack());
          var stacked = stack.get(value);
          if (stacked) {
            return stacked;
          }
          stack.set(value, result2);
          if (isSet(value)) {
            value.forEach(function(subValue) {
              result2.add(baseClone(subValue, bitmask, customizer, subValue, value, stack));
            });
          } else if (isMap(value)) {
            value.forEach(function(subValue, key2) {
              result2.set(key2, baseClone(subValue, bitmask, customizer, key2, value, stack));
            });
          }
          var keysFunc = isFull ? isFlat ? getAllKeysIn : getAllKeys : isFlat ? keysIn : keys;
          var props = isArr ? undefined2 : keysFunc(value);
          arrayEach(props || value, function(subValue, key2) {
            if (props) {
              key2 = subValue;
              subValue = value[key2];
            }
            assignValue(result2, key2, baseClone(subValue, bitmask, customizer, key2, value, stack));
          });
          return result2;
        }
        function baseConforms(source) {
          var props = keys(source);
          return function(object) {
            return baseConformsTo(object, source, props);
          };
        }
        function baseConformsTo(object, source, props) {
          var length = props.length;
          if (object == null) {
            return !length;
          }
          object = Object2(object);
          while (length--) {
            var key = props[length], predicate = source[key], value = object[key];
            if (value === undefined2 && !(key in object) || !predicate(value)) {
              return false;
            }
          }
          return true;
        }
        function baseDelay(func, wait, args) {
          if (typeof func != "function") {
            throw new TypeError2(FUNC_ERROR_TEXT);
          }
          return setTimeout2(function() {
            func.apply(undefined2, args);
          }, wait);
        }
        function baseDifference(array, values2, iteratee2, comparator) {
          var index = -1, includes2 = arrayIncludes, isCommon = true, length = array.length, result2 = [], valuesLength = values2.length;
          if (!length) {
            return result2;
          }
          if (iteratee2) {
            values2 = arrayMap(values2, baseUnary(iteratee2));
          }
          if (comparator) {
            includes2 = arrayIncludesWith;
            isCommon = false;
          } else if (values2.length >= LARGE_ARRAY_SIZE) {
            includes2 = cacheHas;
            isCommon = false;
            values2 = new SetCache(values2);
          }
          outer:
            while (++index < length) {
              var value = array[index], computed = iteratee2 == null ? value : iteratee2(value);
              value = comparator || value !== 0 ? value : 0;
              if (isCommon && computed === computed) {
                var valuesIndex = valuesLength;
                while (valuesIndex--) {
                  if (values2[valuesIndex] === computed) {
                    continue outer;
                  }
                }
                result2.push(value);
              } else if (!includes2(values2, computed, comparator)) {
                result2.push(value);
              }
            }
          return result2;
        }
        var baseEach = createBaseEach(baseForOwn);
        var baseEachRight = createBaseEach(baseForOwnRight, true);
        function baseEvery(collection, predicate) {
          var result2 = true;
          baseEach(collection, function(value, index, collection2) {
            result2 = !!predicate(value, index, collection2);
            return result2;
          });
          return result2;
        }
        function baseExtremum(array, iteratee2, comparator) {
          var index = -1, length = array.length;
          while (++index < length) {
            var value = array[index], current = iteratee2(value);
            if (current != null && (computed === undefined2 ? current === current && !isSymbol(current) : comparator(current, computed))) {
              var computed = current, result2 = value;
            }
          }
          return result2;
        }
        function baseFill(array, value, start, end) {
          var length = array.length;
          start = toInteger(start);
          if (start < 0) {
            start = -start > length ? 0 : length + start;
          }
          end = end === undefined2 || end > length ? length : toInteger(end);
          if (end < 0) {
            end += length;
          }
          end = start > end ? 0 : toLength(end);
          while (start < end) {
            array[start++] = value;
          }
          return array;
        }
        function baseFilter(collection, predicate) {
          var result2 = [];
          baseEach(collection, function(value, index, collection2) {
            if (predicate(value, index, collection2)) {
              result2.push(value);
            }
          });
          return result2;
        }
        function baseFlatten(array, depth, predicate, isStrict, result2) {
          var index = -1, length = array.length;
          predicate || (predicate = isFlattenable);
          result2 || (result2 = []);
          while (++index < length) {
            var value = array[index];
            if (depth > 0 && predicate(value)) {
              if (depth > 1) {
                baseFlatten(value, depth - 1, predicate, isStrict, result2);
              } else {
                arrayPush(result2, value);
              }
            } else if (!isStrict) {
              result2[result2.length] = value;
            }
          }
          return result2;
        }
        var baseFor = createBaseFor();
        var baseForRight = createBaseFor(true);
        function baseForOwn(object, iteratee2) {
          return object && baseFor(object, iteratee2, keys);
        }
        function baseForOwnRight(object, iteratee2) {
          return object && baseForRight(object, iteratee2, keys);
        }
        function baseFunctions(object, props) {
          return arrayFilter(props, function(key) {
            return isFunction(object[key]);
          });
        }
        function baseGet(object, path) {
          path = castPath(path, object);
          var index = 0, length = path.length;
          while (object != null && index < length) {
            object = object[toKey(path[index++])];
          }
          return index && index == length ? object : undefined2;
        }
        function baseGetAllKeys(object, keysFunc, symbolsFunc) {
          var result2 = keysFunc(object);
          return isArray(object) ? result2 : arrayPush(result2, symbolsFunc(object));
        }
        function baseGetTag(value) {
          if (value == null) {
            return value === undefined2 ? undefinedTag : nullTag;
          }
          return symToStringTag && symToStringTag in Object2(value) ? getRawTag(value) : objectToString(value);
        }
        function baseGt(value, other) {
          return value > other;
        }
        function baseHas(object, key) {
          return object != null && hasOwnProperty.call(object, key);
        }
        function baseHasIn(object, key) {
          return object != null && key in Object2(object);
        }
        function baseInRange(number, start, end) {
          return number >= nativeMin(start, end) && number < nativeMax(start, end);
        }
        function baseIntersection(arrays, iteratee2, comparator) {
          var includes2 = comparator ? arrayIncludesWith : arrayIncludes, length = arrays[0].length, othLength = arrays.length, othIndex = othLength, caches = Array2(othLength), maxLength = Infinity, result2 = [];
          while (othIndex--) {
            var array = arrays[othIndex];
            if (othIndex && iteratee2) {
              array = arrayMap(array, baseUnary(iteratee2));
            }
            maxLength = nativeMin(array.length, maxLength);
            caches[othIndex] = !comparator && (iteratee2 || length >= 120 && array.length >= 120) ? new SetCache(othIndex && array) : undefined2;
          }
          array = arrays[0];
          var index = -1, seen = caches[0];
          outer:
            while (++index < length && result2.length < maxLength) {
              var value = array[index], computed = iteratee2 ? iteratee2(value) : value;
              value = comparator || value !== 0 ? value : 0;
              if (!(seen ? cacheHas(seen, computed) : includes2(result2, computed, comparator))) {
                othIndex = othLength;
                while (--othIndex) {
                  var cache = caches[othIndex];
                  if (!(cache ? cacheHas(cache, computed) : includes2(arrays[othIndex], computed, comparator))) {
                    continue outer;
                  }
                }
                if (seen) {
                  seen.push(computed);
                }
                result2.push(value);
              }
            }
          return result2;
        }
        function baseInverter(object, setter, iteratee2, accumulator) {
          baseForOwn(object, function(value, key, object2) {
            setter(accumulator, iteratee2(value), key, object2);
          });
          return accumulator;
        }
        function baseInvoke(object, path, args) {
          path = castPath(path, object);
          object = parent(object, path);
          var func = object == null ? object : object[toKey(last(path))];
          return func == null ? undefined2 : apply(func, object, args);
        }
        function baseIsArguments(value) {
          return isObjectLike(value) && baseGetTag(value) == argsTag;
        }
        function baseIsArrayBuffer(value) {
          return isObjectLike(value) && baseGetTag(value) == arrayBufferTag;
        }
        function baseIsDate(value) {
          return isObjectLike(value) && baseGetTag(value) == dateTag;
        }
        function baseIsEqual(value, other, bitmask, customizer, stack) {
          if (value === other) {
            return true;
          }
          if (value == null || other == null || !isObjectLike(value) && !isObjectLike(other)) {
            return value !== value && other !== other;
          }
          return baseIsEqualDeep(value, other, bitmask, customizer, baseIsEqual, stack);
        }
        function baseIsEqualDeep(object, other, bitmask, customizer, equalFunc, stack) {
          var objIsArr = isArray(object), othIsArr = isArray(other), objTag = objIsArr ? arrayTag : getTag(object), othTag = othIsArr ? arrayTag : getTag(other);
          objTag = objTag == argsTag ? objectTag : objTag;
          othTag = othTag == argsTag ? objectTag : othTag;
          var objIsObj = objTag == objectTag, othIsObj = othTag == objectTag, isSameTag = objTag == othTag;
          if (isSameTag && isBuffer(object)) {
            if (!isBuffer(other)) {
              return false;
            }
            objIsArr = true;
            objIsObj = false;
          }
          if (isSameTag && !objIsObj) {
            stack || (stack = new Stack());
            return objIsArr || isTypedArray2(object) ? equalArrays(object, other, bitmask, customizer, equalFunc, stack) : equalByTag(object, other, objTag, bitmask, customizer, equalFunc, stack);
          }
          if (!(bitmask & COMPARE_PARTIAL_FLAG)) {
            var objIsWrapped = objIsObj && hasOwnProperty.call(object, "__wrapped__"), othIsWrapped = othIsObj && hasOwnProperty.call(other, "__wrapped__");
            if (objIsWrapped || othIsWrapped) {
              var objUnwrapped = objIsWrapped ? object.value() : object, othUnwrapped = othIsWrapped ? other.value() : other;
              stack || (stack = new Stack());
              return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);
            }
          }
          if (!isSameTag) {
            return false;
          }
          stack || (stack = new Stack());
          return equalObjects(object, other, bitmask, customizer, equalFunc, stack);
        }
        function baseIsMap(value) {
          return isObjectLike(value) && getTag(value) == mapTag;
        }
        function baseIsMatch(object, source, matchData, customizer) {
          var index = matchData.length, length = index, noCustomizer = !customizer;
          if (object == null) {
            return !length;
          }
          object = Object2(object);
          while (index--) {
            var data = matchData[index];
            if (noCustomizer && data[2] ? data[1] !== object[data[0]] : !(data[0] in object)) {
              return false;
            }
          }
          while (++index < length) {
            data = matchData[index];
            var key = data[0], objValue = object[key], srcValue = data[1];
            if (noCustomizer && data[2]) {
              if (objValue === undefined2 && !(key in object)) {
                return false;
              }
            } else {
              var stack = new Stack();
              if (customizer) {
                var result2 = customizer(objValue, srcValue, key, object, source, stack);
              }
              if (!(result2 === undefined2 ? baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG, customizer, stack) : result2)) {
                return false;
              }
            }
          }
          return true;
        }
        function baseIsNative(value) {
          if (!isObject(value) || isMasked(value)) {
            return false;
          }
          var pattern = isFunction(value) ? reIsNative : reIsHostCtor;
          return pattern.test(toSource(value));
        }
        function baseIsRegExp(value) {
          return isObjectLike(value) && baseGetTag(value) == regexpTag;
        }
        function baseIsSet(value) {
          return isObjectLike(value) && getTag(value) == setTag;
        }
        function baseIsTypedArray(value) {
          return isObjectLike(value) && isLength(value.length) && !!typedArrayTags[baseGetTag(value)];
        }
        function baseIteratee(value) {
          if (typeof value == "function") {
            return value;
          }
          if (value == null) {
            return identity;
          }
          if (typeof value == "object") {
            return isArray(value) ? baseMatchesProperty(value[0], value[1]) : baseMatches(value);
          }
          return property(value);
        }
        function baseKeys(object) {
          if (!isPrototype(object)) {
            return nativeKeys(object);
          }
          var result2 = [];
          for (var key in Object2(object)) {
            if (hasOwnProperty.call(object, key) && key != "constructor") {
              result2.push(key);
            }
          }
          return result2;
        }
        function baseKeysIn(object) {
          if (!isObject(object)) {
            return nativeKeysIn(object);
          }
          var isProto = isPrototype(object), result2 = [];
          for (var key in object) {
            if (!(key == "constructor" && (isProto || !hasOwnProperty.call(object, key)))) {
              result2.push(key);
            }
          }
          return result2;
        }
        function baseLt(value, other) {
          return value < other;
        }
        function baseMap(collection, iteratee2) {
          var index = -1, result2 = isArrayLike(collection) ? Array2(collection.length) : [];
          baseEach(collection, function(value, key, collection2) {
            result2[++index] = iteratee2(value, key, collection2);
          });
          return result2;
        }
        function baseMatches(source) {
          var matchData = getMatchData(source);
          if (matchData.length == 1 && matchData[0][2]) {
            return matchesStrictComparable(matchData[0][0], matchData[0][1]);
          }
          return function(object) {
            return object === source || baseIsMatch(object, source, matchData);
          };
        }
        function baseMatchesProperty(path, srcValue) {
          if (isKey(path) && isStrictComparable(srcValue)) {
            return matchesStrictComparable(toKey(path), srcValue);
          }
          return function(object) {
            var objValue = get(object, path);
            return objValue === undefined2 && objValue === srcValue ? hasIn(object, path) : baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG);
          };
        }
        function baseMerge(object, source, srcIndex, customizer, stack) {
          if (object === source) {
            return;
          }
          baseFor(source, function(srcValue, key) {
            stack || (stack = new Stack());
            if (isObject(srcValue)) {
              baseMergeDeep(object, source, key, srcIndex, baseMerge, customizer, stack);
            } else {
              var newValue = customizer ? customizer(safeGet(object, key), srcValue, key + "", object, source, stack) : undefined2;
              if (newValue === undefined2) {
                newValue = srcValue;
              }
              assignMergeValue(object, key, newValue);
            }
          }, keysIn);
        }
        function baseMergeDeep(object, source, key, srcIndex, mergeFunc, customizer, stack) {
          var objValue = safeGet(object, key), srcValue = safeGet(source, key), stacked = stack.get(srcValue);
          if (stacked) {
            assignMergeValue(object, key, stacked);
            return;
          }
          var newValue = customizer ? customizer(objValue, srcValue, key + "", object, source, stack) : undefined2;
          var isCommon = newValue === undefined2;
          if (isCommon) {
            var isArr = isArray(srcValue), isBuff = !isArr && isBuffer(srcValue), isTyped = !isArr && !isBuff && isTypedArray2(srcValue);
            newValue = srcValue;
            if (isArr || isBuff || isTyped) {
              if (isArray(objValue)) {
                newValue = objValue;
              } else if (isArrayLikeObject(objValue)) {
                newValue = copyArray2(objValue);
              } else if (isBuff) {
                isCommon = false;
                newValue = cloneBuffer(srcValue, true);
              } else if (isTyped) {
                isCommon = false;
                newValue = cloneTypedArray(srcValue, true);
              } else {
                newValue = [];
              }
            } else if (isPlainObject(srcValue) || isArguments(srcValue)) {
              newValue = objValue;
              if (isArguments(objValue)) {
                newValue = toPlainObject(objValue);
              } else if (!isObject(objValue) || isFunction(objValue)) {
                newValue = initCloneObject(srcValue);
              }
            } else {
              isCommon = false;
            }
          }
          if (isCommon) {
            stack.set(srcValue, newValue);
            mergeFunc(newValue, srcValue, srcIndex, customizer, stack);
            stack["delete"](srcValue);
          }
          assignMergeValue(object, key, newValue);
        }
        function baseNth(array, n) {
          var length = array.length;
          if (!length) {
            return;
          }
          n += n < 0 ? length : 0;
          return isIndex(n, length) ? array[n] : undefined2;
        }
        function baseOrderBy(collection, iteratees, orders) {
          if (iteratees.length) {
            iteratees = arrayMap(iteratees, function(iteratee2) {
              if (isArray(iteratee2)) {
                return function(value) {
                  return baseGet(value, iteratee2.length === 1 ? iteratee2[0] : iteratee2);
                };
              }
              return iteratee2;
            });
          } else {
            iteratees = [identity];
          }
          var index = -1;
          iteratees = arrayMap(iteratees, baseUnary(getIteratee()));
          var result2 = baseMap(collection, function(value, key, collection2) {
            var criteria = arrayMap(iteratees, function(iteratee2) {
              return iteratee2(value);
            });
            return { "criteria": criteria, "index": ++index, "value": value };
          });
          return baseSortBy(result2, function(object, other) {
            return compareMultiple(object, other, orders);
          });
        }
        function basePick(object, paths) {
          return basePickBy(object, paths, function(value, path) {
            return hasIn(object, path);
          });
        }
        function basePickBy(object, paths, predicate) {
          var index = -1, length = paths.length, result2 = {};
          while (++index < length) {
            var path = paths[index], value = baseGet(object, path);
            if (predicate(value, path)) {
              baseSet(result2, castPath(path, object), value);
            }
          }
          return result2;
        }
        function basePropertyDeep(path) {
          return function(object) {
            return baseGet(object, path);
          };
        }
        function basePullAll(array, values2, iteratee2, comparator) {
          var indexOf2 = comparator ? baseIndexOfWith : baseIndexOf, index = -1, length = values2.length, seen = array;
          if (array === values2) {
            values2 = copyArray2(values2);
          }
          if (iteratee2) {
            seen = arrayMap(array, baseUnary(iteratee2));
          }
          while (++index < length) {
            var fromIndex = 0, value = values2[index], computed = iteratee2 ? iteratee2(value) : value;
            while ((fromIndex = indexOf2(seen, computed, fromIndex, comparator)) > -1) {
              if (seen !== array) {
                splice.call(seen, fromIndex, 1);
              }
              splice.call(array, fromIndex, 1);
            }
          }
          return array;
        }
        function basePullAt(array, indexes) {
          var length = array ? indexes.length : 0, lastIndex = length - 1;
          while (length--) {
            var index = indexes[length];
            if (length == lastIndex || index !== previous) {
              var previous = index;
              if (isIndex(index)) {
                splice.call(array, index, 1);
              } else {
                baseUnset(array, index);
              }
            }
          }
          return array;
        }
        function baseRandom(lower, upper) {
          return lower + nativeFloor(nativeRandom() * (upper - lower + 1));
        }
        function baseRange(start, end, step, fromRight) {
          var index = -1, length = nativeMax(nativeCeil((end - start) / (step || 1)), 0), result2 = Array2(length);
          while (length--) {
            result2[fromRight ? length : ++index] = start;
            start += step;
          }
          return result2;
        }
        function baseRepeat(string, n) {
          var result2 = "";
          if (!string || n < 1 || n > MAX_SAFE_INTEGER) {
            return result2;
          }
          do {
            if (n % 2) {
              result2 += string;
            }
            n = nativeFloor(n / 2);
            if (n) {
              string += string;
            }
          } while (n);
          return result2;
        }
        function baseRest(func, start) {
          return setToString(overRest(func, start, identity), func + "");
        }
        function baseSample(collection) {
          return arraySample(values(collection));
        }
        function baseSampleSize(collection, n) {
          var array = values(collection);
          return shuffleSelf(array, baseClamp(n, 0, array.length));
        }
        function baseSet(object, path, value, customizer) {
          if (!isObject(object)) {
            return object;
          }
          path = castPath(path, object);
          var index = -1, length = path.length, lastIndex = length - 1, nested = object;
          while (nested != null && ++index < length) {
            var key = toKey(path[index]), newValue = value;
            if (key === "__proto__" || key === "constructor" || key === "prototype") {
              return object;
            }
            if (index != lastIndex) {
              var objValue = nested[key];
              newValue = customizer ? customizer(objValue, key, nested) : undefined2;
              if (newValue === undefined2) {
                newValue = isObject(objValue) ? objValue : isIndex(path[index + 1]) ? [] : {};
              }
            }
            assignValue(nested, key, newValue);
            nested = nested[key];
          }
          return object;
        }
        var baseSetData = !metaMap ? identity : function(func, data) {
          metaMap.set(func, data);
          return func;
        };
        var baseSetToString = !defineProperty ? identity : function(func, string) {
          return defineProperty(func, "toString", {
            "configurable": true,
            "enumerable": false,
            "value": constant(string),
            "writable": true
          });
        };
        function baseShuffle(collection) {
          return shuffleSelf(values(collection));
        }
        function baseSlice(array, start, end) {
          var index = -1, length = array.length;
          if (start < 0) {
            start = -start > length ? 0 : length + start;
          }
          end = end > length ? length : end;
          if (end < 0) {
            end += length;
          }
          length = start > end ? 0 : end - start >>> 0;
          start >>>= 0;
          var result2 = Array2(length);
          while (++index < length) {
            result2[index] = array[index + start];
          }
          return result2;
        }
        function baseSome(collection, predicate) {
          var result2;
          baseEach(collection, function(value, index, collection2) {
            result2 = predicate(value, index, collection2);
            return !result2;
          });
          return !!result2;
        }
        function baseSortedIndex(array, value, retHighest) {
          var low = 0, high = array == null ? low : array.length;
          if (typeof value == "number" && value === value && high <= HALF_MAX_ARRAY_LENGTH) {
            while (low < high) {
              var mid = low + high >>> 1, computed = array[mid];
              if (computed !== null && !isSymbol(computed) && (retHighest ? computed <= value : computed < value)) {
                low = mid + 1;
              } else {
                high = mid;
              }
            }
            return high;
          }
          return baseSortedIndexBy(array, value, identity, retHighest);
        }
        function baseSortedIndexBy(array, value, iteratee2, retHighest) {
          var low = 0, high = array == null ? 0 : array.length;
          if (high === 0) {
            return 0;
          }
          value = iteratee2(value);
          var valIsNaN = value !== value, valIsNull = value === null, valIsSymbol = isSymbol(value), valIsUndefined = value === undefined2;
          while (low < high) {
            var mid = nativeFloor((low + high) / 2), computed = iteratee2(array[mid]), othIsDefined = computed !== undefined2, othIsNull = computed === null, othIsReflexive = computed === computed, othIsSymbol = isSymbol(computed);
            if (valIsNaN) {
              var setLow = retHighest || othIsReflexive;
            } else if (valIsUndefined) {
              setLow = othIsReflexive && (retHighest || othIsDefined);
            } else if (valIsNull) {
              setLow = othIsReflexive && othIsDefined && (retHighest || !othIsNull);
            } else if (valIsSymbol) {
              setLow = othIsReflexive && othIsDefined && !othIsNull && (retHighest || !othIsSymbol);
            } else if (othIsNull || othIsSymbol) {
              setLow = false;
            } else {
              setLow = retHighest ? computed <= value : computed < value;
            }
            if (setLow) {
              low = mid + 1;
            } else {
              high = mid;
            }
          }
          return nativeMin(high, MAX_ARRAY_INDEX);
        }
        function baseSortedUniq(array, iteratee2) {
          var index = -1, length = array.length, resIndex = 0, result2 = [];
          while (++index < length) {
            var value = array[index], computed = iteratee2 ? iteratee2(value) : value;
            if (!index || !eq(computed, seen)) {
              var seen = computed;
              result2[resIndex++] = value === 0 ? 0 : value;
            }
          }
          return result2;
        }
        function baseToNumber(value) {
          if (typeof value == "number") {
            return value;
          }
          if (isSymbol(value)) {
            return NAN;
          }
          return +value;
        }
        function baseToString(value) {
          if (typeof value == "string") {
            return value;
          }
          if (isArray(value)) {
            return arrayMap(value, baseToString) + "";
          }
          if (isSymbol(value)) {
            return symbolToString ? symbolToString.call(value) : "";
          }
          var result2 = value + "";
          return result2 == "0" && 1 / value == -INFINITY ? "-0" : result2;
        }
        function baseUniq(array, iteratee2, comparator) {
          var index = -1, includes2 = arrayIncludes, length = array.length, isCommon = true, result2 = [], seen = result2;
          if (comparator) {
            isCommon = false;
            includes2 = arrayIncludesWith;
          } else if (length >= LARGE_ARRAY_SIZE) {
            var set2 = iteratee2 ? null : createSet(array);
            if (set2) {
              return setToArray(set2);
            }
            isCommon = false;
            includes2 = cacheHas;
            seen = new SetCache();
          } else {
            seen = iteratee2 ? [] : result2;
          }
          outer:
            while (++index < length) {
              var value = array[index], computed = iteratee2 ? iteratee2(value) : value;
              value = comparator || value !== 0 ? value : 0;
              if (isCommon && computed === computed) {
                var seenIndex = seen.length;
                while (seenIndex--) {
                  if (seen[seenIndex] === computed) {
                    continue outer;
                  }
                }
                if (iteratee2) {
                  seen.push(computed);
                }
                result2.push(value);
              } else if (!includes2(seen, computed, comparator)) {
                if (seen !== result2) {
                  seen.push(computed);
                }
                result2.push(value);
              }
            }
          return result2;
        }
        function baseUnset(object, path) {
          path = castPath(path, object);
          var index = -1, length = path.length;
          if (!length) {
            return true;
          }
          var isRootPrimitive = object == null || typeof object !== "object" && typeof object !== "function";
          while (++index < length) {
            var key = path[index];
            if (typeof key !== "string") {
              continue;
            }
            if (key === "__proto__" && !hasOwnProperty.call(object, "__proto__")) {
              return false;
            }
            if (key === "constructor" && index + 1 < length && typeof path[index + 1] === "string" && path[index + 1] === "prototype") {
              if (isRootPrimitive && index === 0) {
                continue;
              }
              return false;
            }
          }
          var obj = parent(object, path);
          return obj == null || delete obj[toKey(last(path))];
        }
        function baseUpdate(object, path, updater, customizer) {
          return baseSet(object, path, updater(baseGet(object, path)), customizer);
        }
        function baseWhile(array, predicate, isDrop, fromRight) {
          var length = array.length, index = fromRight ? length : -1;
          while ((fromRight ? index-- : ++index < length) && predicate(array[index], index, array)) {
          }
          return isDrop ? baseSlice(array, fromRight ? 0 : index, fromRight ? index + 1 : length) : baseSlice(array, fromRight ? index + 1 : 0, fromRight ? length : index);
        }
        function baseWrapperValue(value, actions2) {
          var result2 = value;
          if (result2 instanceof LazyWrapper) {
            result2 = result2.value();
          }
          return arrayReduce(actions2, function(result3, action) {
            return action.func.apply(action.thisArg, arrayPush([result3], action.args));
          }, result2);
        }
        function baseXor(arrays, iteratee2, comparator) {
          var length = arrays.length;
          if (length < 2) {
            return length ? baseUniq(arrays[0]) : [];
          }
          var index = -1, result2 = Array2(length);
          while (++index < length) {
            var array = arrays[index], othIndex = -1;
            while (++othIndex < length) {
              if (othIndex != index) {
                result2[index] = baseDifference(result2[index] || array, arrays[othIndex], iteratee2, comparator);
              }
            }
          }
          return baseUniq(baseFlatten(result2, 1), iteratee2, comparator);
        }
        function baseZipObject(props, values2, assignFunc) {
          var index = -1, length = props.length, valsLength = values2.length, result2 = {};
          while (++index < length) {
            var value = index < valsLength ? values2[index] : undefined2;
            assignFunc(result2, props[index], value);
          }
          return result2;
        }
        function castArrayLikeObject(value) {
          return isArrayLikeObject(value) ? value : [];
        }
        function castFunction(value) {
          return typeof value == "function" ? value : identity;
        }
        function castPath(value, object) {
          if (isArray(value)) {
            return value;
          }
          return isKey(value, object) ? [value] : stringToPath(toString(value));
        }
        var castRest = baseRest;
        function castSlice(array, start, end) {
          var length = array.length;
          end = end === undefined2 ? length : end;
          return !start && end >= length ? array : baseSlice(array, start, end);
        }
        var clearTimeout = ctxClearTimeout || function(id2) {
          return root.clearTimeout(id2);
        };
        function cloneBuffer(buffer, isDeep) {
          if (isDeep) {
            return buffer.slice();
          }
          var length = buffer.length, result2 = allocUnsafe ? allocUnsafe(length) : new buffer.constructor(length);
          buffer.copy(result2);
          return result2;
        }
        function cloneArrayBuffer(arrayBuffer) {
          var result2 = new arrayBuffer.constructor(arrayBuffer.byteLength);
          new Uint8Array2(result2).set(new Uint8Array2(arrayBuffer));
          return result2;
        }
        function cloneDataView(dataView, isDeep) {
          var buffer = isDeep ? cloneArrayBuffer(dataView.buffer) : dataView.buffer;
          return new dataView.constructor(buffer, dataView.byteOffset, dataView.byteLength);
        }
        function cloneRegExp(regexp) {
          var result2 = new regexp.constructor(regexp.source, reFlags.exec(regexp));
          result2.lastIndex = regexp.lastIndex;
          return result2;
        }
        function cloneSymbol(symbol) {
          return symbolValueOf ? Object2(symbolValueOf.call(symbol)) : {};
        }
        function cloneTypedArray(typedArray, isDeep) {
          var buffer = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;
          return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
        }
        function compareAscending(value, other) {
          if (value !== other) {
            var valIsDefined = value !== undefined2, valIsNull = value === null, valIsReflexive = value === value, valIsSymbol = isSymbol(value);
            var othIsDefined = other !== undefined2, othIsNull = other === null, othIsReflexive = other === other, othIsSymbol = isSymbol(other);
            if (!othIsNull && !othIsSymbol && !valIsSymbol && value > other || valIsSymbol && othIsDefined && othIsReflexive && !othIsNull && !othIsSymbol || valIsNull && othIsDefined && othIsReflexive || !valIsDefined && othIsReflexive || !valIsReflexive) {
              return 1;
            }
            if (!valIsNull && !valIsSymbol && !othIsSymbol && value < other || othIsSymbol && valIsDefined && valIsReflexive && !valIsNull && !valIsSymbol || othIsNull && valIsDefined && valIsReflexive || !othIsDefined && valIsReflexive || !othIsReflexive) {
              return -1;
            }
          }
          return 0;
        }
        function compareMultiple(object, other, orders) {
          var index = -1, objCriteria = object.criteria, othCriteria = other.criteria, length = objCriteria.length, ordersLength = orders.length;
          while (++index < length) {
            var result2 = compareAscending(objCriteria[index], othCriteria[index]);
            if (result2) {
              if (index >= ordersLength) {
                return result2;
              }
              var order = orders[index];
              return result2 * (order == "desc" ? -1 : 1);
            }
          }
          return object.index - other.index;
        }
        function composeArgs(args, partials, holders, isCurried) {
          var argsIndex = -1, argsLength = args.length, holdersLength = holders.length, leftIndex = -1, leftLength = partials.length, rangeLength = nativeMax(argsLength - holdersLength, 0), result2 = Array2(leftLength + rangeLength), isUncurried = !isCurried;
          while (++leftIndex < leftLength) {
            result2[leftIndex] = partials[leftIndex];
          }
          while (++argsIndex < holdersLength) {
            if (isUncurried || argsIndex < argsLength) {
              result2[holders[argsIndex]] = args[argsIndex];
            }
          }
          while (rangeLength--) {
            result2[leftIndex++] = args[argsIndex++];
          }
          return result2;
        }
        function composeArgsRight(args, partials, holders, isCurried) {
          var argsIndex = -1, argsLength = args.length, holdersIndex = -1, holdersLength = holders.length, rightIndex = -1, rightLength = partials.length, rangeLength = nativeMax(argsLength - holdersLength, 0), result2 = Array2(rangeLength + rightLength), isUncurried = !isCurried;
          while (++argsIndex < rangeLength) {
            result2[argsIndex] = args[argsIndex];
          }
          var offset = argsIndex;
          while (++rightIndex < rightLength) {
            result2[offset + rightIndex] = partials[rightIndex];
          }
          while (++holdersIndex < holdersLength) {
            if (isUncurried || argsIndex < argsLength) {
              result2[offset + holders[holdersIndex]] = args[argsIndex++];
            }
          }
          return result2;
        }
        function copyArray2(source, array) {
          var index = -1, length = source.length;
          array || (array = Array2(length));
          while (++index < length) {
            array[index] = source[index];
          }
          return array;
        }
        function copyObject(source, props, object, customizer) {
          var isNew = !object;
          object || (object = {});
          var index = -1, length = props.length;
          while (++index < length) {
            var key = props[index];
            var newValue = customizer ? customizer(object[key], source[key], key, object, source) : undefined2;
            if (newValue === undefined2) {
              newValue = source[key];
            }
            if (isNew) {
              baseAssignValue(object, key, newValue);
            } else {
              assignValue(object, key, newValue);
            }
          }
          return object;
        }
        function copySymbols(source, object) {
          return copyObject(source, getSymbols(source), object);
        }
        function copySymbolsIn(source, object) {
          return copyObject(source, getSymbolsIn(source), object);
        }
        function createAggregator(setter, initializer) {
          return function(collection, iteratee2) {
            var func = isArray(collection) ? arrayAggregator : baseAggregator, accumulator = initializer ? initializer() : {};
            return func(collection, setter, getIteratee(iteratee2, 2), accumulator);
          };
        }
        function createAssigner(assigner) {
          return baseRest(function(object, sources) {
            var index = -1, length = sources.length, customizer = length > 1 ? sources[length - 1] : undefined2, guard = length > 2 ? sources[2] : undefined2;
            customizer = assigner.length > 3 && typeof customizer == "function" ? (length--, customizer) : undefined2;
            if (guard && isIterateeCall(sources[0], sources[1], guard)) {
              customizer = length < 3 ? undefined2 : customizer;
              length = 1;
            }
            object = Object2(object);
            while (++index < length) {
              var source = sources[index];
              if (source) {
                assigner(object, source, index, customizer);
              }
            }
            return object;
          });
        }
        function createBaseEach(eachFunc, fromRight) {
          return function(collection, iteratee2) {
            if (collection == null) {
              return collection;
            }
            if (!isArrayLike(collection)) {
              return eachFunc(collection, iteratee2);
            }
            var length = collection.length, index = fromRight ? length : -1, iterable = Object2(collection);
            while (fromRight ? index-- : ++index < length) {
              if (iteratee2(iterable[index], index, iterable) === false) {
                break;
              }
            }
            return collection;
          };
        }
        function createBaseFor(fromRight) {
          return function(object, iteratee2, keysFunc) {
            var index = -1, iterable = Object2(object), props = keysFunc(object), length = props.length;
            while (length--) {
              var key = props[fromRight ? length : ++index];
              if (iteratee2(iterable[key], key, iterable) === false) {
                break;
              }
            }
            return object;
          };
        }
        function createBind(func, bitmask, thisArg) {
          var isBind = bitmask & WRAP_BIND_FLAG, Ctor = createCtor(func);
          function wrapper2() {
            var fn = this && this !== root && this instanceof wrapper2 ? Ctor : func;
            return fn.apply(isBind ? thisArg : this, arguments);
          }
          return wrapper2;
        }
        function createCaseFirst(methodName) {
          return function(string) {
            string = toString(string);
            var strSymbols = hasUnicode(string) ? stringToArray(string) : undefined2;
            var chr = strSymbols ? strSymbols[0] : string.charAt(0);
            var trailing = strSymbols ? castSlice(strSymbols, 1).join("") : string.slice(1);
            return chr[methodName]() + trailing;
          };
        }
        function createCompounder(callback) {
          return function(string) {
            return arrayReduce(words(deburr(string).replace(reApos, "")), callback, "");
          };
        }
        function createCtor(Ctor) {
          return function() {
            var args = arguments;
            switch (args.length) {
              case 0:
                return new Ctor();
              case 1:
                return new Ctor(args[0]);
              case 2:
                return new Ctor(args[0], args[1]);
              case 3:
                return new Ctor(args[0], args[1], args[2]);
              case 4:
                return new Ctor(args[0], args[1], args[2], args[3]);
              case 5:
                return new Ctor(args[0], args[1], args[2], args[3], args[4]);
              case 6:
                return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5]);
              case 7:
                return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5], args[6]);
            }
            var thisBinding = baseCreate(Ctor.prototype), result2 = Ctor.apply(thisBinding, args);
            return isObject(result2) ? result2 : thisBinding;
          };
        }
        function createCurry(func, bitmask, arity) {
          var Ctor = createCtor(func);
          function wrapper2() {
            var length = arguments.length, args = Array2(length), index = length, placeholder = getHolder(wrapper2);
            while (index--) {
              args[index] = arguments[index];
            }
            var holders = length < 3 && args[0] !== placeholder && args[length - 1] !== placeholder ? [] : replaceHolders(args, placeholder);
            length -= holders.length;
            if (length < arity) {
              return createRecurry(
                func,
                bitmask,
                createHybrid,
                wrapper2.placeholder,
                undefined2,
                args,
                holders,
                undefined2,
                undefined2,
                arity - length
              );
            }
            var fn = this && this !== root && this instanceof wrapper2 ? Ctor : func;
            return apply(fn, this, args);
          }
          return wrapper2;
        }
        function createFind(findIndexFunc) {
          return function(collection, predicate, fromIndex) {
            var iterable = Object2(collection);
            if (!isArrayLike(collection)) {
              var iteratee2 = getIteratee(predicate, 3);
              collection = keys(collection);
              predicate = function(key) {
                return iteratee2(iterable[key], key, iterable);
              };
            }
            var index = findIndexFunc(collection, predicate, fromIndex);
            return index > -1 ? iterable[iteratee2 ? collection[index] : index] : undefined2;
          };
        }
        function createFlow(fromRight) {
          return flatRest(function(funcs) {
            var length = funcs.length, index = length, prereq = LodashWrapper.prototype.thru;
            if (fromRight) {
              funcs.reverse();
            }
            while (index--) {
              var func = funcs[index];
              if (typeof func != "function") {
                throw new TypeError2(FUNC_ERROR_TEXT);
              }
              if (prereq && !wrapper2 && getFuncName(func) == "wrapper") {
                var wrapper2 = new LodashWrapper([], true);
              }
            }
            index = wrapper2 ? index : length;
            while (++index < length) {
              func = funcs[index];
              var funcName = getFuncName(func), data = funcName == "wrapper" ? getData(func) : undefined2;
              if (data && isLaziable(data[0]) && data[1] == (WRAP_ARY_FLAG | WRAP_CURRY_FLAG | WRAP_PARTIAL_FLAG | WRAP_REARG_FLAG) && !data[4].length && data[9] == 1) {
                wrapper2 = wrapper2[getFuncName(data[0])].apply(wrapper2, data[3]);
              } else {
                wrapper2 = func.length == 1 && isLaziable(func) ? wrapper2[funcName]() : wrapper2.thru(func);
              }
            }
            return function() {
              var args = arguments, value = args[0];
              if (wrapper2 && args.length == 1 && isArray(value)) {
                return wrapper2.plant(value).value();
              }
              var index2 = 0, result2 = length ? funcs[index2].apply(this, args) : value;
              while (++index2 < length) {
                result2 = funcs[index2].call(this, result2);
              }
              return result2;
            };
          });
        }
        function createHybrid(func, bitmask, thisArg, partials, holders, partialsRight, holdersRight, argPos, ary2, arity) {
          var isAry = bitmask & WRAP_ARY_FLAG, isBind = bitmask & WRAP_BIND_FLAG, isBindKey = bitmask & WRAP_BIND_KEY_FLAG, isCurried = bitmask & (WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG), isFlip = bitmask & WRAP_FLIP_FLAG, Ctor = isBindKey ? undefined2 : createCtor(func);
          function wrapper2() {
            var length = arguments.length, args = Array2(length), index = length;
            while (index--) {
              args[index] = arguments[index];
            }
            if (isCurried) {
              var placeholder = getHolder(wrapper2), holdersCount = countHolders(args, placeholder);
            }
            if (partials) {
              args = composeArgs(args, partials, holders, isCurried);
            }
            if (partialsRight) {
              args = composeArgsRight(args, partialsRight, holdersRight, isCurried);
            }
            length -= holdersCount;
            if (isCurried && length < arity) {
              var newHolders = replaceHolders(args, placeholder);
              return createRecurry(
                func,
                bitmask,
                createHybrid,
                wrapper2.placeholder,
                thisArg,
                args,
                newHolders,
                argPos,
                ary2,
                arity - length
              );
            }
            var thisBinding = isBind ? thisArg : this, fn = isBindKey ? thisBinding[func] : func;
            length = args.length;
            if (argPos) {
              args = reorder(args, argPos);
            } else if (isFlip && length > 1) {
              args.reverse();
            }
            if (isAry && ary2 < length) {
              args.length = ary2;
            }
            if (this && this !== root && this instanceof wrapper2) {
              fn = Ctor || createCtor(fn);
            }
            return fn.apply(thisBinding, args);
          }
          return wrapper2;
        }
        function createInverter(setter, toIteratee) {
          return function(object, iteratee2) {
            return baseInverter(object, setter, toIteratee(iteratee2), {});
          };
        }
        function createMathOperation(operator, defaultValue) {
          return function(value, other) {
            var result2;
            if (value === undefined2 && other === undefined2) {
              return defaultValue;
            }
            if (value !== undefined2) {
              result2 = value;
            }
            if (other !== undefined2) {
              if (result2 === undefined2) {
                return other;
              }
              if (typeof value == "string" || typeof other == "string") {
                value = baseToString(value);
                other = baseToString(other);
              } else {
                value = baseToNumber(value);
                other = baseToNumber(other);
              }
              result2 = operator(value, other);
            }
            return result2;
          };
        }
        function createOver(arrayFunc) {
          return flatRest(function(iteratees) {
            iteratees = arrayMap(iteratees, baseUnary(getIteratee()));
            return baseRest(function(args) {
              var thisArg = this;
              return arrayFunc(iteratees, function(iteratee2) {
                return apply(iteratee2, thisArg, args);
              });
            });
          });
        }
        function createPadding(length, chars) {
          chars = chars === undefined2 ? " " : baseToString(chars);
          var charsLength = chars.length;
          if (charsLength < 2) {
            return charsLength ? baseRepeat(chars, length) : chars;
          }
          var result2 = baseRepeat(chars, nativeCeil(length / stringSize(chars)));
          return hasUnicode(chars) ? castSlice(stringToArray(result2), 0, length).join("") : result2.slice(0, length);
        }
        function createPartial(func, bitmask, thisArg, partials) {
          var isBind = bitmask & WRAP_BIND_FLAG, Ctor = createCtor(func);
          function wrapper2() {
            var argsIndex = -1, argsLength = arguments.length, leftIndex = -1, leftLength = partials.length, args = Array2(leftLength + argsLength), fn = this && this !== root && this instanceof wrapper2 ? Ctor : func;
            while (++leftIndex < leftLength) {
              args[leftIndex] = partials[leftIndex];
            }
            while (argsLength--) {
              args[leftIndex++] = arguments[++argsIndex];
            }
            return apply(fn, isBind ? thisArg : this, args);
          }
          return wrapper2;
        }
        function createRange(fromRight) {
          return function(start, end, step) {
            if (step && typeof step != "number" && isIterateeCall(start, end, step)) {
              end = step = undefined2;
            }
            start = toFinite(start);
            if (end === undefined2) {
              end = start;
              start = 0;
            } else {
              end = toFinite(end);
            }
            step = step === undefined2 ? start < end ? 1 : -1 : toFinite(step);
            return baseRange(start, end, step, fromRight);
          };
        }
        function createRelationalOperation(operator) {
          return function(value, other) {
            if (!(typeof value == "string" && typeof other == "string")) {
              value = toNumber(value);
              other = toNumber(other);
            }
            return operator(value, other);
          };
        }
        function createRecurry(func, bitmask, wrapFunc, placeholder, thisArg, partials, holders, argPos, ary2, arity) {
          var isCurry = bitmask & WRAP_CURRY_FLAG, newHolders = isCurry ? holders : undefined2, newHoldersRight = isCurry ? undefined2 : holders, newPartials = isCurry ? partials : undefined2, newPartialsRight = isCurry ? undefined2 : partials;
          bitmask |= isCurry ? WRAP_PARTIAL_FLAG : WRAP_PARTIAL_RIGHT_FLAG;
          bitmask &= ~(isCurry ? WRAP_PARTIAL_RIGHT_FLAG : WRAP_PARTIAL_FLAG);
          if (!(bitmask & WRAP_CURRY_BOUND_FLAG)) {
            bitmask &= ~(WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG);
          }
          var newData = [
            func,
            bitmask,
            thisArg,
            newPartials,
            newHolders,
            newPartialsRight,
            newHoldersRight,
            argPos,
            ary2,
            arity
          ];
          var result2 = wrapFunc.apply(undefined2, newData);
          if (isLaziable(func)) {
            setData(result2, newData);
          }
          result2.placeholder = placeholder;
          return setWrapToString(result2, func, bitmask);
        }
        function createRound(methodName) {
          var func = Math2[methodName];
          return function(number, precision) {
            number = toNumber(number);
            precision = precision == null ? 0 : nativeMin(toInteger(precision), 292);
            if (precision && nativeIsFinite(number)) {
              var pair = (toString(number) + "e").split("e"), value = func(pair[0] + "e" + (+pair[1] + precision));
              pair = (toString(value) + "e").split("e");
              return +(pair[0] + "e" + (+pair[1] - precision));
            }
            return func(number);
          };
        }
        var createSet = !(Set2 && 1 / setToArray(new Set2([, -0]))[1] == INFINITY) ? noop : function(values2) {
          return new Set2(values2);
        };
        function createToPairs(keysFunc) {
          return function(object) {
            var tag = getTag(object);
            if (tag == mapTag) {
              return mapToArray(object);
            }
            if (tag == setTag) {
              return setToPairs(object);
            }
            return baseToPairs(object, keysFunc(object));
          };
        }
        function createWrap(func, bitmask, thisArg, partials, holders, argPos, ary2, arity) {
          var isBindKey = bitmask & WRAP_BIND_KEY_FLAG;
          if (!isBindKey && typeof func != "function") {
            throw new TypeError2(FUNC_ERROR_TEXT);
          }
          var length = partials ? partials.length : 0;
          if (!length) {
            bitmask &= ~(WRAP_PARTIAL_FLAG | WRAP_PARTIAL_RIGHT_FLAG);
            partials = holders = undefined2;
          }
          ary2 = ary2 === undefined2 ? ary2 : nativeMax(toInteger(ary2), 0);
          arity = arity === undefined2 ? arity : toInteger(arity);
          length -= holders ? holders.length : 0;
          if (bitmask & WRAP_PARTIAL_RIGHT_FLAG) {
            var partialsRight = partials, holdersRight = holders;
            partials = holders = undefined2;
          }
          var data = isBindKey ? undefined2 : getData(func);
          var newData = [
            func,
            bitmask,
            thisArg,
            partials,
            holders,
            partialsRight,
            holdersRight,
            argPos,
            ary2,
            arity
          ];
          if (data) {
            mergeData(newData, data);
          }
          func = newData[0];
          bitmask = newData[1];
          thisArg = newData[2];
          partials = newData[3];
          holders = newData[4];
          arity = newData[9] = newData[9] === undefined2 ? isBindKey ? 0 : func.length : nativeMax(newData[9] - length, 0);
          if (!arity && bitmask & (WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG)) {
            bitmask &= ~(WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG);
          }
          if (!bitmask || bitmask == WRAP_BIND_FLAG) {
            var result2 = createBind(func, bitmask, thisArg);
          } else if (bitmask == WRAP_CURRY_FLAG || bitmask == WRAP_CURRY_RIGHT_FLAG) {
            result2 = createCurry(func, bitmask, arity);
          } else if ((bitmask == WRAP_PARTIAL_FLAG || bitmask == (WRAP_BIND_FLAG | WRAP_PARTIAL_FLAG)) && !holders.length) {
            result2 = createPartial(func, bitmask, thisArg, partials);
          } else {
            result2 = createHybrid.apply(undefined2, newData);
          }
          var setter = data ? baseSetData : setData;
          return setWrapToString(setter(result2, newData), func, bitmask);
        }
        function customDefaultsAssignIn(objValue, srcValue, key, object) {
          if (objValue === undefined2 || eq(objValue, objectProto[key]) && !hasOwnProperty.call(object, key)) {
            return srcValue;
          }
          return objValue;
        }
        function customDefaultsMerge(objValue, srcValue, key, object, source, stack) {
          if (isObject(objValue) && isObject(srcValue)) {
            stack.set(srcValue, objValue);
            baseMerge(objValue, srcValue, undefined2, customDefaultsMerge, stack);
            stack["delete"](srcValue);
          }
          return objValue;
        }
        function customOmitClone(value) {
          return isPlainObject(value) ? undefined2 : value;
        }
        function equalArrays(array, other, bitmask, customizer, equalFunc, stack) {
          var isPartial = bitmask & COMPARE_PARTIAL_FLAG, arrLength = array.length, othLength = other.length;
          if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
            return false;
          }
          var arrStacked = stack.get(array);
          var othStacked = stack.get(other);
          if (arrStacked && othStacked) {
            return arrStacked == other && othStacked == array;
          }
          var index = -1, result2 = true, seen = bitmask & COMPARE_UNORDERED_FLAG ? new SetCache() : undefined2;
          stack.set(array, other);
          stack.set(other, array);
          while (++index < arrLength) {
            var arrValue = array[index], othValue = other[index];
            if (customizer) {
              var compared = isPartial ? customizer(othValue, arrValue, index, other, array, stack) : customizer(arrValue, othValue, index, array, other, stack);
            }
            if (compared !== undefined2) {
              if (compared) {
                continue;
              }
              result2 = false;
              break;
            }
            if (seen) {
              if (!arraySome(other, function(othValue2, othIndex) {
                if (!cacheHas(seen, othIndex) && (arrValue === othValue2 || equalFunc(arrValue, othValue2, bitmask, customizer, stack))) {
                  return seen.push(othIndex);
                }
              })) {
                result2 = false;
                break;
              }
            } else if (!(arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {
              result2 = false;
              break;
            }
          }
          stack["delete"](array);
          stack["delete"](other);
          return result2;
        }
        function equalByTag(object, other, tag, bitmask, customizer, equalFunc, stack) {
          switch (tag) {
            case dataViewTag:
              if (object.byteLength != other.byteLength || object.byteOffset != other.byteOffset) {
                return false;
              }
              object = object.buffer;
              other = other.buffer;
            case arrayBufferTag:
              if (object.byteLength != other.byteLength || !equalFunc(new Uint8Array2(object), new Uint8Array2(other))) {
                return false;
              }
              return true;
            case boolTag:
            case dateTag:
            case numberTag:
              return eq(+object, +other);
            case errorTag:
              return object.name == other.name && object.message == other.message;
            case regexpTag:
            case stringTag:
              return object == other + "";
            case mapTag:
              var convert = mapToArray;
            case setTag:
              var isPartial = bitmask & COMPARE_PARTIAL_FLAG;
              convert || (convert = setToArray);
              if (object.size != other.size && !isPartial) {
                return false;
              }
              var stacked = stack.get(object);
              if (stacked) {
                return stacked == other;
              }
              bitmask |= COMPARE_UNORDERED_FLAG;
              stack.set(object, other);
              var result2 = equalArrays(convert(object), convert(other), bitmask, customizer, equalFunc, stack);
              stack["delete"](object);
              return result2;
            case symbolTag:
              if (symbolValueOf) {
                return symbolValueOf.call(object) == symbolValueOf.call(other);
              }
          }
          return false;
        }
        function equalObjects(object, other, bitmask, customizer, equalFunc, stack) {
          var isPartial = bitmask & COMPARE_PARTIAL_FLAG, objProps = getAllKeys(object), objLength = objProps.length, othProps = getAllKeys(other), othLength = othProps.length;
          if (objLength != othLength && !isPartial) {
            return false;
          }
          var index = objLength;
          while (index--) {
            var key = objProps[index];
            if (!(isPartial ? key in other : hasOwnProperty.call(other, key))) {
              return false;
            }
          }
          var objStacked = stack.get(object);
          var othStacked = stack.get(other);
          if (objStacked && othStacked) {
            return objStacked == other && othStacked == object;
          }
          var result2 = true;
          stack.set(object, other);
          stack.set(other, object);
          var skipCtor = isPartial;
          while (++index < objLength) {
            key = objProps[index];
            var objValue = object[key], othValue = other[key];
            if (customizer) {
              var compared = isPartial ? customizer(othValue, objValue, key, other, object, stack) : customizer(objValue, othValue, key, object, other, stack);
            }
            if (!(compared === undefined2 ? objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack) : compared)) {
              result2 = false;
              break;
            }
            skipCtor || (skipCtor = key == "constructor");
          }
          if (result2 && !skipCtor) {
            var objCtor = object.constructor, othCtor = other.constructor;
            if (objCtor != othCtor && ("constructor" in object && "constructor" in other) && !(typeof objCtor == "function" && objCtor instanceof objCtor && typeof othCtor == "function" && othCtor instanceof othCtor)) {
              result2 = false;
            }
          }
          stack["delete"](object);
          stack["delete"](other);
          return result2;
        }
        function flatRest(func) {
          return setToString(overRest(func, undefined2, flatten2), func + "");
        }
        function getAllKeys(object) {
          return baseGetAllKeys(object, keys, getSymbols);
        }
        function getAllKeysIn(object) {
          return baseGetAllKeys(object, keysIn, getSymbolsIn);
        }
        var getData = !metaMap ? noop : function(func) {
          return metaMap.get(func);
        };
        function getFuncName(func) {
          var result2 = func.name + "", array = realNames[result2], length = hasOwnProperty.call(realNames, result2) ? array.length : 0;
          while (length--) {
            var data = array[length], otherFunc = data.func;
            if (otherFunc == null || otherFunc == func) {
              return data.name;
            }
          }
          return result2;
        }
        function getHolder(func) {
          var object = hasOwnProperty.call(lodash, "placeholder") ? lodash : func;
          return object.placeholder;
        }
        function getIteratee() {
          var result2 = lodash.iteratee || iteratee;
          result2 = result2 === iteratee ? baseIteratee : result2;
          return arguments.length ? result2(arguments[0], arguments[1]) : result2;
        }
        function getMapData(map2, key) {
          var data = map2.__data__;
          return isKeyable(key) ? data[typeof key == "string" ? "string" : "hash"] : data.map;
        }
        function getMatchData(object) {
          var result2 = keys(object), length = result2.length;
          while (length--) {
            var key = result2[length], value = object[key];
            result2[length] = [key, value, isStrictComparable(value)];
          }
          return result2;
        }
        function getNative(object, key) {
          var value = getValue(object, key);
          return baseIsNative(value) ? value : undefined2;
        }
        function getRawTag(value) {
          var isOwn = hasOwnProperty.call(value, symToStringTag), tag = value[symToStringTag];
          try {
            value[symToStringTag] = undefined2;
            var unmasked = true;
          } catch (e2) {
          }
          var result2 = nativeObjectToString.call(value);
          if (unmasked) {
            if (isOwn) {
              value[symToStringTag] = tag;
            } else {
              delete value[symToStringTag];
            }
          }
          return result2;
        }
        var getSymbols = !nativeGetSymbols ? stubArray : function(object) {
          if (object == null) {
            return [];
          }
          object = Object2(object);
          return arrayFilter(nativeGetSymbols(object), function(symbol) {
            return propertyIsEnumerable.call(object, symbol);
          });
        };
        var getSymbolsIn = !nativeGetSymbols ? stubArray : function(object) {
          var result2 = [];
          while (object) {
            arrayPush(result2, getSymbols(object));
            object = getPrototype(object);
          }
          return result2;
        };
        var getTag = baseGetTag;
        if (DataView2 && getTag(new DataView2(new ArrayBuffer(1))) != dataViewTag || Map2 && getTag(new Map2()) != mapTag || Promise2 && getTag(Promise2.resolve()) != promiseTag || Set2 && getTag(new Set2()) != setTag || WeakMap2 && getTag(new WeakMap2()) != weakMapTag) {
          getTag = function(value) {
            var result2 = baseGetTag(value), Ctor = result2 == objectTag ? value.constructor : undefined2, ctorString = Ctor ? toSource(Ctor) : "";
            if (ctorString) {
              switch (ctorString) {
                case dataViewCtorString:
                  return dataViewTag;
                case mapCtorString:
                  return mapTag;
                case promiseCtorString:
                  return promiseTag;
                case setCtorString:
                  return setTag;
                case weakMapCtorString:
                  return weakMapTag;
              }
            }
            return result2;
          };
        }
        function getView(start, end, transforms) {
          var index = -1, length = transforms.length;
          while (++index < length) {
            var data = transforms[index], size2 = data.size;
            switch (data.type) {
              case "drop":
                start += size2;
                break;
              case "dropRight":
                end -= size2;
                break;
              case "take":
                end = nativeMin(end, start + size2);
                break;
              case "takeRight":
                start = nativeMax(start, end - size2);
                break;
            }
          }
          return { "start": start, "end": end };
        }
        function getWrapDetails(source) {
          var match = source.match(reWrapDetails);
          return match ? match[1].split(reSplitDetails) : [];
        }
        function hasPath(object, path, hasFunc) {
          path = castPath(path, object);
          var index = -1, length = path.length, result2 = false;
          while (++index < length) {
            var key = toKey(path[index]);
            if (!(result2 = object != null && hasFunc(object, key))) {
              break;
            }
            object = object[key];
          }
          if (result2 || ++index != length) {
            return result2;
          }
          length = object == null ? 0 : object.length;
          return !!length && isLength(length) && isIndex(key, length) && (isArray(object) || isArguments(object));
        }
        function initCloneArray(array) {
          var length = array.length, result2 = new array.constructor(length);
          if (length && typeof array[0] == "string" && hasOwnProperty.call(array, "index")) {
            result2.index = array.index;
            result2.input = array.input;
          }
          return result2;
        }
        function initCloneObject(object) {
          return typeof object.constructor == "function" && !isPrototype(object) ? baseCreate(getPrototype(object)) : {};
        }
        function initCloneByTag(object, tag, isDeep) {
          var Ctor = object.constructor;
          switch (tag) {
            case arrayBufferTag:
              return cloneArrayBuffer(object);
            case boolTag:
            case dateTag:
              return new Ctor(+object);
            case dataViewTag:
              return cloneDataView(object, isDeep);
            case float32Tag:
            case float64Tag:
            case int8Tag:
            case int16Tag:
            case int32Tag:
            case uint8Tag:
            case uint8ClampedTag:
            case uint16Tag:
            case uint32Tag:
              return cloneTypedArray(object, isDeep);
            case mapTag:
              return new Ctor();
            case numberTag:
            case stringTag:
              return new Ctor(object);
            case regexpTag:
              return cloneRegExp(object);
            case setTag:
              return new Ctor();
            case symbolTag:
              return cloneSymbol(object);
          }
        }
        function insertWrapDetails(source, details) {
          var length = details.length;
          if (!length) {
            return source;
          }
          var lastIndex = length - 1;
          details[lastIndex] = (length > 1 ? "& " : "") + details[lastIndex];
          details = details.join(length > 2 ? ", " : " ");
          return source.replace(reWrapComment, "{\n/* [wrapped with " + details + "] */\n");
        }
        function isFlattenable(value) {
          return isArray(value) || isArguments(value) || !!(spreadableSymbol && value && value[spreadableSymbol]);
        }
        function isIndex(value, length) {
          var type = typeof value;
          length = length == null ? MAX_SAFE_INTEGER : length;
          return !!length && (type == "number" || type != "symbol" && reIsUint.test(value)) && (value > -1 && value % 1 == 0 && value < length);
        }
        function isIterateeCall(value, index, object) {
          if (!isObject(object)) {
            return false;
          }
          var type = typeof index;
          if (type == "number" ? isArrayLike(object) && isIndex(index, object.length) : type == "string" && index in object) {
            return eq(object[index], value);
          }
          return false;
        }
        function isKey(value, object) {
          if (isArray(value)) {
            return false;
          }
          var type = typeof value;
          if (type == "number" || type == "symbol" || type == "boolean" || value == null || isSymbol(value)) {
            return true;
          }
          return reIsPlainProp.test(value) || !reIsDeepProp.test(value) || object != null && value in Object2(object);
        }
        function isKeyable(value) {
          var type = typeof value;
          return type == "string" || type == "number" || type == "symbol" || type == "boolean" ? value !== "__proto__" : value === null;
        }
        function isLaziable(func) {
          var funcName = getFuncName(func), other = lodash[funcName];
          if (typeof other != "function" || !(funcName in LazyWrapper.prototype)) {
            return false;
          }
          if (func === other) {
            return true;
          }
          var data = getData(other);
          return !!data && func === data[0];
        }
        function isMasked(func) {
          return !!maskSrcKey && maskSrcKey in func;
        }
        var isMaskable = coreJsData ? isFunction : stubFalse;
        function isPrototype(value) {
          var Ctor = value && value.constructor, proto = typeof Ctor == "function" && Ctor.prototype || objectProto;
          return value === proto;
        }
        function isStrictComparable(value) {
          return value === value && !isObject(value);
        }
        function matchesStrictComparable(key, srcValue) {
          return function(object) {
            if (object == null) {
              return false;
            }
            return object[key] === srcValue && (srcValue !== undefined2 || key in Object2(object));
          };
        }
        function memoizeCapped(func) {
          var result2 = memoize(func, function(key) {
            if (cache.size === MAX_MEMOIZE_SIZE) {
              cache.clear();
            }
            return key;
          });
          var cache = result2.cache;
          return result2;
        }
        function mergeData(data, source) {
          var bitmask = data[1], srcBitmask = source[1], newBitmask = bitmask | srcBitmask, isCommon = newBitmask < (WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG | WRAP_ARY_FLAG);
          var isCombo = srcBitmask == WRAP_ARY_FLAG && bitmask == WRAP_CURRY_FLAG || srcBitmask == WRAP_ARY_FLAG && bitmask == WRAP_REARG_FLAG && data[7].length <= source[8] || srcBitmask == (WRAP_ARY_FLAG | WRAP_REARG_FLAG) && source[7].length <= source[8] && bitmask == WRAP_CURRY_FLAG;
          if (!(isCommon || isCombo)) {
            return data;
          }
          if (srcBitmask & WRAP_BIND_FLAG) {
            data[2] = source[2];
            newBitmask |= bitmask & WRAP_BIND_FLAG ? 0 : WRAP_CURRY_BOUND_FLAG;
          }
          var value = source[3];
          if (value) {
            var partials = data[3];
            data[3] = partials ? composeArgs(partials, value, source[4]) : value;
            data[4] = partials ? replaceHolders(data[3], PLACEHOLDER) : source[4];
          }
          value = source[5];
          if (value) {
            partials = data[5];
            data[5] = partials ? composeArgsRight(partials, value, source[6]) : value;
            data[6] = partials ? replaceHolders(data[5], PLACEHOLDER) : source[6];
          }
          value = source[7];
          if (value) {
            data[7] = value;
          }
          if (srcBitmask & WRAP_ARY_FLAG) {
            data[8] = data[8] == null ? source[8] : nativeMin(data[8], source[8]);
          }
          if (data[9] == null) {
            data[9] = source[9];
          }
          data[0] = source[0];
          data[1] = newBitmask;
          return data;
        }
        function nativeKeysIn(object) {
          var result2 = [];
          if (object != null) {
            for (var key in Object2(object)) {
              result2.push(key);
            }
          }
          return result2;
        }
        function objectToString(value) {
          return nativeObjectToString.call(value);
        }
        function overRest(func, start, transform2) {
          start = nativeMax(start === undefined2 ? func.length - 1 : start, 0);
          return function() {
            var args = arguments, index = -1, length = nativeMax(args.length - start, 0), array = Array2(length);
            while (++index < length) {
              array[index] = args[start + index];
            }
            index = -1;
            var otherArgs = Array2(start + 1);
            while (++index < start) {
              otherArgs[index] = args[index];
            }
            otherArgs[start] = transform2(array);
            return apply(func, this, otherArgs);
          };
        }
        function parent(object, path) {
          return path.length < 2 ? object : baseGet(object, baseSlice(path, 0, -1));
        }
        function reorder(array, indexes) {
          var arrLength = array.length, length = nativeMin(indexes.length, arrLength), oldArray = copyArray2(array);
          while (length--) {
            var index = indexes[length];
            array[length] = isIndex(index, arrLength) ? oldArray[index] : undefined2;
          }
          return array;
        }
        function safeGet(object, key) {
          if (key === "constructor" && typeof object[key] === "function") {
            return;
          }
          if (key == "__proto__") {
            return;
          }
          return object[key];
        }
        var setData = shortOut(baseSetData);
        var setTimeout2 = ctxSetTimeout || function(func, wait) {
          return root.setTimeout(func, wait);
        };
        var setToString = shortOut(baseSetToString);
        function setWrapToString(wrapper2, reference, bitmask) {
          var source = reference + "";
          return setToString(wrapper2, insertWrapDetails(source, updateWrapDetails(getWrapDetails(source), bitmask)));
        }
        function shortOut(func) {
          var count = 0, lastCalled = 0;
          return function() {
            var stamp = nativeNow(), remaining = HOT_SPAN - (stamp - lastCalled);
            lastCalled = stamp;
            if (remaining > 0) {
              if (++count >= HOT_COUNT) {
                return arguments[0];
              }
            } else {
              count = 0;
            }
            return func.apply(undefined2, arguments);
          };
        }
        function shuffleSelf(array, size2) {
          var index = -1, length = array.length, lastIndex = length - 1;
          size2 = size2 === undefined2 ? length : size2;
          while (++index < size2) {
            var rand = baseRandom(index, lastIndex), value = array[rand];
            array[rand] = array[index];
            array[index] = value;
          }
          array.length = size2;
          return array;
        }
        var stringToPath = memoizeCapped(function(string) {
          var result2 = [];
          if (string.charCodeAt(0) === 46) {
            result2.push("");
          }
          string.replace(rePropName, function(match, number, quote, subString) {
            result2.push(quote ? subString.replace(reEscapeChar, "$1") : number || match);
          });
          return result2;
        });
        function toKey(value) {
          if (typeof value == "string" || isSymbol(value)) {
            return value;
          }
          var result2 = value + "";
          return result2 == "0" && 1 / value == -INFINITY ? "-0" : result2;
        }
        function toSource(func) {
          if (func != null) {
            try {
              return funcToString.call(func);
            } catch (e2) {
            }
            try {
              return func + "";
            } catch (e2) {
            }
          }
          return "";
        }
        function updateWrapDetails(details, bitmask) {
          arrayEach(wrapFlags, function(pair) {
            var value = "_." + pair[0];
            if (bitmask & pair[1] && !arrayIncludes(details, value)) {
              details.push(value);
            }
          });
          return details.sort();
        }
        function wrapperClone(wrapper2) {
          if (wrapper2 instanceof LazyWrapper) {
            return wrapper2.clone();
          }
          var result2 = new LodashWrapper(wrapper2.__wrapped__, wrapper2.__chain__);
          result2.__actions__ = copyArray2(wrapper2.__actions__);
          result2.__index__ = wrapper2.__index__;
          result2.__values__ = wrapper2.__values__;
          return result2;
        }
        function chunk(array, size2, guard) {
          if (guard ? isIterateeCall(array, size2, guard) : size2 === undefined2) {
            size2 = 1;
          } else {
            size2 = nativeMax(toInteger(size2), 0);
          }
          var length = array == null ? 0 : array.length;
          if (!length || size2 < 1) {
            return [];
          }
          var index = 0, resIndex = 0, result2 = Array2(nativeCeil(length / size2));
          while (index < length) {
            result2[resIndex++] = baseSlice(array, index, index += size2);
          }
          return result2;
        }
        function compact(array) {
          var index = -1, length = array == null ? 0 : array.length, resIndex = 0, result2 = [];
          while (++index < length) {
            var value = array[index];
            if (value) {
              result2[resIndex++] = value;
            }
          }
          return result2;
        }
        function concat() {
          var length = arguments.length;
          if (!length) {
            return [];
          }
          var args = Array2(length - 1), array = arguments[0], index = length;
          while (index--) {
            args[index - 1] = arguments[index];
          }
          return arrayPush(isArray(array) ? copyArray2(array) : [array], baseFlatten(args, 1));
        }
        var difference = baseRest(function(array, values2) {
          return isArrayLikeObject(array) ? baseDifference(array, baseFlatten(values2, 1, isArrayLikeObject, true)) : [];
        });
        var differenceBy = baseRest(function(array, values2) {
          var iteratee2 = last(values2);
          if (isArrayLikeObject(iteratee2)) {
            iteratee2 = undefined2;
          }
          return isArrayLikeObject(array) ? baseDifference(array, baseFlatten(values2, 1, isArrayLikeObject, true), getIteratee(iteratee2, 2)) : [];
        });
        var differenceWith = baseRest(function(array, values2) {
          var comparator = last(values2);
          if (isArrayLikeObject(comparator)) {
            comparator = undefined2;
          }
          return isArrayLikeObject(array) ? baseDifference(array, baseFlatten(values2, 1, isArrayLikeObject, true), undefined2, comparator) : [];
        });
        function drop(array, n, guard) {
          var length = array == null ? 0 : array.length;
          if (!length) {
            return [];
          }
          n = guard || n === undefined2 ? 1 : toInteger(n);
          return baseSlice(array, n < 0 ? 0 : n, length);
        }
        function dropRight(array, n, guard) {
          var length = array == null ? 0 : array.length;
          if (!length) {
            return [];
          }
          n = guard || n === undefined2 ? 1 : toInteger(n);
          n = length - n;
          return baseSlice(array, 0, n < 0 ? 0 : n);
        }
        function dropRightWhile(array, predicate) {
          return array && array.length ? baseWhile(array, getIteratee(predicate, 3), true, true) : [];
        }
        function dropWhile(array, predicate) {
          return array && array.length ? baseWhile(array, getIteratee(predicate, 3), true) : [];
        }
        function fill(array, value, start, end) {
          var length = array == null ? 0 : array.length;
          if (!length) {
            return [];
          }
          if (start && typeof start != "number" && isIterateeCall(array, value, start)) {
            start = 0;
            end = length;
          }
          return baseFill(array, value, start, end);
        }
        function findIndex(array, predicate, fromIndex) {
          var length = array == null ? 0 : array.length;
          if (!length) {
            return -1;
          }
          var index = fromIndex == null ? 0 : toInteger(fromIndex);
          if (index < 0) {
            index = nativeMax(length + index, 0);
          }
          return baseFindIndex(array, getIteratee(predicate, 3), index);
        }
        function findLastIndex(array, predicate, fromIndex) {
          var length = array == null ? 0 : array.length;
          if (!length) {
            return -1;
          }
          var index = length - 1;
          if (fromIndex !== undefined2) {
            index = toInteger(fromIndex);
            index = fromIndex < 0 ? nativeMax(length + index, 0) : nativeMin(index, length - 1);
          }
          return baseFindIndex(array, getIteratee(predicate, 3), index, true);
        }
        function flatten2(array) {
          var length = array == null ? 0 : array.length;
          return length ? baseFlatten(array, 1) : [];
        }
        function flattenDeep(array) {
          var length = array == null ? 0 : array.length;
          return length ? baseFlatten(array, INFINITY) : [];
        }
        function flattenDepth(array, depth) {
          var length = array == null ? 0 : array.length;
          if (!length) {
            return [];
          }
          depth = depth === undefined2 ? 1 : toInteger(depth);
          return baseFlatten(array, depth);
        }
        function fromPairs(pairs) {
          var index = -1, length = pairs == null ? 0 : pairs.length, result2 = {};
          while (++index < length) {
            var pair = pairs[index];
            result2[pair[0]] = pair[1];
          }
          return result2;
        }
        function head(array) {
          return array && array.length ? array[0] : undefined2;
        }
        function indexOf(array, value, fromIndex) {
          var length = array == null ? 0 : array.length;
          if (!length) {
            return -1;
          }
          var index = fromIndex == null ? 0 : toInteger(fromIndex);
          if (index < 0) {
            index = nativeMax(length + index, 0);
          }
          return baseIndexOf(array, value, index);
        }
        function initial(array) {
          var length = array == null ? 0 : array.length;
          return length ? baseSlice(array, 0, -1) : [];
        }
        var intersection = baseRest(function(arrays) {
          var mapped = arrayMap(arrays, castArrayLikeObject);
          return mapped.length && mapped[0] === arrays[0] ? baseIntersection(mapped) : [];
        });
        var intersectionBy = baseRest(function(arrays) {
          var iteratee2 = last(arrays), mapped = arrayMap(arrays, castArrayLikeObject);
          if (iteratee2 === last(mapped)) {
            iteratee2 = undefined2;
          } else {
            mapped.pop();
          }
          return mapped.length && mapped[0] === arrays[0] ? baseIntersection(mapped, getIteratee(iteratee2, 2)) : [];
        });
        var intersectionWith = baseRest(function(arrays) {
          var comparator = last(arrays), mapped = arrayMap(arrays, castArrayLikeObject);
          comparator = typeof comparator == "function" ? comparator : undefined2;
          if (comparator) {
            mapped.pop();
          }
          return mapped.length && mapped[0] === arrays[0] ? baseIntersection(mapped, undefined2, comparator) : [];
        });
        function join(array, separator) {
          return array == null ? "" : nativeJoin.call(array, separator);
        }
        function last(array) {
          var length = array == null ? 0 : array.length;
          return length ? array[length - 1] : undefined2;
        }
        function lastIndexOf(array, value, fromIndex) {
          var length = array == null ? 0 : array.length;
          if (!length) {
            return -1;
          }
          var index = length;
          if (fromIndex !== undefined2) {
            index = toInteger(fromIndex);
            index = index < 0 ? nativeMax(length + index, 0) : nativeMin(index, length - 1);
          }
          return value === value ? strictLastIndexOf(array, value, index) : baseFindIndex(array, baseIsNaN, index, true);
        }
        function nth(array, n) {
          return array && array.length ? baseNth(array, toInteger(n)) : undefined2;
        }
        var pull = baseRest(pullAll);
        function pullAll(array, values2) {
          return array && array.length && values2 && values2.length ? basePullAll(array, values2) : array;
        }
        function pullAllBy(array, values2, iteratee2) {
          return array && array.length && values2 && values2.length ? basePullAll(array, values2, getIteratee(iteratee2, 2)) : array;
        }
        function pullAllWith(array, values2, comparator) {
          return array && array.length && values2 && values2.length ? basePullAll(array, values2, undefined2, comparator) : array;
        }
        var pullAt = flatRest(function(array, indexes) {
          var length = array == null ? 0 : array.length, result2 = baseAt(array, indexes);
          basePullAt(array, arrayMap(indexes, function(index) {
            return isIndex(index, length) ? +index : index;
          }).sort(compareAscending));
          return result2;
        });
        function remove(array, predicate) {
          var result2 = [];
          if (!(array && array.length)) {
            return result2;
          }
          var index = -1, indexes = [], length = array.length;
          predicate = getIteratee(predicate, 3);
          while (++index < length) {
            var value = array[index];
            if (predicate(value, index, array)) {
              result2.push(value);
              indexes.push(index);
            }
          }
          basePullAt(array, indexes);
          return result2;
        }
        function reverse(array) {
          return array == null ? array : nativeReverse.call(array);
        }
        function slice(array, start, end) {
          var length = array == null ? 0 : array.length;
          if (!length) {
            return [];
          }
          if (end && typeof end != "number" && isIterateeCall(array, start, end)) {
            start = 0;
            end = length;
          } else {
            start = start == null ? 0 : toInteger(start);
            end = end === undefined2 ? length : toInteger(end);
          }
          return baseSlice(array, start, end);
        }
        function sortedIndex(array, value) {
          return baseSortedIndex(array, value);
        }
        function sortedIndexBy(array, value, iteratee2) {
          return baseSortedIndexBy(array, value, getIteratee(iteratee2, 2));
        }
        function sortedIndexOf(array, value) {
          var length = array == null ? 0 : array.length;
          if (length) {
            var index = baseSortedIndex(array, value);
            if (index < length && eq(array[index], value)) {
              return index;
            }
          }
          return -1;
        }
        function sortedLastIndex(array, value) {
          return baseSortedIndex(array, value, true);
        }
        function sortedLastIndexBy(array, value, iteratee2) {
          return baseSortedIndexBy(array, value, getIteratee(iteratee2, 2), true);
        }
        function sortedLastIndexOf(array, value) {
          var length = array == null ? 0 : array.length;
          if (length) {
            var index = baseSortedIndex(array, value, true) - 1;
            if (eq(array[index], value)) {
              return index;
            }
          }
          return -1;
        }
        function sortedUniq(array) {
          return array && array.length ? baseSortedUniq(array) : [];
        }
        function sortedUniqBy(array, iteratee2) {
          return array && array.length ? baseSortedUniq(array, getIteratee(iteratee2, 2)) : [];
        }
        function tail(array) {
          var length = array == null ? 0 : array.length;
          return length ? baseSlice(array, 1, length) : [];
        }
        function take(array, n, guard) {
          if (!(array && array.length)) {
            return [];
          }
          n = guard || n === undefined2 ? 1 : toInteger(n);
          return baseSlice(array, 0, n < 0 ? 0 : n);
        }
        function takeRight(array, n, guard) {
          var length = array == null ? 0 : array.length;
          if (!length) {
            return [];
          }
          n = guard || n === undefined2 ? 1 : toInteger(n);
          n = length - n;
          return baseSlice(array, n < 0 ? 0 : n, length);
        }
        function takeRightWhile(array, predicate) {
          return array && array.length ? baseWhile(array, getIteratee(predicate, 3), false, true) : [];
        }
        function takeWhile(array, predicate) {
          return array && array.length ? baseWhile(array, getIteratee(predicate, 3)) : [];
        }
        var union = baseRest(function(arrays) {
          return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true));
        });
        var unionBy = baseRest(function(arrays) {
          var iteratee2 = last(arrays);
          if (isArrayLikeObject(iteratee2)) {
            iteratee2 = undefined2;
          }
          return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true), getIteratee(iteratee2, 2));
        });
        var unionWith = baseRest(function(arrays) {
          var comparator = last(arrays);
          comparator = typeof comparator == "function" ? comparator : undefined2;
          return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true), undefined2, comparator);
        });
        function uniq(array) {
          return array && array.length ? baseUniq(array) : [];
        }
        function uniqBy(array, iteratee2) {
          return array && array.length ? baseUniq(array, getIteratee(iteratee2, 2)) : [];
        }
        function uniqWith(array, comparator) {
          comparator = typeof comparator == "function" ? comparator : undefined2;
          return array && array.length ? baseUniq(array, undefined2, comparator) : [];
        }
        function unzip(array) {
          if (!(array && array.length)) {
            return [];
          }
          var length = 0;
          array = arrayFilter(array, function(group) {
            if (isArrayLikeObject(group)) {
              length = nativeMax(group.length, length);
              return true;
            }
          });
          return baseTimes(length, function(index) {
            return arrayMap(array, baseProperty(index));
          });
        }
        function unzipWith(array, iteratee2) {
          if (!(array && array.length)) {
            return [];
          }
          var result2 = unzip(array);
          if (iteratee2 == null) {
            return result2;
          }
          return arrayMap(result2, function(group) {
            return apply(iteratee2, undefined2, group);
          });
        }
        var without = baseRest(function(array, values2) {
          return isArrayLikeObject(array) ? baseDifference(array, values2) : [];
        });
        var xor = baseRest(function(arrays) {
          return baseXor(arrayFilter(arrays, isArrayLikeObject));
        });
        var xorBy = baseRest(function(arrays) {
          var iteratee2 = last(arrays);
          if (isArrayLikeObject(iteratee2)) {
            iteratee2 = undefined2;
          }
          return baseXor(arrayFilter(arrays, isArrayLikeObject), getIteratee(iteratee2, 2));
        });
        var xorWith = baseRest(function(arrays) {
          var comparator = last(arrays);
          comparator = typeof comparator == "function" ? comparator : undefined2;
          return baseXor(arrayFilter(arrays, isArrayLikeObject), undefined2, comparator);
        });
        var zip = baseRest(unzip);
        function zipObject(props, values2) {
          return baseZipObject(props || [], values2 || [], assignValue);
        }
        function zipObjectDeep(props, values2) {
          return baseZipObject(props || [], values2 || [], baseSet);
        }
        var zipWith = baseRest(function(arrays) {
          var length = arrays.length, iteratee2 = length > 1 ? arrays[length - 1] : undefined2;
          iteratee2 = typeof iteratee2 == "function" ? (arrays.pop(), iteratee2) : undefined2;
          return unzipWith(arrays, iteratee2);
        });
        function chain(value) {
          var result2 = lodash(value);
          result2.__chain__ = true;
          return result2;
        }
        function tap(value, interceptor) {
          interceptor(value);
          return value;
        }
        function thru(value, interceptor) {
          return interceptor(value);
        }
        var wrapperAt = flatRest(function(paths) {
          var length = paths.length, start = length ? paths[0] : 0, value = this.__wrapped__, interceptor = function(object) {
            return baseAt(object, paths);
          };
          if (length > 1 || this.__actions__.length || !(value instanceof LazyWrapper) || !isIndex(start)) {
            return this.thru(interceptor);
          }
          value = value.slice(start, +start + (length ? 1 : 0));
          value.__actions__.push({
            "func": thru,
            "args": [interceptor],
            "thisArg": undefined2
          });
          return new LodashWrapper(value, this.__chain__).thru(function(array) {
            if (length && !array.length) {
              array.push(undefined2);
            }
            return array;
          });
        });
        function wrapperChain() {
          return chain(this);
        }
        function wrapperCommit() {
          return new LodashWrapper(this.value(), this.__chain__);
        }
        function wrapperNext() {
          if (this.__values__ === undefined2) {
            this.__values__ = toArray(this.value());
          }
          var done = this.__index__ >= this.__values__.length, value = done ? undefined2 : this.__values__[this.__index__++];
          return { "done": done, "value": value };
        }
        function wrapperToIterator() {
          return this;
        }
        function wrapperPlant(value) {
          var result2, parent2 = this;
          while (parent2 instanceof baseLodash) {
            var clone2 = wrapperClone(parent2);
            clone2.__index__ = 0;
            clone2.__values__ = undefined2;
            if (result2) {
              previous.__wrapped__ = clone2;
            } else {
              result2 = clone2;
            }
            var previous = clone2;
            parent2 = parent2.__wrapped__;
          }
          previous.__wrapped__ = value;
          return result2;
        }
        function wrapperReverse() {
          var value = this.__wrapped__;
          if (value instanceof LazyWrapper) {
            var wrapped = value;
            if (this.__actions__.length) {
              wrapped = new LazyWrapper(this);
            }
            wrapped = wrapped.reverse();
            wrapped.__actions__.push({
              "func": thru,
              "args": [reverse],
              "thisArg": undefined2
            });
            return new LodashWrapper(wrapped, this.__chain__);
          }
          return this.thru(reverse);
        }
        function wrapperValue() {
          return baseWrapperValue(this.__wrapped__, this.__actions__);
        }
        var countBy = createAggregator(function(result2, value, key) {
          if (hasOwnProperty.call(result2, key)) {
            ++result2[key];
          } else {
            baseAssignValue(result2, key, 1);
          }
        });
        function every(collection, predicate, guard) {
          var func = isArray(collection) ? arrayEvery : baseEvery;
          if (guard && isIterateeCall(collection, predicate, guard)) {
            predicate = undefined2;
          }
          return func(collection, getIteratee(predicate, 3));
        }
        function filter(collection, predicate) {
          var func = isArray(collection) ? arrayFilter : baseFilter;
          return func(collection, getIteratee(predicate, 3));
        }
        var find = createFind(findIndex);
        var findLast = createFind(findLastIndex);
        function flatMap(collection, iteratee2) {
          return baseFlatten(map(collection, iteratee2), 1);
        }
        function flatMapDeep(collection, iteratee2) {
          return baseFlatten(map(collection, iteratee2), INFINITY);
        }
        function flatMapDepth(collection, iteratee2, depth) {
          depth = depth === undefined2 ? 1 : toInteger(depth);
          return baseFlatten(map(collection, iteratee2), depth);
        }
        function forEach(collection, iteratee2) {
          var func = isArray(collection) ? arrayEach : baseEach;
          return func(collection, getIteratee(iteratee2, 3));
        }
        function forEachRight(collection, iteratee2) {
          var func = isArray(collection) ? arrayEachRight : baseEachRight;
          return func(collection, getIteratee(iteratee2, 3));
        }
        var groupBy = createAggregator(function(result2, value, key) {
          if (hasOwnProperty.call(result2, key)) {
            result2[key].push(value);
          } else {
            baseAssignValue(result2, key, [value]);
          }
        });
        function includes(collection, value, fromIndex, guard) {
          collection = isArrayLike(collection) ? collection : values(collection);
          fromIndex = fromIndex && !guard ? toInteger(fromIndex) : 0;
          var length = collection.length;
          if (fromIndex < 0) {
            fromIndex = nativeMax(length + fromIndex, 0);
          }
          return isString(collection) ? fromIndex <= length && collection.indexOf(value, fromIndex) > -1 : !!length && baseIndexOf(collection, value, fromIndex) > -1;
        }
        var invokeMap = baseRest(function(collection, path, args) {
          var index = -1, isFunc = typeof path == "function", result2 = isArrayLike(collection) ? Array2(collection.length) : [];
          baseEach(collection, function(value) {
            result2[++index] = isFunc ? apply(path, value, args) : baseInvoke(value, path, args);
          });
          return result2;
        });
        var keyBy = createAggregator(function(result2, value, key) {
          baseAssignValue(result2, key, value);
        });
        function map(collection, iteratee2) {
          var func = isArray(collection) ? arrayMap : baseMap;
          return func(collection, getIteratee(iteratee2, 3));
        }
        function orderBy(collection, iteratees, orders, guard) {
          if (collection == null) {
            return [];
          }
          if (!isArray(iteratees)) {
            iteratees = iteratees == null ? [] : [iteratees];
          }
          orders = guard ? undefined2 : orders;
          if (!isArray(orders)) {
            orders = orders == null ? [] : [orders];
          }
          return baseOrderBy(collection, iteratees, orders);
        }
        var partition = createAggregator(function(result2, value, key) {
          result2[key ? 0 : 1].push(value);
        }, function() {
          return [[], []];
        });
        function reduce(collection, iteratee2, accumulator) {
          var func = isArray(collection) ? arrayReduce : baseReduce, initAccum = arguments.length < 3;
          return func(collection, getIteratee(iteratee2, 4), accumulator, initAccum, baseEach);
        }
        function reduceRight(collection, iteratee2, accumulator) {
          var func = isArray(collection) ? arrayReduceRight : baseReduce, initAccum = arguments.length < 3;
          return func(collection, getIteratee(iteratee2, 4), accumulator, initAccum, baseEachRight);
        }
        function reject(collection, predicate) {
          var func = isArray(collection) ? arrayFilter : baseFilter;
          return func(collection, negate(getIteratee(predicate, 3)));
        }
        function sample(collection) {
          var func = isArray(collection) ? arraySample : baseSample;
          return func(collection);
        }
        function sampleSize(collection, n, guard) {
          if (guard ? isIterateeCall(collection, n, guard) : n === undefined2) {
            n = 1;
          } else {
            n = toInteger(n);
          }
          var func = isArray(collection) ? arraySampleSize : baseSampleSize;
          return func(collection, n);
        }
        function shuffle(collection) {
          var func = isArray(collection) ? arrayShuffle : baseShuffle;
          return func(collection);
        }
        function size(collection) {
          if (collection == null) {
            return 0;
          }
          if (isArrayLike(collection)) {
            return isString(collection) ? stringSize(collection) : collection.length;
          }
          var tag = getTag(collection);
          if (tag == mapTag || tag == setTag) {
            return collection.size;
          }
          return baseKeys(collection).length;
        }
        function some(collection, predicate, guard) {
          var func = isArray(collection) ? arraySome : baseSome;
          if (guard && isIterateeCall(collection, predicate, guard)) {
            predicate = undefined2;
          }
          return func(collection, getIteratee(predicate, 3));
        }
        var sortBy = baseRest(function(collection, iteratees) {
          if (collection == null) {
            return [];
          }
          var length = iteratees.length;
          if (length > 1 && isIterateeCall(collection, iteratees[0], iteratees[1])) {
            iteratees = [];
          } else if (length > 2 && isIterateeCall(iteratees[0], iteratees[1], iteratees[2])) {
            iteratees = [iteratees[0]];
          }
          return baseOrderBy(collection, baseFlatten(iteratees, 1), []);
        });
        var now3 = ctxNow || function() {
          return root.Date.now();
        };
        function after(n, func) {
          if (typeof func != "function") {
            throw new TypeError2(FUNC_ERROR_TEXT);
          }
          n = toInteger(n);
          return function() {
            if (--n < 1) {
              return func.apply(this, arguments);
            }
          };
        }
        function ary(func, n, guard) {
          n = guard ? undefined2 : n;
          n = func && n == null ? func.length : n;
          return createWrap(func, WRAP_ARY_FLAG, undefined2, undefined2, undefined2, undefined2, n);
        }
        function before(n, func) {
          var result2;
          if (typeof func != "function") {
            throw new TypeError2(FUNC_ERROR_TEXT);
          }
          n = toInteger(n);
          return function() {
            if (--n > 0) {
              result2 = func.apply(this, arguments);
            }
            if (n <= 1) {
              func = undefined2;
            }
            return result2;
          };
        }
        var bind = baseRest(function(func, thisArg, partials) {
          var bitmask = WRAP_BIND_FLAG;
          if (partials.length) {
            var holders = replaceHolders(partials, getHolder(bind));
            bitmask |= WRAP_PARTIAL_FLAG;
          }
          return createWrap(func, bitmask, thisArg, partials, holders);
        });
        var bindKey = baseRest(function(object, key, partials) {
          var bitmask = WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG;
          if (partials.length) {
            var holders = replaceHolders(partials, getHolder(bindKey));
            bitmask |= WRAP_PARTIAL_FLAG;
          }
          return createWrap(key, bitmask, object, partials, holders);
        });
        function curry(func, arity, guard) {
          arity = guard ? undefined2 : arity;
          var result2 = createWrap(func, WRAP_CURRY_FLAG, undefined2, undefined2, undefined2, undefined2, undefined2, arity);
          result2.placeholder = curry.placeholder;
          return result2;
        }
        function curryRight(func, arity, guard) {
          arity = guard ? undefined2 : arity;
          var result2 = createWrap(func, WRAP_CURRY_RIGHT_FLAG, undefined2, undefined2, undefined2, undefined2, undefined2, arity);
          result2.placeholder = curryRight.placeholder;
          return result2;
        }
        function debounce(func, wait, options2) {
          var lastArgs, lastThis, maxWait, result2, timerId, lastCallTime, lastInvokeTime = 0, leading = false, maxing = false, trailing = true;
          if (typeof func != "function") {
            throw new TypeError2(FUNC_ERROR_TEXT);
          }
          wait = toNumber(wait) || 0;
          if (isObject(options2)) {
            leading = !!options2.leading;
            maxing = "maxWait" in options2;
            maxWait = maxing ? nativeMax(toNumber(options2.maxWait) || 0, wait) : maxWait;
            trailing = "trailing" in options2 ? !!options2.trailing : trailing;
          }
          function invokeFunc(time) {
            var args = lastArgs, thisArg = lastThis;
            lastArgs = lastThis = undefined2;
            lastInvokeTime = time;
            result2 = func.apply(thisArg, args);
            return result2;
          }
          function leadingEdge(time) {
            lastInvokeTime = time;
            timerId = setTimeout2(timerExpired, wait);
            return leading ? invokeFunc(time) : result2;
          }
          function remainingWait(time) {
            var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime, timeWaiting = wait - timeSinceLastCall;
            return maxing ? nativeMin(timeWaiting, maxWait - timeSinceLastInvoke) : timeWaiting;
          }
          function shouldInvoke(time) {
            var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime;
            return lastCallTime === undefined2 || timeSinceLastCall >= wait || timeSinceLastCall < 0 || maxing && timeSinceLastInvoke >= maxWait;
          }
          function timerExpired() {
            var time = now3();
            if (shouldInvoke(time)) {
              return trailingEdge(time);
            }
            timerId = setTimeout2(timerExpired, remainingWait(time));
          }
          function trailingEdge(time) {
            timerId = undefined2;
            if (trailing && lastArgs) {
              return invokeFunc(time);
            }
            lastArgs = lastThis = undefined2;
            return result2;
          }
          function cancel() {
            if (timerId !== undefined2) {
              clearTimeout(timerId);
            }
            lastInvokeTime = 0;
            lastArgs = lastCallTime = lastThis = timerId = undefined2;
          }
          function flush() {
            return timerId === undefined2 ? result2 : trailingEdge(now3());
          }
          function debounced() {
            var time = now3(), isInvoking = shouldInvoke(time);
            lastArgs = arguments;
            lastThis = this;
            lastCallTime = time;
            if (isInvoking) {
              if (timerId === undefined2) {
                return leadingEdge(lastCallTime);
              }
              if (maxing) {
                clearTimeout(timerId);
                timerId = setTimeout2(timerExpired, wait);
                return invokeFunc(lastCallTime);
              }
            }
            if (timerId === undefined2) {
              timerId = setTimeout2(timerExpired, wait);
            }
            return result2;
          }
          debounced.cancel = cancel;
          debounced.flush = flush;
          return debounced;
        }
        var defer = baseRest(function(func, args) {
          return baseDelay(func, 1, args);
        });
        var delay = baseRest(function(func, wait, args) {
          return baseDelay(func, toNumber(wait) || 0, args);
        });
        function flip(func) {
          return createWrap(func, WRAP_FLIP_FLAG);
        }
        function memoize(func, resolver) {
          if (typeof func != "function" || resolver != null && typeof resolver != "function") {
            throw new TypeError2(FUNC_ERROR_TEXT);
          }
          var memoized = function() {
            var args = arguments, key = resolver ? resolver.apply(this, args) : args[0], cache = memoized.cache;
            if (cache.has(key)) {
              return cache.get(key);
            }
            var result2 = func.apply(this, args);
            memoized.cache = cache.set(key, result2) || cache;
            return result2;
          };
          memoized.cache = new (memoize.Cache || MapCache)();
          return memoized;
        }
        memoize.Cache = MapCache;
        function negate(predicate) {
          if (typeof predicate != "function") {
            throw new TypeError2(FUNC_ERROR_TEXT);
          }
          return function() {
            var args = arguments;
            switch (args.length) {
              case 0:
                return !predicate.call(this);
              case 1:
                return !predicate.call(this, args[0]);
              case 2:
                return !predicate.call(this, args[0], args[1]);
              case 3:
                return !predicate.call(this, args[0], args[1], args[2]);
            }
            return !predicate.apply(this, args);
          };
        }
        function once(func) {
          return before(2, func);
        }
        var overArgs = castRest(function(func, transforms) {
          transforms = transforms.length == 1 && isArray(transforms[0]) ? arrayMap(transforms[0], baseUnary(getIteratee())) : arrayMap(baseFlatten(transforms, 1), baseUnary(getIteratee()));
          var funcsLength = transforms.length;
          return baseRest(function(args) {
            var index = -1, length = nativeMin(args.length, funcsLength);
            while (++index < length) {
              args[index] = transforms[index].call(this, args[index]);
            }
            return apply(func, this, args);
          });
        });
        var partial = baseRest(function(func, partials) {
          var holders = replaceHolders(partials, getHolder(partial));
          return createWrap(func, WRAP_PARTIAL_FLAG, undefined2, partials, holders);
        });
        var partialRight = baseRest(function(func, partials) {
          var holders = replaceHolders(partials, getHolder(partialRight));
          return createWrap(func, WRAP_PARTIAL_RIGHT_FLAG, undefined2, partials, holders);
        });
        var rearg = flatRest(function(func, indexes) {
          return createWrap(func, WRAP_REARG_FLAG, undefined2, undefined2, undefined2, indexes);
        });
        function rest(func, start) {
          if (typeof func != "function") {
            throw new TypeError2(FUNC_ERROR_TEXT);
          }
          start = start === undefined2 ? start : toInteger(start);
          return baseRest(func, start);
        }
        function spread(func, start) {
          if (typeof func != "function") {
            throw new TypeError2(FUNC_ERROR_TEXT);
          }
          start = start == null ? 0 : nativeMax(toInteger(start), 0);
          return baseRest(function(args) {
            var array = args[start], otherArgs = castSlice(args, 0, start);
            if (array) {
              arrayPush(otherArgs, array);
            }
            return apply(func, this, otherArgs);
          });
        }
        function throttle(func, wait, options2) {
          var leading = true, trailing = true;
          if (typeof func != "function") {
            throw new TypeError2(FUNC_ERROR_TEXT);
          }
          if (isObject(options2)) {
            leading = "leading" in options2 ? !!options2.leading : leading;
            trailing = "trailing" in options2 ? !!options2.trailing : trailing;
          }
          return debounce(func, wait, {
            "leading": leading,
            "maxWait": wait,
            "trailing": trailing
          });
        }
        function unary(func) {
          return ary(func, 1);
        }
        function wrap(value, wrapper2) {
          return partial(castFunction(wrapper2), value);
        }
        function castArray() {
          if (!arguments.length) {
            return [];
          }
          var value = arguments[0];
          return isArray(value) ? value : [value];
        }
        function clone(value) {
          return baseClone(value, CLONE_SYMBOLS_FLAG);
        }
        function cloneWith(value, customizer) {
          customizer = typeof customizer == "function" ? customizer : undefined2;
          return baseClone(value, CLONE_SYMBOLS_FLAG, customizer);
        }
        function cloneDeep(value) {
          return baseClone(value, CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG);
        }
        function cloneDeepWith(value, customizer) {
          customizer = typeof customizer == "function" ? customizer : undefined2;
          return baseClone(value, CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG, customizer);
        }
        function conformsTo(object, source) {
          return source == null || baseConformsTo(object, source, keys(source));
        }
        function eq(value, other) {
          return value === other || value !== value && other !== other;
        }
        var gt = createRelationalOperation(baseGt);
        var gte = createRelationalOperation(function(value, other) {
          return value >= other;
        });
        var isArguments = baseIsArguments(/* @__PURE__ */ function() {
          return arguments;
        }()) ? baseIsArguments : function(value) {
          return isObjectLike(value) && hasOwnProperty.call(value, "callee") && !propertyIsEnumerable.call(value, "callee");
        };
        var isArray = Array2.isArray;
        var isArrayBuffer = nodeIsArrayBuffer ? baseUnary(nodeIsArrayBuffer) : baseIsArrayBuffer;
        function isArrayLike(value) {
          return value != null && isLength(value.length) && !isFunction(value);
        }
        function isArrayLikeObject(value) {
          return isObjectLike(value) && isArrayLike(value);
        }
        function isBoolean(value) {
          return value === true || value === false || isObjectLike(value) && baseGetTag(value) == boolTag;
        }
        var isBuffer = nativeIsBuffer || stubFalse;
        var isDate = nodeIsDate ? baseUnary(nodeIsDate) : baseIsDate;
        function isElement(value) {
          return isObjectLike(value) && value.nodeType === 1 && !isPlainObject(value);
        }
        function isEmpty(value) {
          if (value == null) {
            return true;
          }
          if (isArrayLike(value) && (isArray(value) || typeof value == "string" || typeof value.splice == "function" || isBuffer(value) || isTypedArray2(value) || isArguments(value))) {
            return !value.length;
          }
          var tag = getTag(value);
          if (tag == mapTag || tag == setTag) {
            return !value.size;
          }
          if (isPrototype(value)) {
            return !baseKeys(value).length;
          }
          for (var key in value) {
            if (hasOwnProperty.call(value, key)) {
              return false;
            }
          }
          return true;
        }
        function isEqual(value, other) {
          return baseIsEqual(value, other);
        }
        function isEqualWith(value, other, customizer) {
          customizer = typeof customizer == "function" ? customizer : undefined2;
          var result2 = customizer ? customizer(value, other) : undefined2;
          return result2 === undefined2 ? baseIsEqual(value, other, undefined2, customizer) : !!result2;
        }
        function isError(value) {
          if (!isObjectLike(value)) {
            return false;
          }
          var tag = baseGetTag(value);
          return tag == errorTag || tag == domExcTag || typeof value.message == "string" && typeof value.name == "string" && !isPlainObject(value);
        }
        function isFinite2(value) {
          return typeof value == "number" && nativeIsFinite(value);
        }
        function isFunction(value) {
          if (!isObject(value)) {
            return false;
          }
          var tag = baseGetTag(value);
          return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
        }
        function isInteger(value) {
          return typeof value == "number" && value == toInteger(value);
        }
        function isLength(value) {
          return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
        }
        function isObject(value) {
          var type = typeof value;
          return value != null && (type == "object" || type == "function");
        }
        function isObjectLike(value) {
          return value != null && typeof value == "object";
        }
        var isMap = nodeIsMap ? baseUnary(nodeIsMap) : baseIsMap;
        function isMatch(object, source) {
          return object === source || baseIsMatch(object, source, getMatchData(source));
        }
        function isMatchWith(object, source, customizer) {
          customizer = typeof customizer == "function" ? customizer : undefined2;
          return baseIsMatch(object, source, getMatchData(source), customizer);
        }
        function isNaN2(value) {
          return isNumber(value) && value != +value;
        }
        function isNative(value) {
          if (isMaskable(value)) {
            throw new Error2(CORE_ERROR_TEXT);
          }
          return baseIsNative(value);
        }
        function isNull(value) {
          return value === null;
        }
        function isNil(value) {
          return value == null;
        }
        function isNumber(value) {
          return typeof value == "number" || isObjectLike(value) && baseGetTag(value) == numberTag;
        }
        function isPlainObject(value) {
          if (!isObjectLike(value) || baseGetTag(value) != objectTag) {
            return false;
          }
          var proto = getPrototype(value);
          if (proto === null) {
            return true;
          }
          var Ctor = hasOwnProperty.call(proto, "constructor") && proto.constructor;
          return typeof Ctor == "function" && Ctor instanceof Ctor && funcToString.call(Ctor) == objectCtorString;
        }
        var isRegExp = nodeIsRegExp ? baseUnary(nodeIsRegExp) : baseIsRegExp;
        function isSafeInteger(value) {
          return isInteger(value) && value >= -MAX_SAFE_INTEGER && value <= MAX_SAFE_INTEGER;
        }
        var isSet = nodeIsSet ? baseUnary(nodeIsSet) : baseIsSet;
        function isString(value) {
          return typeof value == "string" || !isArray(value) && isObjectLike(value) && baseGetTag(value) == stringTag;
        }
        function isSymbol(value) {
          return typeof value == "symbol" || isObjectLike(value) && baseGetTag(value) == symbolTag;
        }
        var isTypedArray2 = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;
        function isUndefined(value) {
          return value === undefined2;
        }
        function isWeakMap(value) {
          return isObjectLike(value) && getTag(value) == weakMapTag;
        }
        function isWeakSet(value) {
          return isObjectLike(value) && baseGetTag(value) == weakSetTag;
        }
        var lt = createRelationalOperation(baseLt);
        var lte = createRelationalOperation(function(value, other) {
          return value <= other;
        });
        function toArray(value) {
          if (!value) {
            return [];
          }
          if (isArrayLike(value)) {
            return isString(value) ? stringToArray(value) : copyArray2(value);
          }
          if (symIterator && value[symIterator]) {
            return iteratorToArray(value[symIterator]());
          }
          var tag = getTag(value), func = tag == mapTag ? mapToArray : tag == setTag ? setToArray : values;
          return func(value);
        }
        function toFinite(value) {
          if (!value) {
            return value === 0 ? value : 0;
          }
          value = toNumber(value);
          if (value === INFINITY || value === -INFINITY) {
            var sign2 = value < 0 ? -1 : 1;
            return sign2 * MAX_INTEGER;
          }
          return value === value ? value : 0;
        }
        function toInteger(value) {
          var result2 = toFinite(value), remainder = result2 % 1;
          return result2 === result2 ? remainder ? result2 - remainder : result2 : 0;
        }
        function toLength(value) {
          return value ? baseClamp(toInteger(value), 0, MAX_ARRAY_LENGTH) : 0;
        }
        function toNumber(value) {
          if (typeof value == "number") {
            return value;
          }
          if (isSymbol(value)) {
            return NAN;
          }
          if (isObject(value)) {
            var other = typeof value.valueOf == "function" ? value.valueOf() : value;
            value = isObject(other) ? other + "" : other;
          }
          if (typeof value != "string") {
            return value === 0 ? value : +value;
          }
          value = baseTrim(value);
          var isBinary = reIsBinary.test(value);
          return isBinary || reIsOctal.test(value) ? freeParseInt(value.slice(2), isBinary ? 2 : 8) : reIsBadHex.test(value) ? NAN : +value;
        }
        function toPlainObject(value) {
          return copyObject(value, keysIn(value));
        }
        function toSafeInteger(value) {
          return value ? baseClamp(toInteger(value), -MAX_SAFE_INTEGER, MAX_SAFE_INTEGER) : value === 0 ? value : 0;
        }
        function toString(value) {
          return value == null ? "" : baseToString(value);
        }
        var assign = createAssigner(function(object, source) {
          if (isPrototype(source) || isArrayLike(source)) {
            copyObject(source, keys(source), object);
            return;
          }
          for (var key in source) {
            if (hasOwnProperty.call(source, key)) {
              assignValue(object, key, source[key]);
            }
          }
        });
        var assignIn = createAssigner(function(object, source) {
          copyObject(source, keysIn(source), object);
        });
        var assignInWith = createAssigner(function(object, source, srcIndex, customizer) {
          copyObject(source, keysIn(source), object, customizer);
        });
        var assignWith = createAssigner(function(object, source, srcIndex, customizer) {
          copyObject(source, keys(source), object, customizer);
        });
        var at = flatRest(baseAt);
        function create(prototype, properties) {
          var result2 = baseCreate(prototype);
          return properties == null ? result2 : baseAssign(result2, properties);
        }
        var defaults2 = baseRest(function(object, sources) {
          object = Object2(object);
          var index = -1;
          var length = sources.length;
          var guard = length > 2 ? sources[2] : undefined2;
          if (guard && isIterateeCall(sources[0], sources[1], guard)) {
            length = 1;
          }
          while (++index < length) {
            var source = sources[index];
            var props = keysIn(source);
            var propsIndex = -1;
            var propsLength = props.length;
            while (++propsIndex < propsLength) {
              var key = props[propsIndex];
              var value = object[key];
              if (value === undefined2 || eq(value, objectProto[key]) && !hasOwnProperty.call(object, key)) {
                object[key] = source[key];
              }
            }
          }
          return object;
        });
        var defaultsDeep = baseRest(function(args) {
          args.push(undefined2, customDefaultsMerge);
          return apply(mergeWith, undefined2, args);
        });
        function findKey(object, predicate) {
          return baseFindKey(object, getIteratee(predicate, 3), baseForOwn);
        }
        function findLastKey(object, predicate) {
          return baseFindKey(object, getIteratee(predicate, 3), baseForOwnRight);
        }
        function forIn(object, iteratee2) {
          return object == null ? object : baseFor(object, getIteratee(iteratee2, 3), keysIn);
        }
        function forInRight(object, iteratee2) {
          return object == null ? object : baseForRight(object, getIteratee(iteratee2, 3), keysIn);
        }
        function forOwn(object, iteratee2) {
          return object && baseForOwn(object, getIteratee(iteratee2, 3));
        }
        function forOwnRight(object, iteratee2) {
          return object && baseForOwnRight(object, getIteratee(iteratee2, 3));
        }
        function functions(object) {
          return object == null ? [] : baseFunctions(object, keys(object));
        }
        function functionsIn(object) {
          return object == null ? [] : baseFunctions(object, keysIn(object));
        }
        function get(object, path, defaultValue) {
          var result2 = object == null ? undefined2 : baseGet(object, path);
          return result2 === undefined2 ? defaultValue : result2;
        }
        function has(object, path) {
          return object != null && hasPath(object, path, baseHas);
        }
        function hasIn(object, path) {
          return object != null && hasPath(object, path, baseHasIn);
        }
        var invert = createInverter(function(result2, value, key) {
          if (value != null && typeof value.toString != "function") {
            value = nativeObjectToString.call(value);
          }
          result2[value] = key;
        }, constant(identity));
        var invertBy = createInverter(function(result2, value, key) {
          if (value != null && typeof value.toString != "function") {
            value = nativeObjectToString.call(value);
          }
          if (hasOwnProperty.call(result2, value)) {
            result2[value].push(key);
          } else {
            result2[value] = [key];
          }
        }, getIteratee);
        var invoke = baseRest(baseInvoke);
        function keys(object) {
          return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
        }
        function keysIn(object) {
          return isArrayLike(object) ? arrayLikeKeys(object, true) : baseKeysIn(object);
        }
        function mapKeys(object, iteratee2) {
          var result2 = {};
          iteratee2 = getIteratee(iteratee2, 3);
          baseForOwn(object, function(value, key, object2) {
            baseAssignValue(result2, iteratee2(value, key, object2), value);
          });
          return result2;
        }
        function mapValues(object, iteratee2) {
          var result2 = {};
          iteratee2 = getIteratee(iteratee2, 3);
          baseForOwn(object, function(value, key, object2) {
            baseAssignValue(result2, key, iteratee2(value, key, object2));
          });
          return result2;
        }
        var merge = createAssigner(function(object, source, srcIndex) {
          baseMerge(object, source, srcIndex);
        });
        var mergeWith = createAssigner(function(object, source, srcIndex, customizer) {
          baseMerge(object, source, srcIndex, customizer);
        });
        var omit = flatRest(function(object, paths) {
          var result2 = {};
          if (object == null) {
            return result2;
          }
          var isDeep = false;
          paths = arrayMap(paths, function(path) {
            path = castPath(path, object);
            isDeep || (isDeep = path.length > 1);
            return path;
          });
          copyObject(object, getAllKeysIn(object), result2);
          if (isDeep) {
            result2 = baseClone(result2, CLONE_DEEP_FLAG | CLONE_FLAT_FLAG | CLONE_SYMBOLS_FLAG, customOmitClone);
          }
          var length = paths.length;
          while (length--) {
            baseUnset(result2, paths[length]);
          }
          return result2;
        });
        function omitBy(object, predicate) {
          return pickBy(object, negate(getIteratee(predicate)));
        }
        var pick = flatRest(function(object, paths) {
          return object == null ? {} : basePick(object, paths);
        });
        function pickBy(object, predicate) {
          if (object == null) {
            return {};
          }
          var props = arrayMap(getAllKeysIn(object), function(prop) {
            return [prop];
          });
          predicate = getIteratee(predicate);
          return basePickBy(object, props, function(value, path) {
            return predicate(value, path[0]);
          });
        }
        function result(object, path, defaultValue) {
          path = castPath(path, object);
          var index = -1, length = path.length;
          if (!length) {
            length = 1;
            object = undefined2;
          }
          while (++index < length) {
            var value = object == null ? undefined2 : object[toKey(path[index])];
            if (value === undefined2) {
              index = length;
              value = defaultValue;
            }
            object = isFunction(value) ? value.call(object) : value;
          }
          return object;
        }
        function set(object, path, value) {
          return object == null ? object : baseSet(object, path, value);
        }
        function setWith(object, path, value, customizer) {
          customizer = typeof customizer == "function" ? customizer : undefined2;
          return object == null ? object : baseSet(object, path, value, customizer);
        }
        var toPairs = createToPairs(keys);
        var toPairsIn = createToPairs(keysIn);
        function transform(object, iteratee2, accumulator) {
          var isArr = isArray(object), isArrLike = isArr || isBuffer(object) || isTypedArray2(object);
          iteratee2 = getIteratee(iteratee2, 4);
          if (accumulator == null) {
            var Ctor = object && object.constructor;
            if (isArrLike) {
              accumulator = isArr ? new Ctor() : [];
            } else if (isObject(object)) {
              accumulator = isFunction(Ctor) ? baseCreate(getPrototype(object)) : {};
            } else {
              accumulator = {};
            }
          }
          (isArrLike ? arrayEach : baseForOwn)(object, function(value, index, object2) {
            return iteratee2(accumulator, value, index, object2);
          });
          return accumulator;
        }
        function unset(object, path) {
          return object == null ? true : baseUnset(object, path);
        }
        function update(object, path, updater) {
          return object == null ? object : baseUpdate(object, path, castFunction(updater));
        }
        function updateWith(object, path, updater, customizer) {
          customizer = typeof customizer == "function" ? customizer : undefined2;
          return object == null ? object : baseUpdate(object, path, castFunction(updater), customizer);
        }
        function values(object) {
          return object == null ? [] : baseValues(object, keys(object));
        }
        function valuesIn(object) {
          return object == null ? [] : baseValues(object, keysIn(object));
        }
        function clamp3(number, lower, upper) {
          if (upper === undefined2) {
            upper = lower;
            lower = undefined2;
          }
          if (upper !== undefined2) {
            upper = toNumber(upper);
            upper = upper === upper ? upper : 0;
          }
          if (lower !== undefined2) {
            lower = toNumber(lower);
            lower = lower === lower ? lower : 0;
          }
          return baseClamp(toNumber(number), lower, upper);
        }
        function inRange(number, start, end) {
          start = toFinite(start);
          if (end === undefined2) {
            end = start;
            start = 0;
          } else {
            end = toFinite(end);
          }
          number = toNumber(number);
          return baseInRange(number, start, end);
        }
        function random(lower, upper, floating) {
          if (floating && typeof floating != "boolean" && isIterateeCall(lower, upper, floating)) {
            upper = floating = undefined2;
          }
          if (floating === undefined2) {
            if (typeof upper == "boolean") {
              floating = upper;
              upper = undefined2;
            } else if (typeof lower == "boolean") {
              floating = lower;
              lower = undefined2;
            }
          }
          if (lower === undefined2 && upper === undefined2) {
            lower = 0;
            upper = 1;
          } else {
            lower = toFinite(lower);
            if (upper === undefined2) {
              upper = lower;
              lower = 0;
            } else {
              upper = toFinite(upper);
            }
          }
          if (lower > upper) {
            var temp = lower;
            lower = upper;
            upper = temp;
          }
          if (floating || lower % 1 || upper % 1) {
            var rand = nativeRandom();
            return nativeMin(lower + rand * (upper - lower + freeParseFloat("1e-" + ((rand + "").length - 1))), upper);
          }
          return baseRandom(lower, upper);
        }
        var camelCase = createCompounder(function(result2, word, index) {
          word = word.toLowerCase();
          return result2 + (index ? capitalize(word) : word);
        });
        function capitalize(string) {
          return upperFirst(toString(string).toLowerCase());
        }
        function deburr(string) {
          string = toString(string);
          return string && string.replace(reLatin, deburrLetter).replace(reComboMark, "");
        }
        function endsWith(string, target, position) {
          string = toString(string);
          target = baseToString(target);
          var length = string.length;
          position = position === undefined2 ? length : baseClamp(toInteger(position), 0, length);
          var end = position;
          position -= target.length;
          return position >= 0 && string.slice(position, end) == target;
        }
        function escape2(string) {
          string = toString(string);
          return string && reHasUnescapedHtml.test(string) ? string.replace(reUnescapedHtml, escapeHtmlChar) : string;
        }
        function escapeRegExp(string) {
          string = toString(string);
          return string && reHasRegExpChar.test(string) ? string.replace(reRegExpChar, "\\$&") : string;
        }
        var kebabCase = createCompounder(function(result2, word, index) {
          return result2 + (index ? "-" : "") + word.toLowerCase();
        });
        var lowerCase = createCompounder(function(result2, word, index) {
          return result2 + (index ? " " : "") + word.toLowerCase();
        });
        var lowerFirst = createCaseFirst("toLowerCase");
        function pad(string, length, chars) {
          string = toString(string);
          length = toInteger(length);
          var strLength = length ? stringSize(string) : 0;
          if (!length || strLength >= length) {
            return string;
          }
          var mid = (length - strLength) / 2;
          return createPadding(nativeFloor(mid), chars) + string + createPadding(nativeCeil(mid), chars);
        }
        function padEnd(string, length, chars) {
          string = toString(string);
          length = toInteger(length);
          var strLength = length ? stringSize(string) : 0;
          return length && strLength < length ? string + createPadding(length - strLength, chars) : string;
        }
        function padStart(string, length, chars) {
          string = toString(string);
          length = toInteger(length);
          var strLength = length ? stringSize(string) : 0;
          return length && strLength < length ? createPadding(length - strLength, chars) + string : string;
        }
        function parseInt2(string, radix, guard) {
          if (guard || radix == null) {
            radix = 0;
          } else if (radix) {
            radix = +radix;
          }
          return nativeParseInt(toString(string).replace(reTrimStart, ""), radix || 0);
        }
        function repeat(string, n, guard) {
          if (guard ? isIterateeCall(string, n, guard) : n === undefined2) {
            n = 1;
          } else {
            n = toInteger(n);
          }
          return baseRepeat(toString(string), n);
        }
        function replace() {
          var args = arguments, string = toString(args[0]);
          return args.length < 3 ? string : string.replace(args[1], args[2]);
        }
        var snakeCase = createCompounder(function(result2, word, index) {
          return result2 + (index ? "_" : "") + word.toLowerCase();
        });
        function split(string, separator, limit) {
          if (limit && typeof limit != "number" && isIterateeCall(string, separator, limit)) {
            separator = limit = undefined2;
          }
          limit = limit === undefined2 ? MAX_ARRAY_LENGTH : limit >>> 0;
          if (!limit) {
            return [];
          }
          string = toString(string);
          if (string && (typeof separator == "string" || separator != null && !isRegExp(separator))) {
            separator = baseToString(separator);
            if (!separator && hasUnicode(string)) {
              return castSlice(stringToArray(string), 0, limit);
            }
          }
          return string.split(separator, limit);
        }
        var startCase = createCompounder(function(result2, word, index) {
          return result2 + (index ? " " : "") + upperFirst(word);
        });
        function startsWith(string, target, position) {
          string = toString(string);
          position = position == null ? 0 : baseClamp(toInteger(position), 0, string.length);
          target = baseToString(target);
          return string.slice(position, position + target.length) == target;
        }
        function template(string, options2, guard) {
          var settings2 = lodash.templateSettings;
          if (guard && isIterateeCall(string, options2, guard)) {
            options2 = undefined2;
          }
          string = toString(string);
          options2 = assignInWith({}, options2, settings2, customDefaultsAssignIn);
          var imports = assignInWith({}, options2.imports, settings2.imports, customDefaultsAssignIn), importsKeys = keys(imports), importsValues = baseValues(imports, importsKeys);
          var isEscaping, isEvaluating, index = 0, interpolate = options2.interpolate || reNoMatch, source = "__p += '";
          var reDelimiters = RegExp2(
            (options2.escape || reNoMatch).source + "|" + interpolate.source + "|" + (interpolate === reInterpolate ? reEsTemplate : reNoMatch).source + "|" + (options2.evaluate || reNoMatch).source + "|$",
            "g"
          );
          var sourceURL = "//# sourceURL=" + (hasOwnProperty.call(options2, "sourceURL") ? (options2.sourceURL + "").replace(/\s/g, " ") : "lodash.templateSources[" + ++templateCounter + "]") + "\n";
          string.replace(reDelimiters, function(match, escapeValue, interpolateValue, esTemplateValue, evaluateValue, offset) {
            interpolateValue || (interpolateValue = esTemplateValue);
            source += string.slice(index, offset).replace(reUnescapedString, escapeStringChar);
            if (escapeValue) {
              isEscaping = true;
              source += "' +\n__e(" + escapeValue + ") +\n'";
            }
            if (evaluateValue) {
              isEvaluating = true;
              source += "';\n" + evaluateValue + ";\n__p += '";
            }
            if (interpolateValue) {
              source += "' +\n((__t = (" + interpolateValue + ")) == null ? '' : __t) +\n'";
            }
            index = offset + match.length;
            return match;
          });
          source += "';\n";
          var variable = hasOwnProperty.call(options2, "variable") && options2.variable;
          if (!variable) {
            source = "with (obj) {\n" + source + "\n}\n";
          } else if (reForbiddenIdentifierChars.test(variable)) {
            throw new Error2(INVALID_TEMPL_VAR_ERROR_TEXT);
          }
          source = (isEvaluating ? source.replace(reEmptyStringLeading, "") : source).replace(reEmptyStringMiddle, "$1").replace(reEmptyStringTrailing, "$1;");
          source = "function(" + (variable || "obj") + ") {\n" + (variable ? "" : "obj || (obj = {});\n") + "var __t, __p = ''" + (isEscaping ? ", __e = _.escape" : "") + (isEvaluating ? ", __j = Array.prototype.join;\nfunction print() { __p += __j.call(arguments, '') }\n" : ";\n") + source + "return __p\n}";
          var result2 = attempt(function() {
            return Function2(importsKeys, sourceURL + "return " + source).apply(undefined2, importsValues);
          });
          result2.source = source;
          if (isError(result2)) {
            throw result2;
          }
          return result2;
        }
        function toLower(value) {
          return toString(value).toLowerCase();
        }
        function toUpper(value) {
          return toString(value).toUpperCase();
        }
        function trim(string, chars, guard) {
          string = toString(string);
          if (string && (guard || chars === undefined2)) {
            return baseTrim(string);
          }
          if (!string || !(chars = baseToString(chars))) {
            return string;
          }
          var strSymbols = stringToArray(string), chrSymbols = stringToArray(chars), start = charsStartIndex(strSymbols, chrSymbols), end = charsEndIndex(strSymbols, chrSymbols) + 1;
          return castSlice(strSymbols, start, end).join("");
        }
        function trimEnd(string, chars, guard) {
          string = toString(string);
          if (string && (guard || chars === undefined2)) {
            return string.slice(0, trimmedEndIndex(string) + 1);
          }
          if (!string || !(chars = baseToString(chars))) {
            return string;
          }
          var strSymbols = stringToArray(string), end = charsEndIndex(strSymbols, stringToArray(chars)) + 1;
          return castSlice(strSymbols, 0, end).join("");
        }
        function trimStart(string, chars, guard) {
          string = toString(string);
          if (string && (guard || chars === undefined2)) {
            return string.replace(reTrimStart, "");
          }
          if (!string || !(chars = baseToString(chars))) {
            return string;
          }
          var strSymbols = stringToArray(string), start = charsStartIndex(strSymbols, stringToArray(chars));
          return castSlice(strSymbols, start).join("");
        }
        function truncate(string, options2) {
          var length = DEFAULT_TRUNC_LENGTH, omission = DEFAULT_TRUNC_OMISSION;
          if (isObject(options2)) {
            var separator = "separator" in options2 ? options2.separator : separator;
            length = "length" in options2 ? toInteger(options2.length) : length;
            omission = "omission" in options2 ? baseToString(options2.omission) : omission;
          }
          string = toString(string);
          var strLength = string.length;
          if (hasUnicode(string)) {
            var strSymbols = stringToArray(string);
            strLength = strSymbols.length;
          }
          if (length >= strLength) {
            return string;
          }
          var end = length - stringSize(omission);
          if (end < 1) {
            return omission;
          }
          var result2 = strSymbols ? castSlice(strSymbols, 0, end).join("") : string.slice(0, end);
          if (separator === undefined2) {
            return result2 + omission;
          }
          if (strSymbols) {
            end += result2.length - end;
          }
          if (isRegExp(separator)) {
            if (string.slice(end).search(separator)) {
              var match, substring = result2;
              if (!separator.global) {
                separator = RegExp2(separator.source, toString(reFlags.exec(separator)) + "g");
              }
              separator.lastIndex = 0;
              while (match = separator.exec(substring)) {
                var newEnd = match.index;
              }
              result2 = result2.slice(0, newEnd === undefined2 ? end : newEnd);
            }
          } else if (string.indexOf(baseToString(separator), end) != end) {
            var index = result2.lastIndexOf(separator);
            if (index > -1) {
              result2 = result2.slice(0, index);
            }
          }
          return result2 + omission;
        }
        function unescape2(string) {
          string = toString(string);
          return string && reHasEscapedHtml.test(string) ? string.replace(reEscapedHtml, unescapeHtmlChar) : string;
        }
        var upperCase = createCompounder(function(result2, word, index) {
          return result2 + (index ? " " : "") + word.toUpperCase();
        });
        var upperFirst = createCaseFirst("toUpperCase");
        function words(string, pattern, guard) {
          string = toString(string);
          pattern = guard ? undefined2 : pattern;
          if (pattern === undefined2) {
            return hasUnicodeWord(string) ? unicodeWords(string) : asciiWords(string);
          }
          return string.match(pattern) || [];
        }
        var attempt = baseRest(function(func, args) {
          try {
            return apply(func, undefined2, args);
          } catch (e2) {
            return isError(e2) ? e2 : new Error2(e2);
          }
        });
        var bindAll = flatRest(function(object, methodNames) {
          arrayEach(methodNames, function(key) {
            key = toKey(key);
            baseAssignValue(object, key, bind(object[key], object));
          });
          return object;
        });
        function cond(pairs) {
          var length = pairs == null ? 0 : pairs.length, toIteratee = getIteratee();
          pairs = !length ? [] : arrayMap(pairs, function(pair) {
            if (typeof pair[1] != "function") {
              throw new TypeError2(FUNC_ERROR_TEXT);
            }
            return [toIteratee(pair[0]), pair[1]];
          });
          return baseRest(function(args) {
            var index = -1;
            while (++index < length) {
              var pair = pairs[index];
              if (apply(pair[0], this, args)) {
                return apply(pair[1], this, args);
              }
            }
          });
        }
        function conforms(source) {
          return baseConforms(baseClone(source, CLONE_DEEP_FLAG));
        }
        function constant(value) {
          return function() {
            return value;
          };
        }
        function defaultTo(value, defaultValue) {
          return value == null || value !== value ? defaultValue : value;
        }
        var flow = createFlow();
        var flowRight = createFlow(true);
        function identity(value) {
          return value;
        }
        function iteratee(func) {
          return baseIteratee(typeof func == "function" ? func : baseClone(func, CLONE_DEEP_FLAG));
        }
        function matches(source) {
          return baseMatches(baseClone(source, CLONE_DEEP_FLAG));
        }
        function matchesProperty(path, srcValue) {
          return baseMatchesProperty(path, baseClone(srcValue, CLONE_DEEP_FLAG));
        }
        var method = baseRest(function(path, args) {
          return function(object) {
            return baseInvoke(object, path, args);
          };
        });
        var methodOf = baseRest(function(object, args) {
          return function(path) {
            return baseInvoke(object, path, args);
          };
        });
        function mixin(object, source, options2) {
          var props = keys(source), methodNames = baseFunctions(source, props);
          if (options2 == null && !(isObject(source) && (methodNames.length || !props.length))) {
            options2 = source;
            source = object;
            object = this;
            methodNames = baseFunctions(source, keys(source));
          }
          var chain2 = !(isObject(options2) && "chain" in options2) || !!options2.chain, isFunc = isFunction(object);
          arrayEach(methodNames, function(methodName) {
            var func = source[methodName];
            object[methodName] = func;
            if (isFunc) {
              object.prototype[methodName] = function() {
                var chainAll = this.__chain__;
                if (chain2 || chainAll) {
                  var result2 = object(this.__wrapped__), actions2 = result2.__actions__ = copyArray2(this.__actions__);
                  actions2.push({ "func": func, "args": arguments, "thisArg": object });
                  result2.__chain__ = chainAll;
                  return result2;
                }
                return func.apply(object, arrayPush([this.value()], arguments));
              };
            }
          });
          return object;
        }
        function noConflict() {
          if (root._ === this) {
            root._ = oldDash;
          }
          return this;
        }
        function noop() {
        }
        function nthArg(n) {
          n = toInteger(n);
          return baseRest(function(args) {
            return baseNth(args, n);
          });
        }
        var over = createOver(arrayMap);
        var overEvery = createOver(arrayEvery);
        var overSome = createOver(arraySome);
        function property(path) {
          return isKey(path) ? baseProperty(toKey(path)) : basePropertyDeep(path);
        }
        function propertyOf(object) {
          return function(path) {
            return object == null ? undefined2 : baseGet(object, path);
          };
        }
        var range = createRange();
        var rangeRight = createRange(true);
        function stubArray() {
          return [];
        }
        function stubFalse() {
          return false;
        }
        function stubObject() {
          return {};
        }
        function stubString() {
          return "";
        }
        function stubTrue() {
          return true;
        }
        function times(n, iteratee2) {
          n = toInteger(n);
          if (n < 1 || n > MAX_SAFE_INTEGER) {
            return [];
          }
          var index = MAX_ARRAY_LENGTH, length = nativeMin(n, MAX_ARRAY_LENGTH);
          iteratee2 = getIteratee(iteratee2);
          n -= MAX_ARRAY_LENGTH;
          var result2 = baseTimes(length, iteratee2);
          while (++index < n) {
            iteratee2(index);
          }
          return result2;
        }
        function toPath(value) {
          if (isArray(value)) {
            return arrayMap(value, toKey);
          }
          return isSymbol(value) ? [value] : copyArray2(stringToPath(toString(value)));
        }
        function uniqueId(prefix) {
          var id2 = ++idCounter;
          return toString(prefix) + id2;
        }
        var add = createMathOperation(function(augend, addend) {
          return augend + addend;
        }, 0);
        var ceil = createRound("ceil");
        var divide = createMathOperation(function(dividend, divisor) {
          return dividend / divisor;
        }, 1);
        var floor = createRound("floor");
        function max(array) {
          return array && array.length ? baseExtremum(array, identity, baseGt) : undefined2;
        }
        function maxBy(array, iteratee2) {
          return array && array.length ? baseExtremum(array, getIteratee(iteratee2, 2), baseGt) : undefined2;
        }
        function mean(array) {
          return baseMean(array, identity);
        }
        function meanBy(array, iteratee2) {
          return baseMean(array, getIteratee(iteratee2, 2));
        }
        function min(array) {
          return array && array.length ? baseExtremum(array, identity, baseLt) : undefined2;
        }
        function minBy(array, iteratee2) {
          return array && array.length ? baseExtremum(array, getIteratee(iteratee2, 2), baseLt) : undefined2;
        }
        var multiply = createMathOperation(function(multiplier, multiplicand) {
          return multiplier * multiplicand;
        }, 1);
        var round = createRound("round");
        var subtract = createMathOperation(function(minuend, subtrahend) {
          return minuend - subtrahend;
        }, 0);
        function sum(array) {
          return array && array.length ? baseSum(array, identity) : 0;
        }
        function sumBy(array, iteratee2) {
          return array && array.length ? baseSum(array, getIteratee(iteratee2, 2)) : 0;
        }
        lodash.after = after;
        lodash.ary = ary;
        lodash.assign = assign;
        lodash.assignIn = assignIn;
        lodash.assignInWith = assignInWith;
        lodash.assignWith = assignWith;
        lodash.at = at;
        lodash.before = before;
        lodash.bind = bind;
        lodash.bindAll = bindAll;
        lodash.bindKey = bindKey;
        lodash.castArray = castArray;
        lodash.chain = chain;
        lodash.chunk = chunk;
        lodash.compact = compact;
        lodash.concat = concat;
        lodash.cond = cond;
        lodash.conforms = conforms;
        lodash.constant = constant;
        lodash.countBy = countBy;
        lodash.create = create;
        lodash.curry = curry;
        lodash.curryRight = curryRight;
        lodash.debounce = debounce;
        lodash.defaults = defaults2;
        lodash.defaultsDeep = defaultsDeep;
        lodash.defer = defer;
        lodash.delay = delay;
        lodash.difference = difference;
        lodash.differenceBy = differenceBy;
        lodash.differenceWith = differenceWith;
        lodash.drop = drop;
        lodash.dropRight = dropRight;
        lodash.dropRightWhile = dropRightWhile;
        lodash.dropWhile = dropWhile;
        lodash.fill = fill;
        lodash.filter = filter;
        lodash.flatMap = flatMap;
        lodash.flatMapDeep = flatMapDeep;
        lodash.flatMapDepth = flatMapDepth;
        lodash.flatten = flatten2;
        lodash.flattenDeep = flattenDeep;
        lodash.flattenDepth = flattenDepth;
        lodash.flip = flip;
        lodash.flow = flow;
        lodash.flowRight = flowRight;
        lodash.fromPairs = fromPairs;
        lodash.functions = functions;
        lodash.functionsIn = functionsIn;
        lodash.groupBy = groupBy;
        lodash.initial = initial;
        lodash.intersection = intersection;
        lodash.intersectionBy = intersectionBy;
        lodash.intersectionWith = intersectionWith;
        lodash.invert = invert;
        lodash.invertBy = invertBy;
        lodash.invokeMap = invokeMap;
        lodash.iteratee = iteratee;
        lodash.keyBy = keyBy;
        lodash.keys = keys;
        lodash.keysIn = keysIn;
        lodash.map = map;
        lodash.mapKeys = mapKeys;
        lodash.mapValues = mapValues;
        lodash.matches = matches;
        lodash.matchesProperty = matchesProperty;
        lodash.memoize = memoize;
        lodash.merge = merge;
        lodash.mergeWith = mergeWith;
        lodash.method = method;
        lodash.methodOf = methodOf;
        lodash.mixin = mixin;
        lodash.negate = negate;
        lodash.nthArg = nthArg;
        lodash.omit = omit;
        lodash.omitBy = omitBy;
        lodash.once = once;
        lodash.orderBy = orderBy;
        lodash.over = over;
        lodash.overArgs = overArgs;
        lodash.overEvery = overEvery;
        lodash.overSome = overSome;
        lodash.partial = partial;
        lodash.partialRight = partialRight;
        lodash.partition = partition;
        lodash.pick = pick;
        lodash.pickBy = pickBy;
        lodash.property = property;
        lodash.propertyOf = propertyOf;
        lodash.pull = pull;
        lodash.pullAll = pullAll;
        lodash.pullAllBy = pullAllBy;
        lodash.pullAllWith = pullAllWith;
        lodash.pullAt = pullAt;
        lodash.range = range;
        lodash.rangeRight = rangeRight;
        lodash.rearg = rearg;
        lodash.reject = reject;
        lodash.remove = remove;
        lodash.rest = rest;
        lodash.reverse = reverse;
        lodash.sampleSize = sampleSize;
        lodash.set = set;
        lodash.setWith = setWith;
        lodash.shuffle = shuffle;
        lodash.slice = slice;
        lodash.sortBy = sortBy;
        lodash.sortedUniq = sortedUniq;
        lodash.sortedUniqBy = sortedUniqBy;
        lodash.split = split;
        lodash.spread = spread;
        lodash.tail = tail;
        lodash.take = take;
        lodash.takeRight = takeRight;
        lodash.takeRightWhile = takeRightWhile;
        lodash.takeWhile = takeWhile;
        lodash.tap = tap;
        lodash.throttle = throttle;
        lodash.thru = thru;
        lodash.toArray = toArray;
        lodash.toPairs = toPairs;
        lodash.toPairsIn = toPairsIn;
        lodash.toPath = toPath;
        lodash.toPlainObject = toPlainObject;
        lodash.transform = transform;
        lodash.unary = unary;
        lodash.union = union;
        lodash.unionBy = unionBy;
        lodash.unionWith = unionWith;
        lodash.uniq = uniq;
        lodash.uniqBy = uniqBy;
        lodash.uniqWith = uniqWith;
        lodash.unset = unset;
        lodash.unzip = unzip;
        lodash.unzipWith = unzipWith;
        lodash.update = update;
        lodash.updateWith = updateWith;
        lodash.values = values;
        lodash.valuesIn = valuesIn;
        lodash.without = without;
        lodash.words = words;
        lodash.wrap = wrap;
        lodash.xor = xor;
        lodash.xorBy = xorBy;
        lodash.xorWith = xorWith;
        lodash.zip = zip;
        lodash.zipObject = zipObject;
        lodash.zipObjectDeep = zipObjectDeep;
        lodash.zipWith = zipWith;
        lodash.entries = toPairs;
        lodash.entriesIn = toPairsIn;
        lodash.extend = assignIn;
        lodash.extendWith = assignInWith;
        mixin(lodash, lodash);
        lodash.add = add;
        lodash.attempt = attempt;
        lodash.camelCase = camelCase;
        lodash.capitalize = capitalize;
        lodash.ceil = ceil;
        lodash.clamp = clamp3;
        lodash.clone = clone;
        lodash.cloneDeep = cloneDeep;
        lodash.cloneDeepWith = cloneDeepWith;
        lodash.cloneWith = cloneWith;
        lodash.conformsTo = conformsTo;
        lodash.deburr = deburr;
        lodash.defaultTo = defaultTo;
        lodash.divide = divide;
        lodash.endsWith = endsWith;
        lodash.eq = eq;
        lodash.escape = escape2;
        lodash.escapeRegExp = escapeRegExp;
        lodash.every = every;
        lodash.find = find;
        lodash.findIndex = findIndex;
        lodash.findKey = findKey;
        lodash.findLast = findLast;
        lodash.findLastIndex = findLastIndex;
        lodash.findLastKey = findLastKey;
        lodash.floor = floor;
        lodash.forEach = forEach;
        lodash.forEachRight = forEachRight;
        lodash.forIn = forIn;
        lodash.forInRight = forInRight;
        lodash.forOwn = forOwn;
        lodash.forOwnRight = forOwnRight;
        lodash.get = get;
        lodash.gt = gt;
        lodash.gte = gte;
        lodash.has = has;
        lodash.hasIn = hasIn;
        lodash.head = head;
        lodash.identity = identity;
        lodash.includes = includes;
        lodash.indexOf = indexOf;
        lodash.inRange = inRange;
        lodash.invoke = invoke;
        lodash.isArguments = isArguments;
        lodash.isArray = isArray;
        lodash.isArrayBuffer = isArrayBuffer;
        lodash.isArrayLike = isArrayLike;
        lodash.isArrayLikeObject = isArrayLikeObject;
        lodash.isBoolean = isBoolean;
        lodash.isBuffer = isBuffer;
        lodash.isDate = isDate;
        lodash.isElement = isElement;
        lodash.isEmpty = isEmpty;
        lodash.isEqual = isEqual;
        lodash.isEqualWith = isEqualWith;
        lodash.isError = isError;
        lodash.isFinite = isFinite2;
        lodash.isFunction = isFunction;
        lodash.isInteger = isInteger;
        lodash.isLength = isLength;
        lodash.isMap = isMap;
        lodash.isMatch = isMatch;
        lodash.isMatchWith = isMatchWith;
        lodash.isNaN = isNaN2;
        lodash.isNative = isNative;
        lodash.isNil = isNil;
        lodash.isNull = isNull;
        lodash.isNumber = isNumber;
        lodash.isObject = isObject;
        lodash.isObjectLike = isObjectLike;
        lodash.isPlainObject = isPlainObject;
        lodash.isRegExp = isRegExp;
        lodash.isSafeInteger = isSafeInteger;
        lodash.isSet = isSet;
        lodash.isString = isString;
        lodash.isSymbol = isSymbol;
        lodash.isTypedArray = isTypedArray2;
        lodash.isUndefined = isUndefined;
        lodash.isWeakMap = isWeakMap;
        lodash.isWeakSet = isWeakSet;
        lodash.join = join;
        lodash.kebabCase = kebabCase;
        lodash.last = last;
        lodash.lastIndexOf = lastIndexOf;
        lodash.lowerCase = lowerCase;
        lodash.lowerFirst = lowerFirst;
        lodash.lt = lt;
        lodash.lte = lte;
        lodash.max = max;
        lodash.maxBy = maxBy;
        lodash.mean = mean;
        lodash.meanBy = meanBy;
        lodash.min = min;
        lodash.minBy = minBy;
        lodash.stubArray = stubArray;
        lodash.stubFalse = stubFalse;
        lodash.stubObject = stubObject;
        lodash.stubString = stubString;
        lodash.stubTrue = stubTrue;
        lodash.multiply = multiply;
        lodash.nth = nth;
        lodash.noConflict = noConflict;
        lodash.noop = noop;
        lodash.now = now3;
        lodash.pad = pad;
        lodash.padEnd = padEnd;
        lodash.padStart = padStart;
        lodash.parseInt = parseInt2;
        lodash.random = random;
        lodash.reduce = reduce;
        lodash.reduceRight = reduceRight;
        lodash.repeat = repeat;
        lodash.replace = replace;
        lodash.result = result;
        lodash.round = round;
        lodash.runInContext = runInContext2;
        lodash.sample = sample;
        lodash.size = size;
        lodash.snakeCase = snakeCase;
        lodash.some = some;
        lodash.sortedIndex = sortedIndex;
        lodash.sortedIndexBy = sortedIndexBy;
        lodash.sortedIndexOf = sortedIndexOf;
        lodash.sortedLastIndex = sortedLastIndex;
        lodash.sortedLastIndexBy = sortedLastIndexBy;
        lodash.sortedLastIndexOf = sortedLastIndexOf;
        lodash.startCase = startCase;
        lodash.startsWith = startsWith;
        lodash.subtract = subtract;
        lodash.sum = sum;
        lodash.sumBy = sumBy;
        lodash.template = template;
        lodash.times = times;
        lodash.toFinite = toFinite;
        lodash.toInteger = toInteger;
        lodash.toLength = toLength;
        lodash.toLower = toLower;
        lodash.toNumber = toNumber;
        lodash.toSafeInteger = toSafeInteger;
        lodash.toString = toString;
        lodash.toUpper = toUpper;
        lodash.trim = trim;
        lodash.trimEnd = trimEnd;
        lodash.trimStart = trimStart;
        lodash.truncate = truncate;
        lodash.unescape = unescape2;
        lodash.uniqueId = uniqueId;
        lodash.upperCase = upperCase;
        lodash.upperFirst = upperFirst;
        lodash.each = forEach;
        lodash.eachRight = forEachRight;
        lodash.first = head;
        mixin(lodash, function() {
          var source = {};
          baseForOwn(lodash, function(func, methodName) {
            if (!hasOwnProperty.call(lodash.prototype, methodName)) {
              source[methodName] = func;
            }
          });
          return source;
        }(), { "chain": false });
        lodash.VERSION = VERSION2;
        arrayEach(["bind", "bindKey", "curry", "curryRight", "partial", "partialRight"], function(methodName) {
          lodash[methodName].placeholder = lodash;
        });
        arrayEach(["drop", "take"], function(methodName, index) {
          LazyWrapper.prototype[methodName] = function(n) {
            n = n === undefined2 ? 1 : nativeMax(toInteger(n), 0);
            var result2 = this.__filtered__ && !index ? new LazyWrapper(this) : this.clone();
            if (result2.__filtered__) {
              result2.__takeCount__ = nativeMin(n, result2.__takeCount__);
            } else {
              result2.__views__.push({
                "size": nativeMin(n, MAX_ARRAY_LENGTH),
                "type": methodName + (result2.__dir__ < 0 ? "Right" : "")
              });
            }
            return result2;
          };
          LazyWrapper.prototype[methodName + "Right"] = function(n) {
            return this.reverse()[methodName](n).reverse();
          };
        });
        arrayEach(["filter", "map", "takeWhile"], function(methodName, index) {
          var type = index + 1, isFilter = type == LAZY_FILTER_FLAG || type == LAZY_WHILE_FLAG;
          LazyWrapper.prototype[methodName] = function(iteratee2) {
            var result2 = this.clone();
            result2.__iteratees__.push({
              "iteratee": getIteratee(iteratee2, 3),
              "type": type
            });
            result2.__filtered__ = result2.__filtered__ || isFilter;
            return result2;
          };
        });
        arrayEach(["head", "last"], function(methodName, index) {
          var takeName = "take" + (index ? "Right" : "");
          LazyWrapper.prototype[methodName] = function() {
            return this[takeName](1).value()[0];
          };
        });
        arrayEach(["initial", "tail"], function(methodName, index) {
          var dropName = "drop" + (index ? "" : "Right");
          LazyWrapper.prototype[methodName] = function() {
            return this.__filtered__ ? new LazyWrapper(this) : this[dropName](1);
          };
        });
        LazyWrapper.prototype.compact = function() {
          return this.filter(identity);
        };
        LazyWrapper.prototype.find = function(predicate) {
          return this.filter(predicate).head();
        };
        LazyWrapper.prototype.findLast = function(predicate) {
          return this.reverse().find(predicate);
        };
        LazyWrapper.prototype.invokeMap = baseRest(function(path, args) {
          if (typeof path == "function") {
            return new LazyWrapper(this);
          }
          return this.map(function(value) {
            return baseInvoke(value, path, args);
          });
        });
        LazyWrapper.prototype.reject = function(predicate) {
          return this.filter(negate(getIteratee(predicate)));
        };
        LazyWrapper.prototype.slice = function(start, end) {
          start = toInteger(start);
          var result2 = this;
          if (result2.__filtered__ && (start > 0 || end < 0)) {
            return new LazyWrapper(result2);
          }
          if (start < 0) {
            result2 = result2.takeRight(-start);
          } else if (start) {
            result2 = result2.drop(start);
          }
          if (end !== undefined2) {
            end = toInteger(end);
            result2 = end < 0 ? result2.dropRight(-end) : result2.take(end - start);
          }
          return result2;
        };
        LazyWrapper.prototype.takeRightWhile = function(predicate) {
          return this.reverse().takeWhile(predicate).reverse();
        };
        LazyWrapper.prototype.toArray = function() {
          return this.take(MAX_ARRAY_LENGTH);
        };
        baseForOwn(LazyWrapper.prototype, function(func, methodName) {
          var checkIteratee = /^(?:filter|find|map|reject)|While$/.test(methodName), isTaker = /^(?:head|last)$/.test(methodName), lodashFunc = lodash[isTaker ? "take" + (methodName == "last" ? "Right" : "") : methodName], retUnwrapped = isTaker || /^find/.test(methodName);
          if (!lodashFunc) {
            return;
          }
          lodash.prototype[methodName] = function() {
            var value = this.__wrapped__, args = isTaker ? [1] : arguments, isLazy = value instanceof LazyWrapper, iteratee2 = args[0], useLazy = isLazy || isArray(value);
            var interceptor = function(value2) {
              var result3 = lodashFunc.apply(lodash, arrayPush([value2], args));
              return isTaker && chainAll ? result3[0] : result3;
            };
            if (useLazy && checkIteratee && typeof iteratee2 == "function" && iteratee2.length != 1) {
              isLazy = useLazy = false;
            }
            var chainAll = this.__chain__, isHybrid = !!this.__actions__.length, isUnwrapped = retUnwrapped && !chainAll, onlyLazy = isLazy && !isHybrid;
            if (!retUnwrapped && useLazy) {
              value = onlyLazy ? value : new LazyWrapper(this);
              var result2 = func.apply(value, args);
              result2.__actions__.push({ "func": thru, "args": [interceptor], "thisArg": undefined2 });
              return new LodashWrapper(result2, chainAll);
            }
            if (isUnwrapped && onlyLazy) {
              return func.apply(this, args);
            }
            result2 = this.thru(interceptor);
            return isUnwrapped ? isTaker ? result2.value()[0] : result2.value() : result2;
          };
        });
        arrayEach(["pop", "push", "shift", "sort", "splice", "unshift"], function(methodName) {
          var func = arrayProto[methodName], chainName = /^(?:push|sort|unshift)$/.test(methodName) ? "tap" : "thru", retUnwrapped = /^(?:pop|shift)$/.test(methodName);
          lodash.prototype[methodName] = function() {
            var args = arguments;
            if (retUnwrapped && !this.__chain__) {
              var value = this.value();
              return func.apply(isArray(value) ? value : [], args);
            }
            return this[chainName](function(value2) {
              return func.apply(isArray(value2) ? value2 : [], args);
            });
          };
        });
        baseForOwn(LazyWrapper.prototype, function(func, methodName) {
          var lodashFunc = lodash[methodName];
          if (lodashFunc) {
            var key = lodashFunc.name + "";
            if (!hasOwnProperty.call(realNames, key)) {
              realNames[key] = [];
            }
            realNames[key].push({ "name": methodName, "func": lodashFunc });
          }
        });
        realNames[createHybrid(undefined2, WRAP_BIND_KEY_FLAG).name] = [{
          "name": "wrapper",
          "func": undefined2
        }];
        LazyWrapper.prototype.clone = lazyClone;
        LazyWrapper.prototype.reverse = lazyReverse;
        LazyWrapper.prototype.value = lazyValue;
        lodash.prototype.at = wrapperAt;
        lodash.prototype.chain = wrapperChain;
        lodash.prototype.commit = wrapperCommit;
        lodash.prototype.next = wrapperNext;
        lodash.prototype.plant = wrapperPlant;
        lodash.prototype.reverse = wrapperReverse;
        lodash.prototype.toJSON = lodash.prototype.valueOf = lodash.prototype.value = wrapperValue;
        lodash.prototype.first = lodash.prototype.head;
        if (symIterator) {
          lodash.prototype[symIterator] = wrapperToIterator;
        }
        return lodash;
      };
      var _ = runInContext();
      if (typeof define == "function" && typeof define.amd == "object" && define.amd) {
        root._ = _;
        define(function() {
          return _;
        });
      } else if (freeModule) {
        (freeModule.exports = _)._ = _;
        freeExports._ = _;
      } else {
        root._ = _;
      }
    }).call(exports);
  }
});

// node_modules/miew/dist/Miew.module.js
var __WEBPACK_EXTERNAL_MODULE_lodash__ = __toESM(require_lodash());

// node_modules/three/build/three.module.js
var three_module_exports = {};
__export(three_module_exports, {
  ACESFilmicToneMapping: () => ACESFilmicToneMapping,
  AddEquation: () => AddEquation,
  AddOperation: () => AddOperation,
  AdditiveAnimationBlendMode: () => AdditiveAnimationBlendMode,
  AdditiveBlending: () => AdditiveBlending,
  AlphaFormat: () => AlphaFormat,
  AlwaysCompare: () => AlwaysCompare,
  AlwaysDepth: () => AlwaysDepth,
  AlwaysStencilFunc: () => AlwaysStencilFunc,
  AmbientLight: () => AmbientLight,
  AmbientLightProbe: () => AmbientLightProbe,
  AnimationAction: () => AnimationAction,
  AnimationClip: () => AnimationClip,
  AnimationLoader: () => AnimationLoader,
  AnimationMixer: () => AnimationMixer,
  AnimationObjectGroup: () => AnimationObjectGroup,
  AnimationUtils: () => AnimationUtils,
  ArcCurve: () => ArcCurve,
  ArrayCamera: () => ArrayCamera,
  ArrowHelper: () => ArrowHelper,
  Audio: () => Audio,
  AudioAnalyser: () => AudioAnalyser,
  AudioContext: () => AudioContext,
  AudioListener: () => AudioListener,
  AudioLoader: () => AudioLoader,
  AxesHelper: () => AxesHelper,
  BackSide: () => BackSide,
  BasicDepthPacking: () => BasicDepthPacking,
  BasicShadowMap: () => BasicShadowMap,
  Bone: () => Bone,
  BooleanKeyframeTrack: () => BooleanKeyframeTrack,
  Box2: () => Box2,
  Box3: () => Box3,
  Box3Helper: () => Box3Helper,
  BoxBufferGeometry: () => BoxBufferGeometry,
  BoxGeometry: () => BoxGeometry,
  BoxHelper: () => BoxHelper,
  BufferAttribute: () => BufferAttribute,
  BufferGeometry: () => BufferGeometry,
  BufferGeometryLoader: () => BufferGeometryLoader,
  ByteType: () => ByteType,
  Cache: () => Cache,
  Camera: () => Camera,
  CameraHelper: () => CameraHelper,
  CanvasTexture: () => CanvasTexture,
  CapsuleBufferGeometry: () => CapsuleBufferGeometry,
  CapsuleGeometry: () => CapsuleGeometry,
  CatmullRomCurve3: () => CatmullRomCurve3,
  CineonToneMapping: () => CineonToneMapping,
  CircleBufferGeometry: () => CircleBufferGeometry,
  CircleGeometry: () => CircleGeometry,
  ClampToEdgeWrapping: () => ClampToEdgeWrapping,
  Clock: () => Clock,
  Color: () => Color,
  ColorKeyframeTrack: () => ColorKeyframeTrack,
  ColorManagement: () => ColorManagement,
  CompressedArrayTexture: () => CompressedArrayTexture,
  CompressedTexture: () => CompressedTexture,
  CompressedTextureLoader: () => CompressedTextureLoader,
  ConeBufferGeometry: () => ConeBufferGeometry,
  ConeGeometry: () => ConeGeometry,
  CubeCamera: () => CubeCamera,
  CubeReflectionMapping: () => CubeReflectionMapping,
  CubeRefractionMapping: () => CubeRefractionMapping,
  CubeTexture: () => CubeTexture,
  CubeTextureLoader: () => CubeTextureLoader,
  CubeUVReflectionMapping: () => CubeUVReflectionMapping,
  CubicBezierCurve: () => CubicBezierCurve,
  CubicBezierCurve3: () => CubicBezierCurve3,
  CubicInterpolant: () => CubicInterpolant,
  CullFaceBack: () => CullFaceBack,
  CullFaceFront: () => CullFaceFront,
  CullFaceFrontBack: () => CullFaceFrontBack,
  CullFaceNone: () => CullFaceNone,
  Curve: () => Curve,
  CurvePath: () => CurvePath,
  CustomBlending: () => CustomBlending,
  CustomToneMapping: () => CustomToneMapping,
  CylinderBufferGeometry: () => CylinderBufferGeometry,
  CylinderGeometry: () => CylinderGeometry,
  Cylindrical: () => Cylindrical,
  Data3DTexture: () => Data3DTexture,
  DataArrayTexture: () => DataArrayTexture,
  DataTexture: () => DataTexture,
  DataTextureLoader: () => DataTextureLoader,
  DataUtils: () => DataUtils,
  DecrementStencilOp: () => DecrementStencilOp,
  DecrementWrapStencilOp: () => DecrementWrapStencilOp,
  DefaultLoadingManager: () => DefaultLoadingManager,
  DepthFormat: () => DepthFormat,
  DepthStencilFormat: () => DepthStencilFormat,
  DepthTexture: () => DepthTexture,
  DirectionalLight: () => DirectionalLight,
  DirectionalLightHelper: () => DirectionalLightHelper,
  DiscreteInterpolant: () => DiscreteInterpolant,
  DisplayP3ColorSpace: () => DisplayP3ColorSpace,
  DodecahedronBufferGeometry: () => DodecahedronBufferGeometry,
  DodecahedronGeometry: () => DodecahedronGeometry,
  DoubleSide: () => DoubleSide,
  DstAlphaFactor: () => DstAlphaFactor,
  DstColorFactor: () => DstColorFactor,
  DynamicCopyUsage: () => DynamicCopyUsage,
  DynamicDrawUsage: () => DynamicDrawUsage,
  DynamicReadUsage: () => DynamicReadUsage,
  EdgesGeometry: () => EdgesGeometry,
  EllipseCurve: () => EllipseCurve,
  EqualCompare: () => EqualCompare,
  EqualDepth: () => EqualDepth,
  EqualStencilFunc: () => EqualStencilFunc,
  EquirectangularReflectionMapping: () => EquirectangularReflectionMapping,
  EquirectangularRefractionMapping: () => EquirectangularRefractionMapping,
  Euler: () => Euler,
  EventDispatcher: () => EventDispatcher,
  ExtrudeBufferGeometry: () => ExtrudeBufferGeometry,
  ExtrudeGeometry: () => ExtrudeGeometry,
  FileLoader: () => FileLoader,
  Float16BufferAttribute: () => Float16BufferAttribute,
  Float32BufferAttribute: () => Float32BufferAttribute,
  Float64BufferAttribute: () => Float64BufferAttribute,
  FloatType: () => FloatType,
  Fog: () => Fog,
  FogExp2: () => FogExp2,
  FramebufferTexture: () => FramebufferTexture,
  FrontSide: () => FrontSide,
  Frustum: () => Frustum,
  GLBufferAttribute: () => GLBufferAttribute,
  GLSL1: () => GLSL1,
  GLSL3: () => GLSL3,
  GreaterCompare: () => GreaterCompare,
  GreaterDepth: () => GreaterDepth,
  GreaterEqualCompare: () => GreaterEqualCompare,
  GreaterEqualDepth: () => GreaterEqualDepth,
  GreaterEqualStencilFunc: () => GreaterEqualStencilFunc,
  GreaterStencilFunc: () => GreaterStencilFunc,
  GridHelper: () => GridHelper,
  Group: () => Group,
  HalfFloatType: () => HalfFloatType,
  HemisphereLight: () => HemisphereLight,
  HemisphereLightHelper: () => HemisphereLightHelper,
  HemisphereLightProbe: () => HemisphereLightProbe,
  IcosahedronBufferGeometry: () => IcosahedronBufferGeometry,
  IcosahedronGeometry: () => IcosahedronGeometry,
  ImageBitmapLoader: () => ImageBitmapLoader,
  ImageLoader: () => ImageLoader,
  ImageUtils: () => ImageUtils,
  IncrementStencilOp: () => IncrementStencilOp,
  IncrementWrapStencilOp: () => IncrementWrapStencilOp,
  InstancedBufferAttribute: () => InstancedBufferAttribute,
  InstancedBufferGeometry: () => InstancedBufferGeometry,
  InstancedInterleavedBuffer: () => InstancedInterleavedBuffer,
  InstancedMesh: () => InstancedMesh,
  Int16BufferAttribute: () => Int16BufferAttribute,
  Int32BufferAttribute: () => Int32BufferAttribute,
  Int8BufferAttribute: () => Int8BufferAttribute,
  IntType: () => IntType,
  InterleavedBuffer: () => InterleavedBuffer,
  InterleavedBufferAttribute: () => InterleavedBufferAttribute,
  Interpolant: () => Interpolant,
  InterpolateDiscrete: () => InterpolateDiscrete,
  InterpolateLinear: () => InterpolateLinear,
  InterpolateSmooth: () => InterpolateSmooth,
  InvertStencilOp: () => InvertStencilOp,
  KeepStencilOp: () => KeepStencilOp,
  KeyframeTrack: () => KeyframeTrack,
  LOD: () => LOD,
  LatheBufferGeometry: () => LatheBufferGeometry,
  LatheGeometry: () => LatheGeometry,
  Layers: () => Layers,
  LessCompare: () => LessCompare,
  LessDepth: () => LessDepth,
  LessEqualCompare: () => LessEqualCompare,
  LessEqualDepth: () => LessEqualDepth,
  LessEqualStencilFunc: () => LessEqualStencilFunc,
  LessStencilFunc: () => LessStencilFunc,
  Light: () => Light,
  LightProbe: () => LightProbe,
  Line: () => Line,
  Line3: () => Line3,
  LineBasicMaterial: () => LineBasicMaterial,
  LineCurve: () => LineCurve,
  LineCurve3: () => LineCurve3,
  LineDashedMaterial: () => LineDashedMaterial,
  LineLoop: () => LineLoop,
  LineSegments: () => LineSegments,
  LinearEncoding: () => LinearEncoding,
  LinearFilter: () => LinearFilter,
  LinearInterpolant: () => LinearInterpolant,
  LinearMipMapLinearFilter: () => LinearMipMapLinearFilter,
  LinearMipMapNearestFilter: () => LinearMipMapNearestFilter,
  LinearMipmapLinearFilter: () => LinearMipmapLinearFilter,
  LinearMipmapNearestFilter: () => LinearMipmapNearestFilter,
  LinearSRGBColorSpace: () => LinearSRGBColorSpace,
  LinearToneMapping: () => LinearToneMapping,
  Loader: () => Loader,
  LoaderUtils: () => LoaderUtils,
  LoadingManager: () => LoadingManager,
  LoopOnce: () => LoopOnce,
  LoopPingPong: () => LoopPingPong,
  LoopRepeat: () => LoopRepeat,
  LuminanceAlphaFormat: () => LuminanceAlphaFormat,
  LuminanceFormat: () => LuminanceFormat,
  MOUSE: () => MOUSE,
  Material: () => Material,
  MaterialLoader: () => MaterialLoader,
  MathUtils: () => MathUtils,
  Matrix3: () => Matrix3,
  Matrix4: () => Matrix4,
  MaxEquation: () => MaxEquation,
  Mesh: () => Mesh,
  MeshBasicMaterial: () => MeshBasicMaterial,
  MeshDepthMaterial: () => MeshDepthMaterial,
  MeshDistanceMaterial: () => MeshDistanceMaterial,
  MeshLambertMaterial: () => MeshLambertMaterial,
  MeshMatcapMaterial: () => MeshMatcapMaterial,
  MeshNormalMaterial: () => MeshNormalMaterial,
  MeshPhongMaterial: () => MeshPhongMaterial,
  MeshPhysicalMaterial: () => MeshPhysicalMaterial,
  MeshStandardMaterial: () => MeshStandardMaterial,
  MeshToonMaterial: () => MeshToonMaterial,
  MinEquation: () => MinEquation,
  MirroredRepeatWrapping: () => MirroredRepeatWrapping,
  MixOperation: () => MixOperation,
  MultiplyBlending: () => MultiplyBlending,
  MultiplyOperation: () => MultiplyOperation,
  NearestFilter: () => NearestFilter,
  NearestMipMapLinearFilter: () => NearestMipMapLinearFilter,
  NearestMipMapNearestFilter: () => NearestMipMapNearestFilter,
  NearestMipmapLinearFilter: () => NearestMipmapLinearFilter,
  NearestMipmapNearestFilter: () => NearestMipmapNearestFilter,
  NeverCompare: () => NeverCompare,
  NeverDepth: () => NeverDepth,
  NeverStencilFunc: () => NeverStencilFunc,
  NoBlending: () => NoBlending,
  NoColorSpace: () => NoColorSpace,
  NoToneMapping: () => NoToneMapping,
  NormalAnimationBlendMode: () => NormalAnimationBlendMode,
  NormalBlending: () => NormalBlending,
  NotEqualCompare: () => NotEqualCompare,
  NotEqualDepth: () => NotEqualDepth,
  NotEqualStencilFunc: () => NotEqualStencilFunc,
  NumberKeyframeTrack: () => NumberKeyframeTrack,
  Object3D: () => Object3D,
  ObjectLoader: () => ObjectLoader,
  ObjectSpaceNormalMap: () => ObjectSpaceNormalMap,
  OctahedronBufferGeometry: () => OctahedronBufferGeometry,
  OctahedronGeometry: () => OctahedronGeometry,
  OneFactor: () => OneFactor,
  OneMinusDstAlphaFactor: () => OneMinusDstAlphaFactor,
  OneMinusDstColorFactor: () => OneMinusDstColorFactor,
  OneMinusSrcAlphaFactor: () => OneMinusSrcAlphaFactor,
  OneMinusSrcColorFactor: () => OneMinusSrcColorFactor,
  OrthographicCamera: () => OrthographicCamera,
  PCFShadowMap: () => PCFShadowMap,
  PCFSoftShadowMap: () => PCFSoftShadowMap,
  PMREMGenerator: () => PMREMGenerator,
  Path: () => Path,
  PerspectiveCamera: () => PerspectiveCamera,
  Plane: () => Plane,
  PlaneBufferGeometry: () => PlaneBufferGeometry,
  PlaneGeometry: () => PlaneGeometry,
  PlaneHelper: () => PlaneHelper,
  PointLight: () => PointLight,
  PointLightHelper: () => PointLightHelper,
  Points: () => Points,
  PointsMaterial: () => PointsMaterial,
  PolarGridHelper: () => PolarGridHelper,
  PolyhedronBufferGeometry: () => PolyhedronBufferGeometry,
  PolyhedronGeometry: () => PolyhedronGeometry,
  PositionalAudio: () => PositionalAudio,
  PropertyBinding: () => PropertyBinding,
  PropertyMixer: () => PropertyMixer,
  QuadraticBezierCurve: () => QuadraticBezierCurve,
  QuadraticBezierCurve3: () => QuadraticBezierCurve3,
  Quaternion: () => Quaternion,
  QuaternionKeyframeTrack: () => QuaternionKeyframeTrack,
  QuaternionLinearInterpolant: () => QuaternionLinearInterpolant,
  RED_GREEN_RGTC2_Format: () => RED_GREEN_RGTC2_Format,
  RED_RGTC1_Format: () => RED_RGTC1_Format,
  REVISION: () => REVISION,
  RGBADepthPacking: () => RGBADepthPacking,
  RGBAFormat: () => RGBAFormat,
  RGBAIntegerFormat: () => RGBAIntegerFormat,
  RGBA_ASTC_10x10_Format: () => RGBA_ASTC_10x10_Format,
  RGBA_ASTC_10x5_Format: () => RGBA_ASTC_10x5_Format,
  RGBA_ASTC_10x6_Format: () => RGBA_ASTC_10x6_Format,
  RGBA_ASTC_10x8_Format: () => RGBA_ASTC_10x8_Format,
  RGBA_ASTC_12x10_Format: () => RGBA_ASTC_12x10_Format,
  RGBA_ASTC_12x12_Format: () => RGBA_ASTC_12x12_Format,
  RGBA_ASTC_4x4_Format: () => RGBA_ASTC_4x4_Format,
  RGBA_ASTC_5x4_Format: () => RGBA_ASTC_5x4_Format,
  RGBA_ASTC_5x5_Format: () => RGBA_ASTC_5x5_Format,
  RGBA_ASTC_6x5_Format: () => RGBA_ASTC_6x5_Format,
  RGBA_ASTC_6x6_Format: () => RGBA_ASTC_6x6_Format,
  RGBA_ASTC_8x5_Format: () => RGBA_ASTC_8x5_Format,
  RGBA_ASTC_8x6_Format: () => RGBA_ASTC_8x6_Format,
  RGBA_ASTC_8x8_Format: () => RGBA_ASTC_8x8_Format,
  RGBA_BPTC_Format: () => RGBA_BPTC_Format,
  RGBA_ETC2_EAC_Format: () => RGBA_ETC2_EAC_Format,
  RGBA_PVRTC_2BPPV1_Format: () => RGBA_PVRTC_2BPPV1_Format,
  RGBA_PVRTC_4BPPV1_Format: () => RGBA_PVRTC_4BPPV1_Format,
  RGBA_S3TC_DXT1_Format: () => RGBA_S3TC_DXT1_Format,
  RGBA_S3TC_DXT3_Format: () => RGBA_S3TC_DXT3_Format,
  RGBA_S3TC_DXT5_Format: () => RGBA_S3TC_DXT5_Format,
  RGB_ETC1_Format: () => RGB_ETC1_Format,
  RGB_ETC2_Format: () => RGB_ETC2_Format,
  RGB_PVRTC_2BPPV1_Format: () => RGB_PVRTC_2BPPV1_Format,
  RGB_PVRTC_4BPPV1_Format: () => RGB_PVRTC_4BPPV1_Format,
  RGB_S3TC_DXT1_Format: () => RGB_S3TC_DXT1_Format,
  RGFormat: () => RGFormat,
  RGIntegerFormat: () => RGIntegerFormat,
  RawShaderMaterial: () => RawShaderMaterial,
  Ray: () => Ray,
  Raycaster: () => Raycaster,
  RectAreaLight: () => RectAreaLight,
  RedFormat: () => RedFormat,
  RedIntegerFormat: () => RedIntegerFormat,
  ReinhardToneMapping: () => ReinhardToneMapping,
  RepeatWrapping: () => RepeatWrapping,
  ReplaceStencilOp: () => ReplaceStencilOp,
  ReverseSubtractEquation: () => ReverseSubtractEquation,
  RingBufferGeometry: () => RingBufferGeometry,
  RingGeometry: () => RingGeometry,
  SIGNED_RED_GREEN_RGTC2_Format: () => SIGNED_RED_GREEN_RGTC2_Format,
  SIGNED_RED_RGTC1_Format: () => SIGNED_RED_RGTC1_Format,
  SRGBColorSpace: () => SRGBColorSpace,
  Scene: () => Scene,
  ShaderChunk: () => ShaderChunk,
  ShaderLib: () => ShaderLib,
  ShaderMaterial: () => ShaderMaterial,
  ShadowMaterial: () => ShadowMaterial,
  Shape: () => Shape,
  ShapeBufferGeometry: () => ShapeBufferGeometry,
  ShapeGeometry: () => ShapeGeometry,
  ShapePath: () => ShapePath,
  ShapeUtils: () => ShapeUtils,
  ShortType: () => ShortType,
  Skeleton: () => Skeleton,
  SkeletonHelper: () => SkeletonHelper,
  SkinnedMesh: () => SkinnedMesh,
  Source: () => Source,
  Sphere: () => Sphere,
  SphereBufferGeometry: () => SphereBufferGeometry,
  SphereGeometry: () => SphereGeometry,
  Spherical: () => Spherical,
  SphericalHarmonics3: () => SphericalHarmonics3,
  SplineCurve: () => SplineCurve,
  SpotLight: () => SpotLight,
  SpotLightHelper: () => SpotLightHelper,
  Sprite: () => Sprite,
  SpriteMaterial: () => SpriteMaterial,
  SrcAlphaFactor: () => SrcAlphaFactor,
  SrcAlphaSaturateFactor: () => SrcAlphaSaturateFactor,
  SrcColorFactor: () => SrcColorFactor,
  StaticCopyUsage: () => StaticCopyUsage,
  StaticDrawUsage: () => StaticDrawUsage,
  StaticReadUsage: () => StaticReadUsage,
  StereoCamera: () => StereoCamera,
  StreamCopyUsage: () => StreamCopyUsage,
  StreamDrawUsage: () => StreamDrawUsage,
  StreamReadUsage: () => StreamReadUsage,
  StringKeyframeTrack: () => StringKeyframeTrack,
  SubtractEquation: () => SubtractEquation,
  SubtractiveBlending: () => SubtractiveBlending,
  TOUCH: () => TOUCH,
  TangentSpaceNormalMap: () => TangentSpaceNormalMap,
  TetrahedronBufferGeometry: () => TetrahedronBufferGeometry,
  TetrahedronGeometry: () => TetrahedronGeometry,
  Texture: () => Texture,
  TextureLoader: () => TextureLoader,
  TorusBufferGeometry: () => TorusBufferGeometry,
  TorusGeometry: () => TorusGeometry,
  TorusKnotBufferGeometry: () => TorusKnotBufferGeometry,
  TorusKnotGeometry: () => TorusKnotGeometry,
  Triangle: () => Triangle,
  TriangleFanDrawMode: () => TriangleFanDrawMode,
  TriangleStripDrawMode: () => TriangleStripDrawMode,
  TrianglesDrawMode: () => TrianglesDrawMode,
  TubeBufferGeometry: () => TubeBufferGeometry,
  TubeGeometry: () => TubeGeometry,
  TwoPassDoubleSide: () => TwoPassDoubleSide,
  UVMapping: () => UVMapping,
  Uint16BufferAttribute: () => Uint16BufferAttribute,
  Uint32BufferAttribute: () => Uint32BufferAttribute,
  Uint8BufferAttribute: () => Uint8BufferAttribute,
  Uint8ClampedBufferAttribute: () => Uint8ClampedBufferAttribute,
  Uniform: () => Uniform,
  UniformsGroup: () => UniformsGroup,
  UniformsLib: () => UniformsLib,
  UniformsUtils: () => UniformsUtils,
  UnsignedByteType: () => UnsignedByteType,
  UnsignedInt248Type: () => UnsignedInt248Type,
  UnsignedIntType: () => UnsignedIntType,
  UnsignedShort4444Type: () => UnsignedShort4444Type,
  UnsignedShort5551Type: () => UnsignedShort5551Type,
  UnsignedShortType: () => UnsignedShortType,
  VSMShadowMap: () => VSMShadowMap,
  Vector2: () => Vector2,
  Vector3: () => Vector3,
  Vector4: () => Vector4,
  VectorKeyframeTrack: () => VectorKeyframeTrack,
  VideoTexture: () => VideoTexture,
  WebGL1Renderer: () => WebGL1Renderer,
  WebGL3DRenderTarget: () => WebGL3DRenderTarget,
  WebGLArrayRenderTarget: () => WebGLArrayRenderTarget,
  WebGLCoordinateSystem: () => WebGLCoordinateSystem,
  WebGLCubeRenderTarget: () => WebGLCubeRenderTarget,
  WebGLMultipleRenderTargets: () => WebGLMultipleRenderTargets,
  WebGLRenderTarget: () => WebGLRenderTarget,
  WebGLRenderer: () => WebGLRenderer,
  WebGLUtils: () => WebGLUtils,
  WebGPUCoordinateSystem: () => WebGPUCoordinateSystem,
  WireframeGeometry: () => WireframeGeometry,
  WrapAroundEnding: () => WrapAroundEnding,
  ZeroCurvatureEnding: () => ZeroCurvatureEnding,
  ZeroFactor: () => ZeroFactor,
  ZeroSlopeEnding: () => ZeroSlopeEnding,
  ZeroStencilOp: () => ZeroStencilOp,
  _SRGBAFormat: () => _SRGBAFormat,
  sRGBEncoding: () => sRGBEncoding
});
var REVISION = "153";
var MOUSE = { LEFT: 0, MIDDLE: 1, RIGHT: 2, ROTATE: 0, DOLLY: 1, PAN: 2 };
var TOUCH = { ROTATE: 0, PAN: 1, DOLLY_PAN: 2, DOLLY_ROTATE: 3 };
var CullFaceNone = 0;
var CullFaceBack = 1;
var CullFaceFront = 2;
var CullFaceFrontBack = 3;
var BasicShadowMap = 0;
var PCFShadowMap = 1;
var PCFSoftShadowMap = 2;
var VSMShadowMap = 3;
var FrontSide = 0;
var BackSide = 1;
var DoubleSide = 2;
var TwoPassDoubleSide = 2;
var NoBlending = 0;
var NormalBlending = 1;
var AdditiveBlending = 2;
var SubtractiveBlending = 3;
var MultiplyBlending = 4;
var CustomBlending = 5;
var AddEquation = 100;
var SubtractEquation = 101;
var ReverseSubtractEquation = 102;
var MinEquation = 103;
var MaxEquation = 104;
var ZeroFactor = 200;
var OneFactor = 201;
var SrcColorFactor = 202;
var OneMinusSrcColorFactor = 203;
var SrcAlphaFactor = 204;
var OneMinusSrcAlphaFactor = 205;
var DstAlphaFactor = 206;
var OneMinusDstAlphaFactor = 207;
var DstColorFactor = 208;
var OneMinusDstColorFactor = 209;
var SrcAlphaSaturateFactor = 210;
var NeverDepth = 0;
var AlwaysDepth = 1;
var LessDepth = 2;
var LessEqualDepth = 3;
var EqualDepth = 4;
var GreaterEqualDepth = 5;
var GreaterDepth = 6;
var NotEqualDepth = 7;
var MultiplyOperation = 0;
var MixOperation = 1;
var AddOperation = 2;
var NoToneMapping = 0;
var LinearToneMapping = 1;
var ReinhardToneMapping = 2;
var CineonToneMapping = 3;
var ACESFilmicToneMapping = 4;
var CustomToneMapping = 5;
var UVMapping = 300;
var CubeReflectionMapping = 301;
var CubeRefractionMapping = 302;
var EquirectangularReflectionMapping = 303;
var EquirectangularRefractionMapping = 304;
var CubeUVReflectionMapping = 306;
var RepeatWrapping = 1e3;
var ClampToEdgeWrapping = 1001;
var MirroredRepeatWrapping = 1002;
var NearestFilter = 1003;
var NearestMipmapNearestFilter = 1004;
var NearestMipMapNearestFilter = 1004;
var NearestMipmapLinearFilter = 1005;
var NearestMipMapLinearFilter = 1005;
var LinearFilter = 1006;
var LinearMipmapNearestFilter = 1007;
var LinearMipMapNearestFilter = 1007;
var LinearMipmapLinearFilter = 1008;
var LinearMipMapLinearFilter = 1008;
var UnsignedByteType = 1009;
var ByteType = 1010;
var ShortType = 1011;
var UnsignedShortType = 1012;
var IntType = 1013;
var UnsignedIntType = 1014;
var FloatType = 1015;
var HalfFloatType = 1016;
var UnsignedShort4444Type = 1017;
var UnsignedShort5551Type = 1018;
var UnsignedInt248Type = 1020;
var AlphaFormat = 1021;
var RGBAFormat = 1023;
var LuminanceFormat = 1024;
var LuminanceAlphaFormat = 1025;
var DepthFormat = 1026;
var DepthStencilFormat = 1027;
var RedFormat = 1028;
var RedIntegerFormat = 1029;
var RGFormat = 1030;
var RGIntegerFormat = 1031;
var RGBAIntegerFormat = 1033;
var RGB_S3TC_DXT1_Format = 33776;
var RGBA_S3TC_DXT1_Format = 33777;
var RGBA_S3TC_DXT3_Format = 33778;
var RGBA_S3TC_DXT5_Format = 33779;
var RGB_PVRTC_4BPPV1_Format = 35840;
var RGB_PVRTC_2BPPV1_Format = 35841;
var RGBA_PVRTC_4BPPV1_Format = 35842;
var RGBA_PVRTC_2BPPV1_Format = 35843;
var RGB_ETC1_Format = 36196;
var RGB_ETC2_Format = 37492;
var RGBA_ETC2_EAC_Format = 37496;
var RGBA_ASTC_4x4_Format = 37808;
var RGBA_ASTC_5x4_Format = 37809;
var RGBA_ASTC_5x5_Format = 37810;
var RGBA_ASTC_6x5_Format = 37811;
var RGBA_ASTC_6x6_Format = 37812;
var RGBA_ASTC_8x5_Format = 37813;
var RGBA_ASTC_8x6_Format = 37814;
var RGBA_ASTC_8x8_Format = 37815;
var RGBA_ASTC_10x5_Format = 37816;
var RGBA_ASTC_10x6_Format = 37817;
var RGBA_ASTC_10x8_Format = 37818;
var RGBA_ASTC_10x10_Format = 37819;
var RGBA_ASTC_12x10_Format = 37820;
var RGBA_ASTC_12x12_Format = 37821;
var RGBA_BPTC_Format = 36492;
var RED_RGTC1_Format = 36283;
var SIGNED_RED_RGTC1_Format = 36284;
var RED_GREEN_RGTC2_Format = 36285;
var SIGNED_RED_GREEN_RGTC2_Format = 36286;
var LoopOnce = 2200;
var LoopRepeat = 2201;
var LoopPingPong = 2202;
var InterpolateDiscrete = 2300;
var InterpolateLinear = 2301;
var InterpolateSmooth = 2302;
var ZeroCurvatureEnding = 2400;
var ZeroSlopeEnding = 2401;
var WrapAroundEnding = 2402;
var NormalAnimationBlendMode = 2500;
var AdditiveAnimationBlendMode = 2501;
var TrianglesDrawMode = 0;
var TriangleStripDrawMode = 1;
var TriangleFanDrawMode = 2;
var LinearEncoding = 3e3;
var sRGBEncoding = 3001;
var BasicDepthPacking = 3200;
var RGBADepthPacking = 3201;
var TangentSpaceNormalMap = 0;
var ObjectSpaceNormalMap = 1;
var NoColorSpace = "";
var SRGBColorSpace = "srgb";
var LinearSRGBColorSpace = "srgb-linear";
var DisplayP3ColorSpace = "display-p3";
var ZeroStencilOp = 0;
var KeepStencilOp = 7680;
var ReplaceStencilOp = 7681;
var IncrementStencilOp = 7682;
var DecrementStencilOp = 7683;
var IncrementWrapStencilOp = 34055;
var DecrementWrapStencilOp = 34056;
var InvertStencilOp = 5386;
var NeverStencilFunc = 512;
var LessStencilFunc = 513;
var EqualStencilFunc = 514;
var LessEqualStencilFunc = 515;
var GreaterStencilFunc = 516;
var NotEqualStencilFunc = 517;
var GreaterEqualStencilFunc = 518;
var AlwaysStencilFunc = 519;
var NeverCompare = 512;
var LessCompare = 513;
var EqualCompare = 514;
var LessEqualCompare = 515;
var GreaterCompare = 516;
var NotEqualCompare = 517;
var GreaterEqualCompare = 518;
var AlwaysCompare = 519;
var StaticDrawUsage = 35044;
var DynamicDrawUsage = 35048;
var StreamDrawUsage = 35040;
var StaticReadUsage = 35045;
var DynamicReadUsage = 35049;
var StreamReadUsage = 35041;
var StaticCopyUsage = 35046;
var DynamicCopyUsage = 35050;
var StreamCopyUsage = 35042;
var GLSL1 = "100";
var GLSL3 = "300 es";
var _SRGBAFormat = 1035;
var WebGLCoordinateSystem = 2e3;
var WebGPUCoordinateSystem = 2001;
var EventDispatcher = class {
  addEventListener(type, listener) {
    if (this._listeners === void 0) this._listeners = {};
    const listeners = this._listeners;
    if (listeners[type] === void 0) {
      listeners[type] = [];
    }
    if (listeners[type].indexOf(listener) === -1) {
      listeners[type].push(listener);
    }
  }
  hasEventListener(type, listener) {
    if (this._listeners === void 0) return false;
    const listeners = this._listeners;
    return listeners[type] !== void 0 && listeners[type].indexOf(listener) !== -1;
  }
  removeEventListener(type, listener) {
    if (this._listeners === void 0) return;
    const listeners = this._listeners;
    const listenerArray = listeners[type];
    if (listenerArray !== void 0) {
      const index = listenerArray.indexOf(listener);
      if (index !== -1) {
        listenerArray.splice(index, 1);
      }
    }
  }
  dispatchEvent(event) {
    if (this._listeners === void 0) return;
    const listeners = this._listeners;
    const listenerArray = listeners[event.type];
    if (listenerArray !== void 0) {
      event.target = this;
      const array = listenerArray.slice(0);
      for (let i2 = 0, l2 = array.length; i2 < l2; i2++) {
        array[i2].call(this, event);
      }
      event.target = null;
    }
  }
};
var _lut = ["00", "01", "02", "03", "04", "05", "06", "07", "08", "09", "0a", "0b", "0c", "0d", "0e", "0f", "10", "11", "12", "13", "14", "15", "16", "17", "18", "19", "1a", "1b", "1c", "1d", "1e", "1f", "20", "21", "22", "23", "24", "25", "26", "27", "28", "29", "2a", "2b", "2c", "2d", "2e", "2f", "30", "31", "32", "33", "34", "35", "36", "37", "38", "39", "3a", "3b", "3c", "3d", "3e", "3f", "40", "41", "42", "43", "44", "45", "46", "47", "48", "49", "4a", "4b", "4c", "4d", "4e", "4f", "50", "51", "52", "53", "54", "55", "56", "57", "58", "59", "5a", "5b", "5c", "5d", "5e", "5f", "60", "61", "62", "63", "64", "65", "66", "67", "68", "69", "6a", "6b", "6c", "6d", "6e", "6f", "70", "71", "72", "73", "74", "75", "76", "77", "78", "79", "7a", "7b", "7c", "7d", "7e", "7f", "80", "81", "82", "83", "84", "85", "86", "87", "88", "89", "8a", "8b", "8c", "8d", "8e", "8f", "90", "91", "92", "93", "94", "95", "96", "97", "98", "99", "9a", "9b", "9c", "9d", "9e", "9f", "a0", "a1", "a2", "a3", "a4", "a5", "a6", "a7", "a8", "a9", "aa", "ab", "ac", "ad", "ae", "af", "b0", "b1", "b2", "b3", "b4", "b5", "b6", "b7", "b8", "b9", "ba", "bb", "bc", "bd", "be", "bf", "c0", "c1", "c2", "c3", "c4", "c5", "c6", "c7", "c8", "c9", "ca", "cb", "cc", "cd", "ce", "cf", "d0", "d1", "d2", "d3", "d4", "d5", "d6", "d7", "d8", "d9", "da", "db", "dc", "dd", "de", "df", "e0", "e1", "e2", "e3", "e4", "e5", "e6", "e7", "e8", "e9", "ea", "eb", "ec", "ed", "ee", "ef", "f0", "f1", "f2", "f3", "f4", "f5", "f6", "f7", "f8", "f9", "fa", "fb", "fc", "fd", "fe", "ff"];
var _seed = 1234567;
var DEG2RAD = Math.PI / 180;
var RAD2DEG = 180 / Math.PI;
function generateUUID() {
  const d0 = Math.random() * 4294967295 | 0;
  const d1 = Math.random() * 4294967295 | 0;
  const d2 = Math.random() * 4294967295 | 0;
  const d3 = Math.random() * 4294967295 | 0;
  const uuid = _lut[d0 & 255] + _lut[d0 >> 8 & 255] + _lut[d0 >> 16 & 255] + _lut[d0 >> 24 & 255] + "-" + _lut[d1 & 255] + _lut[d1 >> 8 & 255] + "-" + _lut[d1 >> 16 & 15 | 64] + _lut[d1 >> 24 & 255] + "-" + _lut[d2 & 63 | 128] + _lut[d2 >> 8 & 255] + "-" + _lut[d2 >> 16 & 255] + _lut[d2 >> 24 & 255] + _lut[d3 & 255] + _lut[d3 >> 8 & 255] + _lut[d3 >> 16 & 255] + _lut[d3 >> 24 & 255];
  return uuid.toLowerCase();
}
function clamp(value, min, max) {
  return Math.max(min, Math.min(max, value));
}
function euclideanModulo(n, m2) {
  return (n % m2 + m2) % m2;
}
function mapLinear(x3, a1, a2, b1, b2) {
  return b1 + (x3 - a1) * (b2 - b1) / (a2 - a1);
}
function inverseLerp(x3, y2, value) {
  if (x3 !== y2) {
    return (value - x3) / (y2 - x3);
  } else {
    return 0;
  }
}
function lerp(x3, y2, t2) {
  return (1 - t2) * x3 + t2 * y2;
}
function damp(x3, y2, lambda, dt) {
  return lerp(x3, y2, 1 - Math.exp(-lambda * dt));
}
function pingpong(x3, length = 1) {
  return length - Math.abs(euclideanModulo(x3, length * 2) - length);
}
function smoothstep(x3, min, max) {
  if (x3 <= min) return 0;
  if (x3 >= max) return 1;
  x3 = (x3 - min) / (max - min);
  return x3 * x3 * (3 - 2 * x3);
}
function smootherstep(x3, min, max) {
  if (x3 <= min) return 0;
  if (x3 >= max) return 1;
  x3 = (x3 - min) / (max - min);
  return x3 * x3 * x3 * (x3 * (x3 * 6 - 15) + 10);
}
function randInt(low, high) {
  return low + Math.floor(Math.random() * (high - low + 1));
}
function randFloat(low, high) {
  return low + Math.random() * (high - low);
}
function randFloatSpread(range) {
  return range * (0.5 - Math.random());
}
function seededRandom(s2) {
  if (s2 !== void 0) _seed = s2;
  let t2 = _seed += 1831565813;
  t2 = Math.imul(t2 ^ t2 >>> 15, t2 | 1);
  t2 ^= t2 + Math.imul(t2 ^ t2 >>> 7, t2 | 61);
  return ((t2 ^ t2 >>> 14) >>> 0) / 4294967296;
}
function degToRad(degrees) {
  return degrees * DEG2RAD;
}
function radToDeg(radians) {
  return radians * RAD2DEG;
}
function isPowerOfTwo(value) {
  return (value & value - 1) === 0 && value !== 0;
}
function ceilPowerOfTwo(value) {
  return Math.pow(2, Math.ceil(Math.log(value) / Math.LN2));
}
function floorPowerOfTwo(value) {
  return Math.pow(2, Math.floor(Math.log(value) / Math.LN2));
}
function setQuaternionFromProperEuler(q, a2, b2, c2, order) {
  const cos = Math.cos;
  const sin = Math.sin;
  const c22 = cos(b2 / 2);
  const s2 = sin(b2 / 2);
  const c13 = cos((a2 + c2) / 2);
  const s13 = sin((a2 + c2) / 2);
  const c1_3 = cos((a2 - c2) / 2);
  const s1_3 = sin((a2 - c2) / 2);
  const c3_1 = cos((c2 - a2) / 2);
  const s3_1 = sin((c2 - a2) / 2);
  switch (order) {
    case "XYX":
      q.set(c22 * s13, s2 * c1_3, s2 * s1_3, c22 * c13);
      break;
    case "YZY":
      q.set(s2 * s1_3, c22 * s13, s2 * c1_3, c22 * c13);
      break;
    case "ZXZ":
      q.set(s2 * c1_3, s2 * s1_3, c22 * s13, c22 * c13);
      break;
    case "XZX":
      q.set(c22 * s13, s2 * s3_1, s2 * c3_1, c22 * c13);
      break;
    case "YXY":
      q.set(s2 * c3_1, c22 * s13, s2 * s3_1, c22 * c13);
      break;
    case "ZYZ":
      q.set(s2 * s3_1, s2 * c3_1, c22 * s13, c22 * c13);
      break;
    default:
      console.warn("THREE.MathUtils: .setQuaternionFromProperEuler() encountered an unknown order: " + order);
  }
}
function denormalize(value, array) {
  switch (array.constructor) {
    case Float32Array:
      return value;
    case Uint32Array:
      return value / 4294967295;
    case Uint16Array:
      return value / 65535;
    case Uint8Array:
      return value / 255;
    case Int32Array:
      return Math.max(value / 2147483647, -1);
    case Int16Array:
      return Math.max(value / 32767, -1);
    case Int8Array:
      return Math.max(value / 127, -1);
    default:
      throw new Error("Invalid component type.");
  }
}
function normalize(value, array) {
  switch (array.constructor) {
    case Float32Array:
      return value;
    case Uint32Array:
      return Math.round(value * 4294967295);
    case Uint16Array:
      return Math.round(value * 65535);
    case Uint8Array:
      return Math.round(value * 255);
    case Int32Array:
      return Math.round(value * 2147483647);
    case Int16Array:
      return Math.round(value * 32767);
    case Int8Array:
      return Math.round(value * 127);
    default:
      throw new Error("Invalid component type.");
  }
}
var MathUtils = {
  DEG2RAD,
  RAD2DEG,
  generateUUID,
  clamp,
  euclideanModulo,
  mapLinear,
  inverseLerp,
  lerp,
  damp,
  pingpong,
  smoothstep,
  smootherstep,
  randInt,
  randFloat,
  randFloatSpread,
  seededRandom,
  degToRad,
  radToDeg,
  isPowerOfTwo,
  ceilPowerOfTwo,
  floorPowerOfTwo,
  setQuaternionFromProperEuler,
  normalize,
  denormalize
};
var Vector2 = class _Vector2 {
  constructor(x3 = 0, y2 = 0) {
    _Vector2.prototype.isVector2 = true;
    this.x = x3;
    this.y = y2;
  }
  get width() {
    return this.x;
  }
  set width(value) {
    this.x = value;
  }
  get height() {
    return this.y;
  }
  set height(value) {
    this.y = value;
  }
  set(x3, y2) {
    this.x = x3;
    this.y = y2;
    return this;
  }
  setScalar(scalar) {
    this.x = scalar;
    this.y = scalar;
    return this;
  }
  setX(x3) {
    this.x = x3;
    return this;
  }
  setY(y2) {
    this.y = y2;
    return this;
  }
  setComponent(index, value) {
    switch (index) {
      case 0:
        this.x = value;
        break;
      case 1:
        this.y = value;
        break;
      default:
        throw new Error("index is out of range: " + index);
    }
    return this;
  }
  getComponent(index) {
    switch (index) {
      case 0:
        return this.x;
      case 1:
        return this.y;
      default:
        throw new Error("index is out of range: " + index);
    }
  }
  clone() {
    return new this.constructor(this.x, this.y);
  }
  copy(v2) {
    this.x = v2.x;
    this.y = v2.y;
    return this;
  }
  add(v2) {
    this.x += v2.x;
    this.y += v2.y;
    return this;
  }
  addScalar(s2) {
    this.x += s2;
    this.y += s2;
    return this;
  }
  addVectors(a2, b2) {
    this.x = a2.x + b2.x;
    this.y = a2.y + b2.y;
    return this;
  }
  addScaledVector(v2, s2) {
    this.x += v2.x * s2;
    this.y += v2.y * s2;
    return this;
  }
  sub(v2) {
    this.x -= v2.x;
    this.y -= v2.y;
    return this;
  }
  subScalar(s2) {
    this.x -= s2;
    this.y -= s2;
    return this;
  }
  subVectors(a2, b2) {
    this.x = a2.x - b2.x;
    this.y = a2.y - b2.y;
    return this;
  }
  multiply(v2) {
    this.x *= v2.x;
    this.y *= v2.y;
    return this;
  }
  multiplyScalar(scalar) {
    this.x *= scalar;
    this.y *= scalar;
    return this;
  }
  divide(v2) {
    this.x /= v2.x;
    this.y /= v2.y;
    return this;
  }
  divideScalar(scalar) {
    return this.multiplyScalar(1 / scalar);
  }
  applyMatrix3(m2) {
    const x3 = this.x, y2 = this.y;
    const e2 = m2.elements;
    this.x = e2[0] * x3 + e2[3] * y2 + e2[6];
    this.y = e2[1] * x3 + e2[4] * y2 + e2[7];
    return this;
  }
  min(v2) {
    this.x = Math.min(this.x, v2.x);
    this.y = Math.min(this.y, v2.y);
    return this;
  }
  max(v2) {
    this.x = Math.max(this.x, v2.x);
    this.y = Math.max(this.y, v2.y);
    return this;
  }
  clamp(min, max) {
    this.x = Math.max(min.x, Math.min(max.x, this.x));
    this.y = Math.max(min.y, Math.min(max.y, this.y));
    return this;
  }
  clampScalar(minVal, maxVal) {
    this.x = Math.max(minVal, Math.min(maxVal, this.x));
    this.y = Math.max(minVal, Math.min(maxVal, this.y));
    return this;
  }
  clampLength(min, max) {
    const length = this.length();
    return this.divideScalar(length || 1).multiplyScalar(Math.max(min, Math.min(max, length)));
  }
  floor() {
    this.x = Math.floor(this.x);
    this.y = Math.floor(this.y);
    return this;
  }
  ceil() {
    this.x = Math.ceil(this.x);
    this.y = Math.ceil(this.y);
    return this;
  }
  round() {
    this.x = Math.round(this.x);
    this.y = Math.round(this.y);
    return this;
  }
  roundToZero() {
    this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x);
    this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y);
    return this;
  }
  negate() {
    this.x = -this.x;
    this.y = -this.y;
    return this;
  }
  dot(v2) {
    return this.x * v2.x + this.y * v2.y;
  }
  cross(v2) {
    return this.x * v2.y - this.y * v2.x;
  }
  lengthSq() {
    return this.x * this.x + this.y * this.y;
  }
  length() {
    return Math.sqrt(this.x * this.x + this.y * this.y);
  }
  manhattanLength() {
    return Math.abs(this.x) + Math.abs(this.y);
  }
  normalize() {
    return this.divideScalar(this.length() || 1);
  }
  angle() {
    const angle = Math.atan2(-this.y, -this.x) + Math.PI;
    return angle;
  }
  angleTo(v2) {
    const denominator = Math.sqrt(this.lengthSq() * v2.lengthSq());
    if (denominator === 0) return Math.PI / 2;
    const theta = this.dot(v2) / denominator;
    return Math.acos(clamp(theta, -1, 1));
  }
  distanceTo(v2) {
    return Math.sqrt(this.distanceToSquared(v2));
  }
  distanceToSquared(v2) {
    const dx = this.x - v2.x, dy = this.y - v2.y;
    return dx * dx + dy * dy;
  }
  manhattanDistanceTo(v2) {
    return Math.abs(this.x - v2.x) + Math.abs(this.y - v2.y);
  }
  setLength(length) {
    return this.normalize().multiplyScalar(length);
  }
  lerp(v2, alpha) {
    this.x += (v2.x - this.x) * alpha;
    this.y += (v2.y - this.y) * alpha;
    return this;
  }
  lerpVectors(v1, v2, alpha) {
    this.x = v1.x + (v2.x - v1.x) * alpha;
    this.y = v1.y + (v2.y - v1.y) * alpha;
    return this;
  }
  equals(v2) {
    return v2.x === this.x && v2.y === this.y;
  }
  fromArray(array, offset = 0) {
    this.x = array[offset];
    this.y = array[offset + 1];
    return this;
  }
  toArray(array = [], offset = 0) {
    array[offset] = this.x;
    array[offset + 1] = this.y;
    return array;
  }
  fromBufferAttribute(attribute, index) {
    this.x = attribute.getX(index);
    this.y = attribute.getY(index);
    return this;
  }
  rotateAround(center, angle) {
    const c2 = Math.cos(angle), s2 = Math.sin(angle);
    const x3 = this.x - center.x;
    const y2 = this.y - center.y;
    this.x = x3 * c2 - y2 * s2 + center.x;
    this.y = x3 * s2 + y2 * c2 + center.y;
    return this;
  }
  random() {
    this.x = Math.random();
    this.y = Math.random();
    return this;
  }
  *[Symbol.iterator]() {
    yield this.x;
    yield this.y;
  }
};
var Matrix3 = class _Matrix3 {
  constructor(n11, n12, n13, n21, n22, n23, n31, n32, n33) {
    _Matrix3.prototype.isMatrix3 = true;
    this.elements = [
      1,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      1
    ];
    if (n11 !== void 0) {
      this.set(n11, n12, n13, n21, n22, n23, n31, n32, n33);
    }
  }
  set(n11, n12, n13, n21, n22, n23, n31, n32, n33) {
    const te = this.elements;
    te[0] = n11;
    te[1] = n21;
    te[2] = n31;
    te[3] = n12;
    te[4] = n22;
    te[5] = n32;
    te[6] = n13;
    te[7] = n23;
    te[8] = n33;
    return this;
  }
  identity() {
    this.set(
      1,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      1
    );
    return this;
  }
  copy(m2) {
    const te = this.elements;
    const me = m2.elements;
    te[0] = me[0];
    te[1] = me[1];
    te[2] = me[2];
    te[3] = me[3];
    te[4] = me[4];
    te[5] = me[5];
    te[6] = me[6];
    te[7] = me[7];
    te[8] = me[8];
    return this;
  }
  extractBasis(xAxis, yAxis, zAxis) {
    xAxis.setFromMatrix3Column(this, 0);
    yAxis.setFromMatrix3Column(this, 1);
    zAxis.setFromMatrix3Column(this, 2);
    return this;
  }
  setFromMatrix4(m2) {
    const me = m2.elements;
    this.set(
      me[0],
      me[4],
      me[8],
      me[1],
      me[5],
      me[9],
      me[2],
      me[6],
      me[10]
    );
    return this;
  }
  multiply(m2) {
    return this.multiplyMatrices(this, m2);
  }
  premultiply(m2) {
    return this.multiplyMatrices(m2, this);
  }
  multiplyMatrices(a2, b2) {
    const ae = a2.elements;
    const be = b2.elements;
    const te = this.elements;
    const a11 = ae[0], a12 = ae[3], a13 = ae[6];
    const a21 = ae[1], a22 = ae[4], a23 = ae[7];
    const a31 = ae[2], a32 = ae[5], a33 = ae[8];
    const b11 = be[0], b12 = be[3], b13 = be[6];
    const b21 = be[1], b22 = be[4], b23 = be[7];
    const b31 = be[2], b32 = be[5], b33 = be[8];
    te[0] = a11 * b11 + a12 * b21 + a13 * b31;
    te[3] = a11 * b12 + a12 * b22 + a13 * b32;
    te[6] = a11 * b13 + a12 * b23 + a13 * b33;
    te[1] = a21 * b11 + a22 * b21 + a23 * b31;
    te[4] = a21 * b12 + a22 * b22 + a23 * b32;
    te[7] = a21 * b13 + a22 * b23 + a23 * b33;
    te[2] = a31 * b11 + a32 * b21 + a33 * b31;
    te[5] = a31 * b12 + a32 * b22 + a33 * b32;
    te[8] = a31 * b13 + a32 * b23 + a33 * b33;
    return this;
  }
  multiplyScalar(s2) {
    const te = this.elements;
    te[0] *= s2;
    te[3] *= s2;
    te[6] *= s2;
    te[1] *= s2;
    te[4] *= s2;
    te[7] *= s2;
    te[2] *= s2;
    te[5] *= s2;
    te[8] *= s2;
    return this;
  }
  determinant() {
    const te = this.elements;
    const a2 = te[0], b2 = te[1], c2 = te[2], d2 = te[3], e2 = te[4], f2 = te[5], g2 = te[6], h2 = te[7], i2 = te[8];
    return a2 * e2 * i2 - a2 * f2 * h2 - b2 * d2 * i2 + b2 * f2 * g2 + c2 * d2 * h2 - c2 * e2 * g2;
  }
  invert() {
    const te = this.elements, n11 = te[0], n21 = te[1], n31 = te[2], n12 = te[3], n22 = te[4], n32 = te[5], n13 = te[6], n23 = te[7], n33 = te[8], t11 = n33 * n22 - n32 * n23, t12 = n32 * n13 - n33 * n12, t13 = n23 * n12 - n22 * n13, det = n11 * t11 + n21 * t12 + n31 * t13;
    if (det === 0) return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0);
    const detInv = 1 / det;
    te[0] = t11 * detInv;
    te[1] = (n31 * n23 - n33 * n21) * detInv;
    te[2] = (n32 * n21 - n31 * n22) * detInv;
    te[3] = t12 * detInv;
    te[4] = (n33 * n11 - n31 * n13) * detInv;
    te[5] = (n31 * n12 - n32 * n11) * detInv;
    te[6] = t13 * detInv;
    te[7] = (n21 * n13 - n23 * n11) * detInv;
    te[8] = (n22 * n11 - n21 * n12) * detInv;
    return this;
  }
  transpose() {
    let tmp2;
    const m2 = this.elements;
    tmp2 = m2[1];
    m2[1] = m2[3];
    m2[3] = tmp2;
    tmp2 = m2[2];
    m2[2] = m2[6];
    m2[6] = tmp2;
    tmp2 = m2[5];
    m2[5] = m2[7];
    m2[7] = tmp2;
    return this;
  }
  getNormalMatrix(matrix42) {
    return this.setFromMatrix4(matrix42).invert().transpose();
  }
  transposeIntoArray(r2) {
    const m2 = this.elements;
    r2[0] = m2[0];
    r2[1] = m2[3];
    r2[2] = m2[6];
    r2[3] = m2[1];
    r2[4] = m2[4];
    r2[5] = m2[7];
    r2[6] = m2[2];
    r2[7] = m2[5];
    r2[8] = m2[8];
    return this;
  }
  setUvTransform(tx, ty, sx, sy, rotation, cx, cy) {
    const c2 = Math.cos(rotation);
    const s2 = Math.sin(rotation);
    this.set(
      sx * c2,
      sx * s2,
      -sx * (c2 * cx + s2 * cy) + cx + tx,
      -sy * s2,
      sy * c2,
      -sy * (-s2 * cx + c2 * cy) + cy + ty,
      0,
      0,
      1
    );
    return this;
  }
  //
  scale(sx, sy) {
    this.premultiply(_m3.makeScale(sx, sy));
    return this;
  }
  rotate(theta) {
    this.premultiply(_m3.makeRotation(-theta));
    return this;
  }
  translate(tx, ty) {
    this.premultiply(_m3.makeTranslation(tx, ty));
    return this;
  }
  // for 2D Transforms
  makeTranslation(x3, y2) {
    if (x3.isVector2) {
      this.set(
        1,
        0,
        x3.x,
        0,
        1,
        x3.y,
        0,
        0,
        1
      );
    } else {
      this.set(
        1,
        0,
        x3,
        0,
        1,
        y2,
        0,
        0,
        1
      );
    }
    return this;
  }
  makeRotation(theta) {
    const c2 = Math.cos(theta);
    const s2 = Math.sin(theta);
    this.set(
      c2,
      -s2,
      0,
      s2,
      c2,
      0,
      0,
      0,
      1
    );
    return this;
  }
  makeScale(x3, y2) {
    this.set(
      x3,
      0,
      0,
      0,
      y2,
      0,
      0,
      0,
      1
    );
    return this;
  }
  //
  equals(matrix) {
    const te = this.elements;
    const me = matrix.elements;
    for (let i2 = 0; i2 < 9; i2++) {
      if (te[i2] !== me[i2]) return false;
    }
    return true;
  }
  fromArray(array, offset = 0) {
    for (let i2 = 0; i2 < 9; i2++) {
      this.elements[i2] = array[i2 + offset];
    }
    return this;
  }
  toArray(array = [], offset = 0) {
    const te = this.elements;
    array[offset] = te[0];
    array[offset + 1] = te[1];
    array[offset + 2] = te[2];
    array[offset + 3] = te[3];
    array[offset + 4] = te[4];
    array[offset + 5] = te[5];
    array[offset + 6] = te[6];
    array[offset + 7] = te[7];
    array[offset + 8] = te[8];
    return array;
  }
  clone() {
    return new this.constructor().fromArray(this.elements);
  }
};
var _m3 = new Matrix3();
function arrayNeedsUint32(array) {
  for (let i2 = array.length - 1; i2 >= 0; --i2) {
    if (array[i2] >= 65535) return true;
  }
  return false;
}
var TYPED_ARRAYS = {
  Int8Array,
  Uint8Array,
  Uint8ClampedArray,
  Int16Array,
  Uint16Array,
  Int32Array,
  Uint32Array,
  Float32Array,
  Float64Array
};
function getTypedArray(type, buffer) {
  return new TYPED_ARRAYS[type](buffer);
}
function createElementNS(name) {
  return document.createElementNS("http://www.w3.org/1999/xhtml", name);
}
var _cache = {};
function warnOnce(message) {
  if (message in _cache) return;
  _cache[message] = true;
  console.warn(message);
}
function SRGBToLinear(c2) {
  return c2 < 0.04045 ? c2 * 0.0773993808 : Math.pow(c2 * 0.9478672986 + 0.0521327014, 2.4);
}
function LinearToSRGB(c2) {
  return c2 < 31308e-7 ? c2 * 12.92 : 1.055 * Math.pow(c2, 0.41666) - 0.055;
}
var LINEAR_SRGB_TO_LINEAR_DISPLAY_P3 = new Matrix3().fromArray([
  0.8224621,
  0.0331941,
  0.0170827,
  0.177538,
  0.9668058,
  0.0723974,
  -1e-7,
  1e-7,
  0.9105199
]);
var LINEAR_DISPLAY_P3_TO_LINEAR_SRGB = new Matrix3().fromArray([
  1.2249401,
  -0.0420569,
  -0.0196376,
  -0.2249404,
  1.0420571,
  -0.0786361,
  1e-7,
  0,
  1.0982735
]);
function DisplayP3ToLinearSRGB(color) {
  return color.convertSRGBToLinear().applyMatrix3(LINEAR_DISPLAY_P3_TO_LINEAR_SRGB);
}
function LinearSRGBToDisplayP3(color) {
  return color.applyMatrix3(LINEAR_SRGB_TO_LINEAR_DISPLAY_P3).convertLinearToSRGB();
}
var TO_LINEAR = {
  [LinearSRGBColorSpace]: (color) => color,
  [SRGBColorSpace]: (color) => color.convertSRGBToLinear(),
  [DisplayP3ColorSpace]: DisplayP3ToLinearSRGB
};
var FROM_LINEAR = {
  [LinearSRGBColorSpace]: (color) => color,
  [SRGBColorSpace]: (color) => color.convertLinearToSRGB(),
  [DisplayP3ColorSpace]: LinearSRGBToDisplayP3
};
var ColorManagement = {
  enabled: true,
  get legacyMode() {
    console.warn("THREE.ColorManagement: .legacyMode=false renamed to .enabled=true in r150.");
    return !this.enabled;
  },
  set legacyMode(legacyMode) {
    console.warn("THREE.ColorManagement: .legacyMode=false renamed to .enabled=true in r150.");
    this.enabled = !legacyMode;
  },
  get workingColorSpace() {
    return LinearSRGBColorSpace;
  },
  set workingColorSpace(colorSpace) {
    console.warn("THREE.ColorManagement: .workingColorSpace is readonly.");
  },
  convert: function(color, sourceColorSpace, targetColorSpace) {
    if (this.enabled === false || sourceColorSpace === targetColorSpace || !sourceColorSpace || !targetColorSpace) {
      return color;
    }
    const sourceToLinear = TO_LINEAR[sourceColorSpace];
    const targetFromLinear = FROM_LINEAR[targetColorSpace];
    if (sourceToLinear === void 0 || targetFromLinear === void 0) {
      throw new Error(`Unsupported color space conversion, "${sourceColorSpace}" to "${targetColorSpace}".`);
    }
    return targetFromLinear(sourceToLinear(color));
  },
  fromWorkingColorSpace: function(color, targetColorSpace) {
    return this.convert(color, this.workingColorSpace, targetColorSpace);
  },
  toWorkingColorSpace: function(color, sourceColorSpace) {
    return this.convert(color, sourceColorSpace, this.workingColorSpace);
  }
};
var _canvas;
var ImageUtils = class {
  static getDataURL(image) {
    if (/^data:/i.test(image.src)) {
      return image.src;
    }
    if (typeof HTMLCanvasElement === "undefined") {
      return image.src;
    }
    let canvas;
    if (image instanceof HTMLCanvasElement) {
      canvas = image;
    } else {
      if (_canvas === void 0) _canvas = createElementNS("canvas");
      _canvas.width = image.width;
      _canvas.height = image.height;
      const context = _canvas.getContext("2d");
      if (image instanceof ImageData) {
        context.putImageData(image, 0, 0);
      } else {
        context.drawImage(image, 0, 0, image.width, image.height);
      }
      canvas = _canvas;
    }
    if (canvas.width > 2048 || canvas.height > 2048) {
      console.warn("THREE.ImageUtils.getDataURL: Image converted to jpg for performance reasons", image);
      return canvas.toDataURL("image/jpeg", 0.6);
    } else {
      return canvas.toDataURL("image/png");
    }
  }
  static sRGBToLinear(image) {
    if (typeof HTMLImageElement !== "undefined" && image instanceof HTMLImageElement || typeof HTMLCanvasElement !== "undefined" && image instanceof HTMLCanvasElement || typeof ImageBitmap !== "undefined" && image instanceof ImageBitmap) {
      const canvas = createElementNS("canvas");
      canvas.width = image.width;
      canvas.height = image.height;
      const context = canvas.getContext("2d");
      context.drawImage(image, 0, 0, image.width, image.height);
      const imageData = context.getImageData(0, 0, image.width, image.height);
      const data = imageData.data;
      for (let i2 = 0; i2 < data.length; i2++) {
        data[i2] = SRGBToLinear(data[i2] / 255) * 255;
      }
      context.putImageData(imageData, 0, 0);
      return canvas;
    } else if (image.data) {
      const data = image.data.slice(0);
      for (let i2 = 0; i2 < data.length; i2++) {
        if (data instanceof Uint8Array || data instanceof Uint8ClampedArray) {
          data[i2] = Math.floor(SRGBToLinear(data[i2] / 255) * 255);
        } else {
          data[i2] = SRGBToLinear(data[i2]);
        }
      }
      return {
        data,
        width: image.width,
        height: image.height
      };
    } else {
      console.warn("THREE.ImageUtils.sRGBToLinear(): Unsupported image type. No color space conversion applied.");
      return image;
    }
  }
};
var sourceId = 0;
var Source = class {
  constructor(data = null) {
    this.isSource = true;
    Object.defineProperty(this, "id", { value: sourceId++ });
    this.uuid = generateUUID();
    this.data = data;
    this.version = 0;
  }
  set needsUpdate(value) {
    if (value === true) this.version++;
  }
  toJSON(meta) {
    const isRootObject = meta === void 0 || typeof meta === "string";
    if (!isRootObject && meta.images[this.uuid] !== void 0) {
      return meta.images[this.uuid];
    }
    const output = {
      uuid: this.uuid,
      url: ""
    };
    const data = this.data;
    if (data !== null) {
      let url;
      if (Array.isArray(data)) {
        url = [];
        for (let i2 = 0, l2 = data.length; i2 < l2; i2++) {
          if (data[i2].isDataTexture) {
            url.push(serializeImage(data[i2].image));
          } else {
            url.push(serializeImage(data[i2]));
          }
        }
      } else {
        url = serializeImage(data);
      }
      output.url = url;
    }
    if (!isRootObject) {
      meta.images[this.uuid] = output;
    }
    return output;
  }
};
function serializeImage(image) {
  if (typeof HTMLImageElement !== "undefined" && image instanceof HTMLImageElement || typeof HTMLCanvasElement !== "undefined" && image instanceof HTMLCanvasElement || typeof ImageBitmap !== "undefined" && image instanceof ImageBitmap) {
    return ImageUtils.getDataURL(image);
  } else {
    if (image.data) {
      return {
        data: Array.from(image.data),
        width: image.width,
        height: image.height,
        type: image.data.constructor.name
      };
    } else {
      console.warn("THREE.Texture: Unable to serialize Texture.");
      return {};
    }
  }
}
var textureId = 0;
var Texture = class _Texture extends EventDispatcher {
  constructor(image = _Texture.DEFAULT_IMAGE, mapping = _Texture.DEFAULT_MAPPING, wrapS = ClampToEdgeWrapping, wrapT = ClampToEdgeWrapping, magFilter = LinearFilter, minFilter = LinearMipmapLinearFilter, format = RGBAFormat, type = UnsignedByteType, anisotropy = _Texture.DEFAULT_ANISOTROPY, colorSpace = NoColorSpace) {
    super();
    this.isTexture = true;
    Object.defineProperty(this, "id", { value: textureId++ });
    this.uuid = generateUUID();
    this.name = "";
    this.source = new Source(image);
    this.mipmaps = [];
    this.mapping = mapping;
    this.channel = 0;
    this.wrapS = wrapS;
    this.wrapT = wrapT;
    this.magFilter = magFilter;
    this.minFilter = minFilter;
    this.anisotropy = anisotropy;
    this.format = format;
    this.internalFormat = null;
    this.type = type;
    this.offset = new Vector2(0, 0);
    this.repeat = new Vector2(1, 1);
    this.center = new Vector2(0, 0);
    this.rotation = 0;
    this.matrixAutoUpdate = true;
    this.matrix = new Matrix3();
    this.generateMipmaps = true;
    this.premultiplyAlpha = false;
    this.flipY = true;
    this.unpackAlignment = 4;
    if (typeof colorSpace === "string") {
      this.colorSpace = colorSpace;
    } else {
      warnOnce("THREE.Texture: Property .encoding has been replaced by .colorSpace.");
      this.colorSpace = colorSpace === sRGBEncoding ? SRGBColorSpace : NoColorSpace;
    }
    this.userData = {};
    this.version = 0;
    this.onUpdate = null;
    this.isRenderTargetTexture = false;
    this.needsPMREMUpdate = false;
  }
  get image() {
    return this.source.data;
  }
  set image(value = null) {
    this.source.data = value;
  }
  updateMatrix() {
    this.matrix.setUvTransform(this.offset.x, this.offset.y, this.repeat.x, this.repeat.y, this.rotation, this.center.x, this.center.y);
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(source) {
    this.name = source.name;
    this.source = source.source;
    this.mipmaps = source.mipmaps.slice(0);
    this.mapping = source.mapping;
    this.channel = source.channel;
    this.wrapS = source.wrapS;
    this.wrapT = source.wrapT;
    this.magFilter = source.magFilter;
    this.minFilter = source.minFilter;
    this.anisotropy = source.anisotropy;
    this.format = source.format;
    this.internalFormat = source.internalFormat;
    this.type = source.type;
    this.offset.copy(source.offset);
    this.repeat.copy(source.repeat);
    this.center.copy(source.center);
    this.rotation = source.rotation;
    this.matrixAutoUpdate = source.matrixAutoUpdate;
    this.matrix.copy(source.matrix);
    this.generateMipmaps = source.generateMipmaps;
    this.premultiplyAlpha = source.premultiplyAlpha;
    this.flipY = source.flipY;
    this.unpackAlignment = source.unpackAlignment;
    this.colorSpace = source.colorSpace;
    this.userData = JSON.parse(JSON.stringify(source.userData));
    this.needsUpdate = true;
    return this;
  }
  toJSON(meta) {
    const isRootObject = meta === void 0 || typeof meta === "string";
    if (!isRootObject && meta.textures[this.uuid] !== void 0) {
      return meta.textures[this.uuid];
    }
    const output = {
      metadata: {
        version: 4.6,
        type: "Texture",
        generator: "Texture.toJSON"
      },
      uuid: this.uuid,
      name: this.name,
      image: this.source.toJSON(meta).uuid,
      mapping: this.mapping,
      channel: this.channel,
      repeat: [this.repeat.x, this.repeat.y],
      offset: [this.offset.x, this.offset.y],
      center: [this.center.x, this.center.y],
      rotation: this.rotation,
      wrap: [this.wrapS, this.wrapT],
      format: this.format,
      internalFormat: this.internalFormat,
      type: this.type,
      colorSpace: this.colorSpace,
      minFilter: this.minFilter,
      magFilter: this.magFilter,
      anisotropy: this.anisotropy,
      flipY: this.flipY,
      generateMipmaps: this.generateMipmaps,
      premultiplyAlpha: this.premultiplyAlpha,
      unpackAlignment: this.unpackAlignment
    };
    if (Object.keys(this.userData).length > 0) output.userData = this.userData;
    if (!isRootObject) {
      meta.textures[this.uuid] = output;
    }
    return output;
  }
  dispose() {
    this.dispatchEvent({ type: "dispose" });
  }
  transformUv(uv) {
    if (this.mapping !== UVMapping) return uv;
    uv.applyMatrix3(this.matrix);
    if (uv.x < 0 || uv.x > 1) {
      switch (this.wrapS) {
        case RepeatWrapping:
          uv.x = uv.x - Math.floor(uv.x);
          break;
        case ClampToEdgeWrapping:
          uv.x = uv.x < 0 ? 0 : 1;
          break;
        case MirroredRepeatWrapping:
          if (Math.abs(Math.floor(uv.x) % 2) === 1) {
            uv.x = Math.ceil(uv.x) - uv.x;
          } else {
            uv.x = uv.x - Math.floor(uv.x);
          }
          break;
      }
    }
    if (uv.y < 0 || uv.y > 1) {
      switch (this.wrapT) {
        case RepeatWrapping:
          uv.y = uv.y - Math.floor(uv.y);
          break;
        case ClampToEdgeWrapping:
          uv.y = uv.y < 0 ? 0 : 1;
          break;
        case MirroredRepeatWrapping:
          if (Math.abs(Math.floor(uv.y) % 2) === 1) {
            uv.y = Math.ceil(uv.y) - uv.y;
          } else {
            uv.y = uv.y - Math.floor(uv.y);
          }
          break;
      }
    }
    if (this.flipY) {
      uv.y = 1 - uv.y;
    }
    return uv;
  }
  set needsUpdate(value) {
    if (value === true) {
      this.version++;
      this.source.needsUpdate = true;
    }
  }
  get encoding() {
    warnOnce("THREE.Texture: Property .encoding has been replaced by .colorSpace.");
    return this.colorSpace === SRGBColorSpace ? sRGBEncoding : LinearEncoding;
  }
  set encoding(encoding) {
    warnOnce("THREE.Texture: Property .encoding has been replaced by .colorSpace.");
    this.colorSpace = encoding === sRGBEncoding ? SRGBColorSpace : NoColorSpace;
  }
};
Texture.DEFAULT_IMAGE = null;
Texture.DEFAULT_MAPPING = UVMapping;
Texture.DEFAULT_ANISOTROPY = 1;
var Vector4 = class _Vector4 {
  constructor(x3 = 0, y2 = 0, z = 0, w2 = 1) {
    _Vector4.prototype.isVector4 = true;
    this.x = x3;
    this.y = y2;
    this.z = z;
    this.w = w2;
  }
  get width() {
    return this.z;
  }
  set width(value) {
    this.z = value;
  }
  get height() {
    return this.w;
  }
  set height(value) {
    this.w = value;
  }
  set(x3, y2, z, w2) {
    this.x = x3;
    this.y = y2;
    this.z = z;
    this.w = w2;
    return this;
  }
  setScalar(scalar) {
    this.x = scalar;
    this.y = scalar;
    this.z = scalar;
    this.w = scalar;
    return this;
  }
  setX(x3) {
    this.x = x3;
    return this;
  }
  setY(y2) {
    this.y = y2;
    return this;
  }
  setZ(z) {
    this.z = z;
    return this;
  }
  setW(w2) {
    this.w = w2;
    return this;
  }
  setComponent(index, value) {
    switch (index) {
      case 0:
        this.x = value;
        break;
      case 1:
        this.y = value;
        break;
      case 2:
        this.z = value;
        break;
      case 3:
        this.w = value;
        break;
      default:
        throw new Error("index is out of range: " + index);
    }
    return this;
  }
  getComponent(index) {
    switch (index) {
      case 0:
        return this.x;
      case 1:
        return this.y;
      case 2:
        return this.z;
      case 3:
        return this.w;
      default:
        throw new Error("index is out of range: " + index);
    }
  }
  clone() {
    return new this.constructor(this.x, this.y, this.z, this.w);
  }
  copy(v2) {
    this.x = v2.x;
    this.y = v2.y;
    this.z = v2.z;
    this.w = v2.w !== void 0 ? v2.w : 1;
    return this;
  }
  add(v2) {
    this.x += v2.x;
    this.y += v2.y;
    this.z += v2.z;
    this.w += v2.w;
    return this;
  }
  addScalar(s2) {
    this.x += s2;
    this.y += s2;
    this.z += s2;
    this.w += s2;
    return this;
  }
  addVectors(a2, b2) {
    this.x = a2.x + b2.x;
    this.y = a2.y + b2.y;
    this.z = a2.z + b2.z;
    this.w = a2.w + b2.w;
    return this;
  }
  addScaledVector(v2, s2) {
    this.x += v2.x * s2;
    this.y += v2.y * s2;
    this.z += v2.z * s2;
    this.w += v2.w * s2;
    return this;
  }
  sub(v2) {
    this.x -= v2.x;
    this.y -= v2.y;
    this.z -= v2.z;
    this.w -= v2.w;
    return this;
  }
  subScalar(s2) {
    this.x -= s2;
    this.y -= s2;
    this.z -= s2;
    this.w -= s2;
    return this;
  }
  subVectors(a2, b2) {
    this.x = a2.x - b2.x;
    this.y = a2.y - b2.y;
    this.z = a2.z - b2.z;
    this.w = a2.w - b2.w;
    return this;
  }
  multiply(v2) {
    this.x *= v2.x;
    this.y *= v2.y;
    this.z *= v2.z;
    this.w *= v2.w;
    return this;
  }
  multiplyScalar(scalar) {
    this.x *= scalar;
    this.y *= scalar;
    this.z *= scalar;
    this.w *= scalar;
    return this;
  }
  applyMatrix4(m2) {
    const x3 = this.x, y2 = this.y, z = this.z, w2 = this.w;
    const e2 = m2.elements;
    this.x = e2[0] * x3 + e2[4] * y2 + e2[8] * z + e2[12] * w2;
    this.y = e2[1] * x3 + e2[5] * y2 + e2[9] * z + e2[13] * w2;
    this.z = e2[2] * x3 + e2[6] * y2 + e2[10] * z + e2[14] * w2;
    this.w = e2[3] * x3 + e2[7] * y2 + e2[11] * z + e2[15] * w2;
    return this;
  }
  divideScalar(scalar) {
    return this.multiplyScalar(1 / scalar);
  }
  setAxisAngleFromQuaternion(q) {
    this.w = 2 * Math.acos(q.w);
    const s2 = Math.sqrt(1 - q.w * q.w);
    if (s2 < 1e-4) {
      this.x = 1;
      this.y = 0;
      this.z = 0;
    } else {
      this.x = q.x / s2;
      this.y = q.y / s2;
      this.z = q.z / s2;
    }
    return this;
  }
  setAxisAngleFromRotationMatrix(m2) {
    let angle, x3, y2, z;
    const epsilon = 0.01, epsilon2 = 0.1, te = m2.elements, m11 = te[0], m12 = te[4], m13 = te[8], m21 = te[1], m22 = te[5], m23 = te[9], m31 = te[2], m32 = te[6], m33 = te[10];
    if (Math.abs(m12 - m21) < epsilon && Math.abs(m13 - m31) < epsilon && Math.abs(m23 - m32) < epsilon) {
      if (Math.abs(m12 + m21) < epsilon2 && Math.abs(m13 + m31) < epsilon2 && Math.abs(m23 + m32) < epsilon2 && Math.abs(m11 + m22 + m33 - 3) < epsilon2) {
        this.set(1, 0, 0, 0);
        return this;
      }
      angle = Math.PI;
      const xx = (m11 + 1) / 2;
      const yy = (m22 + 1) / 2;
      const zz = (m33 + 1) / 2;
      const xy = (m12 + m21) / 4;
      const xz = (m13 + m31) / 4;
      const yz = (m23 + m32) / 4;
      if (xx > yy && xx > zz) {
        if (xx < epsilon) {
          x3 = 0;
          y2 = 0.707106781;
          z = 0.707106781;
        } else {
          x3 = Math.sqrt(xx);
          y2 = xy / x3;
          z = xz / x3;
        }
      } else if (yy > zz) {
        if (yy < epsilon) {
          x3 = 0.707106781;
          y2 = 0;
          z = 0.707106781;
        } else {
          y2 = Math.sqrt(yy);
          x3 = xy / y2;
          z = yz / y2;
        }
      } else {
        if (zz < epsilon) {
          x3 = 0.707106781;
          y2 = 0.707106781;
          z = 0;
        } else {
          z = Math.sqrt(zz);
          x3 = xz / z;
          y2 = yz / z;
        }
      }
      this.set(x3, y2, z, angle);
      return this;
    }
    let s2 = Math.sqrt((m32 - m23) * (m32 - m23) + (m13 - m31) * (m13 - m31) + (m21 - m12) * (m21 - m12));
    if (Math.abs(s2) < 1e-3) s2 = 1;
    this.x = (m32 - m23) / s2;
    this.y = (m13 - m31) / s2;
    this.z = (m21 - m12) / s2;
    this.w = Math.acos((m11 + m22 + m33 - 1) / 2);
    return this;
  }
  min(v2) {
    this.x = Math.min(this.x, v2.x);
    this.y = Math.min(this.y, v2.y);
    this.z = Math.min(this.z, v2.z);
    this.w = Math.min(this.w, v2.w);
    return this;
  }
  max(v2) {
    this.x = Math.max(this.x, v2.x);
    this.y = Math.max(this.y, v2.y);
    this.z = Math.max(this.z, v2.z);
    this.w = Math.max(this.w, v2.w);
    return this;
  }
  clamp(min, max) {
    this.x = Math.max(min.x, Math.min(max.x, this.x));
    this.y = Math.max(min.y, Math.min(max.y, this.y));
    this.z = Math.max(min.z, Math.min(max.z, this.z));
    this.w = Math.max(min.w, Math.min(max.w, this.w));
    return this;
  }
  clampScalar(minVal, maxVal) {
    this.x = Math.max(minVal, Math.min(maxVal, this.x));
    this.y = Math.max(minVal, Math.min(maxVal, this.y));
    this.z = Math.max(minVal, Math.min(maxVal, this.z));
    this.w = Math.max(minVal, Math.min(maxVal, this.w));
    return this;
  }
  clampLength(min, max) {
    const length = this.length();
    return this.divideScalar(length || 1).multiplyScalar(Math.max(min, Math.min(max, length)));
  }
  floor() {
    this.x = Math.floor(this.x);
    this.y = Math.floor(this.y);
    this.z = Math.floor(this.z);
    this.w = Math.floor(this.w);
    return this;
  }
  ceil() {
    this.x = Math.ceil(this.x);
    this.y = Math.ceil(this.y);
    this.z = Math.ceil(this.z);
    this.w = Math.ceil(this.w);
    return this;
  }
  round() {
    this.x = Math.round(this.x);
    this.y = Math.round(this.y);
    this.z = Math.round(this.z);
    this.w = Math.round(this.w);
    return this;
  }
  roundToZero() {
    this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x);
    this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y);
    this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z);
    this.w = this.w < 0 ? Math.ceil(this.w) : Math.floor(this.w);
    return this;
  }
  negate() {
    this.x = -this.x;
    this.y = -this.y;
    this.z = -this.z;
    this.w = -this.w;
    return this;
  }
  dot(v2) {
    return this.x * v2.x + this.y * v2.y + this.z * v2.z + this.w * v2.w;
  }
  lengthSq() {
    return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;
  }
  length() {
    return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w);
  }
  manhattanLength() {
    return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z) + Math.abs(this.w);
  }
  normalize() {
    return this.divideScalar(this.length() || 1);
  }
  setLength(length) {
    return this.normalize().multiplyScalar(length);
  }
  lerp(v2, alpha) {
    this.x += (v2.x - this.x) * alpha;
    this.y += (v2.y - this.y) * alpha;
    this.z += (v2.z - this.z) * alpha;
    this.w += (v2.w - this.w) * alpha;
    return this;
  }
  lerpVectors(v1, v2, alpha) {
    this.x = v1.x + (v2.x - v1.x) * alpha;
    this.y = v1.y + (v2.y - v1.y) * alpha;
    this.z = v1.z + (v2.z - v1.z) * alpha;
    this.w = v1.w + (v2.w - v1.w) * alpha;
    return this;
  }
  equals(v2) {
    return v2.x === this.x && v2.y === this.y && v2.z === this.z && v2.w === this.w;
  }
  fromArray(array, offset = 0) {
    this.x = array[offset];
    this.y = array[offset + 1];
    this.z = array[offset + 2];
    this.w = array[offset + 3];
    return this;
  }
  toArray(array = [], offset = 0) {
    array[offset] = this.x;
    array[offset + 1] = this.y;
    array[offset + 2] = this.z;
    array[offset + 3] = this.w;
    return array;
  }
  fromBufferAttribute(attribute, index) {
    this.x = attribute.getX(index);
    this.y = attribute.getY(index);
    this.z = attribute.getZ(index);
    this.w = attribute.getW(index);
    return this;
  }
  random() {
    this.x = Math.random();
    this.y = Math.random();
    this.z = Math.random();
    this.w = Math.random();
    return this;
  }
  *[Symbol.iterator]() {
    yield this.x;
    yield this.y;
    yield this.z;
    yield this.w;
  }
};
var WebGLRenderTarget = class extends EventDispatcher {
  constructor(width = 1, height = 1, options2 = {}) {
    super();
    this.isWebGLRenderTarget = true;
    this.width = width;
    this.height = height;
    this.depth = 1;
    this.scissor = new Vector4(0, 0, width, height);
    this.scissorTest = false;
    this.viewport = new Vector4(0, 0, width, height);
    const image = { width, height, depth: 1 };
    if (options2.encoding !== void 0) {
      warnOnce("THREE.WebGLRenderTarget: option.encoding has been replaced by option.colorSpace.");
      options2.colorSpace = options2.encoding === sRGBEncoding ? SRGBColorSpace : NoColorSpace;
    }
    this.texture = new Texture(image, options2.mapping, options2.wrapS, options2.wrapT, options2.magFilter, options2.minFilter, options2.format, options2.type, options2.anisotropy, options2.colorSpace);
    this.texture.isRenderTargetTexture = true;
    this.texture.flipY = false;
    this.texture.generateMipmaps = options2.generateMipmaps !== void 0 ? options2.generateMipmaps : false;
    this.texture.internalFormat = options2.internalFormat !== void 0 ? options2.internalFormat : null;
    this.texture.minFilter = options2.minFilter !== void 0 ? options2.minFilter : LinearFilter;
    this.depthBuffer = options2.depthBuffer !== void 0 ? options2.depthBuffer : true;
    this.stencilBuffer = options2.stencilBuffer !== void 0 ? options2.stencilBuffer : false;
    this.depthTexture = options2.depthTexture !== void 0 ? options2.depthTexture : null;
    this.samples = options2.samples !== void 0 ? options2.samples : 0;
  }
  setSize(width, height, depth = 1) {
    if (this.width !== width || this.height !== height || this.depth !== depth) {
      this.width = width;
      this.height = height;
      this.depth = depth;
      this.texture.image.width = width;
      this.texture.image.height = height;
      this.texture.image.depth = depth;
      this.dispose();
    }
    this.viewport.set(0, 0, width, height);
    this.scissor.set(0, 0, width, height);
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(source) {
    this.width = source.width;
    this.height = source.height;
    this.depth = source.depth;
    this.scissor.copy(source.scissor);
    this.scissorTest = source.scissorTest;
    this.viewport.copy(source.viewport);
    this.texture = source.texture.clone();
    this.texture.isRenderTargetTexture = true;
    const image = Object.assign({}, source.texture.image);
    this.texture.source = new Source(image);
    this.depthBuffer = source.depthBuffer;
    this.stencilBuffer = source.stencilBuffer;
    if (source.depthTexture !== null) this.depthTexture = source.depthTexture.clone();
    this.samples = source.samples;
    return this;
  }
  dispose() {
    this.dispatchEvent({ type: "dispose" });
  }
};
var DataArrayTexture = class extends Texture {
  constructor(data = null, width = 1, height = 1, depth = 1) {
    super(null);
    this.isDataArrayTexture = true;
    this.image = { data, width, height, depth };
    this.magFilter = NearestFilter;
    this.minFilter = NearestFilter;
    this.wrapR = ClampToEdgeWrapping;
    this.generateMipmaps = false;
    this.flipY = false;
    this.unpackAlignment = 1;
  }
};
var WebGLArrayRenderTarget = class extends WebGLRenderTarget {
  constructor(width = 1, height = 1, depth = 1) {
    super(width, height);
    this.isWebGLArrayRenderTarget = true;
    this.depth = depth;
    this.texture = new DataArrayTexture(null, width, height, depth);
    this.texture.isRenderTargetTexture = true;
  }
};
var Data3DTexture = class extends Texture {
  constructor(data = null, width = 1, height = 1, depth = 1) {
    super(null);
    this.isData3DTexture = true;
    this.image = { data, width, height, depth };
    this.magFilter = NearestFilter;
    this.minFilter = NearestFilter;
    this.wrapR = ClampToEdgeWrapping;
    this.generateMipmaps = false;
    this.flipY = false;
    this.unpackAlignment = 1;
  }
};
var WebGL3DRenderTarget = class extends WebGLRenderTarget {
  constructor(width = 1, height = 1, depth = 1) {
    super(width, height);
    this.isWebGL3DRenderTarget = true;
    this.depth = depth;
    this.texture = new Data3DTexture(null, width, height, depth);
    this.texture.isRenderTargetTexture = true;
  }
};
var WebGLMultipleRenderTargets = class extends WebGLRenderTarget {
  constructor(width = 1, height = 1, count = 1, options2 = {}) {
    super(width, height, options2);
    this.isWebGLMultipleRenderTargets = true;
    const texture = this.texture;
    this.texture = [];
    for (let i2 = 0; i2 < count; i2++) {
      this.texture[i2] = texture.clone();
      this.texture[i2].isRenderTargetTexture = true;
    }
  }
  setSize(width, height, depth = 1) {
    if (this.width !== width || this.height !== height || this.depth !== depth) {
      this.width = width;
      this.height = height;
      this.depth = depth;
      for (let i2 = 0, il = this.texture.length; i2 < il; i2++) {
        this.texture[i2].image.width = width;
        this.texture[i2].image.height = height;
        this.texture[i2].image.depth = depth;
      }
      this.dispose();
    }
    this.viewport.set(0, 0, width, height);
    this.scissor.set(0, 0, width, height);
    return this;
  }
  copy(source) {
    this.dispose();
    this.width = source.width;
    this.height = source.height;
    this.depth = source.depth;
    this.scissor.copy(source.scissor);
    this.scissorTest = source.scissorTest;
    this.viewport.copy(source.viewport);
    this.depthBuffer = source.depthBuffer;
    this.stencilBuffer = source.stencilBuffer;
    if (source.depthTexture !== null) this.depthTexture = source.depthTexture.clone();
    this.texture.length = 0;
    for (let i2 = 0, il = source.texture.length; i2 < il; i2++) {
      this.texture[i2] = source.texture[i2].clone();
      this.texture[i2].isRenderTargetTexture = true;
    }
    return this;
  }
};
var Quaternion = class {
  constructor(x3 = 0, y2 = 0, z = 0, w2 = 1) {
    this.isQuaternion = true;
    this._x = x3;
    this._y = y2;
    this._z = z;
    this._w = w2;
  }
  static slerpFlat(dst, dstOffset, src0, srcOffset0, src1, srcOffset1, t2) {
    let x0 = src0[srcOffset0 + 0], y0 = src0[srcOffset0 + 1], z0 = src0[srcOffset0 + 2], w0 = src0[srcOffset0 + 3];
    const x1 = src1[srcOffset1 + 0], y1 = src1[srcOffset1 + 1], z1 = src1[srcOffset1 + 2], w1 = src1[srcOffset1 + 3];
    if (t2 === 0) {
      dst[dstOffset + 0] = x0;
      dst[dstOffset + 1] = y0;
      dst[dstOffset + 2] = z0;
      dst[dstOffset + 3] = w0;
      return;
    }
    if (t2 === 1) {
      dst[dstOffset + 0] = x1;
      dst[dstOffset + 1] = y1;
      dst[dstOffset + 2] = z1;
      dst[dstOffset + 3] = w1;
      return;
    }
    if (w0 !== w1 || x0 !== x1 || y0 !== y1 || z0 !== z1) {
      let s2 = 1 - t2;
      const cos = x0 * x1 + y0 * y1 + z0 * z1 + w0 * w1, dir = cos >= 0 ? 1 : -1, sqrSin = 1 - cos * cos;
      if (sqrSin > Number.EPSILON) {
        const sin = Math.sqrt(sqrSin), len = Math.atan2(sin, cos * dir);
        s2 = Math.sin(s2 * len) / sin;
        t2 = Math.sin(t2 * len) / sin;
      }
      const tDir = t2 * dir;
      x0 = x0 * s2 + x1 * tDir;
      y0 = y0 * s2 + y1 * tDir;
      z0 = z0 * s2 + z1 * tDir;
      w0 = w0 * s2 + w1 * tDir;
      if (s2 === 1 - t2) {
        const f2 = 1 / Math.sqrt(x0 * x0 + y0 * y0 + z0 * z0 + w0 * w0);
        x0 *= f2;
        y0 *= f2;
        z0 *= f2;
        w0 *= f2;
      }
    }
    dst[dstOffset] = x0;
    dst[dstOffset + 1] = y0;
    dst[dstOffset + 2] = z0;
    dst[dstOffset + 3] = w0;
  }
  static multiplyQuaternionsFlat(dst, dstOffset, src0, srcOffset0, src1, srcOffset1) {
    const x0 = src0[srcOffset0];
    const y0 = src0[srcOffset0 + 1];
    const z0 = src0[srcOffset0 + 2];
    const w0 = src0[srcOffset0 + 3];
    const x1 = src1[srcOffset1];
    const y1 = src1[srcOffset1 + 1];
    const z1 = src1[srcOffset1 + 2];
    const w1 = src1[srcOffset1 + 3];
    dst[dstOffset] = x0 * w1 + w0 * x1 + y0 * z1 - z0 * y1;
    dst[dstOffset + 1] = y0 * w1 + w0 * y1 + z0 * x1 - x0 * z1;
    dst[dstOffset + 2] = z0 * w1 + w0 * z1 + x0 * y1 - y0 * x1;
    dst[dstOffset + 3] = w0 * w1 - x0 * x1 - y0 * y1 - z0 * z1;
    return dst;
  }
  get x() {
    return this._x;
  }
  set x(value) {
    this._x = value;
    this._onChangeCallback();
  }
  get y() {
    return this._y;
  }
  set y(value) {
    this._y = value;
    this._onChangeCallback();
  }
  get z() {
    return this._z;
  }
  set z(value) {
    this._z = value;
    this._onChangeCallback();
  }
  get w() {
    return this._w;
  }
  set w(value) {
    this._w = value;
    this._onChangeCallback();
  }
  set(x3, y2, z, w2) {
    this._x = x3;
    this._y = y2;
    this._z = z;
    this._w = w2;
    this._onChangeCallback();
    return this;
  }
  clone() {
    return new this.constructor(this._x, this._y, this._z, this._w);
  }
  copy(quaternion2) {
    this._x = quaternion2.x;
    this._y = quaternion2.y;
    this._z = quaternion2.z;
    this._w = quaternion2.w;
    this._onChangeCallback();
    return this;
  }
  setFromEuler(euler, update) {
    const x3 = euler._x, y2 = euler._y, z = euler._z, order = euler._order;
    const cos = Math.cos;
    const sin = Math.sin;
    const c1 = cos(x3 / 2);
    const c2 = cos(y2 / 2);
    const c3 = cos(z / 2);
    const s1 = sin(x3 / 2);
    const s2 = sin(y2 / 2);
    const s3 = sin(z / 2);
    switch (order) {
      case "XYZ":
        this._x = s1 * c2 * c3 + c1 * s2 * s3;
        this._y = c1 * s2 * c3 - s1 * c2 * s3;
        this._z = c1 * c2 * s3 + s1 * s2 * c3;
        this._w = c1 * c2 * c3 - s1 * s2 * s3;
        break;
      case "YXZ":
        this._x = s1 * c2 * c3 + c1 * s2 * s3;
        this._y = c1 * s2 * c3 - s1 * c2 * s3;
        this._z = c1 * c2 * s3 - s1 * s2 * c3;
        this._w = c1 * c2 * c3 + s1 * s2 * s3;
        break;
      case "ZXY":
        this._x = s1 * c2 * c3 - c1 * s2 * s3;
        this._y = c1 * s2 * c3 + s1 * c2 * s3;
        this._z = c1 * c2 * s3 + s1 * s2 * c3;
        this._w = c1 * c2 * c3 - s1 * s2 * s3;
        break;
      case "ZYX":
        this._x = s1 * c2 * c3 - c1 * s2 * s3;
        this._y = c1 * s2 * c3 + s1 * c2 * s3;
        this._z = c1 * c2 * s3 - s1 * s2 * c3;
        this._w = c1 * c2 * c3 + s1 * s2 * s3;
        break;
      case "YZX":
        this._x = s1 * c2 * c3 + c1 * s2 * s3;
        this._y = c1 * s2 * c3 + s1 * c2 * s3;
        this._z = c1 * c2 * s3 - s1 * s2 * c3;
        this._w = c1 * c2 * c3 - s1 * s2 * s3;
        break;
      case "XZY":
        this._x = s1 * c2 * c3 - c1 * s2 * s3;
        this._y = c1 * s2 * c3 - s1 * c2 * s3;
        this._z = c1 * c2 * s3 + s1 * s2 * c3;
        this._w = c1 * c2 * c3 + s1 * s2 * s3;
        break;
      default:
        console.warn("THREE.Quaternion: .setFromEuler() encountered an unknown order: " + order);
    }
    if (update !== false) this._onChangeCallback();
    return this;
  }
  setFromAxisAngle(axis, angle) {
    const halfAngle = angle / 2, s2 = Math.sin(halfAngle);
    this._x = axis.x * s2;
    this._y = axis.y * s2;
    this._z = axis.z * s2;
    this._w = Math.cos(halfAngle);
    this._onChangeCallback();
    return this;
  }
  setFromRotationMatrix(m2) {
    const te = m2.elements, m11 = te[0], m12 = te[4], m13 = te[8], m21 = te[1], m22 = te[5], m23 = te[9], m31 = te[2], m32 = te[6], m33 = te[10], trace = m11 + m22 + m33;
    if (trace > 0) {
      const s2 = 0.5 / Math.sqrt(trace + 1);
      this._w = 0.25 / s2;
      this._x = (m32 - m23) * s2;
      this._y = (m13 - m31) * s2;
      this._z = (m21 - m12) * s2;
    } else if (m11 > m22 && m11 > m33) {
      const s2 = 2 * Math.sqrt(1 + m11 - m22 - m33);
      this._w = (m32 - m23) / s2;
      this._x = 0.25 * s2;
      this._y = (m12 + m21) / s2;
      this._z = (m13 + m31) / s2;
    } else if (m22 > m33) {
      const s2 = 2 * Math.sqrt(1 + m22 - m11 - m33);
      this._w = (m13 - m31) / s2;
      this._x = (m12 + m21) / s2;
      this._y = 0.25 * s2;
      this._z = (m23 + m32) / s2;
    } else {
      const s2 = 2 * Math.sqrt(1 + m33 - m11 - m22);
      this._w = (m21 - m12) / s2;
      this._x = (m13 + m31) / s2;
      this._y = (m23 + m32) / s2;
      this._z = 0.25 * s2;
    }
    this._onChangeCallback();
    return this;
  }
  setFromUnitVectors(vFrom, vTo) {
    let r2 = vFrom.dot(vTo) + 1;
    if (r2 < Number.EPSILON) {
      r2 = 0;
      if (Math.abs(vFrom.x) > Math.abs(vFrom.z)) {
        this._x = -vFrom.y;
        this._y = vFrom.x;
        this._z = 0;
        this._w = r2;
      } else {
        this._x = 0;
        this._y = -vFrom.z;
        this._z = vFrom.y;
        this._w = r2;
      }
    } else {
      this._x = vFrom.y * vTo.z - vFrom.z * vTo.y;
      this._y = vFrom.z * vTo.x - vFrom.x * vTo.z;
      this._z = vFrom.x * vTo.y - vFrom.y * vTo.x;
      this._w = r2;
    }
    return this.normalize();
  }
  angleTo(q) {
    return 2 * Math.acos(Math.abs(clamp(this.dot(q), -1, 1)));
  }
  rotateTowards(q, step) {
    const angle = this.angleTo(q);
    if (angle === 0) return this;
    const t2 = Math.min(1, step / angle);
    this.slerp(q, t2);
    return this;
  }
  identity() {
    return this.set(0, 0, 0, 1);
  }
  invert() {
    return this.conjugate();
  }
  conjugate() {
    this._x *= -1;
    this._y *= -1;
    this._z *= -1;
    this._onChangeCallback();
    return this;
  }
  dot(v2) {
    return this._x * v2._x + this._y * v2._y + this._z * v2._z + this._w * v2._w;
  }
  lengthSq() {
    return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w;
  }
  length() {
    return Math.sqrt(this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w);
  }
  normalize() {
    let l2 = this.length();
    if (l2 === 0) {
      this._x = 0;
      this._y = 0;
      this._z = 0;
      this._w = 1;
    } else {
      l2 = 1 / l2;
      this._x = this._x * l2;
      this._y = this._y * l2;
      this._z = this._z * l2;
      this._w = this._w * l2;
    }
    this._onChangeCallback();
    return this;
  }
  multiply(q) {
    return this.multiplyQuaternions(this, q);
  }
  premultiply(q) {
    return this.multiplyQuaternions(q, this);
  }
  multiplyQuaternions(a2, b2) {
    const qax = a2._x, qay = a2._y, qaz = a2._z, qaw = a2._w;
    const qbx = b2._x, qby = b2._y, qbz = b2._z, qbw = b2._w;
    this._x = qax * qbw + qaw * qbx + qay * qbz - qaz * qby;
    this._y = qay * qbw + qaw * qby + qaz * qbx - qax * qbz;
    this._z = qaz * qbw + qaw * qbz + qax * qby - qay * qbx;
    this._w = qaw * qbw - qax * qbx - qay * qby - qaz * qbz;
    this._onChangeCallback();
    return this;
  }
  slerp(qb, t2) {
    if (t2 === 0) return this;
    if (t2 === 1) return this.copy(qb);
    const x3 = this._x, y2 = this._y, z = this._z, w2 = this._w;
    let cosHalfTheta = w2 * qb._w + x3 * qb._x + y2 * qb._y + z * qb._z;
    if (cosHalfTheta < 0) {
      this._w = -qb._w;
      this._x = -qb._x;
      this._y = -qb._y;
      this._z = -qb._z;
      cosHalfTheta = -cosHalfTheta;
    } else {
      this.copy(qb);
    }
    if (cosHalfTheta >= 1) {
      this._w = w2;
      this._x = x3;
      this._y = y2;
      this._z = z;
      return this;
    }
    const sqrSinHalfTheta = 1 - cosHalfTheta * cosHalfTheta;
    if (sqrSinHalfTheta <= Number.EPSILON) {
      const s2 = 1 - t2;
      this._w = s2 * w2 + t2 * this._w;
      this._x = s2 * x3 + t2 * this._x;
      this._y = s2 * y2 + t2 * this._y;
      this._z = s2 * z + t2 * this._z;
      this.normalize();
      this._onChangeCallback();
      return this;
    }
    const sinHalfTheta = Math.sqrt(sqrSinHalfTheta);
    const halfTheta = Math.atan2(sinHalfTheta, cosHalfTheta);
    const ratioA = Math.sin((1 - t2) * halfTheta) / sinHalfTheta, ratioB = Math.sin(t2 * halfTheta) / sinHalfTheta;
    this._w = w2 * ratioA + this._w * ratioB;
    this._x = x3 * ratioA + this._x * ratioB;
    this._y = y2 * ratioA + this._y * ratioB;
    this._z = z * ratioA + this._z * ratioB;
    this._onChangeCallback();
    return this;
  }
  slerpQuaternions(qa, qb, t2) {
    return this.copy(qa).slerp(qb, t2);
  }
  random() {
    const u1 = Math.random();
    const sqrt1u1 = Math.sqrt(1 - u1);
    const sqrtu1 = Math.sqrt(u1);
    const u2 = 2 * Math.PI * Math.random();
    const u3 = 2 * Math.PI * Math.random();
    return this.set(
      sqrt1u1 * Math.cos(u2),
      sqrtu1 * Math.sin(u3),
      sqrtu1 * Math.cos(u3),
      sqrt1u1 * Math.sin(u2)
    );
  }
  equals(quaternion2) {
    return quaternion2._x === this._x && quaternion2._y === this._y && quaternion2._z === this._z && quaternion2._w === this._w;
  }
  fromArray(array, offset = 0) {
    this._x = array[offset];
    this._y = array[offset + 1];
    this._z = array[offset + 2];
    this._w = array[offset + 3];
    this._onChangeCallback();
    return this;
  }
  toArray(array = [], offset = 0) {
    array[offset] = this._x;
    array[offset + 1] = this._y;
    array[offset + 2] = this._z;
    array[offset + 3] = this._w;
    return array;
  }
  fromBufferAttribute(attribute, index) {
    this._x = attribute.getX(index);
    this._y = attribute.getY(index);
    this._z = attribute.getZ(index);
    this._w = attribute.getW(index);
    return this;
  }
  toJSON() {
    return this.toArray();
  }
  _onChange(callback) {
    this._onChangeCallback = callback;
    return this;
  }
  _onChangeCallback() {
  }
  *[Symbol.iterator]() {
    yield this._x;
    yield this._y;
    yield this._z;
    yield this._w;
  }
};
var Vector3 = class _Vector3 {
  constructor(x3 = 0, y2 = 0, z = 0) {
    _Vector3.prototype.isVector3 = true;
    this.x = x3;
    this.y = y2;
    this.z = z;
  }
  set(x3, y2, z) {
    if (z === void 0) z = this.z;
    this.x = x3;
    this.y = y2;
    this.z = z;
    return this;
  }
  setScalar(scalar) {
    this.x = scalar;
    this.y = scalar;
    this.z = scalar;
    return this;
  }
  setX(x3) {
    this.x = x3;
    return this;
  }
  setY(y2) {
    this.y = y2;
    return this;
  }
  setZ(z) {
    this.z = z;
    return this;
  }
  setComponent(index, value) {
    switch (index) {
      case 0:
        this.x = value;
        break;
      case 1:
        this.y = value;
        break;
      case 2:
        this.z = value;
        break;
      default:
        throw new Error("index is out of range: " + index);
    }
    return this;
  }
  getComponent(index) {
    switch (index) {
      case 0:
        return this.x;
      case 1:
        return this.y;
      case 2:
        return this.z;
      default:
        throw new Error("index is out of range: " + index);
    }
  }
  clone() {
    return new this.constructor(this.x, this.y, this.z);
  }
  copy(v2) {
    this.x = v2.x;
    this.y = v2.y;
    this.z = v2.z;
    return this;
  }
  add(v2) {
    this.x += v2.x;
    this.y += v2.y;
    this.z += v2.z;
    return this;
  }
  addScalar(s2) {
    this.x += s2;
    this.y += s2;
    this.z += s2;
    return this;
  }
  addVectors(a2, b2) {
    this.x = a2.x + b2.x;
    this.y = a2.y + b2.y;
    this.z = a2.z + b2.z;
    return this;
  }
  addScaledVector(v2, s2) {
    this.x += v2.x * s2;
    this.y += v2.y * s2;
    this.z += v2.z * s2;
    return this;
  }
  sub(v2) {
    this.x -= v2.x;
    this.y -= v2.y;
    this.z -= v2.z;
    return this;
  }
  subScalar(s2) {
    this.x -= s2;
    this.y -= s2;
    this.z -= s2;
    return this;
  }
  subVectors(a2, b2) {
    this.x = a2.x - b2.x;
    this.y = a2.y - b2.y;
    this.z = a2.z - b2.z;
    return this;
  }
  multiply(v2) {
    this.x *= v2.x;
    this.y *= v2.y;
    this.z *= v2.z;
    return this;
  }
  multiplyScalar(scalar) {
    this.x *= scalar;
    this.y *= scalar;
    this.z *= scalar;
    return this;
  }
  multiplyVectors(a2, b2) {
    this.x = a2.x * b2.x;
    this.y = a2.y * b2.y;
    this.z = a2.z * b2.z;
    return this;
  }
  applyEuler(euler) {
    return this.applyQuaternion(_quaternion$4.setFromEuler(euler));
  }
  applyAxisAngle(axis, angle) {
    return this.applyQuaternion(_quaternion$4.setFromAxisAngle(axis, angle));
  }
  applyMatrix3(m2) {
    const x3 = this.x, y2 = this.y, z = this.z;
    const e2 = m2.elements;
    this.x = e2[0] * x3 + e2[3] * y2 + e2[6] * z;
    this.y = e2[1] * x3 + e2[4] * y2 + e2[7] * z;
    this.z = e2[2] * x3 + e2[5] * y2 + e2[8] * z;
    return this;
  }
  applyNormalMatrix(m2) {
    return this.applyMatrix3(m2).normalize();
  }
  applyMatrix4(m2) {
    const x3 = this.x, y2 = this.y, z = this.z;
    const e2 = m2.elements;
    const w2 = 1 / (e2[3] * x3 + e2[7] * y2 + e2[11] * z + e2[15]);
    this.x = (e2[0] * x3 + e2[4] * y2 + e2[8] * z + e2[12]) * w2;
    this.y = (e2[1] * x3 + e2[5] * y2 + e2[9] * z + e2[13]) * w2;
    this.z = (e2[2] * x3 + e2[6] * y2 + e2[10] * z + e2[14]) * w2;
    return this;
  }
  applyQuaternion(q) {
    const x3 = this.x, y2 = this.y, z = this.z;
    const qx = q.x, qy = q.y, qz = q.z, qw = q.w;
    const ix = qw * x3 + qy * z - qz * y2;
    const iy = qw * y2 + qz * x3 - qx * z;
    const iz = qw * z + qx * y2 - qy * x3;
    const iw = -qx * x3 - qy * y2 - qz * z;
    this.x = ix * qw + iw * -qx + iy * -qz - iz * -qy;
    this.y = iy * qw + iw * -qy + iz * -qx - ix * -qz;
    this.z = iz * qw + iw * -qz + ix * -qy - iy * -qx;
    return this;
  }
  project(camera) {
    return this.applyMatrix4(camera.matrixWorldInverse).applyMatrix4(camera.projectionMatrix);
  }
  unproject(camera) {
    return this.applyMatrix4(camera.projectionMatrixInverse).applyMatrix4(camera.matrixWorld);
  }
  transformDirection(m2) {
    const x3 = this.x, y2 = this.y, z = this.z;
    const e2 = m2.elements;
    this.x = e2[0] * x3 + e2[4] * y2 + e2[8] * z;
    this.y = e2[1] * x3 + e2[5] * y2 + e2[9] * z;
    this.z = e2[2] * x3 + e2[6] * y2 + e2[10] * z;
    return this.normalize();
  }
  divide(v2) {
    this.x /= v2.x;
    this.y /= v2.y;
    this.z /= v2.z;
    return this;
  }
  divideScalar(scalar) {
    return this.multiplyScalar(1 / scalar);
  }
  min(v2) {
    this.x = Math.min(this.x, v2.x);
    this.y = Math.min(this.y, v2.y);
    this.z = Math.min(this.z, v2.z);
    return this;
  }
  max(v2) {
    this.x = Math.max(this.x, v2.x);
    this.y = Math.max(this.y, v2.y);
    this.z = Math.max(this.z, v2.z);
    return this;
  }
  clamp(min, max) {
    this.x = Math.max(min.x, Math.min(max.x, this.x));
    this.y = Math.max(min.y, Math.min(max.y, this.y));
    this.z = Math.max(min.z, Math.min(max.z, this.z));
    return this;
  }
  clampScalar(minVal, maxVal) {
    this.x = Math.max(minVal, Math.min(maxVal, this.x));
    this.y = Math.max(minVal, Math.min(maxVal, this.y));
    this.z = Math.max(minVal, Math.min(maxVal, this.z));
    return this;
  }
  clampLength(min, max) {
    const length = this.length();
    return this.divideScalar(length || 1).multiplyScalar(Math.max(min, Math.min(max, length)));
  }
  floor() {
    this.x = Math.floor(this.x);
    this.y = Math.floor(this.y);
    this.z = Math.floor(this.z);
    return this;
  }
  ceil() {
    this.x = Math.ceil(this.x);
    this.y = Math.ceil(this.y);
    this.z = Math.ceil(this.z);
    return this;
  }
  round() {
    this.x = Math.round(this.x);
    this.y = Math.round(this.y);
    this.z = Math.round(this.z);
    return this;
  }
  roundToZero() {
    this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x);
    this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y);
    this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z);
    return this;
  }
  negate() {
    this.x = -this.x;
    this.y = -this.y;
    this.z = -this.z;
    return this;
  }
  dot(v2) {
    return this.x * v2.x + this.y * v2.y + this.z * v2.z;
  }
  // TODO lengthSquared?
  lengthSq() {
    return this.x * this.x + this.y * this.y + this.z * this.z;
  }
  length() {
    return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);
  }
  manhattanLength() {
    return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z);
  }
  normalize() {
    return this.divideScalar(this.length() || 1);
  }
  setLength(length) {
    return this.normalize().multiplyScalar(length);
  }
  lerp(v2, alpha) {
    this.x += (v2.x - this.x) * alpha;
    this.y += (v2.y - this.y) * alpha;
    this.z += (v2.z - this.z) * alpha;
    return this;
  }
  lerpVectors(v1, v2, alpha) {
    this.x = v1.x + (v2.x - v1.x) * alpha;
    this.y = v1.y + (v2.y - v1.y) * alpha;
    this.z = v1.z + (v2.z - v1.z) * alpha;
    return this;
  }
  cross(v2) {
    return this.crossVectors(this, v2);
  }
  crossVectors(a2, b2) {
    const ax = a2.x, ay = a2.y, az = a2.z;
    const bx = b2.x, by = b2.y, bz = b2.z;
    this.x = ay * bz - az * by;
    this.y = az * bx - ax * bz;
    this.z = ax * by - ay * bx;
    return this;
  }
  projectOnVector(v2) {
    const denominator = v2.lengthSq();
    if (denominator === 0) return this.set(0, 0, 0);
    const scalar = v2.dot(this) / denominator;
    return this.copy(v2).multiplyScalar(scalar);
  }
  projectOnPlane(planeNormal) {
    _vector$b.copy(this).projectOnVector(planeNormal);
    return this.sub(_vector$b);
  }
  reflect(normal) {
    return this.sub(_vector$b.copy(normal).multiplyScalar(2 * this.dot(normal)));
  }
  angleTo(v2) {
    const denominator = Math.sqrt(this.lengthSq() * v2.lengthSq());
    if (denominator === 0) return Math.PI / 2;
    const theta = this.dot(v2) / denominator;
    return Math.acos(clamp(theta, -1, 1));
  }
  distanceTo(v2) {
    return Math.sqrt(this.distanceToSquared(v2));
  }
  distanceToSquared(v2) {
    const dx = this.x - v2.x, dy = this.y - v2.y, dz = this.z - v2.z;
    return dx * dx + dy * dy + dz * dz;
  }
  manhattanDistanceTo(v2) {
    return Math.abs(this.x - v2.x) + Math.abs(this.y - v2.y) + Math.abs(this.z - v2.z);
  }
  setFromSpherical(s2) {
    return this.setFromSphericalCoords(s2.radius, s2.phi, s2.theta);
  }
  setFromSphericalCoords(radius, phi, theta) {
    const sinPhiRadius = Math.sin(phi) * radius;
    this.x = sinPhiRadius * Math.sin(theta);
    this.y = Math.cos(phi) * radius;
    this.z = sinPhiRadius * Math.cos(theta);
    return this;
  }
  setFromCylindrical(c2) {
    return this.setFromCylindricalCoords(c2.radius, c2.theta, c2.y);
  }
  setFromCylindricalCoords(radius, theta, y2) {
    this.x = radius * Math.sin(theta);
    this.y = y2;
    this.z = radius * Math.cos(theta);
    return this;
  }
  setFromMatrixPosition(m2) {
    const e2 = m2.elements;
    this.x = e2[12];
    this.y = e2[13];
    this.z = e2[14];
    return this;
  }
  setFromMatrixScale(m2) {
    const sx = this.setFromMatrixColumn(m2, 0).length();
    const sy = this.setFromMatrixColumn(m2, 1).length();
    const sz = this.setFromMatrixColumn(m2, 2).length();
    this.x = sx;
    this.y = sy;
    this.z = sz;
    return this;
  }
  setFromMatrixColumn(m2, index) {
    return this.fromArray(m2.elements, index * 4);
  }
  setFromMatrix3Column(m2, index) {
    return this.fromArray(m2.elements, index * 3);
  }
  setFromEuler(e2) {
    this.x = e2._x;
    this.y = e2._y;
    this.z = e2._z;
    return this;
  }
  setFromColor(c2) {
    this.x = c2.r;
    this.y = c2.g;
    this.z = c2.b;
    return this;
  }
  equals(v2) {
    return v2.x === this.x && v2.y === this.y && v2.z === this.z;
  }
  fromArray(array, offset = 0) {
    this.x = array[offset];
    this.y = array[offset + 1];
    this.z = array[offset + 2];
    return this;
  }
  toArray(array = [], offset = 0) {
    array[offset] = this.x;
    array[offset + 1] = this.y;
    array[offset + 2] = this.z;
    return array;
  }
  fromBufferAttribute(attribute, index) {
    this.x = attribute.getX(index);
    this.y = attribute.getY(index);
    this.z = attribute.getZ(index);
    return this;
  }
  random() {
    this.x = Math.random();
    this.y = Math.random();
    this.z = Math.random();
    return this;
  }
  randomDirection() {
    const u2 = (Math.random() - 0.5) * 2;
    const t2 = Math.random() * Math.PI * 2;
    const f2 = Math.sqrt(1 - u2 ** 2);
    this.x = f2 * Math.cos(t2);
    this.y = f2 * Math.sin(t2);
    this.z = u2;
    return this;
  }
  *[Symbol.iterator]() {
    yield this.x;
    yield this.y;
    yield this.z;
  }
};
var _vector$b = new Vector3();
var _quaternion$4 = new Quaternion();
var Box3 = class {
  constructor(min = new Vector3(Infinity, Infinity, Infinity), max = new Vector3(-Infinity, -Infinity, -Infinity)) {
    this.isBox3 = true;
    this.min = min;
    this.max = max;
  }
  set(min, max) {
    this.min.copy(min);
    this.max.copy(max);
    return this;
  }
  setFromArray(array) {
    this.makeEmpty();
    for (let i2 = 0, il = array.length; i2 < il; i2 += 3) {
      this.expandByPoint(_vector$a.fromArray(array, i2));
    }
    return this;
  }
  setFromBufferAttribute(attribute) {
    this.makeEmpty();
    for (let i2 = 0, il = attribute.count; i2 < il; i2++) {
      this.expandByPoint(_vector$a.fromBufferAttribute(attribute, i2));
    }
    return this;
  }
  setFromPoints(points) {
    this.makeEmpty();
    for (let i2 = 0, il = points.length; i2 < il; i2++) {
      this.expandByPoint(points[i2]);
    }
    return this;
  }
  setFromCenterAndSize(center, size) {
    const halfSize = _vector$a.copy(size).multiplyScalar(0.5);
    this.min.copy(center).sub(halfSize);
    this.max.copy(center).add(halfSize);
    return this;
  }
  setFromObject(object, precise = false) {
    this.makeEmpty();
    return this.expandByObject(object, precise);
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(box) {
    this.min.copy(box.min);
    this.max.copy(box.max);
    return this;
  }
  makeEmpty() {
    this.min.x = this.min.y = this.min.z = Infinity;
    this.max.x = this.max.y = this.max.z = -Infinity;
    return this;
  }
  isEmpty() {
    return this.max.x < this.min.x || this.max.y < this.min.y || this.max.z < this.min.z;
  }
  getCenter(target) {
    return this.isEmpty() ? target.set(0, 0, 0) : target.addVectors(this.min, this.max).multiplyScalar(0.5);
  }
  getSize(target) {
    return this.isEmpty() ? target.set(0, 0, 0) : target.subVectors(this.max, this.min);
  }
  expandByPoint(point) {
    this.min.min(point);
    this.max.max(point);
    return this;
  }
  expandByVector(vector) {
    this.min.sub(vector);
    this.max.add(vector);
    return this;
  }
  expandByScalar(scalar) {
    this.min.addScalar(-scalar);
    this.max.addScalar(scalar);
    return this;
  }
  expandByObject(object, precise = false) {
    object.updateWorldMatrix(false, false);
    if (object.boundingBox !== void 0) {
      if (object.boundingBox === null) {
        object.computeBoundingBox();
      }
      _box$3.copy(object.boundingBox);
      _box$3.applyMatrix4(object.matrixWorld);
      this.union(_box$3);
    } else {
      const geometry = object.geometry;
      if (geometry !== void 0) {
        if (precise && geometry.attributes !== void 0 && geometry.attributes.position !== void 0) {
          const position = geometry.attributes.position;
          for (let i2 = 0, l2 = position.count; i2 < l2; i2++) {
            _vector$a.fromBufferAttribute(position, i2).applyMatrix4(object.matrixWorld);
            this.expandByPoint(_vector$a);
          }
        } else {
          if (geometry.boundingBox === null) {
            geometry.computeBoundingBox();
          }
          _box$3.copy(geometry.boundingBox);
          _box$3.applyMatrix4(object.matrixWorld);
          this.union(_box$3);
        }
      }
    }
    const children = object.children;
    for (let i2 = 0, l2 = children.length; i2 < l2; i2++) {
      this.expandByObject(children[i2], precise);
    }
    return this;
  }
  containsPoint(point) {
    return point.x < this.min.x || point.x > this.max.x || point.y < this.min.y || point.y > this.max.y || point.z < this.min.z || point.z > this.max.z ? false : true;
  }
  containsBox(box) {
    return this.min.x <= box.min.x && box.max.x <= this.max.x && this.min.y <= box.min.y && box.max.y <= this.max.y && this.min.z <= box.min.z && box.max.z <= this.max.z;
  }
  getParameter(point, target) {
    return target.set(
      (point.x - this.min.x) / (this.max.x - this.min.x),
      (point.y - this.min.y) / (this.max.y - this.min.y),
      (point.z - this.min.z) / (this.max.z - this.min.z)
    );
  }
  intersectsBox(box) {
    return box.max.x < this.min.x || box.min.x > this.max.x || box.max.y < this.min.y || box.min.y > this.max.y || box.max.z < this.min.z || box.min.z > this.max.z ? false : true;
  }
  intersectsSphere(sphere) {
    this.clampPoint(sphere.center, _vector$a);
    return _vector$a.distanceToSquared(sphere.center) <= sphere.radius * sphere.radius;
  }
  intersectsPlane(plane) {
    let min, max;
    if (plane.normal.x > 0) {
      min = plane.normal.x * this.min.x;
      max = plane.normal.x * this.max.x;
    } else {
      min = plane.normal.x * this.max.x;
      max = plane.normal.x * this.min.x;
    }
    if (plane.normal.y > 0) {
      min += plane.normal.y * this.min.y;
      max += plane.normal.y * this.max.y;
    } else {
      min += plane.normal.y * this.max.y;
      max += plane.normal.y * this.min.y;
    }
    if (plane.normal.z > 0) {
      min += plane.normal.z * this.min.z;
      max += plane.normal.z * this.max.z;
    } else {
      min += plane.normal.z * this.max.z;
      max += plane.normal.z * this.min.z;
    }
    return min <= -plane.constant && max >= -plane.constant;
  }
  intersectsTriangle(triangle) {
    if (this.isEmpty()) {
      return false;
    }
    this.getCenter(_center);
    _extents.subVectors(this.max, _center);
    _v0$2.subVectors(triangle.a, _center);
    _v1$7.subVectors(triangle.b, _center);
    _v2$4.subVectors(triangle.c, _center);
    _f0.subVectors(_v1$7, _v0$2);
    _f1.subVectors(_v2$4, _v1$7);
    _f2.subVectors(_v0$2, _v2$4);
    let axes = [
      0,
      -_f0.z,
      _f0.y,
      0,
      -_f1.z,
      _f1.y,
      0,
      -_f2.z,
      _f2.y,
      _f0.z,
      0,
      -_f0.x,
      _f1.z,
      0,
      -_f1.x,
      _f2.z,
      0,
      -_f2.x,
      -_f0.y,
      _f0.x,
      0,
      -_f1.y,
      _f1.x,
      0,
      -_f2.y,
      _f2.x,
      0
    ];
    if (!satForAxes(axes, _v0$2, _v1$7, _v2$4, _extents)) {
      return false;
    }
    axes = [1, 0, 0, 0, 1, 0, 0, 0, 1];
    if (!satForAxes(axes, _v0$2, _v1$7, _v2$4, _extents)) {
      return false;
    }
    _triangleNormal.crossVectors(_f0, _f1);
    axes = [_triangleNormal.x, _triangleNormal.y, _triangleNormal.z];
    return satForAxes(axes, _v0$2, _v1$7, _v2$4, _extents);
  }
  clampPoint(point, target) {
    return target.copy(point).clamp(this.min, this.max);
  }
  distanceToPoint(point) {
    return this.clampPoint(point, _vector$a).distanceTo(point);
  }
  getBoundingSphere(target) {
    if (this.isEmpty()) {
      target.makeEmpty();
    } else {
      this.getCenter(target.center);
      target.radius = this.getSize(_vector$a).length() * 0.5;
    }
    return target;
  }
  intersect(box) {
    this.min.max(box.min);
    this.max.min(box.max);
    if (this.isEmpty()) this.makeEmpty();
    return this;
  }
  union(box) {
    this.min.min(box.min);
    this.max.max(box.max);
    return this;
  }
  applyMatrix4(matrix) {
    if (this.isEmpty()) return this;
    _points[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(matrix);
    _points[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(matrix);
    _points[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(matrix);
    _points[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(matrix);
    _points[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(matrix);
    _points[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(matrix);
    _points[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(matrix);
    _points[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(matrix);
    this.setFromPoints(_points);
    return this;
  }
  translate(offset) {
    this.min.add(offset);
    this.max.add(offset);
    return this;
  }
  equals(box) {
    return box.min.equals(this.min) && box.max.equals(this.max);
  }
};
var _points = [
  new Vector3(),
  new Vector3(),
  new Vector3(),
  new Vector3(),
  new Vector3(),
  new Vector3(),
  new Vector3(),
  new Vector3()
];
var _vector$a = new Vector3();
var _box$3 = new Box3();
var _v0$2 = new Vector3();
var _v1$7 = new Vector3();
var _v2$4 = new Vector3();
var _f0 = new Vector3();
var _f1 = new Vector3();
var _f2 = new Vector3();
var _center = new Vector3();
var _extents = new Vector3();
var _triangleNormal = new Vector3();
var _testAxis = new Vector3();
function satForAxes(axes, v0, v1, v2, extents) {
  for (let i2 = 0, j = axes.length - 3; i2 <= j; i2 += 3) {
    _testAxis.fromArray(axes, i2);
    const r2 = extents.x * Math.abs(_testAxis.x) + extents.y * Math.abs(_testAxis.y) + extents.z * Math.abs(_testAxis.z);
    const p0 = v0.dot(_testAxis);
    const p1 = v1.dot(_testAxis);
    const p2 = v2.dot(_testAxis);
    if (Math.max(-Math.max(p0, p1, p2), Math.min(p0, p1, p2)) > r2) {
      return false;
    }
  }
  return true;
}
var _box$2 = new Box3();
var _v1$6 = new Vector3();
var _v2$3 = new Vector3();
var Sphere = class {
  constructor(center = new Vector3(), radius = -1) {
    this.center = center;
    this.radius = radius;
  }
  set(center, radius) {
    this.center.copy(center);
    this.radius = radius;
    return this;
  }
  setFromPoints(points, optionalCenter) {
    const center = this.center;
    if (optionalCenter !== void 0) {
      center.copy(optionalCenter);
    } else {
      _box$2.setFromPoints(points).getCenter(center);
    }
    let maxRadiusSq = 0;
    for (let i2 = 0, il = points.length; i2 < il; i2++) {
      maxRadiusSq = Math.max(maxRadiusSq, center.distanceToSquared(points[i2]));
    }
    this.radius = Math.sqrt(maxRadiusSq);
    return this;
  }
  copy(sphere) {
    this.center.copy(sphere.center);
    this.radius = sphere.radius;
    return this;
  }
  isEmpty() {
    return this.radius < 0;
  }
  makeEmpty() {
    this.center.set(0, 0, 0);
    this.radius = -1;
    return this;
  }
  containsPoint(point) {
    return point.distanceToSquared(this.center) <= this.radius * this.radius;
  }
  distanceToPoint(point) {
    return point.distanceTo(this.center) - this.radius;
  }
  intersectsSphere(sphere) {
    const radiusSum = this.radius + sphere.radius;
    return sphere.center.distanceToSquared(this.center) <= radiusSum * radiusSum;
  }
  intersectsBox(box) {
    return box.intersectsSphere(this);
  }
  intersectsPlane(plane) {
    return Math.abs(plane.distanceToPoint(this.center)) <= this.radius;
  }
  clampPoint(point, target) {
    const deltaLengthSq = this.center.distanceToSquared(point);
    target.copy(point);
    if (deltaLengthSq > this.radius * this.radius) {
      target.sub(this.center).normalize();
      target.multiplyScalar(this.radius).add(this.center);
    }
    return target;
  }
  getBoundingBox(target) {
    if (this.isEmpty()) {
      target.makeEmpty();
      return target;
    }
    target.set(this.center, this.center);
    target.expandByScalar(this.radius);
    return target;
  }
  applyMatrix4(matrix) {
    this.center.applyMatrix4(matrix);
    this.radius = this.radius * matrix.getMaxScaleOnAxis();
    return this;
  }
  translate(offset) {
    this.center.add(offset);
    return this;
  }
  expandByPoint(point) {
    if (this.isEmpty()) {
      this.center.copy(point);
      this.radius = 0;
      return this;
    }
    _v1$6.subVectors(point, this.center);
    const lengthSq = _v1$6.lengthSq();
    if (lengthSq > this.radius * this.radius) {
      const length = Math.sqrt(lengthSq);
      const delta = (length - this.radius) * 0.5;
      this.center.addScaledVector(_v1$6, delta / length);
      this.radius += delta;
    }
    return this;
  }
  union(sphere) {
    if (sphere.isEmpty()) {
      return this;
    }
    if (this.isEmpty()) {
      this.copy(sphere);
      return this;
    }
    if (this.center.equals(sphere.center) === true) {
      this.radius = Math.max(this.radius, sphere.radius);
    } else {
      _v2$3.subVectors(sphere.center, this.center).setLength(sphere.radius);
      this.expandByPoint(_v1$6.copy(sphere.center).add(_v2$3));
      this.expandByPoint(_v1$6.copy(sphere.center).sub(_v2$3));
    }
    return this;
  }
  equals(sphere) {
    return sphere.center.equals(this.center) && sphere.radius === this.radius;
  }
  clone() {
    return new this.constructor().copy(this);
  }
};
var _vector$9 = new Vector3();
var _segCenter = new Vector3();
var _segDir = new Vector3();
var _diff = new Vector3();
var _edge1 = new Vector3();
var _edge2 = new Vector3();
var _normal$1 = new Vector3();
var Ray = class {
  constructor(origin = new Vector3(), direction2 = new Vector3(0, 0, -1)) {
    this.origin = origin;
    this.direction = direction2;
  }
  set(origin, direction2) {
    this.origin.copy(origin);
    this.direction.copy(direction2);
    return this;
  }
  copy(ray) {
    this.origin.copy(ray.origin);
    this.direction.copy(ray.direction);
    return this;
  }
  at(t2, target) {
    return target.copy(this.origin).addScaledVector(this.direction, t2);
  }
  lookAt(v2) {
    this.direction.copy(v2).sub(this.origin).normalize();
    return this;
  }
  recast(t2) {
    this.origin.copy(this.at(t2, _vector$9));
    return this;
  }
  closestPointToPoint(point, target) {
    target.subVectors(point, this.origin);
    const directionDistance = target.dot(this.direction);
    if (directionDistance < 0) {
      return target.copy(this.origin);
    }
    return target.copy(this.origin).addScaledVector(this.direction, directionDistance);
  }
  distanceToPoint(point) {
    return Math.sqrt(this.distanceSqToPoint(point));
  }
  distanceSqToPoint(point) {
    const directionDistance = _vector$9.subVectors(point, this.origin).dot(this.direction);
    if (directionDistance < 0) {
      return this.origin.distanceToSquared(point);
    }
    _vector$9.copy(this.origin).addScaledVector(this.direction, directionDistance);
    return _vector$9.distanceToSquared(point);
  }
  distanceSqToSegment(v0, v1, optionalPointOnRay, optionalPointOnSegment) {
    _segCenter.copy(v0).add(v1).multiplyScalar(0.5);
    _segDir.copy(v1).sub(v0).normalize();
    _diff.copy(this.origin).sub(_segCenter);
    const segExtent = v0.distanceTo(v1) * 0.5;
    const a01 = -this.direction.dot(_segDir);
    const b0 = _diff.dot(this.direction);
    const b1 = -_diff.dot(_segDir);
    const c2 = _diff.lengthSq();
    const det = Math.abs(1 - a01 * a01);
    let s0, s1, sqrDist, extDet;
    if (det > 0) {
      s0 = a01 * b1 - b0;
      s1 = a01 * b0 - b1;
      extDet = segExtent * det;
      if (s0 >= 0) {
        if (s1 >= -extDet) {
          if (s1 <= extDet) {
            const invDet = 1 / det;
            s0 *= invDet;
            s1 *= invDet;
            sqrDist = s0 * (s0 + a01 * s1 + 2 * b0) + s1 * (a01 * s0 + s1 + 2 * b1) + c2;
          } else {
            s1 = segExtent;
            s0 = Math.max(0, -(a01 * s1 + b0));
            sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c2;
          }
        } else {
          s1 = -segExtent;
          s0 = Math.max(0, -(a01 * s1 + b0));
          sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c2;
        }
      } else {
        if (s1 <= -extDet) {
          s0 = Math.max(0, -(-a01 * segExtent + b0));
          s1 = s0 > 0 ? -segExtent : Math.min(Math.max(-segExtent, -b1), segExtent);
          sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c2;
        } else if (s1 <= extDet) {
          s0 = 0;
          s1 = Math.min(Math.max(-segExtent, -b1), segExtent);
          sqrDist = s1 * (s1 + 2 * b1) + c2;
        } else {
          s0 = Math.max(0, -(a01 * segExtent + b0));
          s1 = s0 > 0 ? segExtent : Math.min(Math.max(-segExtent, -b1), segExtent);
          sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c2;
        }
      }
    } else {
      s1 = a01 > 0 ? -segExtent : segExtent;
      s0 = Math.max(0, -(a01 * s1 + b0));
      sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c2;
    }
    if (optionalPointOnRay) {
      optionalPointOnRay.copy(this.origin).addScaledVector(this.direction, s0);
    }
    if (optionalPointOnSegment) {
      optionalPointOnSegment.copy(_segCenter).addScaledVector(_segDir, s1);
    }
    return sqrDist;
  }
  intersectSphere(sphere, target) {
    _vector$9.subVectors(sphere.center, this.origin);
    const tca = _vector$9.dot(this.direction);
    const d2 = _vector$9.dot(_vector$9) - tca * tca;
    const radius2 = sphere.radius * sphere.radius;
    if (d2 > radius2) return null;
    const thc = Math.sqrt(radius2 - d2);
    const t0 = tca - thc;
    const t1 = tca + thc;
    if (t1 < 0) return null;
    if (t0 < 0) return this.at(t1, target);
    return this.at(t0, target);
  }
  intersectsSphere(sphere) {
    return this.distanceSqToPoint(sphere.center) <= sphere.radius * sphere.radius;
  }
  distanceToPlane(plane) {
    const denominator = plane.normal.dot(this.direction);
    if (denominator === 0) {
      if (plane.distanceToPoint(this.origin) === 0) {
        return 0;
      }
      return null;
    }
    const t2 = -(this.origin.dot(plane.normal) + plane.constant) / denominator;
    return t2 >= 0 ? t2 : null;
  }
  intersectPlane(plane, target) {
    const t2 = this.distanceToPlane(plane);
    if (t2 === null) {
      return null;
    }
    return this.at(t2, target);
  }
  intersectsPlane(plane) {
    const distToPoint = plane.distanceToPoint(this.origin);
    if (distToPoint === 0) {
      return true;
    }
    const denominator = plane.normal.dot(this.direction);
    if (denominator * distToPoint < 0) {
      return true;
    }
    return false;
  }
  intersectBox(box, target) {
    let tmin, tmax, tymin, tymax, tzmin, tzmax;
    const invdirx = 1 / this.direction.x, invdiry = 1 / this.direction.y, invdirz = 1 / this.direction.z;
    const origin = this.origin;
    if (invdirx >= 0) {
      tmin = (box.min.x - origin.x) * invdirx;
      tmax = (box.max.x - origin.x) * invdirx;
    } else {
      tmin = (box.max.x - origin.x) * invdirx;
      tmax = (box.min.x - origin.x) * invdirx;
    }
    if (invdiry >= 0) {
      tymin = (box.min.y - origin.y) * invdiry;
      tymax = (box.max.y - origin.y) * invdiry;
    } else {
      tymin = (box.max.y - origin.y) * invdiry;
      tymax = (box.min.y - origin.y) * invdiry;
    }
    if (tmin > tymax || tymin > tmax) return null;
    if (tymin > tmin || isNaN(tmin)) tmin = tymin;
    if (tymax < tmax || isNaN(tmax)) tmax = tymax;
    if (invdirz >= 0) {
      tzmin = (box.min.z - origin.z) * invdirz;
      tzmax = (box.max.z - origin.z) * invdirz;
    } else {
      tzmin = (box.max.z - origin.z) * invdirz;
      tzmax = (box.min.z - origin.z) * invdirz;
    }
    if (tmin > tzmax || tzmin > tmax) return null;
    if (tzmin > tmin || tmin !== tmin) tmin = tzmin;
    if (tzmax < tmax || tmax !== tmax) tmax = tzmax;
    if (tmax < 0) return null;
    return this.at(tmin >= 0 ? tmin : tmax, target);
  }
  intersectsBox(box) {
    return this.intersectBox(box, _vector$9) !== null;
  }
  intersectTriangle(a2, b2, c2, backfaceCulling, target) {
    _edge1.subVectors(b2, a2);
    _edge2.subVectors(c2, a2);
    _normal$1.crossVectors(_edge1, _edge2);
    let DdN = this.direction.dot(_normal$1);
    let sign2;
    if (DdN > 0) {
      if (backfaceCulling) return null;
      sign2 = 1;
    } else if (DdN < 0) {
      sign2 = -1;
      DdN = -DdN;
    } else {
      return null;
    }
    _diff.subVectors(this.origin, a2);
    const DdQxE2 = sign2 * this.direction.dot(_edge2.crossVectors(_diff, _edge2));
    if (DdQxE2 < 0) {
      return null;
    }
    const DdE1xQ = sign2 * this.direction.dot(_edge1.cross(_diff));
    if (DdE1xQ < 0) {
      return null;
    }
    if (DdQxE2 + DdE1xQ > DdN) {
      return null;
    }
    const QdN = -sign2 * _diff.dot(_normal$1);
    if (QdN < 0) {
      return null;
    }
    return this.at(QdN / DdN, target);
  }
  applyMatrix4(matrix42) {
    this.origin.applyMatrix4(matrix42);
    this.direction.transformDirection(matrix42);
    return this;
  }
  equals(ray) {
    return ray.origin.equals(this.origin) && ray.direction.equals(this.direction);
  }
  clone() {
    return new this.constructor().copy(this);
  }
};
var Matrix4 = class _Matrix4 {
  constructor(n11, n12, n13, n14, n21, n22, n23, n24, n31, n32, n33, n34, n41, n42, n43, n44) {
    _Matrix4.prototype.isMatrix4 = true;
    this.elements = [
      1,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      1
    ];
    if (n11 !== void 0) {
      this.set(n11, n12, n13, n14, n21, n22, n23, n24, n31, n32, n33, n34, n41, n42, n43, n44);
    }
  }
  set(n11, n12, n13, n14, n21, n22, n23, n24, n31, n32, n33, n34, n41, n42, n43, n44) {
    const te = this.elements;
    te[0] = n11;
    te[4] = n12;
    te[8] = n13;
    te[12] = n14;
    te[1] = n21;
    te[5] = n22;
    te[9] = n23;
    te[13] = n24;
    te[2] = n31;
    te[6] = n32;
    te[10] = n33;
    te[14] = n34;
    te[3] = n41;
    te[7] = n42;
    te[11] = n43;
    te[15] = n44;
    return this;
  }
  identity() {
    this.set(
      1,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      1
    );
    return this;
  }
  clone() {
    return new _Matrix4().fromArray(this.elements);
  }
  copy(m2) {
    const te = this.elements;
    const me = m2.elements;
    te[0] = me[0];
    te[1] = me[1];
    te[2] = me[2];
    te[3] = me[3];
    te[4] = me[4];
    te[5] = me[5];
    te[6] = me[6];
    te[7] = me[7];
    te[8] = me[8];
    te[9] = me[9];
    te[10] = me[10];
    te[11] = me[11];
    te[12] = me[12];
    te[13] = me[13];
    te[14] = me[14];
    te[15] = me[15];
    return this;
  }
  copyPosition(m2) {
    const te = this.elements, me = m2.elements;
    te[12] = me[12];
    te[13] = me[13];
    te[14] = me[14];
    return this;
  }
  setFromMatrix3(m2) {
    const me = m2.elements;
    this.set(
      me[0],
      me[3],
      me[6],
      0,
      me[1],
      me[4],
      me[7],
      0,
      me[2],
      me[5],
      me[8],
      0,
      0,
      0,
      0,
      1
    );
    return this;
  }
  extractBasis(xAxis, yAxis, zAxis) {
    xAxis.setFromMatrixColumn(this, 0);
    yAxis.setFromMatrixColumn(this, 1);
    zAxis.setFromMatrixColumn(this, 2);
    return this;
  }
  makeBasis(xAxis, yAxis, zAxis) {
    this.set(
      xAxis.x,
      yAxis.x,
      zAxis.x,
      0,
      xAxis.y,
      yAxis.y,
      zAxis.y,
      0,
      xAxis.z,
      yAxis.z,
      zAxis.z,
      0,
      0,
      0,
      0,
      1
    );
    return this;
  }
  extractRotation(m2) {
    const te = this.elements;
    const me = m2.elements;
    const scaleX = 1 / _v1$5.setFromMatrixColumn(m2, 0).length();
    const scaleY = 1 / _v1$5.setFromMatrixColumn(m2, 1).length();
    const scaleZ = 1 / _v1$5.setFromMatrixColumn(m2, 2).length();
    te[0] = me[0] * scaleX;
    te[1] = me[1] * scaleX;
    te[2] = me[2] * scaleX;
    te[3] = 0;
    te[4] = me[4] * scaleY;
    te[5] = me[5] * scaleY;
    te[6] = me[6] * scaleY;
    te[7] = 0;
    te[8] = me[8] * scaleZ;
    te[9] = me[9] * scaleZ;
    te[10] = me[10] * scaleZ;
    te[11] = 0;
    te[12] = 0;
    te[13] = 0;
    te[14] = 0;
    te[15] = 1;
    return this;
  }
  makeRotationFromEuler(euler) {
    const te = this.elements;
    const x3 = euler.x, y2 = euler.y, z = euler.z;
    const a2 = Math.cos(x3), b2 = Math.sin(x3);
    const c2 = Math.cos(y2), d2 = Math.sin(y2);
    const e2 = Math.cos(z), f2 = Math.sin(z);
    if (euler.order === "XYZ") {
      const ae = a2 * e2, af = a2 * f2, be = b2 * e2, bf = b2 * f2;
      te[0] = c2 * e2;
      te[4] = -c2 * f2;
      te[8] = d2;
      te[1] = af + be * d2;
      te[5] = ae - bf * d2;
      te[9] = -b2 * c2;
      te[2] = bf - ae * d2;
      te[6] = be + af * d2;
      te[10] = a2 * c2;
    } else if (euler.order === "YXZ") {
      const ce = c2 * e2, cf = c2 * f2, de = d2 * e2, df = d2 * f2;
      te[0] = ce + df * b2;
      te[4] = de * b2 - cf;
      te[8] = a2 * d2;
      te[1] = a2 * f2;
      te[5] = a2 * e2;
      te[9] = -b2;
      te[2] = cf * b2 - de;
      te[6] = df + ce * b2;
      te[10] = a2 * c2;
    } else if (euler.order === "ZXY") {
      const ce = c2 * e2, cf = c2 * f2, de = d2 * e2, df = d2 * f2;
      te[0] = ce - df * b2;
      te[4] = -a2 * f2;
      te[8] = de + cf * b2;
      te[1] = cf + de * b2;
      te[5] = a2 * e2;
      te[9] = df - ce * b2;
      te[2] = -a2 * d2;
      te[6] = b2;
      te[10] = a2 * c2;
    } else if (euler.order === "ZYX") {
      const ae = a2 * e2, af = a2 * f2, be = b2 * e2, bf = b2 * f2;
      te[0] = c2 * e2;
      te[4] = be * d2 - af;
      te[8] = ae * d2 + bf;
      te[1] = c2 * f2;
      te[5] = bf * d2 + ae;
      te[9] = af * d2 - be;
      te[2] = -d2;
      te[6] = b2 * c2;
      te[10] = a2 * c2;
    } else if (euler.order === "YZX") {
      const ac = a2 * c2, ad = a2 * d2, bc = b2 * c2, bd = b2 * d2;
      te[0] = c2 * e2;
      te[4] = bd - ac * f2;
      te[8] = bc * f2 + ad;
      te[1] = f2;
      te[5] = a2 * e2;
      te[9] = -b2 * e2;
      te[2] = -d2 * e2;
      te[6] = ad * f2 + bc;
      te[10] = ac - bd * f2;
    } else if (euler.order === "XZY") {
      const ac = a2 * c2, ad = a2 * d2, bc = b2 * c2, bd = b2 * d2;
      te[0] = c2 * e2;
      te[4] = -f2;
      te[8] = d2 * e2;
      te[1] = ac * f2 + bd;
      te[5] = a2 * e2;
      te[9] = ad * f2 - bc;
      te[2] = bc * f2 - ad;
      te[6] = b2 * e2;
      te[10] = bd * f2 + ac;
    }
    te[3] = 0;
    te[7] = 0;
    te[11] = 0;
    te[12] = 0;
    te[13] = 0;
    te[14] = 0;
    te[15] = 1;
    return this;
  }
  makeRotationFromQuaternion(q) {
    return this.compose(_zero, q, _one);
  }
  lookAt(eye, target, up) {
    const te = this.elements;
    _z.subVectors(eye, target);
    if (_z.lengthSq() === 0) {
      _z.z = 1;
    }
    _z.normalize();
    _x.crossVectors(up, _z);
    if (_x.lengthSq() === 0) {
      if (Math.abs(up.z) === 1) {
        _z.x += 1e-4;
      } else {
        _z.z += 1e-4;
      }
      _z.normalize();
      _x.crossVectors(up, _z);
    }
    _x.normalize();
    _y.crossVectors(_z, _x);
    te[0] = _x.x;
    te[4] = _y.x;
    te[8] = _z.x;
    te[1] = _x.y;
    te[5] = _y.y;
    te[9] = _z.y;
    te[2] = _x.z;
    te[6] = _y.z;
    te[10] = _z.z;
    return this;
  }
  multiply(m2) {
    return this.multiplyMatrices(this, m2);
  }
  premultiply(m2) {
    return this.multiplyMatrices(m2, this);
  }
  multiplyMatrices(a2, b2) {
    const ae = a2.elements;
    const be = b2.elements;
    const te = this.elements;
    const a11 = ae[0], a12 = ae[4], a13 = ae[8], a14 = ae[12];
    const a21 = ae[1], a22 = ae[5], a23 = ae[9], a24 = ae[13];
    const a31 = ae[2], a32 = ae[6], a33 = ae[10], a34 = ae[14];
    const a41 = ae[3], a42 = ae[7], a43 = ae[11], a44 = ae[15];
    const b11 = be[0], b12 = be[4], b13 = be[8], b14 = be[12];
    const b21 = be[1], b22 = be[5], b23 = be[9], b24 = be[13];
    const b31 = be[2], b32 = be[6], b33 = be[10], b34 = be[14];
    const b41 = be[3], b42 = be[7], b43 = be[11], b44 = be[15];
    te[0] = a11 * b11 + a12 * b21 + a13 * b31 + a14 * b41;
    te[4] = a11 * b12 + a12 * b22 + a13 * b32 + a14 * b42;
    te[8] = a11 * b13 + a12 * b23 + a13 * b33 + a14 * b43;
    te[12] = a11 * b14 + a12 * b24 + a13 * b34 + a14 * b44;
    te[1] = a21 * b11 + a22 * b21 + a23 * b31 + a24 * b41;
    te[5] = a21 * b12 + a22 * b22 + a23 * b32 + a24 * b42;
    te[9] = a21 * b13 + a22 * b23 + a23 * b33 + a24 * b43;
    te[13] = a21 * b14 + a22 * b24 + a23 * b34 + a24 * b44;
    te[2] = a31 * b11 + a32 * b21 + a33 * b31 + a34 * b41;
    te[6] = a31 * b12 + a32 * b22 + a33 * b32 + a34 * b42;
    te[10] = a31 * b13 + a32 * b23 + a33 * b33 + a34 * b43;
    te[14] = a31 * b14 + a32 * b24 + a33 * b34 + a34 * b44;
    te[3] = a41 * b11 + a42 * b21 + a43 * b31 + a44 * b41;
    te[7] = a41 * b12 + a42 * b22 + a43 * b32 + a44 * b42;
    te[11] = a41 * b13 + a42 * b23 + a43 * b33 + a44 * b43;
    te[15] = a41 * b14 + a42 * b24 + a43 * b34 + a44 * b44;
    return this;
  }
  multiplyScalar(s2) {
    const te = this.elements;
    te[0] *= s2;
    te[4] *= s2;
    te[8] *= s2;
    te[12] *= s2;
    te[1] *= s2;
    te[5] *= s2;
    te[9] *= s2;
    te[13] *= s2;
    te[2] *= s2;
    te[6] *= s2;
    te[10] *= s2;
    te[14] *= s2;
    te[3] *= s2;
    te[7] *= s2;
    te[11] *= s2;
    te[15] *= s2;
    return this;
  }
  determinant() {
    const te = this.elements;
    const n11 = te[0], n12 = te[4], n13 = te[8], n14 = te[12];
    const n21 = te[1], n22 = te[5], n23 = te[9], n24 = te[13];
    const n31 = te[2], n32 = te[6], n33 = te[10], n34 = te[14];
    const n41 = te[3], n42 = te[7], n43 = te[11], n44 = te[15];
    return n41 * (+n14 * n23 * n32 - n13 * n24 * n32 - n14 * n22 * n33 + n12 * n24 * n33 + n13 * n22 * n34 - n12 * n23 * n34) + n42 * (+n11 * n23 * n34 - n11 * n24 * n33 + n14 * n21 * n33 - n13 * n21 * n34 + n13 * n24 * n31 - n14 * n23 * n31) + n43 * (+n11 * n24 * n32 - n11 * n22 * n34 - n14 * n21 * n32 + n12 * n21 * n34 + n14 * n22 * n31 - n12 * n24 * n31) + n44 * (-n13 * n22 * n31 - n11 * n23 * n32 + n11 * n22 * n33 + n13 * n21 * n32 - n12 * n21 * n33 + n12 * n23 * n31);
  }
  transpose() {
    const te = this.elements;
    let tmp2;
    tmp2 = te[1];
    te[1] = te[4];
    te[4] = tmp2;
    tmp2 = te[2];
    te[2] = te[8];
    te[8] = tmp2;
    tmp2 = te[6];
    te[6] = te[9];
    te[9] = tmp2;
    tmp2 = te[3];
    te[3] = te[12];
    te[12] = tmp2;
    tmp2 = te[7];
    te[7] = te[13];
    te[13] = tmp2;
    tmp2 = te[11];
    te[11] = te[14];
    te[14] = tmp2;
    return this;
  }
  setPosition(x3, y2, z) {
    const te = this.elements;
    if (x3.isVector3) {
      te[12] = x3.x;
      te[13] = x3.y;
      te[14] = x3.z;
    } else {
      te[12] = x3;
      te[13] = y2;
      te[14] = z;
    }
    return this;
  }
  invert() {
    const te = this.elements, n11 = te[0], n21 = te[1], n31 = te[2], n41 = te[3], n12 = te[4], n22 = te[5], n32 = te[6], n42 = te[7], n13 = te[8], n23 = te[9], n33 = te[10], n43 = te[11], n14 = te[12], n24 = te[13], n34 = te[14], n44 = te[15], t11 = n23 * n34 * n42 - n24 * n33 * n42 + n24 * n32 * n43 - n22 * n34 * n43 - n23 * n32 * n44 + n22 * n33 * n44, t12 = n14 * n33 * n42 - n13 * n34 * n42 - n14 * n32 * n43 + n12 * n34 * n43 + n13 * n32 * n44 - n12 * n33 * n44, t13 = n13 * n24 * n42 - n14 * n23 * n42 + n14 * n22 * n43 - n12 * n24 * n43 - n13 * n22 * n44 + n12 * n23 * n44, t14 = n14 * n23 * n32 - n13 * n24 * n32 - n14 * n22 * n33 + n12 * n24 * n33 + n13 * n22 * n34 - n12 * n23 * n34;
    const det = n11 * t11 + n21 * t12 + n31 * t13 + n41 * t14;
    if (det === 0) return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
    const detInv = 1 / det;
    te[0] = t11 * detInv;
    te[1] = (n24 * n33 * n41 - n23 * n34 * n41 - n24 * n31 * n43 + n21 * n34 * n43 + n23 * n31 * n44 - n21 * n33 * n44) * detInv;
    te[2] = (n22 * n34 * n41 - n24 * n32 * n41 + n24 * n31 * n42 - n21 * n34 * n42 - n22 * n31 * n44 + n21 * n32 * n44) * detInv;
    te[3] = (n23 * n32 * n41 - n22 * n33 * n41 - n23 * n31 * n42 + n21 * n33 * n42 + n22 * n31 * n43 - n21 * n32 * n43) * detInv;
    te[4] = t12 * detInv;
    te[5] = (n13 * n34 * n41 - n14 * n33 * n41 + n14 * n31 * n43 - n11 * n34 * n43 - n13 * n31 * n44 + n11 * n33 * n44) * detInv;
    te[6] = (n14 * n32 * n41 - n12 * n34 * n41 - n14 * n31 * n42 + n11 * n34 * n42 + n12 * n31 * n44 - n11 * n32 * n44) * detInv;
    te[7] = (n12 * n33 * n41 - n13 * n32 * n41 + n13 * n31 * n42 - n11 * n33 * n42 - n12 * n31 * n43 + n11 * n32 * n43) * detInv;
    te[8] = t13 * detInv;
    te[9] = (n14 * n23 * n41 - n13 * n24 * n41 - n14 * n21 * n43 + n11 * n24 * n43 + n13 * n21 * n44 - n11 * n23 * n44) * detInv;
    te[10] = (n12 * n24 * n41 - n14 * n22 * n41 + n14 * n21 * n42 - n11 * n24 * n42 - n12 * n21 * n44 + n11 * n22 * n44) * detInv;
    te[11] = (n13 * n22 * n41 - n12 * n23 * n41 - n13 * n21 * n42 + n11 * n23 * n42 + n12 * n21 * n43 - n11 * n22 * n43) * detInv;
    te[12] = t14 * detInv;
    te[13] = (n13 * n24 * n31 - n14 * n23 * n31 + n14 * n21 * n33 - n11 * n24 * n33 - n13 * n21 * n34 + n11 * n23 * n34) * detInv;
    te[14] = (n14 * n22 * n31 - n12 * n24 * n31 - n14 * n21 * n32 + n11 * n24 * n32 + n12 * n21 * n34 - n11 * n22 * n34) * detInv;
    te[15] = (n12 * n23 * n31 - n13 * n22 * n31 + n13 * n21 * n32 - n11 * n23 * n32 - n12 * n21 * n33 + n11 * n22 * n33) * detInv;
    return this;
  }
  scale(v2) {
    const te = this.elements;
    const x3 = v2.x, y2 = v2.y, z = v2.z;
    te[0] *= x3;
    te[4] *= y2;
    te[8] *= z;
    te[1] *= x3;
    te[5] *= y2;
    te[9] *= z;
    te[2] *= x3;
    te[6] *= y2;
    te[10] *= z;
    te[3] *= x3;
    te[7] *= y2;
    te[11] *= z;
    return this;
  }
  getMaxScaleOnAxis() {
    const te = this.elements;
    const scaleXSq = te[0] * te[0] + te[1] * te[1] + te[2] * te[2];
    const scaleYSq = te[4] * te[4] + te[5] * te[5] + te[6] * te[6];
    const scaleZSq = te[8] * te[8] + te[9] * te[9] + te[10] * te[10];
    return Math.sqrt(Math.max(scaleXSq, scaleYSq, scaleZSq));
  }
  makeTranslation(x3, y2, z) {
    if (x3.isVector3) {
      this.set(
        1,
        0,
        0,
        x3.x,
        0,
        1,
        0,
        x3.y,
        0,
        0,
        1,
        x3.z,
        0,
        0,
        0,
        1
      );
    } else {
      this.set(
        1,
        0,
        0,
        x3,
        0,
        1,
        0,
        y2,
        0,
        0,
        1,
        z,
        0,
        0,
        0,
        1
      );
    }
    return this;
  }
  makeRotationX(theta) {
    const c2 = Math.cos(theta), s2 = Math.sin(theta);
    this.set(
      1,
      0,
      0,
      0,
      0,
      c2,
      -s2,
      0,
      0,
      s2,
      c2,
      0,
      0,
      0,
      0,
      1
    );
    return this;
  }
  makeRotationY(theta) {
    const c2 = Math.cos(theta), s2 = Math.sin(theta);
    this.set(
      c2,
      0,
      s2,
      0,
      0,
      1,
      0,
      0,
      -s2,
      0,
      c2,
      0,
      0,
      0,
      0,
      1
    );
    return this;
  }
  makeRotationZ(theta) {
    const c2 = Math.cos(theta), s2 = Math.sin(theta);
    this.set(
      c2,
      -s2,
      0,
      0,
      s2,
      c2,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      1
    );
    return this;
  }
  makeRotationAxis(axis, angle) {
    const c2 = Math.cos(angle);
    const s2 = Math.sin(angle);
    const t2 = 1 - c2;
    const x3 = axis.x, y2 = axis.y, z = axis.z;
    const tx = t2 * x3, ty = t2 * y2;
    this.set(
      tx * x3 + c2,
      tx * y2 - s2 * z,
      tx * z + s2 * y2,
      0,
      tx * y2 + s2 * z,
      ty * y2 + c2,
      ty * z - s2 * x3,
      0,
      tx * z - s2 * y2,
      ty * z + s2 * x3,
      t2 * z * z + c2,
      0,
      0,
      0,
      0,
      1
    );
    return this;
  }
  makeScale(x3, y2, z) {
    this.set(
      x3,
      0,
      0,
      0,
      0,
      y2,
      0,
      0,
      0,
      0,
      z,
      0,
      0,
      0,
      0,
      1
    );
    return this;
  }
  makeShear(xy, xz, yx, yz, zx, zy) {
    this.set(
      1,
      yx,
      zx,
      0,
      xy,
      1,
      zy,
      0,
      xz,
      yz,
      1,
      0,
      0,
      0,
      0,
      1
    );
    return this;
  }
  compose(position, quaternion2, scale) {
    const te = this.elements;
    const x3 = quaternion2._x, y2 = quaternion2._y, z = quaternion2._z, w2 = quaternion2._w;
    const x22 = x3 + x3, y22 = y2 + y2, z2 = z + z;
    const xx = x3 * x22, xy = x3 * y22, xz = x3 * z2;
    const yy = y2 * y22, yz = y2 * z2, zz = z * z2;
    const wx = w2 * x22, wy = w2 * y22, wz = w2 * z2;
    const sx = scale.x, sy = scale.y, sz = scale.z;
    te[0] = (1 - (yy + zz)) * sx;
    te[1] = (xy + wz) * sx;
    te[2] = (xz - wy) * sx;
    te[3] = 0;
    te[4] = (xy - wz) * sy;
    te[5] = (1 - (xx + zz)) * sy;
    te[6] = (yz + wx) * sy;
    te[7] = 0;
    te[8] = (xz + wy) * sz;
    te[9] = (yz - wx) * sz;
    te[10] = (1 - (xx + yy)) * sz;
    te[11] = 0;
    te[12] = position.x;
    te[13] = position.y;
    te[14] = position.z;
    te[15] = 1;
    return this;
  }
  decompose(position, quaternion2, scale) {
    const te = this.elements;
    let sx = _v1$5.set(te[0], te[1], te[2]).length();
    const sy = _v1$5.set(te[4], te[5], te[6]).length();
    const sz = _v1$5.set(te[8], te[9], te[10]).length();
    const det = this.determinant();
    if (det < 0) sx = -sx;
    position.x = te[12];
    position.y = te[13];
    position.z = te[14];
    _m1$2.copy(this);
    const invSX = 1 / sx;
    const invSY = 1 / sy;
    const invSZ = 1 / sz;
    _m1$2.elements[0] *= invSX;
    _m1$2.elements[1] *= invSX;
    _m1$2.elements[2] *= invSX;
    _m1$2.elements[4] *= invSY;
    _m1$2.elements[5] *= invSY;
    _m1$2.elements[6] *= invSY;
    _m1$2.elements[8] *= invSZ;
    _m1$2.elements[9] *= invSZ;
    _m1$2.elements[10] *= invSZ;
    quaternion2.setFromRotationMatrix(_m1$2);
    scale.x = sx;
    scale.y = sy;
    scale.z = sz;
    return this;
  }
  makePerspective(left, right, top, bottom, near, far, coordinateSystem = WebGLCoordinateSystem) {
    const te = this.elements;
    const x3 = 2 * near / (right - left);
    const y2 = 2 * near / (top - bottom);
    const a2 = (right + left) / (right - left);
    const b2 = (top + bottom) / (top - bottom);
    let c2, d2;
    if (coordinateSystem === WebGLCoordinateSystem) {
      c2 = -(far + near) / (far - near);
      d2 = -2 * far * near / (far - near);
    } else if (coordinateSystem === WebGPUCoordinateSystem) {
      c2 = -far / (far - near);
      d2 = -far * near / (far - near);
    } else {
      throw new Error("THREE.Matrix4.makePerspective(): Invalid coordinate system: " + coordinateSystem);
    }
    te[0] = x3;
    te[4] = 0;
    te[8] = a2;
    te[12] = 0;
    te[1] = 0;
    te[5] = y2;
    te[9] = b2;
    te[13] = 0;
    te[2] = 0;
    te[6] = 0;
    te[10] = c2;
    te[14] = d2;
    te[3] = 0;
    te[7] = 0;
    te[11] = -1;
    te[15] = 0;
    return this;
  }
  makeOrthographic(left, right, top, bottom, near, far, coordinateSystem = WebGLCoordinateSystem) {
    const te = this.elements;
    const w2 = 1 / (right - left);
    const h2 = 1 / (top - bottom);
    const p2 = 1 / (far - near);
    const x3 = (right + left) * w2;
    const y2 = (top + bottom) * h2;
    let z, zInv;
    if (coordinateSystem === WebGLCoordinateSystem) {
      z = (far + near) * p2;
      zInv = -2 * p2;
    } else if (coordinateSystem === WebGPUCoordinateSystem) {
      z = near * p2;
      zInv = -1 * p2;
    } else {
      throw new Error("THREE.Matrix4.makeOrthographic(): Invalid coordinate system: " + coordinateSystem);
    }
    te[0] = 2 * w2;
    te[4] = 0;
    te[8] = 0;
    te[12] = -x3;
    te[1] = 0;
    te[5] = 2 * h2;
    te[9] = 0;
    te[13] = -y2;
    te[2] = 0;
    te[6] = 0;
    te[10] = zInv;
    te[14] = -z;
    te[3] = 0;
    te[7] = 0;
    te[11] = 0;
    te[15] = 1;
    return this;
  }
  equals(matrix) {
    const te = this.elements;
    const me = matrix.elements;
    for (let i2 = 0; i2 < 16; i2++) {
      if (te[i2] !== me[i2]) return false;
    }
    return true;
  }
  fromArray(array, offset = 0) {
    for (let i2 = 0; i2 < 16; i2++) {
      this.elements[i2] = array[i2 + offset];
    }
    return this;
  }
  toArray(array = [], offset = 0) {
    const te = this.elements;
    array[offset] = te[0];
    array[offset + 1] = te[1];
    array[offset + 2] = te[2];
    array[offset + 3] = te[3];
    array[offset + 4] = te[4];
    array[offset + 5] = te[5];
    array[offset + 6] = te[6];
    array[offset + 7] = te[7];
    array[offset + 8] = te[8];
    array[offset + 9] = te[9];
    array[offset + 10] = te[10];
    array[offset + 11] = te[11];
    array[offset + 12] = te[12];
    array[offset + 13] = te[13];
    array[offset + 14] = te[14];
    array[offset + 15] = te[15];
    return array;
  }
};
var _v1$5 = new Vector3();
var _m1$2 = new Matrix4();
var _zero = new Vector3(0, 0, 0);
var _one = new Vector3(1, 1, 1);
var _x = new Vector3();
var _y = new Vector3();
var _z = new Vector3();
var _matrix = new Matrix4();
var _quaternion$3 = new Quaternion();
var Euler = class _Euler {
  constructor(x3 = 0, y2 = 0, z = 0, order = _Euler.DEFAULT_ORDER) {
    this.isEuler = true;
    this._x = x3;
    this._y = y2;
    this._z = z;
    this._order = order;
  }
  get x() {
    return this._x;
  }
  set x(value) {
    this._x = value;
    this._onChangeCallback();
  }
  get y() {
    return this._y;
  }
  set y(value) {
    this._y = value;
    this._onChangeCallback();
  }
  get z() {
    return this._z;
  }
  set z(value) {
    this._z = value;
    this._onChangeCallback();
  }
  get order() {
    return this._order;
  }
  set order(value) {
    this._order = value;
    this._onChangeCallback();
  }
  set(x3, y2, z, order = this._order) {
    this._x = x3;
    this._y = y2;
    this._z = z;
    this._order = order;
    this._onChangeCallback();
    return this;
  }
  clone() {
    return new this.constructor(this._x, this._y, this._z, this._order);
  }
  copy(euler) {
    this._x = euler._x;
    this._y = euler._y;
    this._z = euler._z;
    this._order = euler._order;
    this._onChangeCallback();
    return this;
  }
  setFromRotationMatrix(m2, order = this._order, update = true) {
    const te = m2.elements;
    const m11 = te[0], m12 = te[4], m13 = te[8];
    const m21 = te[1], m22 = te[5], m23 = te[9];
    const m31 = te[2], m32 = te[6], m33 = te[10];
    switch (order) {
      case "XYZ":
        this._y = Math.asin(clamp(m13, -1, 1));
        if (Math.abs(m13) < 0.9999999) {
          this._x = Math.atan2(-m23, m33);
          this._z = Math.atan2(-m12, m11);
        } else {
          this._x = Math.atan2(m32, m22);
          this._z = 0;
        }
        break;
      case "YXZ":
        this._x = Math.asin(-clamp(m23, -1, 1));
        if (Math.abs(m23) < 0.9999999) {
          this._y = Math.atan2(m13, m33);
          this._z = Math.atan2(m21, m22);
        } else {
          this._y = Math.atan2(-m31, m11);
          this._z = 0;
        }
        break;
      case "ZXY":
        this._x = Math.asin(clamp(m32, -1, 1));
        if (Math.abs(m32) < 0.9999999) {
          this._y = Math.atan2(-m31, m33);
          this._z = Math.atan2(-m12, m22);
        } else {
          this._y = 0;
          this._z = Math.atan2(m21, m11);
        }
        break;
      case "ZYX":
        this._y = Math.asin(-clamp(m31, -1, 1));
        if (Math.abs(m31) < 0.9999999) {
          this._x = Math.atan2(m32, m33);
          this._z = Math.atan2(m21, m11);
        } else {
          this._x = 0;
          this._z = Math.atan2(-m12, m22);
        }
        break;
      case "YZX":
        this._z = Math.asin(clamp(m21, -1, 1));
        if (Math.abs(m21) < 0.9999999) {
          this._x = Math.atan2(-m23, m22);
          this._y = Math.atan2(-m31, m11);
        } else {
          this._x = 0;
          this._y = Math.atan2(m13, m33);
        }
        break;
      case "XZY":
        this._z = Math.asin(-clamp(m12, -1, 1));
        if (Math.abs(m12) < 0.9999999) {
          this._x = Math.atan2(m32, m22);
          this._y = Math.atan2(m13, m11);
        } else {
          this._x = Math.atan2(-m23, m33);
          this._y = 0;
        }
        break;
      default:
        console.warn("THREE.Euler: .setFromRotationMatrix() encountered an unknown order: " + order);
    }
    this._order = order;
    if (update === true) this._onChangeCallback();
    return this;
  }
  setFromQuaternion(q, order, update) {
    _matrix.makeRotationFromQuaternion(q);
    return this.setFromRotationMatrix(_matrix, order, update);
  }
  setFromVector3(v2, order = this._order) {
    return this.set(v2.x, v2.y, v2.z, order);
  }
  reorder(newOrder) {
    _quaternion$3.setFromEuler(this);
    return this.setFromQuaternion(_quaternion$3, newOrder);
  }
  equals(euler) {
    return euler._x === this._x && euler._y === this._y && euler._z === this._z && euler._order === this._order;
  }
  fromArray(array) {
    this._x = array[0];
    this._y = array[1];
    this._z = array[2];
    if (array[3] !== void 0) this._order = array[3];
    this._onChangeCallback();
    return this;
  }
  toArray(array = [], offset = 0) {
    array[offset] = this._x;
    array[offset + 1] = this._y;
    array[offset + 2] = this._z;
    array[offset + 3] = this._order;
    return array;
  }
  _onChange(callback) {
    this._onChangeCallback = callback;
    return this;
  }
  _onChangeCallback() {
  }
  *[Symbol.iterator]() {
    yield this._x;
    yield this._y;
    yield this._z;
    yield this._order;
  }
};
Euler.DEFAULT_ORDER = "XYZ";
var Layers = class {
  constructor() {
    this.mask = 1 | 0;
  }
  set(channel) {
    this.mask = (1 << channel | 0) >>> 0;
  }
  enable(channel) {
    this.mask |= 1 << channel | 0;
  }
  enableAll() {
    this.mask = 4294967295 | 0;
  }
  toggle(channel) {
    this.mask ^= 1 << channel | 0;
  }
  disable(channel) {
    this.mask &= ~(1 << channel | 0);
  }
  disableAll() {
    this.mask = 0;
  }
  test(layers) {
    return (this.mask & layers.mask) !== 0;
  }
  isEnabled(channel) {
    return (this.mask & (1 << channel | 0)) !== 0;
  }
};
var _object3DId = 0;
var _v1$4 = new Vector3();
var _q1 = new Quaternion();
var _m1$1 = new Matrix4();
var _target = new Vector3();
var _position$3 = new Vector3();
var _scale$2 = new Vector3();
var _quaternion$2 = new Quaternion();
var _xAxis = new Vector3(1, 0, 0);
var _yAxis = new Vector3(0, 1, 0);
var _zAxis = new Vector3(0, 0, 1);
var _addedEvent = { type: "added" };
var _removedEvent = { type: "removed" };
var Object3D = class _Object3D extends EventDispatcher {
  constructor() {
    super();
    this.isObject3D = true;
    Object.defineProperty(this, "id", { value: _object3DId++ });
    this.uuid = generateUUID();
    this.name = "";
    this.type = "Object3D";
    this.parent = null;
    this.children = [];
    this.up = _Object3D.DEFAULT_UP.clone();
    const position = new Vector3();
    const rotation = new Euler();
    const quaternion2 = new Quaternion();
    const scale = new Vector3(1, 1, 1);
    function onRotationChange() {
      quaternion2.setFromEuler(rotation, false);
    }
    function onQuaternionChange() {
      rotation.setFromQuaternion(quaternion2, void 0, false);
    }
    rotation._onChange(onRotationChange);
    quaternion2._onChange(onQuaternionChange);
    Object.defineProperties(this, {
      position: {
        configurable: true,
        enumerable: true,
        value: position
      },
      rotation: {
        configurable: true,
        enumerable: true,
        value: rotation
      },
      quaternion: {
        configurable: true,
        enumerable: true,
        value: quaternion2
      },
      scale: {
        configurable: true,
        enumerable: true,
        value: scale
      },
      modelViewMatrix: {
        value: new Matrix4()
      },
      normalMatrix: {
        value: new Matrix3()
      }
    });
    this.matrix = new Matrix4();
    this.matrixWorld = new Matrix4();
    this.matrixAutoUpdate = _Object3D.DEFAULT_MATRIX_AUTO_UPDATE;
    this.matrixWorldNeedsUpdate = false;
    this.matrixWorldAutoUpdate = _Object3D.DEFAULT_MATRIX_WORLD_AUTO_UPDATE;
    this.layers = new Layers();
    this.visible = true;
    this.castShadow = false;
    this.receiveShadow = false;
    this.frustumCulled = true;
    this.renderOrder = 0;
    this.animations = [];
    this.userData = {};
  }
  onBeforeRender() {
  }
  onAfterRender() {
  }
  applyMatrix4(matrix) {
    if (this.matrixAutoUpdate) this.updateMatrix();
    this.matrix.premultiply(matrix);
    this.matrix.decompose(this.position, this.quaternion, this.scale);
  }
  applyQuaternion(q) {
    this.quaternion.premultiply(q);
    return this;
  }
  setRotationFromAxisAngle(axis, angle) {
    this.quaternion.setFromAxisAngle(axis, angle);
  }
  setRotationFromEuler(euler) {
    this.quaternion.setFromEuler(euler, true);
  }
  setRotationFromMatrix(m2) {
    this.quaternion.setFromRotationMatrix(m2);
  }
  setRotationFromQuaternion(q) {
    this.quaternion.copy(q);
  }
  rotateOnAxis(axis, angle) {
    _q1.setFromAxisAngle(axis, angle);
    this.quaternion.multiply(_q1);
    return this;
  }
  rotateOnWorldAxis(axis, angle) {
    _q1.setFromAxisAngle(axis, angle);
    this.quaternion.premultiply(_q1);
    return this;
  }
  rotateX(angle) {
    return this.rotateOnAxis(_xAxis, angle);
  }
  rotateY(angle) {
    return this.rotateOnAxis(_yAxis, angle);
  }
  rotateZ(angle) {
    return this.rotateOnAxis(_zAxis, angle);
  }
  translateOnAxis(axis, distance) {
    _v1$4.copy(axis).applyQuaternion(this.quaternion);
    this.position.add(_v1$4.multiplyScalar(distance));
    return this;
  }
  translateX(distance) {
    return this.translateOnAxis(_xAxis, distance);
  }
  translateY(distance) {
    return this.translateOnAxis(_yAxis, distance);
  }
  translateZ(distance) {
    return this.translateOnAxis(_zAxis, distance);
  }
  localToWorld(vector) {
    this.updateWorldMatrix(true, false);
    return vector.applyMatrix4(this.matrixWorld);
  }
  worldToLocal(vector) {
    this.updateWorldMatrix(true, false);
    return vector.applyMatrix4(_m1$1.copy(this.matrixWorld).invert());
  }
  lookAt(x3, y2, z) {
    if (x3.isVector3) {
      _target.copy(x3);
    } else {
      _target.set(x3, y2, z);
    }
    const parent = this.parent;
    this.updateWorldMatrix(true, false);
    _position$3.setFromMatrixPosition(this.matrixWorld);
    if (this.isCamera || this.isLight) {
      _m1$1.lookAt(_position$3, _target, this.up);
    } else {
      _m1$1.lookAt(_target, _position$3, this.up);
    }
    this.quaternion.setFromRotationMatrix(_m1$1);
    if (parent) {
      _m1$1.extractRotation(parent.matrixWorld);
      _q1.setFromRotationMatrix(_m1$1);
      this.quaternion.premultiply(_q1.invert());
    }
  }
  add(object) {
    if (arguments.length > 1) {
      for (let i2 = 0; i2 < arguments.length; i2++) {
        this.add(arguments[i2]);
      }
      return this;
    }
    if (object === this) {
      console.error("THREE.Object3D.add: object can't be added as a child of itself.", object);
      return this;
    }
    if (object && object.isObject3D) {
      if (object.parent !== null) {
        object.parent.remove(object);
      }
      object.parent = this;
      this.children.push(object);
      object.dispatchEvent(_addedEvent);
    } else {
      console.error("THREE.Object3D.add: object not an instance of THREE.Object3D.", object);
    }
    return this;
  }
  remove(object) {
    if (arguments.length > 1) {
      for (let i2 = 0; i2 < arguments.length; i2++) {
        this.remove(arguments[i2]);
      }
      return this;
    }
    const index = this.children.indexOf(object);
    if (index !== -1) {
      object.parent = null;
      this.children.splice(index, 1);
      object.dispatchEvent(_removedEvent);
    }
    return this;
  }
  removeFromParent() {
    const parent = this.parent;
    if (parent !== null) {
      parent.remove(this);
    }
    return this;
  }
  clear() {
    for (let i2 = 0; i2 < this.children.length; i2++) {
      const object = this.children[i2];
      object.parent = null;
      object.dispatchEvent(_removedEvent);
    }
    this.children.length = 0;
    return this;
  }
  attach(object) {
    this.updateWorldMatrix(true, false);
    _m1$1.copy(this.matrixWorld).invert();
    if (object.parent !== null) {
      object.parent.updateWorldMatrix(true, false);
      _m1$1.multiply(object.parent.matrixWorld);
    }
    object.applyMatrix4(_m1$1);
    this.add(object);
    object.updateWorldMatrix(false, true);
    return this;
  }
  getObjectById(id2) {
    return this.getObjectByProperty("id", id2);
  }
  getObjectByName(name) {
    return this.getObjectByProperty("name", name);
  }
  getObjectByProperty(name, value) {
    if (this[name] === value) return this;
    for (let i2 = 0, l2 = this.children.length; i2 < l2; i2++) {
      const child = this.children[i2];
      const object = child.getObjectByProperty(name, value);
      if (object !== void 0) {
        return object;
      }
    }
    return void 0;
  }
  getObjectsByProperty(name, value) {
    let result = [];
    if (this[name] === value) result.push(this);
    for (let i2 = 0, l2 = this.children.length; i2 < l2; i2++) {
      const childResult = this.children[i2].getObjectsByProperty(name, value);
      if (childResult.length > 0) {
        result = result.concat(childResult);
      }
    }
    return result;
  }
  getWorldPosition(target) {
    this.updateWorldMatrix(true, false);
    return target.setFromMatrixPosition(this.matrixWorld);
  }
  getWorldQuaternion(target) {
    this.updateWorldMatrix(true, false);
    this.matrixWorld.decompose(_position$3, target, _scale$2);
    return target;
  }
  getWorldScale(target) {
    this.updateWorldMatrix(true, false);
    this.matrixWorld.decompose(_position$3, _quaternion$2, target);
    return target;
  }
  getWorldDirection(target) {
    this.updateWorldMatrix(true, false);
    const e2 = this.matrixWorld.elements;
    return target.set(e2[8], e2[9], e2[10]).normalize();
  }
  raycast() {
  }
  traverse(callback) {
    callback(this);
    const children = this.children;
    for (let i2 = 0, l2 = children.length; i2 < l2; i2++) {
      children[i2].traverse(callback);
    }
  }
  traverseVisible(callback) {
    if (this.visible === false) return;
    callback(this);
    const children = this.children;
    for (let i2 = 0, l2 = children.length; i2 < l2; i2++) {
      children[i2].traverseVisible(callback);
    }
  }
  traverseAncestors(callback) {
    const parent = this.parent;
    if (parent !== null) {
      callback(parent);
      parent.traverseAncestors(callback);
    }
  }
  updateMatrix() {
    this.matrix.compose(this.position, this.quaternion, this.scale);
    this.matrixWorldNeedsUpdate = true;
  }
  updateMatrixWorld(force) {
    if (this.matrixAutoUpdate) this.updateMatrix();
    if (this.matrixWorldNeedsUpdate || force) {
      if (this.parent === null) {
        this.matrixWorld.copy(this.matrix);
      } else {
        this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix);
      }
      this.matrixWorldNeedsUpdate = false;
      force = true;
    }
    const children = this.children;
    for (let i2 = 0, l2 = children.length; i2 < l2; i2++) {
      const child = children[i2];
      if (child.matrixWorldAutoUpdate === true || force === true) {
        child.updateMatrixWorld(force);
      }
    }
  }
  updateWorldMatrix(updateParents, updateChildren) {
    const parent = this.parent;
    if (updateParents === true && parent !== null && parent.matrixWorldAutoUpdate === true) {
      parent.updateWorldMatrix(true, false);
    }
    if (this.matrixAutoUpdate) this.updateMatrix();
    if (this.parent === null) {
      this.matrixWorld.copy(this.matrix);
    } else {
      this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix);
    }
    if (updateChildren === true) {
      const children = this.children;
      for (let i2 = 0, l2 = children.length; i2 < l2; i2++) {
        const child = children[i2];
        if (child.matrixWorldAutoUpdate === true) {
          child.updateWorldMatrix(false, true);
        }
      }
    }
  }
  toJSON(meta) {
    const isRootObject = meta === void 0 || typeof meta === "string";
    const output = {};
    if (isRootObject) {
      meta = {
        geometries: {},
        materials: {},
        textures: {},
        images: {},
        shapes: {},
        skeletons: {},
        animations: {},
        nodes: {}
      };
      output.metadata = {
        version: 4.6,
        type: "Object",
        generator: "Object3D.toJSON"
      };
    }
    const object = {};
    object.uuid = this.uuid;
    object.type = this.type;
    if (this.name !== "") object.name = this.name;
    if (this.castShadow === true) object.castShadow = true;
    if (this.receiveShadow === true) object.receiveShadow = true;
    if (this.visible === false) object.visible = false;
    if (this.frustumCulled === false) object.frustumCulled = false;
    if (this.renderOrder !== 0) object.renderOrder = this.renderOrder;
    if (Object.keys(this.userData).length > 0) object.userData = this.userData;
    object.layers = this.layers.mask;
    object.matrix = this.matrix.toArray();
    object.up = this.up.toArray();
    if (this.matrixAutoUpdate === false) object.matrixAutoUpdate = false;
    if (this.isInstancedMesh) {
      object.type = "InstancedMesh";
      object.count = this.count;
      object.instanceMatrix = this.instanceMatrix.toJSON();
      if (this.instanceColor !== null) object.instanceColor = this.instanceColor.toJSON();
    }
    function serialize(library, element) {
      if (library[element.uuid] === void 0) {
        library[element.uuid] = element.toJSON(meta);
      }
      return element.uuid;
    }
    if (this.isScene) {
      if (this.background) {
        if (this.background.isColor) {
          object.background = this.background.toJSON();
        } else if (this.background.isTexture) {
          object.background = this.background.toJSON(meta).uuid;
        }
      }
      if (this.environment && this.environment.isTexture && this.environment.isRenderTargetTexture !== true) {
        object.environment = this.environment.toJSON(meta).uuid;
      }
    } else if (this.isMesh || this.isLine || this.isPoints) {
      object.geometry = serialize(meta.geometries, this.geometry);
      const parameters = this.geometry.parameters;
      if (parameters !== void 0 && parameters.shapes !== void 0) {
        const shapes = parameters.shapes;
        if (Array.isArray(shapes)) {
          for (let i2 = 0, l2 = shapes.length; i2 < l2; i2++) {
            const shape = shapes[i2];
            serialize(meta.shapes, shape);
          }
        } else {
          serialize(meta.shapes, shapes);
        }
      }
    }
    if (this.isSkinnedMesh) {
      object.bindMode = this.bindMode;
      object.bindMatrix = this.bindMatrix.toArray();
      if (this.skeleton !== void 0) {
        serialize(meta.skeletons, this.skeleton);
        object.skeleton = this.skeleton.uuid;
      }
    }
    if (this.material !== void 0) {
      if (Array.isArray(this.material)) {
        const uuids = [];
        for (let i2 = 0, l2 = this.material.length; i2 < l2; i2++) {
          uuids.push(serialize(meta.materials, this.material[i2]));
        }
        object.material = uuids;
      } else {
        object.material = serialize(meta.materials, this.material);
      }
    }
    if (this.children.length > 0) {
      object.children = [];
      for (let i2 = 0; i2 < this.children.length; i2++) {
        object.children.push(this.children[i2].toJSON(meta).object);
      }
    }
    if (this.animations.length > 0) {
      object.animations = [];
      for (let i2 = 0; i2 < this.animations.length; i2++) {
        const animation = this.animations[i2];
        object.animations.push(serialize(meta.animations, animation));
      }
    }
    if (isRootObject) {
      const geometries2 = extractFromCache(meta.geometries);
      const materials2 = extractFromCache(meta.materials);
      const textures = extractFromCache(meta.textures);
      const images = extractFromCache(meta.images);
      const shapes = extractFromCache(meta.shapes);
      const skeletons = extractFromCache(meta.skeletons);
      const animations = extractFromCache(meta.animations);
      const nodes = extractFromCache(meta.nodes);
      if (geometries2.length > 0) output.geometries = geometries2;
      if (materials2.length > 0) output.materials = materials2;
      if (textures.length > 0) output.textures = textures;
      if (images.length > 0) output.images = images;
      if (shapes.length > 0) output.shapes = shapes;
      if (skeletons.length > 0) output.skeletons = skeletons;
      if (animations.length > 0) output.animations = animations;
      if (nodes.length > 0) output.nodes = nodes;
    }
    output.object = object;
    return output;
    function extractFromCache(cache) {
      const values = [];
      for (const key in cache) {
        const data = cache[key];
        delete data.metadata;
        values.push(data);
      }
      return values;
    }
  }
  clone(recursive) {
    return new this.constructor().copy(this, recursive);
  }
  copy(source, recursive = true) {
    this.name = source.name;
    this.up.copy(source.up);
    this.position.copy(source.position);
    this.rotation.order = source.rotation.order;
    this.quaternion.copy(source.quaternion);
    this.scale.copy(source.scale);
    this.matrix.copy(source.matrix);
    this.matrixWorld.copy(source.matrixWorld);
    this.matrixAutoUpdate = source.matrixAutoUpdate;
    this.matrixWorldNeedsUpdate = source.matrixWorldNeedsUpdate;
    this.matrixWorldAutoUpdate = source.matrixWorldAutoUpdate;
    this.layers.mask = source.layers.mask;
    this.visible = source.visible;
    this.castShadow = source.castShadow;
    this.receiveShadow = source.receiveShadow;
    this.frustumCulled = source.frustumCulled;
    this.renderOrder = source.renderOrder;
    this.animations = source.animations;
    this.userData = JSON.parse(JSON.stringify(source.userData));
    if (recursive === true) {
      for (let i2 = 0; i2 < source.children.length; i2++) {
        const child = source.children[i2];
        this.add(child.clone());
      }
    }
    return this;
  }
};
Object3D.DEFAULT_UP = new Vector3(0, 1, 0);
Object3D.DEFAULT_MATRIX_AUTO_UPDATE = true;
Object3D.DEFAULT_MATRIX_WORLD_AUTO_UPDATE = true;
var _v0$1 = new Vector3();
var _v1$3 = new Vector3();
var _v2$2 = new Vector3();
var _v3$1 = new Vector3();
var _vab = new Vector3();
var _vac = new Vector3();
var _vbc = new Vector3();
var _vap = new Vector3();
var _vbp = new Vector3();
var _vcp = new Vector3();
var warnedGetUV = false;
var Triangle = class _Triangle {
  constructor(a2 = new Vector3(), b2 = new Vector3(), c2 = new Vector3()) {
    this.a = a2;
    this.b = b2;
    this.c = c2;
  }
  static getNormal(a2, b2, c2, target) {
    target.subVectors(c2, b2);
    _v0$1.subVectors(a2, b2);
    target.cross(_v0$1);
    const targetLengthSq = target.lengthSq();
    if (targetLengthSq > 0) {
      return target.multiplyScalar(1 / Math.sqrt(targetLengthSq));
    }
    return target.set(0, 0, 0);
  }
  // static/instance method to calculate barycentric coordinates
  // based on: http://www.blackpawn.com/texts/pointinpoly/default.html
  static getBarycoord(point, a2, b2, c2, target) {
    _v0$1.subVectors(c2, a2);
    _v1$3.subVectors(b2, a2);
    _v2$2.subVectors(point, a2);
    const dot00 = _v0$1.dot(_v0$1);
    const dot01 = _v0$1.dot(_v1$3);
    const dot02 = _v0$1.dot(_v2$2);
    const dot11 = _v1$3.dot(_v1$3);
    const dot12 = _v1$3.dot(_v2$2);
    const denom = dot00 * dot11 - dot01 * dot01;
    if (denom === 0) {
      return target.set(-2, -1, -1);
    }
    const invDenom = 1 / denom;
    const u2 = (dot11 * dot02 - dot01 * dot12) * invDenom;
    const v2 = (dot00 * dot12 - dot01 * dot02) * invDenom;
    return target.set(1 - u2 - v2, v2, u2);
  }
  static containsPoint(point, a2, b2, c2) {
    this.getBarycoord(point, a2, b2, c2, _v3$1);
    return _v3$1.x >= 0 && _v3$1.y >= 0 && _v3$1.x + _v3$1.y <= 1;
  }
  static getUV(point, p1, p2, p3, uv1, uv2, uv3, target) {
    if (warnedGetUV === false) {
      console.warn("THREE.Triangle.getUV() has been renamed to THREE.Triangle.getInterpolation().");
      warnedGetUV = true;
    }
    return this.getInterpolation(point, p1, p2, p3, uv1, uv2, uv3, target);
  }
  static getInterpolation(point, p1, p2, p3, v1, v2, v3, target) {
    this.getBarycoord(point, p1, p2, p3, _v3$1);
    target.setScalar(0);
    target.addScaledVector(v1, _v3$1.x);
    target.addScaledVector(v2, _v3$1.y);
    target.addScaledVector(v3, _v3$1.z);
    return target;
  }
  static isFrontFacing(a2, b2, c2, direction2) {
    _v0$1.subVectors(c2, b2);
    _v1$3.subVectors(a2, b2);
    return _v0$1.cross(_v1$3).dot(direction2) < 0 ? true : false;
  }
  set(a2, b2, c2) {
    this.a.copy(a2);
    this.b.copy(b2);
    this.c.copy(c2);
    return this;
  }
  setFromPointsAndIndices(points, i0, i1, i2) {
    this.a.copy(points[i0]);
    this.b.copy(points[i1]);
    this.c.copy(points[i2]);
    return this;
  }
  setFromAttributeAndIndices(attribute, i0, i1, i2) {
    this.a.fromBufferAttribute(attribute, i0);
    this.b.fromBufferAttribute(attribute, i1);
    this.c.fromBufferAttribute(attribute, i2);
    return this;
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(triangle) {
    this.a.copy(triangle.a);
    this.b.copy(triangle.b);
    this.c.copy(triangle.c);
    return this;
  }
  getArea() {
    _v0$1.subVectors(this.c, this.b);
    _v1$3.subVectors(this.a, this.b);
    return _v0$1.cross(_v1$3).length() * 0.5;
  }
  getMidpoint(target) {
    return target.addVectors(this.a, this.b).add(this.c).multiplyScalar(1 / 3);
  }
  getNormal(target) {
    return _Triangle.getNormal(this.a, this.b, this.c, target);
  }
  getPlane(target) {
    return target.setFromCoplanarPoints(this.a, this.b, this.c);
  }
  getBarycoord(point, target) {
    return _Triangle.getBarycoord(point, this.a, this.b, this.c, target);
  }
  getUV(point, uv1, uv2, uv3, target) {
    if (warnedGetUV === false) {
      console.warn("THREE.Triangle.getUV() has been renamed to THREE.Triangle.getInterpolation().");
      warnedGetUV = true;
    }
    return _Triangle.getInterpolation(point, this.a, this.b, this.c, uv1, uv2, uv3, target);
  }
  getInterpolation(point, v1, v2, v3, target) {
    return _Triangle.getInterpolation(point, this.a, this.b, this.c, v1, v2, v3, target);
  }
  containsPoint(point) {
    return _Triangle.containsPoint(point, this.a, this.b, this.c);
  }
  isFrontFacing(direction2) {
    return _Triangle.isFrontFacing(this.a, this.b, this.c, direction2);
  }
  intersectsBox(box) {
    return box.intersectsTriangle(this);
  }
  closestPointToPoint(p2, target) {
    const a2 = this.a, b2 = this.b, c2 = this.c;
    let v2, w2;
    _vab.subVectors(b2, a2);
    _vac.subVectors(c2, a2);
    _vap.subVectors(p2, a2);
    const d1 = _vab.dot(_vap);
    const d2 = _vac.dot(_vap);
    if (d1 <= 0 && d2 <= 0) {
      return target.copy(a2);
    }
    _vbp.subVectors(p2, b2);
    const d3 = _vab.dot(_vbp);
    const d4 = _vac.dot(_vbp);
    if (d3 >= 0 && d4 <= d3) {
      return target.copy(b2);
    }
    const vc = d1 * d4 - d3 * d2;
    if (vc <= 0 && d1 >= 0 && d3 <= 0) {
      v2 = d1 / (d1 - d3);
      return target.copy(a2).addScaledVector(_vab, v2);
    }
    _vcp.subVectors(p2, c2);
    const d5 = _vab.dot(_vcp);
    const d6 = _vac.dot(_vcp);
    if (d6 >= 0 && d5 <= d6) {
      return target.copy(c2);
    }
    const vb = d5 * d2 - d1 * d6;
    if (vb <= 0 && d2 >= 0 && d6 <= 0) {
      w2 = d2 / (d2 - d6);
      return target.copy(a2).addScaledVector(_vac, w2);
    }
    const va = d3 * d6 - d5 * d4;
    if (va <= 0 && d4 - d3 >= 0 && d5 - d6 >= 0) {
      _vbc.subVectors(c2, b2);
      w2 = (d4 - d3) / (d4 - d3 + (d5 - d6));
      return target.copy(b2).addScaledVector(_vbc, w2);
    }
    const denom = 1 / (va + vb + vc);
    v2 = vb * denom;
    w2 = vc * denom;
    return target.copy(a2).addScaledVector(_vab, v2).addScaledVector(_vac, w2);
  }
  equals(triangle) {
    return triangle.a.equals(this.a) && triangle.b.equals(this.b) && triangle.c.equals(this.c);
  }
};
var materialId = 0;
var Material = class extends EventDispatcher {
  constructor() {
    super();
    this.isMaterial = true;
    Object.defineProperty(this, "id", { value: materialId++ });
    this.uuid = generateUUID();
    this.name = "";
    this.type = "Material";
    this.blending = NormalBlending;
    this.side = FrontSide;
    this.vertexColors = false;
    this.opacity = 1;
    this.transparent = false;
    this.blendSrc = SrcAlphaFactor;
    this.blendDst = OneMinusSrcAlphaFactor;
    this.blendEquation = AddEquation;
    this.blendSrcAlpha = null;
    this.blendDstAlpha = null;
    this.blendEquationAlpha = null;
    this.depthFunc = LessEqualDepth;
    this.depthTest = true;
    this.depthWrite = true;
    this.stencilWriteMask = 255;
    this.stencilFunc = AlwaysStencilFunc;
    this.stencilRef = 0;
    this.stencilFuncMask = 255;
    this.stencilFail = KeepStencilOp;
    this.stencilZFail = KeepStencilOp;
    this.stencilZPass = KeepStencilOp;
    this.stencilWrite = false;
    this.clippingPlanes = null;
    this.clipIntersection = false;
    this.clipShadows = false;
    this.shadowSide = null;
    this.colorWrite = true;
    this.precision = null;
    this.polygonOffset = false;
    this.polygonOffsetFactor = 0;
    this.polygonOffsetUnits = 0;
    this.dithering = false;
    this.alphaToCoverage = false;
    this.premultipliedAlpha = false;
    this.forceSinglePass = false;
    this.visible = true;
    this.toneMapped = true;
    this.userData = {};
    this.version = 0;
    this._alphaTest = 0;
  }
  get alphaTest() {
    return this._alphaTest;
  }
  set alphaTest(value) {
    if (this._alphaTest > 0 !== value > 0) {
      this.version++;
    }
    this._alphaTest = value;
  }
  onBuild() {
  }
  onBeforeRender() {
  }
  onBeforeCompile() {
  }
  customProgramCacheKey() {
    return this.onBeforeCompile.toString();
  }
  setValues(values) {
    if (values === void 0) return;
    for (const key in values) {
      const newValue = values[key];
      if (newValue === void 0) {
        console.warn(`THREE.Material: parameter '${key}' has value of undefined.`);
        continue;
      }
      const currentValue = this[key];
      if (currentValue === void 0) {
        console.warn(`THREE.Material: '${key}' is not a property of THREE.${this.type}.`);
        continue;
      }
      if (currentValue && currentValue.isColor) {
        currentValue.set(newValue);
      } else if (currentValue && currentValue.isVector3 && (newValue && newValue.isVector3)) {
        currentValue.copy(newValue);
      } else {
        this[key] = newValue;
      }
    }
  }
  toJSON(meta) {
    const isRootObject = meta === void 0 || typeof meta === "string";
    if (isRootObject) {
      meta = {
        textures: {},
        images: {}
      };
    }
    const data = {
      metadata: {
        version: 4.6,
        type: "Material",
        generator: "Material.toJSON"
      }
    };
    data.uuid = this.uuid;
    data.type = this.type;
    if (this.name !== "") data.name = this.name;
    if (this.color && this.color.isColor) data.color = this.color.getHex();
    if (this.roughness !== void 0) data.roughness = this.roughness;
    if (this.metalness !== void 0) data.metalness = this.metalness;
    if (this.sheen !== void 0) data.sheen = this.sheen;
    if (this.sheenColor && this.sheenColor.isColor) data.sheenColor = this.sheenColor.getHex();
    if (this.sheenRoughness !== void 0) data.sheenRoughness = this.sheenRoughness;
    if (this.emissive && this.emissive.isColor) data.emissive = this.emissive.getHex();
    if (this.emissiveIntensity && this.emissiveIntensity !== 1) data.emissiveIntensity = this.emissiveIntensity;
    if (this.specular && this.specular.isColor) data.specular = this.specular.getHex();
    if (this.specularIntensity !== void 0) data.specularIntensity = this.specularIntensity;
    if (this.specularColor && this.specularColor.isColor) data.specularColor = this.specularColor.getHex();
    if (this.shininess !== void 0) data.shininess = this.shininess;
    if (this.clearcoat !== void 0) data.clearcoat = this.clearcoat;
    if (this.clearcoatRoughness !== void 0) data.clearcoatRoughness = this.clearcoatRoughness;
    if (this.clearcoatMap && this.clearcoatMap.isTexture) {
      data.clearcoatMap = this.clearcoatMap.toJSON(meta).uuid;
    }
    if (this.clearcoatRoughnessMap && this.clearcoatRoughnessMap.isTexture) {
      data.clearcoatRoughnessMap = this.clearcoatRoughnessMap.toJSON(meta).uuid;
    }
    if (this.clearcoatNormalMap && this.clearcoatNormalMap.isTexture) {
      data.clearcoatNormalMap = this.clearcoatNormalMap.toJSON(meta).uuid;
      data.clearcoatNormalScale = this.clearcoatNormalScale.toArray();
    }
    if (this.iridescence !== void 0) data.iridescence = this.iridescence;
    if (this.iridescenceIOR !== void 0) data.iridescenceIOR = this.iridescenceIOR;
    if (this.iridescenceThicknessRange !== void 0) data.iridescenceThicknessRange = this.iridescenceThicknessRange;
    if (this.iridescenceMap && this.iridescenceMap.isTexture) {
      data.iridescenceMap = this.iridescenceMap.toJSON(meta).uuid;
    }
    if (this.iridescenceThicknessMap && this.iridescenceThicknessMap.isTexture) {
      data.iridescenceThicknessMap = this.iridescenceThicknessMap.toJSON(meta).uuid;
    }
    if (this.anisotropy !== void 0) data.anisotropy = this.anisotropy;
    if (this.anisotropyRotation !== void 0) data.anisotropyRotation = this.anisotropyRotation;
    if (this.anisotropyMap && this.anisotropyMap.isTexture) {
      data.anisotropyMap = this.anisotropyMap.toJSON(meta).uuid;
    }
    if (this.map && this.map.isTexture) data.map = this.map.toJSON(meta).uuid;
    if (this.matcap && this.matcap.isTexture) data.matcap = this.matcap.toJSON(meta).uuid;
    if (this.alphaMap && this.alphaMap.isTexture) data.alphaMap = this.alphaMap.toJSON(meta).uuid;
    if (this.lightMap && this.lightMap.isTexture) {
      data.lightMap = this.lightMap.toJSON(meta).uuid;
      data.lightMapIntensity = this.lightMapIntensity;
    }
    if (this.aoMap && this.aoMap.isTexture) {
      data.aoMap = this.aoMap.toJSON(meta).uuid;
      data.aoMapIntensity = this.aoMapIntensity;
    }
    if (this.bumpMap && this.bumpMap.isTexture) {
      data.bumpMap = this.bumpMap.toJSON(meta).uuid;
      data.bumpScale = this.bumpScale;
    }
    if (this.normalMap && this.normalMap.isTexture) {
      data.normalMap = this.normalMap.toJSON(meta).uuid;
      data.normalMapType = this.normalMapType;
      data.normalScale = this.normalScale.toArray();
    }
    if (this.displacementMap && this.displacementMap.isTexture) {
      data.displacementMap = this.displacementMap.toJSON(meta).uuid;
      data.displacementScale = this.displacementScale;
      data.displacementBias = this.displacementBias;
    }
    if (this.roughnessMap && this.roughnessMap.isTexture) data.roughnessMap = this.roughnessMap.toJSON(meta).uuid;
    if (this.metalnessMap && this.metalnessMap.isTexture) data.metalnessMap = this.metalnessMap.toJSON(meta).uuid;
    if (this.emissiveMap && this.emissiveMap.isTexture) data.emissiveMap = this.emissiveMap.toJSON(meta).uuid;
    if (this.specularMap && this.specularMap.isTexture) data.specularMap = this.specularMap.toJSON(meta).uuid;
    if (this.specularIntensityMap && this.specularIntensityMap.isTexture) data.specularIntensityMap = this.specularIntensityMap.toJSON(meta).uuid;
    if (this.specularColorMap && this.specularColorMap.isTexture) data.specularColorMap = this.specularColorMap.toJSON(meta).uuid;
    if (this.envMap && this.envMap.isTexture) {
      data.envMap = this.envMap.toJSON(meta).uuid;
      if (this.combine !== void 0) data.combine = this.combine;
    }
    if (this.envMapIntensity !== void 0) data.envMapIntensity = this.envMapIntensity;
    if (this.reflectivity !== void 0) data.reflectivity = this.reflectivity;
    if (this.refractionRatio !== void 0) data.refractionRatio = this.refractionRatio;
    if (this.gradientMap && this.gradientMap.isTexture) {
      data.gradientMap = this.gradientMap.toJSON(meta).uuid;
    }
    if (this.transmission !== void 0) data.transmission = this.transmission;
    if (this.transmissionMap && this.transmissionMap.isTexture) data.transmissionMap = this.transmissionMap.toJSON(meta).uuid;
    if (this.thickness !== void 0) data.thickness = this.thickness;
    if (this.thicknessMap && this.thicknessMap.isTexture) data.thicknessMap = this.thicknessMap.toJSON(meta).uuid;
    if (this.attenuationDistance !== void 0 && this.attenuationDistance !== Infinity) data.attenuationDistance = this.attenuationDistance;
    if (this.attenuationColor !== void 0) data.attenuationColor = this.attenuationColor.getHex();
    if (this.size !== void 0) data.size = this.size;
    if (this.shadowSide !== null) data.shadowSide = this.shadowSide;
    if (this.sizeAttenuation !== void 0) data.sizeAttenuation = this.sizeAttenuation;
    if (this.blending !== NormalBlending) data.blending = this.blending;
    if (this.side !== FrontSide) data.side = this.side;
    if (this.vertexColors) data.vertexColors = true;
    if (this.opacity < 1) data.opacity = this.opacity;
    if (this.transparent === true) data.transparent = this.transparent;
    data.depthFunc = this.depthFunc;
    data.depthTest = this.depthTest;
    data.depthWrite = this.depthWrite;
    data.colorWrite = this.colorWrite;
    data.stencilWrite = this.stencilWrite;
    data.stencilWriteMask = this.stencilWriteMask;
    data.stencilFunc = this.stencilFunc;
    data.stencilRef = this.stencilRef;
    data.stencilFuncMask = this.stencilFuncMask;
    data.stencilFail = this.stencilFail;
    data.stencilZFail = this.stencilZFail;
    data.stencilZPass = this.stencilZPass;
    if (this.rotation !== void 0 && this.rotation !== 0) data.rotation = this.rotation;
    if (this.polygonOffset === true) data.polygonOffset = true;
    if (this.polygonOffsetFactor !== 0) data.polygonOffsetFactor = this.polygonOffsetFactor;
    if (this.polygonOffsetUnits !== 0) data.polygonOffsetUnits = this.polygonOffsetUnits;
    if (this.linewidth !== void 0 && this.linewidth !== 1) data.linewidth = this.linewidth;
    if (this.dashSize !== void 0) data.dashSize = this.dashSize;
    if (this.gapSize !== void 0) data.gapSize = this.gapSize;
    if (this.scale !== void 0) data.scale = this.scale;
    if (this.dithering === true) data.dithering = true;
    if (this.alphaTest > 0) data.alphaTest = this.alphaTest;
    if (this.alphaToCoverage === true) data.alphaToCoverage = this.alphaToCoverage;
    if (this.premultipliedAlpha === true) data.premultipliedAlpha = this.premultipliedAlpha;
    if (this.forceSinglePass === true) data.forceSinglePass = this.forceSinglePass;
    if (this.wireframe === true) data.wireframe = this.wireframe;
    if (this.wireframeLinewidth > 1) data.wireframeLinewidth = this.wireframeLinewidth;
    if (this.wireframeLinecap !== "round") data.wireframeLinecap = this.wireframeLinecap;
    if (this.wireframeLinejoin !== "round") data.wireframeLinejoin = this.wireframeLinejoin;
    if (this.flatShading === true) data.flatShading = this.flatShading;
    if (this.visible === false) data.visible = false;
    if (this.toneMapped === false) data.toneMapped = false;
    if (this.fog === false) data.fog = false;
    if (Object.keys(this.userData).length > 0) data.userData = this.userData;
    function extractFromCache(cache) {
      const values = [];
      for (const key in cache) {
        const data2 = cache[key];
        delete data2.metadata;
        values.push(data2);
      }
      return values;
    }
    if (isRootObject) {
      const textures = extractFromCache(meta.textures);
      const images = extractFromCache(meta.images);
      if (textures.length > 0) data.textures = textures;
      if (images.length > 0) data.images = images;
    }
    return data;
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(source) {
    this.name = source.name;
    this.blending = source.blending;
    this.side = source.side;
    this.vertexColors = source.vertexColors;
    this.opacity = source.opacity;
    this.transparent = source.transparent;
    this.blendSrc = source.blendSrc;
    this.blendDst = source.blendDst;
    this.blendEquation = source.blendEquation;
    this.blendSrcAlpha = source.blendSrcAlpha;
    this.blendDstAlpha = source.blendDstAlpha;
    this.blendEquationAlpha = source.blendEquationAlpha;
    this.depthFunc = source.depthFunc;
    this.depthTest = source.depthTest;
    this.depthWrite = source.depthWrite;
    this.stencilWriteMask = source.stencilWriteMask;
    this.stencilFunc = source.stencilFunc;
    this.stencilRef = source.stencilRef;
    this.stencilFuncMask = source.stencilFuncMask;
    this.stencilFail = source.stencilFail;
    this.stencilZFail = source.stencilZFail;
    this.stencilZPass = source.stencilZPass;
    this.stencilWrite = source.stencilWrite;
    const srcPlanes = source.clippingPlanes;
    let dstPlanes = null;
    if (srcPlanes !== null) {
      const n = srcPlanes.length;
      dstPlanes = new Array(n);
      for (let i2 = 0; i2 !== n; ++i2) {
        dstPlanes[i2] = srcPlanes[i2].clone();
      }
    }
    this.clippingPlanes = dstPlanes;
    this.clipIntersection = source.clipIntersection;
    this.clipShadows = source.clipShadows;
    this.shadowSide = source.shadowSide;
    this.colorWrite = source.colorWrite;
    this.precision = source.precision;
    this.polygonOffset = source.polygonOffset;
    this.polygonOffsetFactor = source.polygonOffsetFactor;
    this.polygonOffsetUnits = source.polygonOffsetUnits;
    this.dithering = source.dithering;
    this.alphaTest = source.alphaTest;
    this.alphaToCoverage = source.alphaToCoverage;
    this.premultipliedAlpha = source.premultipliedAlpha;
    this.forceSinglePass = source.forceSinglePass;
    this.visible = source.visible;
    this.toneMapped = source.toneMapped;
    this.userData = JSON.parse(JSON.stringify(source.userData));
    return this;
  }
  dispose() {
    this.dispatchEvent({ type: "dispose" });
  }
  set needsUpdate(value) {
    if (value === true) this.version++;
  }
};
var _colorKeywords = {
  "aliceblue": 15792383,
  "antiquewhite": 16444375,
  "aqua": 65535,
  "aquamarine": 8388564,
  "azure": 15794175,
  "beige": 16119260,
  "bisque": 16770244,
  "black": 0,
  "blanchedalmond": 16772045,
  "blue": 255,
  "blueviolet": 9055202,
  "brown": 10824234,
  "burlywood": 14596231,
  "cadetblue": 6266528,
  "chartreuse": 8388352,
  "chocolate": 13789470,
  "coral": 16744272,
  "cornflowerblue": 6591981,
  "cornsilk": 16775388,
  "crimson": 14423100,
  "cyan": 65535,
  "darkblue": 139,
  "darkcyan": 35723,
  "darkgoldenrod": 12092939,
  "darkgray": 11119017,
  "darkgreen": 25600,
  "darkgrey": 11119017,
  "darkkhaki": 12433259,
  "darkmagenta": 9109643,
  "darkolivegreen": 5597999,
  "darkorange": 16747520,
  "darkorchid": 10040012,
  "darkred": 9109504,
  "darksalmon": 15308410,
  "darkseagreen": 9419919,
  "darkslateblue": 4734347,
  "darkslategray": 3100495,
  "darkslategrey": 3100495,
  "darkturquoise": 52945,
  "darkviolet": 9699539,
  "deeppink": 16716947,
  "deepskyblue": 49151,
  "dimgray": 6908265,
  "dimgrey": 6908265,
  "dodgerblue": 2003199,
  "firebrick": 11674146,
  "floralwhite": 16775920,
  "forestgreen": 2263842,
  "fuchsia": 16711935,
  "gainsboro": 14474460,
  "ghostwhite": 16316671,
  "gold": 16766720,
  "goldenrod": 14329120,
  "gray": 8421504,
  "green": 32768,
  "greenyellow": 11403055,
  "grey": 8421504,
  "honeydew": 15794160,
  "hotpink": 16738740,
  "indianred": 13458524,
  "indigo": 4915330,
  "ivory": 16777200,
  "khaki": 15787660,
  "lavender": 15132410,
  "lavenderblush": 16773365,
  "lawngreen": 8190976,
  "lemonchiffon": 16775885,
  "lightblue": 11393254,
  "lightcoral": 15761536,
  "lightcyan": 14745599,
  "lightgoldenrodyellow": 16448210,
  "lightgray": 13882323,
  "lightgreen": 9498256,
  "lightgrey": 13882323,
  "lightpink": 16758465,
  "lightsalmon": 16752762,
  "lightseagreen": 2142890,
  "lightskyblue": 8900346,
  "lightslategray": 7833753,
  "lightslategrey": 7833753,
  "lightsteelblue": 11584734,
  "lightyellow": 16777184,
  "lime": 65280,
  "limegreen": 3329330,
  "linen": 16445670,
  "magenta": 16711935,
  "maroon": 8388608,
  "mediumaquamarine": 6737322,
  "mediumblue": 205,
  "mediumorchid": 12211667,
  "mediumpurple": 9662683,
  "mediumseagreen": 3978097,
  "mediumslateblue": 8087790,
  "mediumspringgreen": 64154,
  "mediumturquoise": 4772300,
  "mediumvioletred": 13047173,
  "midnightblue": 1644912,
  "mintcream": 16121850,
  "mistyrose": 16770273,
  "moccasin": 16770229,
  "navajowhite": 16768685,
  "navy": 128,
  "oldlace": 16643558,
  "olive": 8421376,
  "olivedrab": 7048739,
  "orange": 16753920,
  "orangered": 16729344,
  "orchid": 14315734,
  "palegoldenrod": 15657130,
  "palegreen": 10025880,
  "paleturquoise": 11529966,
  "palevioletred": 14381203,
  "papayawhip": 16773077,
  "peachpuff": 16767673,
  "peru": 13468991,
  "pink": 16761035,
  "plum": 14524637,
  "powderblue": 11591910,
  "purple": 8388736,
  "rebeccapurple": 6697881,
  "red": 16711680,
  "rosybrown": 12357519,
  "royalblue": 4286945,
  "saddlebrown": 9127187,
  "salmon": 16416882,
  "sandybrown": 16032864,
  "seagreen": 3050327,
  "seashell": 16774638,
  "sienna": 10506797,
  "silver": 12632256,
  "skyblue": 8900331,
  "slateblue": 6970061,
  "slategray": 7372944,
  "slategrey": 7372944,
  "snow": 16775930,
  "springgreen": 65407,
  "steelblue": 4620980,
  "tan": 13808780,
  "teal": 32896,
  "thistle": 14204888,
  "tomato": 16737095,
  "turquoise": 4251856,
  "violet": 15631086,
  "wheat": 16113331,
  "white": 16777215,
  "whitesmoke": 16119285,
  "yellow": 16776960,
  "yellowgreen": 10145074
};
var _hslA = { h: 0, s: 0, l: 0 };
var _hslB = { h: 0, s: 0, l: 0 };
function hue2rgb(p2, q, t2) {
  if (t2 < 0) t2 += 1;
  if (t2 > 1) t2 -= 1;
  if (t2 < 1 / 6) return p2 + (q - p2) * 6 * t2;
  if (t2 < 1 / 2) return q;
  if (t2 < 2 / 3) return p2 + (q - p2) * 6 * (2 / 3 - t2);
  return p2;
}
var Color = class {
  constructor(r2, g2, b2) {
    this.isColor = true;
    this.r = 1;
    this.g = 1;
    this.b = 1;
    return this.set(r2, g2, b2);
  }
  set(r2, g2, b2) {
    if (g2 === void 0 && b2 === void 0) {
      const value = r2;
      if (value && value.isColor) {
        this.copy(value);
      } else if (typeof value === "number") {
        this.setHex(value);
      } else if (typeof value === "string") {
        this.setStyle(value);
      }
    } else {
      this.setRGB(r2, g2, b2);
    }
    return this;
  }
  setScalar(scalar) {
    this.r = scalar;
    this.g = scalar;
    this.b = scalar;
    return this;
  }
  setHex(hex, colorSpace = SRGBColorSpace) {
    hex = Math.floor(hex);
    this.r = (hex >> 16 & 255) / 255;
    this.g = (hex >> 8 & 255) / 255;
    this.b = (hex & 255) / 255;
    ColorManagement.toWorkingColorSpace(this, colorSpace);
    return this;
  }
  setRGB(r2, g2, b2, colorSpace = ColorManagement.workingColorSpace) {
    this.r = r2;
    this.g = g2;
    this.b = b2;
    ColorManagement.toWorkingColorSpace(this, colorSpace);
    return this;
  }
  setHSL(h2, s2, l2, colorSpace = ColorManagement.workingColorSpace) {
    h2 = euclideanModulo(h2, 1);
    s2 = clamp(s2, 0, 1);
    l2 = clamp(l2, 0, 1);
    if (s2 === 0) {
      this.r = this.g = this.b = l2;
    } else {
      const p2 = l2 <= 0.5 ? l2 * (1 + s2) : l2 + s2 - l2 * s2;
      const q = 2 * l2 - p2;
      this.r = hue2rgb(q, p2, h2 + 1 / 3);
      this.g = hue2rgb(q, p2, h2);
      this.b = hue2rgb(q, p2, h2 - 1 / 3);
    }
    ColorManagement.toWorkingColorSpace(this, colorSpace);
    return this;
  }
  setStyle(style, colorSpace = SRGBColorSpace) {
    function handleAlpha(string) {
      if (string === void 0) return;
      if (parseFloat(string) < 1) {
        console.warn("THREE.Color: Alpha component of " + style + " will be ignored.");
      }
    }
    let m2;
    if (m2 = /^(\w+)\(([^\)]*)\)/.exec(style)) {
      let color;
      const name = m2[1];
      const components = m2[2];
      switch (name) {
        case "rgb":
        case "rgba":
          if (color = /^\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(components)) {
            handleAlpha(color[4]);
            return this.setRGB(
              Math.min(255, parseInt(color[1], 10)) / 255,
              Math.min(255, parseInt(color[2], 10)) / 255,
              Math.min(255, parseInt(color[3], 10)) / 255,
              colorSpace
            );
          }
          if (color = /^\s*(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(components)) {
            handleAlpha(color[4]);
            return this.setRGB(
              Math.min(100, parseInt(color[1], 10)) / 100,
              Math.min(100, parseInt(color[2], 10)) / 100,
              Math.min(100, parseInt(color[3], 10)) / 100,
              colorSpace
            );
          }
          break;
        case "hsl":
        case "hsla":
          if (color = /^\s*(\d*\.?\d+)\s*,\s*(\d*\.?\d+)\%\s*,\s*(\d*\.?\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(components)) {
            handleAlpha(color[4]);
            return this.setHSL(
              parseFloat(color[1]) / 360,
              parseFloat(color[2]) / 100,
              parseFloat(color[3]) / 100,
              colorSpace
            );
          }
          break;
        default:
          console.warn("THREE.Color: Unknown color model " + style);
      }
    } else if (m2 = /^\#([A-Fa-f\d]+)$/.exec(style)) {
      const hex = m2[1];
      const size = hex.length;
      if (size === 3) {
        return this.setRGB(
          parseInt(hex.charAt(0), 16) / 15,
          parseInt(hex.charAt(1), 16) / 15,
          parseInt(hex.charAt(2), 16) / 15,
          colorSpace
        );
      } else if (size === 6) {
        return this.setHex(parseInt(hex, 16), colorSpace);
      } else {
        console.warn("THREE.Color: Invalid hex color " + style);
      }
    } else if (style && style.length > 0) {
      return this.setColorName(style, colorSpace);
    }
    return this;
  }
  setColorName(style, colorSpace = SRGBColorSpace) {
    const hex = _colorKeywords[style.toLowerCase()];
    if (hex !== void 0) {
      this.setHex(hex, colorSpace);
    } else {
      console.warn("THREE.Color: Unknown color " + style);
    }
    return this;
  }
  clone() {
    return new this.constructor(this.r, this.g, this.b);
  }
  copy(color) {
    this.r = color.r;
    this.g = color.g;
    this.b = color.b;
    return this;
  }
  copySRGBToLinear(color) {
    this.r = SRGBToLinear(color.r);
    this.g = SRGBToLinear(color.g);
    this.b = SRGBToLinear(color.b);
    return this;
  }
  copyLinearToSRGB(color) {
    this.r = LinearToSRGB(color.r);
    this.g = LinearToSRGB(color.g);
    this.b = LinearToSRGB(color.b);
    return this;
  }
  convertSRGBToLinear() {
    this.copySRGBToLinear(this);
    return this;
  }
  convertLinearToSRGB() {
    this.copyLinearToSRGB(this);
    return this;
  }
  getHex(colorSpace = SRGBColorSpace) {
    ColorManagement.fromWorkingColorSpace(_color.copy(this), colorSpace);
    return Math.round(clamp(_color.r * 255, 0, 255)) * 65536 + Math.round(clamp(_color.g * 255, 0, 255)) * 256 + Math.round(clamp(_color.b * 255, 0, 255));
  }
  getHexString(colorSpace = SRGBColorSpace) {
    return ("000000" + this.getHex(colorSpace).toString(16)).slice(-6);
  }
  getHSL(target, colorSpace = ColorManagement.workingColorSpace) {
    ColorManagement.fromWorkingColorSpace(_color.copy(this), colorSpace);
    const r2 = _color.r, g2 = _color.g, b2 = _color.b;
    const max = Math.max(r2, g2, b2);
    const min = Math.min(r2, g2, b2);
    let hue, saturation;
    const lightness = (min + max) / 2;
    if (min === max) {
      hue = 0;
      saturation = 0;
    } else {
      const delta = max - min;
      saturation = lightness <= 0.5 ? delta / (max + min) : delta / (2 - max - min);
      switch (max) {
        case r2:
          hue = (g2 - b2) / delta + (g2 < b2 ? 6 : 0);
          break;
        case g2:
          hue = (b2 - r2) / delta + 2;
          break;
        case b2:
          hue = (r2 - g2) / delta + 4;
          break;
      }
      hue /= 6;
    }
    target.h = hue;
    target.s = saturation;
    target.l = lightness;
    return target;
  }
  getRGB(target, colorSpace = ColorManagement.workingColorSpace) {
    ColorManagement.fromWorkingColorSpace(_color.copy(this), colorSpace);
    target.r = _color.r;
    target.g = _color.g;
    target.b = _color.b;
    return target;
  }
  getStyle(colorSpace = SRGBColorSpace) {
    ColorManagement.fromWorkingColorSpace(_color.copy(this), colorSpace);
    const r2 = _color.r, g2 = _color.g, b2 = _color.b;
    if (colorSpace !== SRGBColorSpace) {
      return `color(${colorSpace} ${r2.toFixed(3)} ${g2.toFixed(3)} ${b2.toFixed(3)})`;
    }
    return `rgb(${Math.round(r2 * 255)},${Math.round(g2 * 255)},${Math.round(b2 * 255)})`;
  }
  offsetHSL(h2, s2, l2) {
    this.getHSL(_hslA);
    _hslA.h += h2;
    _hslA.s += s2;
    _hslA.l += l2;
    this.setHSL(_hslA.h, _hslA.s, _hslA.l);
    return this;
  }
  add(color) {
    this.r += color.r;
    this.g += color.g;
    this.b += color.b;
    return this;
  }
  addColors(color1, color2) {
    this.r = color1.r + color2.r;
    this.g = color1.g + color2.g;
    this.b = color1.b + color2.b;
    return this;
  }
  addScalar(s2) {
    this.r += s2;
    this.g += s2;
    this.b += s2;
    return this;
  }
  sub(color) {
    this.r = Math.max(0, this.r - color.r);
    this.g = Math.max(0, this.g - color.g);
    this.b = Math.max(0, this.b - color.b);
    return this;
  }
  multiply(color) {
    this.r *= color.r;
    this.g *= color.g;
    this.b *= color.b;
    return this;
  }
  multiplyScalar(s2) {
    this.r *= s2;
    this.g *= s2;
    this.b *= s2;
    return this;
  }
  lerp(color, alpha) {
    this.r += (color.r - this.r) * alpha;
    this.g += (color.g - this.g) * alpha;
    this.b += (color.b - this.b) * alpha;
    return this;
  }
  lerpColors(color1, color2, alpha) {
    this.r = color1.r + (color2.r - color1.r) * alpha;
    this.g = color1.g + (color2.g - color1.g) * alpha;
    this.b = color1.b + (color2.b - color1.b) * alpha;
    return this;
  }
  lerpHSL(color, alpha) {
    this.getHSL(_hslA);
    color.getHSL(_hslB);
    const h2 = lerp(_hslA.h, _hslB.h, alpha);
    const s2 = lerp(_hslA.s, _hslB.s, alpha);
    const l2 = lerp(_hslA.l, _hslB.l, alpha);
    this.setHSL(h2, s2, l2);
    return this;
  }
  setFromVector3(v2) {
    this.r = v2.x;
    this.g = v2.y;
    this.b = v2.z;
    return this;
  }
  applyMatrix3(m2) {
    const r2 = this.r, g2 = this.g, b2 = this.b;
    const e2 = m2.elements;
    this.r = e2[0] * r2 + e2[3] * g2 + e2[6] * b2;
    this.g = e2[1] * r2 + e2[4] * g2 + e2[7] * b2;
    this.b = e2[2] * r2 + e2[5] * g2 + e2[8] * b2;
    return this;
  }
  equals(c2) {
    return c2.r === this.r && c2.g === this.g && c2.b === this.b;
  }
  fromArray(array, offset = 0) {
    this.r = array[offset];
    this.g = array[offset + 1];
    this.b = array[offset + 2];
    return this;
  }
  toArray(array = [], offset = 0) {
    array[offset] = this.r;
    array[offset + 1] = this.g;
    array[offset + 2] = this.b;
    return array;
  }
  fromBufferAttribute(attribute, index) {
    this.r = attribute.getX(index);
    this.g = attribute.getY(index);
    this.b = attribute.getZ(index);
    return this;
  }
  toJSON() {
    return this.getHex();
  }
  *[Symbol.iterator]() {
    yield this.r;
    yield this.g;
    yield this.b;
  }
};
var _color = new Color();
Color.NAMES = _colorKeywords;
var MeshBasicMaterial = class extends Material {
  constructor(parameters) {
    super();
    this.isMeshBasicMaterial = true;
    this.type = "MeshBasicMaterial";
    this.color = new Color(16777215);
    this.map = null;
    this.lightMap = null;
    this.lightMapIntensity = 1;
    this.aoMap = null;
    this.aoMapIntensity = 1;
    this.specularMap = null;
    this.alphaMap = null;
    this.envMap = null;
    this.combine = MultiplyOperation;
    this.reflectivity = 1;
    this.refractionRatio = 0.98;
    this.wireframe = false;
    this.wireframeLinewidth = 1;
    this.wireframeLinecap = "round";
    this.wireframeLinejoin = "round";
    this.fog = true;
    this.setValues(parameters);
  }
  copy(source) {
    super.copy(source);
    this.color.copy(source.color);
    this.map = source.map;
    this.lightMap = source.lightMap;
    this.lightMapIntensity = source.lightMapIntensity;
    this.aoMap = source.aoMap;
    this.aoMapIntensity = source.aoMapIntensity;
    this.specularMap = source.specularMap;
    this.alphaMap = source.alphaMap;
    this.envMap = source.envMap;
    this.combine = source.combine;
    this.reflectivity = source.reflectivity;
    this.refractionRatio = source.refractionRatio;
    this.wireframe = source.wireframe;
    this.wireframeLinewidth = source.wireframeLinewidth;
    this.wireframeLinecap = source.wireframeLinecap;
    this.wireframeLinejoin = source.wireframeLinejoin;
    this.fog = source.fog;
    return this;
  }
};
var _tables = _generateTables();
function _generateTables() {
  const buffer = new ArrayBuffer(4);
  const floatView = new Float32Array(buffer);
  const uint32View = new Uint32Array(buffer);
  const baseTable = new Uint32Array(512);
  const shiftTable = new Uint32Array(512);
  for (let i2 = 0; i2 < 256; ++i2) {
    const e2 = i2 - 127;
    if (e2 < -27) {
      baseTable[i2] = 0;
      baseTable[i2 | 256] = 32768;
      shiftTable[i2] = 24;
      shiftTable[i2 | 256] = 24;
    } else if (e2 < -14) {
      baseTable[i2] = 1024 >> -e2 - 14;
      baseTable[i2 | 256] = 1024 >> -e2 - 14 | 32768;
      shiftTable[i2] = -e2 - 1;
      shiftTable[i2 | 256] = -e2 - 1;
    } else if (e2 <= 15) {
      baseTable[i2] = e2 + 15 << 10;
      baseTable[i2 | 256] = e2 + 15 << 10 | 32768;
      shiftTable[i2] = 13;
      shiftTable[i2 | 256] = 13;
    } else if (e2 < 128) {
      baseTable[i2] = 31744;
      baseTable[i2 | 256] = 64512;
      shiftTable[i2] = 24;
      shiftTable[i2 | 256] = 24;
    } else {
      baseTable[i2] = 31744;
      baseTable[i2 | 256] = 64512;
      shiftTable[i2] = 13;
      shiftTable[i2 | 256] = 13;
    }
  }
  const mantissaTable = new Uint32Array(2048);
  const exponentTable = new Uint32Array(64);
  const offsetTable = new Uint32Array(64);
  for (let i2 = 1; i2 < 1024; ++i2) {
    let m2 = i2 << 13;
    let e2 = 0;
    while ((m2 & 8388608) === 0) {
      m2 <<= 1;
      e2 -= 8388608;
    }
    m2 &= ~8388608;
    e2 += 947912704;
    mantissaTable[i2] = m2 | e2;
  }
  for (let i2 = 1024; i2 < 2048; ++i2) {
    mantissaTable[i2] = 939524096 + (i2 - 1024 << 13);
  }
  for (let i2 = 1; i2 < 31; ++i2) {
    exponentTable[i2] = i2 << 23;
  }
  exponentTable[31] = 1199570944;
  exponentTable[32] = 2147483648;
  for (let i2 = 33; i2 < 63; ++i2) {
    exponentTable[i2] = 2147483648 + (i2 - 32 << 23);
  }
  exponentTable[63] = 3347054592;
  for (let i2 = 1; i2 < 64; ++i2) {
    if (i2 !== 32) {
      offsetTable[i2] = 1024;
    }
  }
  return {
    floatView,
    uint32View,
    baseTable,
    shiftTable,
    mantissaTable,
    exponentTable,
    offsetTable
  };
}
function toHalfFloat(val) {
  if (Math.abs(val) > 65504) console.warn("THREE.DataUtils.toHalfFloat(): Value out of range.");
  val = clamp(val, -65504, 65504);
  _tables.floatView[0] = val;
  const f2 = _tables.uint32View[0];
  const e2 = f2 >> 23 & 511;
  return _tables.baseTable[e2] + ((f2 & 8388607) >> _tables.shiftTable[e2]);
}
function fromHalfFloat(val) {
  const m2 = val >> 10;
  _tables.uint32View[0] = _tables.mantissaTable[_tables.offsetTable[m2] + (val & 1023)] + _tables.exponentTable[m2];
  return _tables.floatView[0];
}
var DataUtils = {
  toHalfFloat,
  fromHalfFloat
};
var _vector$8 = new Vector3();
var _vector2$1 = new Vector2();
var BufferAttribute = class {
  constructor(array, itemSize, normalized = false) {
    if (Array.isArray(array)) {
      throw new TypeError("THREE.BufferAttribute: array should be a Typed Array.");
    }
    this.isBufferAttribute = true;
    this.name = "";
    this.array = array;
    this.itemSize = itemSize;
    this.count = array !== void 0 ? array.length / itemSize : 0;
    this.normalized = normalized;
    this.usage = StaticDrawUsage;
    this.updateRange = { offset: 0, count: -1 };
    this.gpuType = FloatType;
    this.version = 0;
  }
  onUploadCallback() {
  }
  set needsUpdate(value) {
    if (value === true) this.version++;
  }
  setUsage(value) {
    this.usage = value;
    return this;
  }
  copy(source) {
    this.name = source.name;
    this.array = new source.array.constructor(source.array);
    this.itemSize = source.itemSize;
    this.count = source.count;
    this.normalized = source.normalized;
    this.usage = source.usage;
    this.gpuType = source.gpuType;
    return this;
  }
  copyAt(index1, attribute, index2) {
    index1 *= this.itemSize;
    index2 *= attribute.itemSize;
    for (let i2 = 0, l2 = this.itemSize; i2 < l2; i2++) {
      this.array[index1 + i2] = attribute.array[index2 + i2];
    }
    return this;
  }
  copyArray(array) {
    this.array.set(array);
    return this;
  }
  applyMatrix3(m2) {
    if (this.itemSize === 2) {
      for (let i2 = 0, l2 = this.count; i2 < l2; i2++) {
        _vector2$1.fromBufferAttribute(this, i2);
        _vector2$1.applyMatrix3(m2);
        this.setXY(i2, _vector2$1.x, _vector2$1.y);
      }
    } else if (this.itemSize === 3) {
      for (let i2 = 0, l2 = this.count; i2 < l2; i2++) {
        _vector$8.fromBufferAttribute(this, i2);
        _vector$8.applyMatrix3(m2);
        this.setXYZ(i2, _vector$8.x, _vector$8.y, _vector$8.z);
      }
    }
    return this;
  }
  applyMatrix4(m2) {
    for (let i2 = 0, l2 = this.count; i2 < l2; i2++) {
      _vector$8.fromBufferAttribute(this, i2);
      _vector$8.applyMatrix4(m2);
      this.setXYZ(i2, _vector$8.x, _vector$8.y, _vector$8.z);
    }
    return this;
  }
  applyNormalMatrix(m2) {
    for (let i2 = 0, l2 = this.count; i2 < l2; i2++) {
      _vector$8.fromBufferAttribute(this, i2);
      _vector$8.applyNormalMatrix(m2);
      this.setXYZ(i2, _vector$8.x, _vector$8.y, _vector$8.z);
    }
    return this;
  }
  transformDirection(m2) {
    for (let i2 = 0, l2 = this.count; i2 < l2; i2++) {
      _vector$8.fromBufferAttribute(this, i2);
      _vector$8.transformDirection(m2);
      this.setXYZ(i2, _vector$8.x, _vector$8.y, _vector$8.z);
    }
    return this;
  }
  set(value, offset = 0) {
    this.array.set(value, offset);
    return this;
  }
  getX(index) {
    let x3 = this.array[index * this.itemSize];
    if (this.normalized) x3 = denormalize(x3, this.array);
    return x3;
  }
  setX(index, x3) {
    if (this.normalized) x3 = normalize(x3, this.array);
    this.array[index * this.itemSize] = x3;
    return this;
  }
  getY(index) {
    let y2 = this.array[index * this.itemSize + 1];
    if (this.normalized) y2 = denormalize(y2, this.array);
    return y2;
  }
  setY(index, y2) {
    if (this.normalized) y2 = normalize(y2, this.array);
    this.array[index * this.itemSize + 1] = y2;
    return this;
  }
  getZ(index) {
    let z = this.array[index * this.itemSize + 2];
    if (this.normalized) z = denormalize(z, this.array);
    return z;
  }
  setZ(index, z) {
    if (this.normalized) z = normalize(z, this.array);
    this.array[index * this.itemSize + 2] = z;
    return this;
  }
  getW(index) {
    let w2 = this.array[index * this.itemSize + 3];
    if (this.normalized) w2 = denormalize(w2, this.array);
    return w2;
  }
  setW(index, w2) {
    if (this.normalized) w2 = normalize(w2, this.array);
    this.array[index * this.itemSize + 3] = w2;
    return this;
  }
  setXY(index, x3, y2) {
    index *= this.itemSize;
    if (this.normalized) {
      x3 = normalize(x3, this.array);
      y2 = normalize(y2, this.array);
    }
    this.array[index + 0] = x3;
    this.array[index + 1] = y2;
    return this;
  }
  setXYZ(index, x3, y2, z) {
    index *= this.itemSize;
    if (this.normalized) {
      x3 = normalize(x3, this.array);
      y2 = normalize(y2, this.array);
      z = normalize(z, this.array);
    }
    this.array[index + 0] = x3;
    this.array[index + 1] = y2;
    this.array[index + 2] = z;
    return this;
  }
  setXYZW(index, x3, y2, z, w2) {
    index *= this.itemSize;
    if (this.normalized) {
      x3 = normalize(x3, this.array);
      y2 = normalize(y2, this.array);
      z = normalize(z, this.array);
      w2 = normalize(w2, this.array);
    }
    this.array[index + 0] = x3;
    this.array[index + 1] = y2;
    this.array[index + 2] = z;
    this.array[index + 3] = w2;
    return this;
  }
  onUpload(callback) {
    this.onUploadCallback = callback;
    return this;
  }
  clone() {
    return new this.constructor(this.array, this.itemSize).copy(this);
  }
  toJSON() {
    const data = {
      itemSize: this.itemSize,
      type: this.array.constructor.name,
      array: Array.from(this.array),
      normalized: this.normalized
    };
    if (this.name !== "") data.name = this.name;
    if (this.usage !== StaticDrawUsage) data.usage = this.usage;
    if (this.updateRange.offset !== 0 || this.updateRange.count !== -1) data.updateRange = this.updateRange;
    return data;
  }
  copyColorsArray() {
    console.error("THREE.BufferAttribute: copyColorsArray() was removed in r144.");
  }
  copyVector2sArray() {
    console.error("THREE.BufferAttribute: copyVector2sArray() was removed in r144.");
  }
  copyVector3sArray() {
    console.error("THREE.BufferAttribute: copyVector3sArray() was removed in r144.");
  }
  copyVector4sArray() {
    console.error("THREE.BufferAttribute: copyVector4sArray() was removed in r144.");
  }
};
var Int8BufferAttribute = class extends BufferAttribute {
  constructor(array, itemSize, normalized) {
    super(new Int8Array(array), itemSize, normalized);
  }
};
var Uint8BufferAttribute = class extends BufferAttribute {
  constructor(array, itemSize, normalized) {
    super(new Uint8Array(array), itemSize, normalized);
  }
};
var Uint8ClampedBufferAttribute = class extends BufferAttribute {
  constructor(array, itemSize, normalized) {
    super(new Uint8ClampedArray(array), itemSize, normalized);
  }
};
var Int16BufferAttribute = class extends BufferAttribute {
  constructor(array, itemSize, normalized) {
    super(new Int16Array(array), itemSize, normalized);
  }
};
var Uint16BufferAttribute = class extends BufferAttribute {
  constructor(array, itemSize, normalized) {
    super(new Uint16Array(array), itemSize, normalized);
  }
};
var Int32BufferAttribute = class extends BufferAttribute {
  constructor(array, itemSize, normalized) {
    super(new Int32Array(array), itemSize, normalized);
  }
};
var Uint32BufferAttribute = class extends BufferAttribute {
  constructor(array, itemSize, normalized) {
    super(new Uint32Array(array), itemSize, normalized);
  }
};
var Float16BufferAttribute = class extends BufferAttribute {
  constructor(array, itemSize, normalized) {
    super(new Uint16Array(array), itemSize, normalized);
    this.isFloat16BufferAttribute = true;
  }
  getX(index) {
    let x3 = fromHalfFloat(this.array[index * this.itemSize]);
    if (this.normalized) x3 = denormalize(x3, this.array);
    return x3;
  }
  setX(index, x3) {
    if (this.normalized) x3 = normalize(x3, this.array);
    this.array[index * this.itemSize] = toHalfFloat(x3);
    return this;
  }
  getY(index) {
    let y2 = fromHalfFloat(this.array[index * this.itemSize + 1]);
    if (this.normalized) y2 = denormalize(y2, this.array);
    return y2;
  }
  setY(index, y2) {
    if (this.normalized) y2 = normalize(y2, this.array);
    this.array[index * this.itemSize + 1] = toHalfFloat(y2);
    return this;
  }
  getZ(index) {
    let z = fromHalfFloat(this.array[index * this.itemSize + 2]);
    if (this.normalized) z = denormalize(z, this.array);
    return z;
  }
  setZ(index, z) {
    if (this.normalized) z = normalize(z, this.array);
    this.array[index * this.itemSize + 2] = toHalfFloat(z);
    return this;
  }
  getW(index) {
    let w2 = fromHalfFloat(this.array[index * this.itemSize + 3]);
    if (this.normalized) w2 = denormalize(w2, this.array);
    return w2;
  }
  setW(index, w2) {
    if (this.normalized) w2 = normalize(w2, this.array);
    this.array[index * this.itemSize + 3] = toHalfFloat(w2);
    return this;
  }
  setXY(index, x3, y2) {
    index *= this.itemSize;
    if (this.normalized) {
      x3 = normalize(x3, this.array);
      y2 = normalize(y2, this.array);
    }
    this.array[index + 0] = toHalfFloat(x3);
    this.array[index + 1] = toHalfFloat(y2);
    return this;
  }
  setXYZ(index, x3, y2, z) {
    index *= this.itemSize;
    if (this.normalized) {
      x3 = normalize(x3, this.array);
      y2 = normalize(y2, this.array);
      z = normalize(z, this.array);
    }
    this.array[index + 0] = toHalfFloat(x3);
    this.array[index + 1] = toHalfFloat(y2);
    this.array[index + 2] = toHalfFloat(z);
    return this;
  }
  setXYZW(index, x3, y2, z, w2) {
    index *= this.itemSize;
    if (this.normalized) {
      x3 = normalize(x3, this.array);
      y2 = normalize(y2, this.array);
      z = normalize(z, this.array);
      w2 = normalize(w2, this.array);
    }
    this.array[index + 0] = toHalfFloat(x3);
    this.array[index + 1] = toHalfFloat(y2);
    this.array[index + 2] = toHalfFloat(z);
    this.array[index + 3] = toHalfFloat(w2);
    return this;
  }
};
var Float32BufferAttribute = class extends BufferAttribute {
  constructor(array, itemSize, normalized) {
    super(new Float32Array(array), itemSize, normalized);
  }
};
var Float64BufferAttribute = class extends BufferAttribute {
  constructor(array, itemSize, normalized) {
    super(new Float64Array(array), itemSize, normalized);
  }
};
var _id$1 = 0;
var _m1 = new Matrix4();
var _obj = new Object3D();
var _offset = new Vector3();
var _box$1 = new Box3();
var _boxMorphTargets = new Box3();
var _vector$7 = new Vector3();
var BufferGeometry = class _BufferGeometry extends EventDispatcher {
  constructor() {
    super();
    this.isBufferGeometry = true;
    Object.defineProperty(this, "id", { value: _id$1++ });
    this.uuid = generateUUID();
    this.name = "";
    this.type = "BufferGeometry";
    this.index = null;
    this.attributes = {};
    this.morphAttributes = {};
    this.morphTargetsRelative = false;
    this.groups = [];
    this.boundingBox = null;
    this.boundingSphere = null;
    this.drawRange = { start: 0, count: Infinity };
    this.userData = {};
  }
  getIndex() {
    return this.index;
  }
  setIndex(index) {
    if (Array.isArray(index)) {
      this.index = new (arrayNeedsUint32(index) ? Uint32BufferAttribute : Uint16BufferAttribute)(index, 1);
    } else {
      this.index = index;
    }
    return this;
  }
  getAttribute(name) {
    return this.attributes[name];
  }
  setAttribute(name, attribute) {
    this.attributes[name] = attribute;
    return this;
  }
  deleteAttribute(name) {
    delete this.attributes[name];
    return this;
  }
  hasAttribute(name) {
    return this.attributes[name] !== void 0;
  }
  addGroup(start, count, materialIndex = 0) {
    this.groups.push({
      start,
      count,
      materialIndex
    });
  }
  clearGroups() {
    this.groups = [];
  }
  setDrawRange(start, count) {
    this.drawRange.start = start;
    this.drawRange.count = count;
  }
  applyMatrix4(matrix) {
    const position = this.attributes.position;
    if (position !== void 0) {
      position.applyMatrix4(matrix);
      position.needsUpdate = true;
    }
    const normal = this.attributes.normal;
    if (normal !== void 0) {
      const normalMatrix = new Matrix3().getNormalMatrix(matrix);
      normal.applyNormalMatrix(normalMatrix);
      normal.needsUpdate = true;
    }
    const tangent = this.attributes.tangent;
    if (tangent !== void 0) {
      tangent.transformDirection(matrix);
      tangent.needsUpdate = true;
    }
    if (this.boundingBox !== null) {
      this.computeBoundingBox();
    }
    if (this.boundingSphere !== null) {
      this.computeBoundingSphere();
    }
    return this;
  }
  applyQuaternion(q) {
    _m1.makeRotationFromQuaternion(q);
    this.applyMatrix4(_m1);
    return this;
  }
  rotateX(angle) {
    _m1.makeRotationX(angle);
    this.applyMatrix4(_m1);
    return this;
  }
  rotateY(angle) {
    _m1.makeRotationY(angle);
    this.applyMatrix4(_m1);
    return this;
  }
  rotateZ(angle) {
    _m1.makeRotationZ(angle);
    this.applyMatrix4(_m1);
    return this;
  }
  translate(x3, y2, z) {
    _m1.makeTranslation(x3, y2, z);
    this.applyMatrix4(_m1);
    return this;
  }
  scale(x3, y2, z) {
    _m1.makeScale(x3, y2, z);
    this.applyMatrix4(_m1);
    return this;
  }
  lookAt(vector) {
    _obj.lookAt(vector);
    _obj.updateMatrix();
    this.applyMatrix4(_obj.matrix);
    return this;
  }
  center() {
    this.computeBoundingBox();
    this.boundingBox.getCenter(_offset).negate();
    this.translate(_offset.x, _offset.y, _offset.z);
    return this;
  }
  setFromPoints(points) {
    const position = [];
    for (let i2 = 0, l2 = points.length; i2 < l2; i2++) {
      const point = points[i2];
      position.push(point.x, point.y, point.z || 0);
    }
    this.setAttribute("position", new Float32BufferAttribute(position, 3));
    return this;
  }
  computeBoundingBox() {
    if (this.boundingBox === null) {
      this.boundingBox = new Box3();
    }
    const position = this.attributes.position;
    const morphAttributesPosition = this.morphAttributes.position;
    if (position && position.isGLBufferAttribute) {
      console.error('THREE.BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box. Alternatively set "mesh.frustumCulled" to "false".', this);
      this.boundingBox.set(
        new Vector3(-Infinity, -Infinity, -Infinity),
        new Vector3(Infinity, Infinity, Infinity)
      );
      return;
    }
    if (position !== void 0) {
      this.boundingBox.setFromBufferAttribute(position);
      if (morphAttributesPosition) {
        for (let i2 = 0, il = morphAttributesPosition.length; i2 < il; i2++) {
          const morphAttribute = morphAttributesPosition[i2];
          _box$1.setFromBufferAttribute(morphAttribute);
          if (this.morphTargetsRelative) {
            _vector$7.addVectors(this.boundingBox.min, _box$1.min);
            this.boundingBox.expandByPoint(_vector$7);
            _vector$7.addVectors(this.boundingBox.max, _box$1.max);
            this.boundingBox.expandByPoint(_vector$7);
          } else {
            this.boundingBox.expandByPoint(_box$1.min);
            this.boundingBox.expandByPoint(_box$1.max);
          }
        }
      }
    } else {
      this.boundingBox.makeEmpty();
    }
    if (isNaN(this.boundingBox.min.x) || isNaN(this.boundingBox.min.y) || isNaN(this.boundingBox.min.z)) {
      console.error('THREE.BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The "position" attribute is likely to have NaN values.', this);
    }
  }
  computeBoundingSphere() {
    if (this.boundingSphere === null) {
      this.boundingSphere = new Sphere();
    }
    const position = this.attributes.position;
    const morphAttributesPosition = this.morphAttributes.position;
    if (position && position.isGLBufferAttribute) {
      console.error('THREE.BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere. Alternatively set "mesh.frustumCulled" to "false".', this);
      this.boundingSphere.set(new Vector3(), Infinity);
      return;
    }
    if (position) {
      const center = this.boundingSphere.center;
      _box$1.setFromBufferAttribute(position);
      if (morphAttributesPosition) {
        for (let i2 = 0, il = morphAttributesPosition.length; i2 < il; i2++) {
          const morphAttribute = morphAttributesPosition[i2];
          _boxMorphTargets.setFromBufferAttribute(morphAttribute);
          if (this.morphTargetsRelative) {
            _vector$7.addVectors(_box$1.min, _boxMorphTargets.min);
            _box$1.expandByPoint(_vector$7);
            _vector$7.addVectors(_box$1.max, _boxMorphTargets.max);
            _box$1.expandByPoint(_vector$7);
          } else {
            _box$1.expandByPoint(_boxMorphTargets.min);
            _box$1.expandByPoint(_boxMorphTargets.max);
          }
        }
      }
      _box$1.getCenter(center);
      let maxRadiusSq = 0;
      for (let i2 = 0, il = position.count; i2 < il; i2++) {
        _vector$7.fromBufferAttribute(position, i2);
        maxRadiusSq = Math.max(maxRadiusSq, center.distanceToSquared(_vector$7));
      }
      if (morphAttributesPosition) {
        for (let i2 = 0, il = morphAttributesPosition.length; i2 < il; i2++) {
          const morphAttribute = morphAttributesPosition[i2];
          const morphTargetsRelative = this.morphTargetsRelative;
          for (let j = 0, jl = morphAttribute.count; j < jl; j++) {
            _vector$7.fromBufferAttribute(morphAttribute, j);
            if (morphTargetsRelative) {
              _offset.fromBufferAttribute(position, j);
              _vector$7.add(_offset);
            }
            maxRadiusSq = Math.max(maxRadiusSq, center.distanceToSquared(_vector$7));
          }
        }
      }
      this.boundingSphere.radius = Math.sqrt(maxRadiusSq);
      if (isNaN(this.boundingSphere.radius)) {
        console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.', this);
      }
    }
  }
  computeTangents() {
    const index = this.index;
    const attributes = this.attributes;
    if (index === null || attributes.position === void 0 || attributes.normal === void 0 || attributes.uv === void 0) {
      console.error("THREE.BufferGeometry: .computeTangents() failed. Missing required attributes (index, position, normal or uv)");
      return;
    }
    const indices = index.array;
    const positions = attributes.position.array;
    const normals = attributes.normal.array;
    const uvs = attributes.uv.array;
    const nVertices = positions.length / 3;
    if (this.hasAttribute("tangent") === false) {
      this.setAttribute("tangent", new BufferAttribute(new Float32Array(4 * nVertices), 4));
    }
    const tangents = this.getAttribute("tangent").array;
    const tan1 = [], tan2 = [];
    for (let i2 = 0; i2 < nVertices; i2++) {
      tan1[i2] = new Vector3();
      tan2[i2] = new Vector3();
    }
    const vA = new Vector3(), vB = new Vector3(), vC = new Vector3(), uvA = new Vector2(), uvB = new Vector2(), uvC = new Vector2(), sdir = new Vector3(), tdir = new Vector3();
    function handleTriangle(a2, b2, c2) {
      vA.fromArray(positions, a2 * 3);
      vB.fromArray(positions, b2 * 3);
      vC.fromArray(positions, c2 * 3);
      uvA.fromArray(uvs, a2 * 2);
      uvB.fromArray(uvs, b2 * 2);
      uvC.fromArray(uvs, c2 * 2);
      vB.sub(vA);
      vC.sub(vA);
      uvB.sub(uvA);
      uvC.sub(uvA);
      const r2 = 1 / (uvB.x * uvC.y - uvC.x * uvB.y);
      if (!isFinite(r2)) return;
      sdir.copy(vB).multiplyScalar(uvC.y).addScaledVector(vC, -uvB.y).multiplyScalar(r2);
      tdir.copy(vC).multiplyScalar(uvB.x).addScaledVector(vB, -uvC.x).multiplyScalar(r2);
      tan1[a2].add(sdir);
      tan1[b2].add(sdir);
      tan1[c2].add(sdir);
      tan2[a2].add(tdir);
      tan2[b2].add(tdir);
      tan2[c2].add(tdir);
    }
    let groups2 = this.groups;
    if (groups2.length === 0) {
      groups2 = [{
        start: 0,
        count: indices.length
      }];
    }
    for (let i2 = 0, il = groups2.length; i2 < il; ++i2) {
      const group = groups2[i2];
      const start = group.start;
      const count = group.count;
      for (let j = start, jl = start + count; j < jl; j += 3) {
        handleTriangle(
          indices[j + 0],
          indices[j + 1],
          indices[j + 2]
        );
      }
    }
    const tmp2 = new Vector3(), tmp22 = new Vector3();
    const n = new Vector3(), n2 = new Vector3();
    function handleVertex(v2) {
      n.fromArray(normals, v2 * 3);
      n2.copy(n);
      const t2 = tan1[v2];
      tmp2.copy(t2);
      tmp2.sub(n.multiplyScalar(n.dot(t2))).normalize();
      tmp22.crossVectors(n2, t2);
      const test = tmp22.dot(tan2[v2]);
      const w2 = test < 0 ? -1 : 1;
      tangents[v2 * 4] = tmp2.x;
      tangents[v2 * 4 + 1] = tmp2.y;
      tangents[v2 * 4 + 2] = tmp2.z;
      tangents[v2 * 4 + 3] = w2;
    }
    for (let i2 = 0, il = groups2.length; i2 < il; ++i2) {
      const group = groups2[i2];
      const start = group.start;
      const count = group.count;
      for (let j = start, jl = start + count; j < jl; j += 3) {
        handleVertex(indices[j + 0]);
        handleVertex(indices[j + 1]);
        handleVertex(indices[j + 2]);
      }
    }
  }
  computeVertexNormals() {
    const index = this.index;
    const positionAttribute = this.getAttribute("position");
    if (positionAttribute !== void 0) {
      let normalAttribute = this.getAttribute("normal");
      if (normalAttribute === void 0) {
        normalAttribute = new BufferAttribute(new Float32Array(positionAttribute.count * 3), 3);
        this.setAttribute("normal", normalAttribute);
      } else {
        for (let i2 = 0, il = normalAttribute.count; i2 < il; i2++) {
          normalAttribute.setXYZ(i2, 0, 0, 0);
        }
      }
      const pA = new Vector3(), pB = new Vector3(), pC = new Vector3();
      const nA = new Vector3(), nB = new Vector3(), nC = new Vector3();
      const cb = new Vector3(), ab = new Vector3();
      if (index) {
        for (let i2 = 0, il = index.count; i2 < il; i2 += 3) {
          const vA = index.getX(i2 + 0);
          const vB = index.getX(i2 + 1);
          const vC = index.getX(i2 + 2);
          pA.fromBufferAttribute(positionAttribute, vA);
          pB.fromBufferAttribute(positionAttribute, vB);
          pC.fromBufferAttribute(positionAttribute, vC);
          cb.subVectors(pC, pB);
          ab.subVectors(pA, pB);
          cb.cross(ab);
          nA.fromBufferAttribute(normalAttribute, vA);
          nB.fromBufferAttribute(normalAttribute, vB);
          nC.fromBufferAttribute(normalAttribute, vC);
          nA.add(cb);
          nB.add(cb);
          nC.add(cb);
          normalAttribute.setXYZ(vA, nA.x, nA.y, nA.z);
          normalAttribute.setXYZ(vB, nB.x, nB.y, nB.z);
          normalAttribute.setXYZ(vC, nC.x, nC.y, nC.z);
        }
      } else {
        for (let i2 = 0, il = positionAttribute.count; i2 < il; i2 += 3) {
          pA.fromBufferAttribute(positionAttribute, i2 + 0);
          pB.fromBufferAttribute(positionAttribute, i2 + 1);
          pC.fromBufferAttribute(positionAttribute, i2 + 2);
          cb.subVectors(pC, pB);
          ab.subVectors(pA, pB);
          cb.cross(ab);
          normalAttribute.setXYZ(i2 + 0, cb.x, cb.y, cb.z);
          normalAttribute.setXYZ(i2 + 1, cb.x, cb.y, cb.z);
          normalAttribute.setXYZ(i2 + 2, cb.x, cb.y, cb.z);
        }
      }
      this.normalizeNormals();
      normalAttribute.needsUpdate = true;
    }
  }
  merge() {
    console.error("THREE.BufferGeometry.merge() has been removed. Use THREE.BufferGeometryUtils.mergeGeometries() instead.");
    return this;
  }
  normalizeNormals() {
    const normals = this.attributes.normal;
    for (let i2 = 0, il = normals.count; i2 < il; i2++) {
      _vector$7.fromBufferAttribute(normals, i2);
      _vector$7.normalize();
      normals.setXYZ(i2, _vector$7.x, _vector$7.y, _vector$7.z);
    }
  }
  toNonIndexed() {
    function convertBufferAttribute(attribute, indices2) {
      const array = attribute.array;
      const itemSize = attribute.itemSize;
      const normalized = attribute.normalized;
      const array2 = new array.constructor(indices2.length * itemSize);
      let index = 0, index2 = 0;
      for (let i2 = 0, l2 = indices2.length; i2 < l2; i2++) {
        if (attribute.isInterleavedBufferAttribute) {
          index = indices2[i2] * attribute.data.stride + attribute.offset;
        } else {
          index = indices2[i2] * itemSize;
        }
        for (let j = 0; j < itemSize; j++) {
          array2[index2++] = array[index++];
        }
      }
      return new BufferAttribute(array2, itemSize, normalized);
    }
    if (this.index === null) {
      console.warn("THREE.BufferGeometry.toNonIndexed(): BufferGeometry is already non-indexed.");
      return this;
    }
    const geometry2 = new _BufferGeometry();
    const indices = this.index.array;
    const attributes = this.attributes;
    for (const name in attributes) {
      const attribute = attributes[name];
      const newAttribute = convertBufferAttribute(attribute, indices);
      geometry2.setAttribute(name, newAttribute);
    }
    const morphAttributes = this.morphAttributes;
    for (const name in morphAttributes) {
      const morphArray = [];
      const morphAttribute = morphAttributes[name];
      for (let i2 = 0, il = morphAttribute.length; i2 < il; i2++) {
        const attribute = morphAttribute[i2];
        const newAttribute = convertBufferAttribute(attribute, indices);
        morphArray.push(newAttribute);
      }
      geometry2.morphAttributes[name] = morphArray;
    }
    geometry2.morphTargetsRelative = this.morphTargetsRelative;
    const groups2 = this.groups;
    for (let i2 = 0, l2 = groups2.length; i2 < l2; i2++) {
      const group = groups2[i2];
      geometry2.addGroup(group.start, group.count, group.materialIndex);
    }
    return geometry2;
  }
  toJSON() {
    const data = {
      metadata: {
        version: 4.6,
        type: "BufferGeometry",
        generator: "BufferGeometry.toJSON"
      }
    };
    data.uuid = this.uuid;
    data.type = this.type;
    if (this.name !== "") data.name = this.name;
    if (Object.keys(this.userData).length > 0) data.userData = this.userData;
    if (this.parameters !== void 0) {
      const parameters = this.parameters;
      for (const key in parameters) {
        if (parameters[key] !== void 0) data[key] = parameters[key];
      }
      return data;
    }
    data.data = { attributes: {} };
    const index = this.index;
    if (index !== null) {
      data.data.index = {
        type: index.array.constructor.name,
        array: Array.prototype.slice.call(index.array)
      };
    }
    const attributes = this.attributes;
    for (const key in attributes) {
      const attribute = attributes[key];
      data.data.attributes[key] = attribute.toJSON(data.data);
    }
    const morphAttributes = {};
    let hasMorphAttributes = false;
    for (const key in this.morphAttributes) {
      const attributeArray = this.morphAttributes[key];
      const array = [];
      for (let i2 = 0, il = attributeArray.length; i2 < il; i2++) {
        const attribute = attributeArray[i2];
        array.push(attribute.toJSON(data.data));
      }
      if (array.length > 0) {
        morphAttributes[key] = array;
        hasMorphAttributes = true;
      }
    }
    if (hasMorphAttributes) {
      data.data.morphAttributes = morphAttributes;
      data.data.morphTargetsRelative = this.morphTargetsRelative;
    }
    const groups2 = this.groups;
    if (groups2.length > 0) {
      data.data.groups = JSON.parse(JSON.stringify(groups2));
    }
    const boundingSphere = this.boundingSphere;
    if (boundingSphere !== null) {
      data.data.boundingSphere = {
        center: boundingSphere.center.toArray(),
        radius: boundingSphere.radius
      };
    }
    return data;
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(source) {
    this.index = null;
    this.attributes = {};
    this.morphAttributes = {};
    this.groups = [];
    this.boundingBox = null;
    this.boundingSphere = null;
    const data = {};
    this.name = source.name;
    const index = source.index;
    if (index !== null) {
      this.setIndex(index.clone(data));
    }
    const attributes = source.attributes;
    for (const name in attributes) {
      const attribute = attributes[name];
      this.setAttribute(name, attribute.clone(data));
    }
    const morphAttributes = source.morphAttributes;
    for (const name in morphAttributes) {
      const array = [];
      const morphAttribute = morphAttributes[name];
      for (let i2 = 0, l2 = morphAttribute.length; i2 < l2; i2++) {
        array.push(morphAttribute[i2].clone(data));
      }
      this.morphAttributes[name] = array;
    }
    this.morphTargetsRelative = source.morphTargetsRelative;
    const groups2 = source.groups;
    for (let i2 = 0, l2 = groups2.length; i2 < l2; i2++) {
      const group = groups2[i2];
      this.addGroup(group.start, group.count, group.materialIndex);
    }
    const boundingBox = source.boundingBox;
    if (boundingBox !== null) {
      this.boundingBox = boundingBox.clone();
    }
    const boundingSphere = source.boundingSphere;
    if (boundingSphere !== null) {
      this.boundingSphere = boundingSphere.clone();
    }
    this.drawRange.start = source.drawRange.start;
    this.drawRange.count = source.drawRange.count;
    this.userData = source.userData;
    return this;
  }
  dispose() {
    this.dispatchEvent({ type: "dispose" });
  }
};
var _inverseMatrix$3 = new Matrix4();
var _ray$3 = new Ray();
var _sphere$5 = new Sphere();
var _sphereHitAt = new Vector3();
var _vA$1 = new Vector3();
var _vB$1 = new Vector3();
var _vC$1 = new Vector3();
var _tempA = new Vector3();
var _morphA = new Vector3();
var _uvA$1 = new Vector2();
var _uvB$1 = new Vector2();
var _uvC$1 = new Vector2();
var _normalA = new Vector3();
var _normalB = new Vector3();
var _normalC = new Vector3();
var _intersectionPoint = new Vector3();
var _intersectionPointWorld = new Vector3();
var Mesh = class extends Object3D {
  constructor(geometry = new BufferGeometry(), material = new MeshBasicMaterial()) {
    super();
    this.isMesh = true;
    this.type = "Mesh";
    this.geometry = geometry;
    this.material = material;
    this.updateMorphTargets();
  }
  copy(source, recursive) {
    super.copy(source, recursive);
    if (source.morphTargetInfluences !== void 0) {
      this.morphTargetInfluences = source.morphTargetInfluences.slice();
    }
    if (source.morphTargetDictionary !== void 0) {
      this.morphTargetDictionary = Object.assign({}, source.morphTargetDictionary);
    }
    this.material = source.material;
    this.geometry = source.geometry;
    return this;
  }
  updateMorphTargets() {
    const geometry = this.geometry;
    const morphAttributes = geometry.morphAttributes;
    const keys = Object.keys(morphAttributes);
    if (keys.length > 0) {
      const morphAttribute = morphAttributes[keys[0]];
      if (morphAttribute !== void 0) {
        this.morphTargetInfluences = [];
        this.morphTargetDictionary = {};
        for (let m2 = 0, ml = morphAttribute.length; m2 < ml; m2++) {
          const name = morphAttribute[m2].name || String(m2);
          this.morphTargetInfluences.push(0);
          this.morphTargetDictionary[name] = m2;
        }
      }
    }
  }
  getVertexPosition(index, target) {
    const geometry = this.geometry;
    const position = geometry.attributes.position;
    const morphPosition = geometry.morphAttributes.position;
    const morphTargetsRelative = geometry.morphTargetsRelative;
    target.fromBufferAttribute(position, index);
    const morphInfluences = this.morphTargetInfluences;
    if (morphPosition && morphInfluences) {
      _morphA.set(0, 0, 0);
      for (let i2 = 0, il = morphPosition.length; i2 < il; i2++) {
        const influence = morphInfluences[i2];
        const morphAttribute = morphPosition[i2];
        if (influence === 0) continue;
        _tempA.fromBufferAttribute(morphAttribute, index);
        if (morphTargetsRelative) {
          _morphA.addScaledVector(_tempA, influence);
        } else {
          _morphA.addScaledVector(_tempA.sub(target), influence);
        }
      }
      target.add(_morphA);
    }
    return target;
  }
  raycast(raycaster, intersects2) {
    const geometry = this.geometry;
    const material = this.material;
    const matrixWorld = this.matrixWorld;
    if (material === void 0) return;
    if (geometry.boundingSphere === null) geometry.computeBoundingSphere();
    _sphere$5.copy(geometry.boundingSphere);
    _sphere$5.applyMatrix4(matrixWorld);
    _ray$3.copy(raycaster.ray).recast(raycaster.near);
    if (_sphere$5.containsPoint(_ray$3.origin) === false) {
      if (_ray$3.intersectSphere(_sphere$5, _sphereHitAt) === null) return;
      if (_ray$3.origin.distanceToSquared(_sphereHitAt) > (raycaster.far - raycaster.near) ** 2) return;
    }
    _inverseMatrix$3.copy(matrixWorld).invert();
    _ray$3.copy(raycaster.ray).applyMatrix4(_inverseMatrix$3);
    if (geometry.boundingBox !== null) {
      if (_ray$3.intersectsBox(geometry.boundingBox) === false) return;
    }
    this._computeIntersections(raycaster, intersects2, _ray$3);
  }
  _computeIntersections(raycaster, intersects2, rayLocalSpace) {
    let intersection;
    const geometry = this.geometry;
    const material = this.material;
    const index = geometry.index;
    const position = geometry.attributes.position;
    const uv = geometry.attributes.uv;
    const uv1 = geometry.attributes.uv1;
    const normal = geometry.attributes.normal;
    const groups2 = geometry.groups;
    const drawRange = geometry.drawRange;
    if (index !== null) {
      if (Array.isArray(material)) {
        for (let i2 = 0, il = groups2.length; i2 < il; i2++) {
          const group = groups2[i2];
          const groupMaterial = material[group.materialIndex];
          const start = Math.max(group.start, drawRange.start);
          const end = Math.min(index.count, Math.min(group.start + group.count, drawRange.start + drawRange.count));
          for (let j = start, jl = end; j < jl; j += 3) {
            const a2 = index.getX(j);
            const b2 = index.getX(j + 1);
            const c2 = index.getX(j + 2);
            intersection = checkGeometryIntersection(this, groupMaterial, raycaster, rayLocalSpace, uv, uv1, normal, a2, b2, c2);
            if (intersection) {
              intersection.faceIndex = Math.floor(j / 3);
              intersection.face.materialIndex = group.materialIndex;
              intersects2.push(intersection);
            }
          }
        }
      } else {
        const start = Math.max(0, drawRange.start);
        const end = Math.min(index.count, drawRange.start + drawRange.count);
        for (let i2 = start, il = end; i2 < il; i2 += 3) {
          const a2 = index.getX(i2);
          const b2 = index.getX(i2 + 1);
          const c2 = index.getX(i2 + 2);
          intersection = checkGeometryIntersection(this, material, raycaster, rayLocalSpace, uv, uv1, normal, a2, b2, c2);
          if (intersection) {
            intersection.faceIndex = Math.floor(i2 / 3);
            intersects2.push(intersection);
          }
        }
      }
    } else if (position !== void 0) {
      if (Array.isArray(material)) {
        for (let i2 = 0, il = groups2.length; i2 < il; i2++) {
          const group = groups2[i2];
          const groupMaterial = material[group.materialIndex];
          const start = Math.max(group.start, drawRange.start);
          const end = Math.min(position.count, Math.min(group.start + group.count, drawRange.start + drawRange.count));
          for (let j = start, jl = end; j < jl; j += 3) {
            const a2 = j;
            const b2 = j + 1;
            const c2 = j + 2;
            intersection = checkGeometryIntersection(this, groupMaterial, raycaster, rayLocalSpace, uv, uv1, normal, a2, b2, c2);
            if (intersection) {
              intersection.faceIndex = Math.floor(j / 3);
              intersection.face.materialIndex = group.materialIndex;
              intersects2.push(intersection);
            }
          }
        }
      } else {
        const start = Math.max(0, drawRange.start);
        const end = Math.min(position.count, drawRange.start + drawRange.count);
        for (let i2 = start, il = end; i2 < il; i2 += 3) {
          const a2 = i2;
          const b2 = i2 + 1;
          const c2 = i2 + 2;
          intersection = checkGeometryIntersection(this, material, raycaster, rayLocalSpace, uv, uv1, normal, a2, b2, c2);
          if (intersection) {
            intersection.faceIndex = Math.floor(i2 / 3);
            intersects2.push(intersection);
          }
        }
      }
    }
  }
};
function checkIntersection(object, material, raycaster, ray, pA, pB, pC, point) {
  let intersect;
  if (material.side === BackSide) {
    intersect = ray.intersectTriangle(pC, pB, pA, true, point);
  } else {
    intersect = ray.intersectTriangle(pA, pB, pC, material.side === FrontSide, point);
  }
  if (intersect === null) return null;
  _intersectionPointWorld.copy(point);
  _intersectionPointWorld.applyMatrix4(object.matrixWorld);
  const distance = raycaster.ray.origin.distanceTo(_intersectionPointWorld);
  if (distance < raycaster.near || distance > raycaster.far) return null;
  return {
    distance,
    point: _intersectionPointWorld.clone(),
    object
  };
}
function checkGeometryIntersection(object, material, raycaster, ray, uv, uv1, normal, a2, b2, c2) {
  object.getVertexPosition(a2, _vA$1);
  object.getVertexPosition(b2, _vB$1);
  object.getVertexPosition(c2, _vC$1);
  const intersection = checkIntersection(object, material, raycaster, ray, _vA$1, _vB$1, _vC$1, _intersectionPoint);
  if (intersection) {
    if (uv) {
      _uvA$1.fromBufferAttribute(uv, a2);
      _uvB$1.fromBufferAttribute(uv, b2);
      _uvC$1.fromBufferAttribute(uv, c2);
      intersection.uv = Triangle.getInterpolation(_intersectionPoint, _vA$1, _vB$1, _vC$1, _uvA$1, _uvB$1, _uvC$1, new Vector2());
    }
    if (uv1) {
      _uvA$1.fromBufferAttribute(uv1, a2);
      _uvB$1.fromBufferAttribute(uv1, b2);
      _uvC$1.fromBufferAttribute(uv1, c2);
      intersection.uv1 = Triangle.getInterpolation(_intersectionPoint, _vA$1, _vB$1, _vC$1, _uvA$1, _uvB$1, _uvC$1, new Vector2());
      intersection.uv2 = intersection.uv1;
    }
    if (normal) {
      _normalA.fromBufferAttribute(normal, a2);
      _normalB.fromBufferAttribute(normal, b2);
      _normalC.fromBufferAttribute(normal, c2);
      intersection.normal = Triangle.getInterpolation(_intersectionPoint, _vA$1, _vB$1, _vC$1, _normalA, _normalB, _normalC, new Vector3());
      if (intersection.normal.dot(ray.direction) > 0) {
        intersection.normal.multiplyScalar(-1);
      }
    }
    const face = {
      a: a2,
      b: b2,
      c: c2,
      normal: new Vector3(),
      materialIndex: 0
    };
    Triangle.getNormal(_vA$1, _vB$1, _vC$1, face.normal);
    intersection.face = face;
  }
  return intersection;
}
var BoxGeometry = class _BoxGeometry extends BufferGeometry {
  constructor(width = 1, height = 1, depth = 1, widthSegments = 1, heightSegments = 1, depthSegments = 1) {
    super();
    this.type = "BoxGeometry";
    this.parameters = {
      width,
      height,
      depth,
      widthSegments,
      heightSegments,
      depthSegments
    };
    const scope = this;
    widthSegments = Math.floor(widthSegments);
    heightSegments = Math.floor(heightSegments);
    depthSegments = Math.floor(depthSegments);
    const indices = [];
    const vertices = [];
    const normals = [];
    const uvs = [];
    let numberOfVertices = 0;
    let groupStart = 0;
    buildPlane("z", "y", "x", -1, -1, depth, height, width, depthSegments, heightSegments, 0);
    buildPlane("z", "y", "x", 1, -1, depth, height, -width, depthSegments, heightSegments, 1);
    buildPlane("x", "z", "y", 1, 1, width, depth, height, widthSegments, depthSegments, 2);
    buildPlane("x", "z", "y", 1, -1, width, depth, -height, widthSegments, depthSegments, 3);
    buildPlane("x", "y", "z", 1, -1, width, height, depth, widthSegments, heightSegments, 4);
    buildPlane("x", "y", "z", -1, -1, width, height, -depth, widthSegments, heightSegments, 5);
    this.setIndex(indices);
    this.setAttribute("position", new Float32BufferAttribute(vertices, 3));
    this.setAttribute("normal", new Float32BufferAttribute(normals, 3));
    this.setAttribute("uv", new Float32BufferAttribute(uvs, 2));
    function buildPlane(u2, v2, w2, udir, vdir, width2, height2, depth2, gridX, gridY, materialIndex) {
      const segmentWidth = width2 / gridX;
      const segmentHeight = height2 / gridY;
      const widthHalf = width2 / 2;
      const heightHalf = height2 / 2;
      const depthHalf = depth2 / 2;
      const gridX1 = gridX + 1;
      const gridY1 = gridY + 1;
      let vertexCounter = 0;
      let groupCount = 0;
      const vector = new Vector3();
      for (let iy = 0; iy < gridY1; iy++) {
        const y2 = iy * segmentHeight - heightHalf;
        for (let ix = 0; ix < gridX1; ix++) {
          const x3 = ix * segmentWidth - widthHalf;
          vector[u2] = x3 * udir;
          vector[v2] = y2 * vdir;
          vector[w2] = depthHalf;
          vertices.push(vector.x, vector.y, vector.z);
          vector[u2] = 0;
          vector[v2] = 0;
          vector[w2] = depth2 > 0 ? 1 : -1;
          normals.push(vector.x, vector.y, vector.z);
          uvs.push(ix / gridX);
          uvs.push(1 - iy / gridY);
          vertexCounter += 1;
        }
      }
      for (let iy = 0; iy < gridY; iy++) {
        for (let ix = 0; ix < gridX; ix++) {
          const a2 = numberOfVertices + ix + gridX1 * iy;
          const b2 = numberOfVertices + ix + gridX1 * (iy + 1);
          const c2 = numberOfVertices + (ix + 1) + gridX1 * (iy + 1);
          const d2 = numberOfVertices + (ix + 1) + gridX1 * iy;
          indices.push(a2, b2, d2);
          indices.push(b2, c2, d2);
          groupCount += 6;
        }
      }
      scope.addGroup(groupStart, groupCount, materialIndex);
      groupStart += groupCount;
      numberOfVertices += vertexCounter;
    }
  }
  copy(source) {
    super.copy(source);
    this.parameters = Object.assign({}, source.parameters);
    return this;
  }
  static fromJSON(data) {
    return new _BoxGeometry(data.width, data.height, data.depth, data.widthSegments, data.heightSegments, data.depthSegments);
  }
};
function cloneUniforms(src2) {
  const dst = {};
  for (const u2 in src2) {
    dst[u2] = {};
    for (const p2 in src2[u2]) {
      const property = src2[u2][p2];
      if (property && (property.isColor || property.isMatrix3 || property.isMatrix4 || property.isVector2 || property.isVector3 || property.isVector4 || property.isTexture || property.isQuaternion)) {
        if (property.isRenderTargetTexture) {
          console.warn("UniformsUtils: Textures of render targets cannot be cloned via cloneUniforms() or mergeUniforms().");
          dst[u2][p2] = null;
        } else {
          dst[u2][p2] = property.clone();
        }
      } else if (Array.isArray(property)) {
        dst[u2][p2] = property.slice();
      } else {
        dst[u2][p2] = property;
      }
    }
  }
  return dst;
}
function mergeUniforms(uniforms) {
  const merged = {};
  for (let u2 = 0; u2 < uniforms.length; u2++) {
    const tmp2 = cloneUniforms(uniforms[u2]);
    for (const p2 in tmp2) {
      merged[p2] = tmp2[p2];
    }
  }
  return merged;
}
function cloneUniformsGroups(src2) {
  const dst = [];
  for (let u2 = 0; u2 < src2.length; u2++) {
    dst.push(src2[u2].clone());
  }
  return dst;
}
function getUnlitUniformColorSpace(renderer) {
  if (renderer.getRenderTarget() === null) {
    return renderer.outputColorSpace;
  }
  return LinearSRGBColorSpace;
}
var UniformsUtils = { clone: cloneUniforms, merge: mergeUniforms };
var default_vertex = "void main() {\n	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}";
var default_fragment = "void main() {\n	gl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );\n}";
var ShaderMaterial = class extends Material {
  constructor(parameters) {
    super();
    this.isShaderMaterial = true;
    this.type = "ShaderMaterial";
    this.defines = {};
    this.uniforms = {};
    this.uniformsGroups = [];
    this.vertexShader = default_vertex;
    this.fragmentShader = default_fragment;
    this.linewidth = 1;
    this.wireframe = false;
    this.wireframeLinewidth = 1;
    this.fog = false;
    this.lights = false;
    this.clipping = false;
    this.forceSinglePass = true;
    this.extensions = {
      derivatives: false,
      // set to use derivatives
      fragDepth: false,
      // set to use fragment depth values
      drawBuffers: false,
      // set to use draw buffers
      shaderTextureLOD: false
      // set to use shader texture LOD
    };
    this.defaultAttributeValues = {
      "color": [1, 1, 1],
      "uv": [0, 0],
      "uv1": [0, 0]
    };
    this.index0AttributeName = void 0;
    this.uniformsNeedUpdate = false;
    this.glslVersion = null;
    if (parameters !== void 0) {
      this.setValues(parameters);
    }
  }
  copy(source) {
    super.copy(source);
    this.fragmentShader = source.fragmentShader;
    this.vertexShader = source.vertexShader;
    this.uniforms = cloneUniforms(source.uniforms);
    this.uniformsGroups = cloneUniformsGroups(source.uniformsGroups);
    this.defines = Object.assign({}, source.defines);
    this.wireframe = source.wireframe;
    this.wireframeLinewidth = source.wireframeLinewidth;
    this.fog = source.fog;
    this.lights = source.lights;
    this.clipping = source.clipping;
    this.extensions = Object.assign({}, source.extensions);
    this.glslVersion = source.glslVersion;
    return this;
  }
  toJSON(meta) {
    const data = super.toJSON(meta);
    data.glslVersion = this.glslVersion;
    data.uniforms = {};
    for (const name in this.uniforms) {
      const uniform = this.uniforms[name];
      const value = uniform.value;
      if (value && value.isTexture) {
        data.uniforms[name] = {
          type: "t",
          value: value.toJSON(meta).uuid
        };
      } else if (value && value.isColor) {
        data.uniforms[name] = {
          type: "c",
          value: value.getHex()
        };
      } else if (value && value.isVector2) {
        data.uniforms[name] = {
          type: "v2",
          value: value.toArray()
        };
      } else if (value && value.isVector3) {
        data.uniforms[name] = {
          type: "v3",
          value: value.toArray()
        };
      } else if (value && value.isVector4) {
        data.uniforms[name] = {
          type: "v4",
          value: value.toArray()
        };
      } else if (value && value.isMatrix3) {
        data.uniforms[name] = {
          type: "m3",
          value: value.toArray()
        };
      } else if (value && value.isMatrix4) {
        data.uniforms[name] = {
          type: "m4",
          value: value.toArray()
        };
      } else {
        data.uniforms[name] = {
          value
        };
      }
    }
    if (Object.keys(this.defines).length > 0) data.defines = this.defines;
    data.vertexShader = this.vertexShader;
    data.fragmentShader = this.fragmentShader;
    data.lights = this.lights;
    data.clipping = this.clipping;
    const extensions = {};
    for (const key in this.extensions) {
      if (this.extensions[key] === true) extensions[key] = true;
    }
    if (Object.keys(extensions).length > 0) data.extensions = extensions;
    return data;
  }
};
var Camera = class extends Object3D {
  constructor() {
    super();
    this.isCamera = true;
    this.type = "Camera";
    this.matrixWorldInverse = new Matrix4();
    this.projectionMatrix = new Matrix4();
    this.projectionMatrixInverse = new Matrix4();
    this.coordinateSystem = WebGLCoordinateSystem;
  }
  copy(source, recursive) {
    super.copy(source, recursive);
    this.matrixWorldInverse.copy(source.matrixWorldInverse);
    this.projectionMatrix.copy(source.projectionMatrix);
    this.projectionMatrixInverse.copy(source.projectionMatrixInverse);
    this.coordinateSystem = source.coordinateSystem;
    return this;
  }
  getWorldDirection(target) {
    this.updateWorldMatrix(true, false);
    const e2 = this.matrixWorld.elements;
    return target.set(-e2[8], -e2[9], -e2[10]).normalize();
  }
  updateMatrixWorld(force) {
    super.updateMatrixWorld(force);
    this.matrixWorldInverse.copy(this.matrixWorld).invert();
  }
  updateWorldMatrix(updateParents, updateChildren) {
    super.updateWorldMatrix(updateParents, updateChildren);
    this.matrixWorldInverse.copy(this.matrixWorld).invert();
  }
  clone() {
    return new this.constructor().copy(this);
  }
};
var PerspectiveCamera = class extends Camera {
  constructor(fov2 = 50, aspect2 = 1, near = 0.1, far = 2e3) {
    super();
    this.isPerspectiveCamera = true;
    this.type = "PerspectiveCamera";
    this.fov = fov2;
    this.zoom = 1;
    this.near = near;
    this.far = far;
    this.focus = 10;
    this.aspect = aspect2;
    this.view = null;
    this.filmGauge = 35;
    this.filmOffset = 0;
    this.updateProjectionMatrix();
  }
  copy(source, recursive) {
    super.copy(source, recursive);
    this.fov = source.fov;
    this.zoom = source.zoom;
    this.near = source.near;
    this.far = source.far;
    this.focus = source.focus;
    this.aspect = source.aspect;
    this.view = source.view === null ? null : Object.assign({}, source.view);
    this.filmGauge = source.filmGauge;
    this.filmOffset = source.filmOffset;
    return this;
  }
  /**
   * Sets the FOV by focal length in respect to the current .filmGauge.
   *
   * The default film gauge is 35, so that the focal length can be specified for
   * a 35mm (full frame) camera.
   *
   * Values for focal length and film gauge must have the same unit.
   */
  setFocalLength(focalLength) {
    const vExtentSlope = 0.5 * this.getFilmHeight() / focalLength;
    this.fov = RAD2DEG * 2 * Math.atan(vExtentSlope);
    this.updateProjectionMatrix();
  }
  /**
   * Calculates the focal length from the current .fov and .filmGauge.
   */
  getFocalLength() {
    const vExtentSlope = Math.tan(DEG2RAD * 0.5 * this.fov);
    return 0.5 * this.getFilmHeight() / vExtentSlope;
  }
  getEffectiveFOV() {
    return RAD2DEG * 2 * Math.atan(
      Math.tan(DEG2RAD * 0.5 * this.fov) / this.zoom
    );
  }
  getFilmWidth() {
    return this.filmGauge * Math.min(this.aspect, 1);
  }
  getFilmHeight() {
    return this.filmGauge / Math.max(this.aspect, 1);
  }
  /**
   * Sets an offset in a larger frustum. This is useful for multi-window or
   * multi-monitor/multi-machine setups.
   *
   * For example, if you have 3x2 monitors and each monitor is 1920x1080 and
   * the monitors are in grid like this
   *
   *   +---+---+---+
   *   | A | B | C |
   *   +---+---+---+
   *   | D | E | F |
   *   +---+---+---+
   *
   * then for each monitor you would call it like this
   *
   *   const w = 1920;
   *   const h = 1080;
   *   const fullWidth = w * 3;
   *   const fullHeight = h * 2;
   *
   *   --A--
   *   camera.setViewOffset( fullWidth, fullHeight, w * 0, h * 0, w, h );
   *   --B--
   *   camera.setViewOffset( fullWidth, fullHeight, w * 1, h * 0, w, h );
   *   --C--
   *   camera.setViewOffset( fullWidth, fullHeight, w * 2, h * 0, w, h );
   *   --D--
   *   camera.setViewOffset( fullWidth, fullHeight, w * 0, h * 1, w, h );
   *   --E--
   *   camera.setViewOffset( fullWidth, fullHeight, w * 1, h * 1, w, h );
   *   --F--
   *   camera.setViewOffset( fullWidth, fullHeight, w * 2, h * 1, w, h );
   *
   *   Note there is no reason monitors have to be the same size or in a grid.
   */
  setViewOffset(fullWidth, fullHeight, x3, y2, width, height) {
    this.aspect = fullWidth / fullHeight;
    if (this.view === null) {
      this.view = {
        enabled: true,
        fullWidth: 1,
        fullHeight: 1,
        offsetX: 0,
        offsetY: 0,
        width: 1,
        height: 1
      };
    }
    this.view.enabled = true;
    this.view.fullWidth = fullWidth;
    this.view.fullHeight = fullHeight;
    this.view.offsetX = x3;
    this.view.offsetY = y2;
    this.view.width = width;
    this.view.height = height;
    this.updateProjectionMatrix();
  }
  clearViewOffset() {
    if (this.view !== null) {
      this.view.enabled = false;
    }
    this.updateProjectionMatrix();
  }
  updateProjectionMatrix() {
    const near = this.near;
    let top = near * Math.tan(DEG2RAD * 0.5 * this.fov) / this.zoom;
    let height = 2 * top;
    let width = this.aspect * height;
    let left = -0.5 * width;
    const view = this.view;
    if (this.view !== null && this.view.enabled) {
      const fullWidth = view.fullWidth, fullHeight = view.fullHeight;
      left += view.offsetX * width / fullWidth;
      top -= view.offsetY * height / fullHeight;
      width *= view.width / fullWidth;
      height *= view.height / fullHeight;
    }
    const skew = this.filmOffset;
    if (skew !== 0) left += near * skew / this.getFilmWidth();
    this.projectionMatrix.makePerspective(left, left + width, top, top - height, near, this.far, this.coordinateSystem);
    this.projectionMatrixInverse.copy(this.projectionMatrix).invert();
  }
  toJSON(meta) {
    const data = super.toJSON(meta);
    data.object.fov = this.fov;
    data.object.zoom = this.zoom;
    data.object.near = this.near;
    data.object.far = this.far;
    data.object.focus = this.focus;
    data.object.aspect = this.aspect;
    if (this.view !== null) data.object.view = Object.assign({}, this.view);
    data.object.filmGauge = this.filmGauge;
    data.object.filmOffset = this.filmOffset;
    return data;
  }
};
var fov = -90;
var aspect = 1;
var CubeCamera = class extends Object3D {
  constructor(near, far, renderTarget) {
    super();
    this.type = "CubeCamera";
    this.renderTarget = renderTarget;
    this.coordinateSystem = null;
    const cameraPX = new PerspectiveCamera(fov, aspect, near, far);
    cameraPX.layers = this.layers;
    this.add(cameraPX);
    const cameraNX = new PerspectiveCamera(fov, aspect, near, far);
    cameraNX.layers = this.layers;
    this.add(cameraNX);
    const cameraPY = new PerspectiveCamera(fov, aspect, near, far);
    cameraPY.layers = this.layers;
    this.add(cameraPY);
    const cameraNY = new PerspectiveCamera(fov, aspect, near, far);
    cameraNY.layers = this.layers;
    this.add(cameraNY);
    const cameraPZ = new PerspectiveCamera(fov, aspect, near, far);
    cameraPZ.layers = this.layers;
    this.add(cameraPZ);
    const cameraNZ = new PerspectiveCamera(fov, aspect, near, far);
    cameraNZ.layers = this.layers;
    this.add(cameraNZ);
  }
  updateCoordinateSystem() {
    const coordinateSystem = this.coordinateSystem;
    const cameras = this.children.concat();
    const [cameraPX, cameraNX, cameraPY, cameraNY, cameraPZ, cameraNZ] = cameras;
    for (const camera of cameras) this.remove(camera);
    if (coordinateSystem === WebGLCoordinateSystem) {
      cameraPX.up.set(0, 1, 0);
      cameraPX.lookAt(1, 0, 0);
      cameraNX.up.set(0, 1, 0);
      cameraNX.lookAt(-1, 0, 0);
      cameraPY.up.set(0, 0, -1);
      cameraPY.lookAt(0, 1, 0);
      cameraNY.up.set(0, 0, 1);
      cameraNY.lookAt(0, -1, 0);
      cameraPZ.up.set(0, 1, 0);
      cameraPZ.lookAt(0, 0, 1);
      cameraNZ.up.set(0, 1, 0);
      cameraNZ.lookAt(0, 0, -1);
    } else if (coordinateSystem === WebGPUCoordinateSystem) {
      cameraPX.up.set(0, -1, 0);
      cameraPX.lookAt(-1, 0, 0);
      cameraNX.up.set(0, -1, 0);
      cameraNX.lookAt(1, 0, 0);
      cameraPY.up.set(0, 0, 1);
      cameraPY.lookAt(0, 1, 0);
      cameraNY.up.set(0, 0, -1);
      cameraNY.lookAt(0, -1, 0);
      cameraPZ.up.set(0, -1, 0);
      cameraPZ.lookAt(0, 0, 1);
      cameraNZ.up.set(0, -1, 0);
      cameraNZ.lookAt(0, 0, -1);
    } else {
      throw new Error("THREE.CubeCamera.updateCoordinateSystem(): Invalid coordinate system: " + coordinateSystem);
    }
    for (const camera of cameras) {
      this.add(camera);
      camera.updateMatrixWorld();
    }
  }
  update(renderer, scene) {
    if (this.parent === null) this.updateMatrixWorld();
    const renderTarget = this.renderTarget;
    if (this.coordinateSystem !== renderer.coordinateSystem) {
      this.coordinateSystem = renderer.coordinateSystem;
      this.updateCoordinateSystem();
    }
    const [cameraPX, cameraNX, cameraPY, cameraNY, cameraPZ, cameraNZ] = this.children;
    const currentRenderTarget = renderer.getRenderTarget();
    const currentToneMapping = renderer.toneMapping;
    const currentXrEnabled = renderer.xr.enabled;
    renderer.toneMapping = NoToneMapping;
    renderer.xr.enabled = false;
    const generateMipmaps = renderTarget.texture.generateMipmaps;
    renderTarget.texture.generateMipmaps = false;
    renderer.setRenderTarget(renderTarget, 0);
    renderer.render(scene, cameraPX);
    renderer.setRenderTarget(renderTarget, 1);
    renderer.render(scene, cameraNX);
    renderer.setRenderTarget(renderTarget, 2);
    renderer.render(scene, cameraPY);
    renderer.setRenderTarget(renderTarget, 3);
    renderer.render(scene, cameraNY);
    renderer.setRenderTarget(renderTarget, 4);
    renderer.render(scene, cameraPZ);
    renderTarget.texture.generateMipmaps = generateMipmaps;
    renderer.setRenderTarget(renderTarget, 5);
    renderer.render(scene, cameraNZ);
    renderer.setRenderTarget(currentRenderTarget);
    renderer.toneMapping = currentToneMapping;
    renderer.xr.enabled = currentXrEnabled;
    renderTarget.texture.needsPMREMUpdate = true;
  }
};
var CubeTexture = class extends Texture {
  constructor(images, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, colorSpace) {
    images = images !== void 0 ? images : [];
    mapping = mapping !== void 0 ? mapping : CubeReflectionMapping;
    super(images, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, colorSpace);
    this.isCubeTexture = true;
    this.flipY = false;
  }
  get images() {
    return this.image;
  }
  set images(value) {
    this.image = value;
  }
};
var WebGLCubeRenderTarget = class extends WebGLRenderTarget {
  constructor(size = 1, options2 = {}) {
    super(size, size, options2);
    this.isWebGLCubeRenderTarget = true;
    const image = { width: size, height: size, depth: 1 };
    const images = [image, image, image, image, image, image];
    if (options2.encoding !== void 0) {
      warnOnce("THREE.WebGLCubeRenderTarget: option.encoding has been replaced by option.colorSpace.");
      options2.colorSpace = options2.encoding === sRGBEncoding ? SRGBColorSpace : NoColorSpace;
    }
    this.texture = new CubeTexture(images, options2.mapping, options2.wrapS, options2.wrapT, options2.magFilter, options2.minFilter, options2.format, options2.type, options2.anisotropy, options2.colorSpace);
    this.texture.isRenderTargetTexture = true;
    this.texture.generateMipmaps = options2.generateMipmaps !== void 0 ? options2.generateMipmaps : false;
    this.texture.minFilter = options2.minFilter !== void 0 ? options2.minFilter : LinearFilter;
  }
  fromEquirectangularTexture(renderer, texture) {
    this.texture.type = texture.type;
    this.texture.colorSpace = texture.colorSpace;
    this.texture.generateMipmaps = texture.generateMipmaps;
    this.texture.minFilter = texture.minFilter;
    this.texture.magFilter = texture.magFilter;
    const shader = {
      uniforms: {
        tEquirect: { value: null }
      },
      vertexShader: (
        /* glsl */
        `

				varying vec3 vWorldDirection;

				vec3 transformDirection( in vec3 dir, in mat4 matrix ) {

					return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );

				}

				void main() {

					vWorldDirection = transformDirection( position, modelMatrix );

					#include <begin_vertex>
					#include <project_vertex>

				}
			`
      ),
      fragmentShader: (
        /* glsl */
        `

				uniform sampler2D tEquirect;

				varying vec3 vWorldDirection;

				#include <common>

				void main() {

					vec3 direction = normalize( vWorldDirection );

					vec2 sampleUV = equirectUv( direction );

					gl_FragColor = texture2D( tEquirect, sampleUV );

				}
			`
      )
    };
    const geometry = new BoxGeometry(5, 5, 5);
    const material = new ShaderMaterial({
      name: "CubemapFromEquirect",
      uniforms: cloneUniforms(shader.uniforms),
      vertexShader: shader.vertexShader,
      fragmentShader: shader.fragmentShader,
      side: BackSide,
      blending: NoBlending
    });
    material.uniforms.tEquirect.value = texture;
    const mesh = new Mesh(geometry, material);
    const currentMinFilter = texture.minFilter;
    if (texture.minFilter === LinearMipmapLinearFilter) texture.minFilter = LinearFilter;
    const camera = new CubeCamera(1, 10, this);
    camera.update(renderer, mesh);
    texture.minFilter = currentMinFilter;
    mesh.geometry.dispose();
    mesh.material.dispose();
    return this;
  }
  clear(renderer, color, depth, stencil) {
    const currentRenderTarget = renderer.getRenderTarget();
    for (let i2 = 0; i2 < 6; i2++) {
      renderer.setRenderTarget(this, i2);
      renderer.clear(color, depth, stencil);
    }
    renderer.setRenderTarget(currentRenderTarget);
  }
};
var _vector1 = new Vector3();
var _vector2 = new Vector3();
var _normalMatrix = new Matrix3();
var Plane = class {
  constructor(normal = new Vector3(1, 0, 0), constant = 0) {
    this.isPlane = true;
    this.normal = normal;
    this.constant = constant;
  }
  set(normal, constant) {
    this.normal.copy(normal);
    this.constant = constant;
    return this;
  }
  setComponents(x3, y2, z, w2) {
    this.normal.set(x3, y2, z);
    this.constant = w2;
    return this;
  }
  setFromNormalAndCoplanarPoint(normal, point) {
    this.normal.copy(normal);
    this.constant = -point.dot(this.normal);
    return this;
  }
  setFromCoplanarPoints(a2, b2, c2) {
    const normal = _vector1.subVectors(c2, b2).cross(_vector2.subVectors(a2, b2)).normalize();
    this.setFromNormalAndCoplanarPoint(normal, a2);
    return this;
  }
  copy(plane) {
    this.normal.copy(plane.normal);
    this.constant = plane.constant;
    return this;
  }
  normalize() {
    const inverseNormalLength = 1 / this.normal.length();
    this.normal.multiplyScalar(inverseNormalLength);
    this.constant *= inverseNormalLength;
    return this;
  }
  negate() {
    this.constant *= -1;
    this.normal.negate();
    return this;
  }
  distanceToPoint(point) {
    return this.normal.dot(point) + this.constant;
  }
  distanceToSphere(sphere) {
    return this.distanceToPoint(sphere.center) - sphere.radius;
  }
  projectPoint(point, target) {
    return target.copy(point).addScaledVector(this.normal, -this.distanceToPoint(point));
  }
  intersectLine(line, target) {
    const direction2 = line.delta(_vector1);
    const denominator = this.normal.dot(direction2);
    if (denominator === 0) {
      if (this.distanceToPoint(line.start) === 0) {
        return target.copy(line.start);
      }
      return null;
    }
    const t2 = -(line.start.dot(this.normal) + this.constant) / denominator;
    if (t2 < 0 || t2 > 1) {
      return null;
    }
    return target.copy(line.start).addScaledVector(direction2, t2);
  }
  intersectsLine(line) {
    const startSign = this.distanceToPoint(line.start);
    const endSign = this.distanceToPoint(line.end);
    return startSign < 0 && endSign > 0 || endSign < 0 && startSign > 0;
  }
  intersectsBox(box) {
    return box.intersectsPlane(this);
  }
  intersectsSphere(sphere) {
    return sphere.intersectsPlane(this);
  }
  coplanarPoint(target) {
    return target.copy(this.normal).multiplyScalar(-this.constant);
  }
  applyMatrix4(matrix, optionalNormalMatrix) {
    const normalMatrix = optionalNormalMatrix || _normalMatrix.getNormalMatrix(matrix);
    const referencePoint = this.coplanarPoint(_vector1).applyMatrix4(matrix);
    const normal = this.normal.applyMatrix3(normalMatrix).normalize();
    this.constant = -referencePoint.dot(normal);
    return this;
  }
  translate(offset) {
    this.constant -= offset.dot(this.normal);
    return this;
  }
  equals(plane) {
    return plane.normal.equals(this.normal) && plane.constant === this.constant;
  }
  clone() {
    return new this.constructor().copy(this);
  }
};
var _sphere$4 = new Sphere();
var _vector$6 = new Vector3();
var Frustum = class {
  constructor(p0 = new Plane(), p1 = new Plane(), p2 = new Plane(), p3 = new Plane(), p4 = new Plane(), p5 = new Plane()) {
    this.planes = [p0, p1, p2, p3, p4, p5];
  }
  set(p0, p1, p2, p3, p4, p5) {
    const planes = this.planes;
    planes[0].copy(p0);
    planes[1].copy(p1);
    planes[2].copy(p2);
    planes[3].copy(p3);
    planes[4].copy(p4);
    planes[5].copy(p5);
    return this;
  }
  copy(frustum) {
    const planes = this.planes;
    for (let i2 = 0; i2 < 6; i2++) {
      planes[i2].copy(frustum.planes[i2]);
    }
    return this;
  }
  setFromProjectionMatrix(m2, coordinateSystem = WebGLCoordinateSystem) {
    const planes = this.planes;
    const me = m2.elements;
    const me0 = me[0], me1 = me[1], me2 = me[2], me3 = me[3];
    const me4 = me[4], me5 = me[5], me6 = me[6], me7 = me[7];
    const me8 = me[8], me9 = me[9], me10 = me[10], me11 = me[11];
    const me12 = me[12], me13 = me[13], me14 = me[14], me15 = me[15];
    planes[0].setComponents(me3 - me0, me7 - me4, me11 - me8, me15 - me12).normalize();
    planes[1].setComponents(me3 + me0, me7 + me4, me11 + me8, me15 + me12).normalize();
    planes[2].setComponents(me3 + me1, me7 + me5, me11 + me9, me15 + me13).normalize();
    planes[3].setComponents(me3 - me1, me7 - me5, me11 - me9, me15 - me13).normalize();
    planes[4].setComponents(me3 - me2, me7 - me6, me11 - me10, me15 - me14).normalize();
    if (coordinateSystem === WebGLCoordinateSystem) {
      planes[5].setComponents(me3 + me2, me7 + me6, me11 + me10, me15 + me14).normalize();
    } else if (coordinateSystem === WebGPUCoordinateSystem) {
      planes[5].setComponents(me2, me6, me10, me14).normalize();
    } else {
      throw new Error("THREE.Frustum.setFromProjectionMatrix(): Invalid coordinate system: " + coordinateSystem);
    }
    return this;
  }
  intersectsObject(object) {
    if (object.boundingSphere !== void 0) {
      if (object.boundingSphere === null) object.computeBoundingSphere();
      _sphere$4.copy(object.boundingSphere).applyMatrix4(object.matrixWorld);
    } else {
      const geometry = object.geometry;
      if (geometry.boundingSphere === null) geometry.computeBoundingSphere();
      _sphere$4.copy(geometry.boundingSphere).applyMatrix4(object.matrixWorld);
    }
    return this.intersectsSphere(_sphere$4);
  }
  intersectsSprite(sprite) {
    _sphere$4.center.set(0, 0, 0);
    _sphere$4.radius = 0.7071067811865476;
    _sphere$4.applyMatrix4(sprite.matrixWorld);
    return this.intersectsSphere(_sphere$4);
  }
  intersectsSphere(sphere) {
    const planes = this.planes;
    const center = sphere.center;
    const negRadius = -sphere.radius;
    for (let i2 = 0; i2 < 6; i2++) {
      const distance = planes[i2].distanceToPoint(center);
      if (distance < negRadius) {
        return false;
      }
    }
    return true;
  }
  intersectsBox(box) {
    const planes = this.planes;
    for (let i2 = 0; i2 < 6; i2++) {
      const plane = planes[i2];
      _vector$6.x = plane.normal.x > 0 ? box.max.x : box.min.x;
      _vector$6.y = plane.normal.y > 0 ? box.max.y : box.min.y;
      _vector$6.z = plane.normal.z > 0 ? box.max.z : box.min.z;
      if (plane.distanceToPoint(_vector$6) < 0) {
        return false;
      }
    }
    return true;
  }
  containsPoint(point) {
    const planes = this.planes;
    for (let i2 = 0; i2 < 6; i2++) {
      if (planes[i2].distanceToPoint(point) < 0) {
        return false;
      }
    }
    return true;
  }
  clone() {
    return new this.constructor().copy(this);
  }
};
function WebGLAnimation() {
  let context = null;
  let isAnimating = false;
  let animationLoop = null;
  let requestId = null;
  function onAnimationFrame(time, frame) {
    animationLoop(time, frame);
    requestId = context.requestAnimationFrame(onAnimationFrame);
  }
  return {
    start: function() {
      if (isAnimating === true) return;
      if (animationLoop === null) return;
      requestId = context.requestAnimationFrame(onAnimationFrame);
      isAnimating = true;
    },
    stop: function() {
      context.cancelAnimationFrame(requestId);
      isAnimating = false;
    },
    setAnimationLoop: function(callback) {
      animationLoop = callback;
    },
    setContext: function(value) {
      context = value;
    }
  };
}
function WebGLAttributes(gl, capabilities2) {
  const isWebGL2 = capabilities2.isWebGL2;
  const buffers = /* @__PURE__ */ new WeakMap();
  function createBuffer(attribute, bufferType) {
    const array = attribute.array;
    const usage = attribute.usage;
    const buffer = gl.createBuffer();
    gl.bindBuffer(bufferType, buffer);
    gl.bufferData(bufferType, array, usage);
    attribute.onUploadCallback();
    let type;
    if (array instanceof Float32Array) {
      type = gl.FLOAT;
    } else if (array instanceof Uint16Array) {
      if (attribute.isFloat16BufferAttribute) {
        if (isWebGL2) {
          type = gl.HALF_FLOAT;
        } else {
          throw new Error("THREE.WebGLAttributes: Usage of Float16BufferAttribute requires WebGL2.");
        }
      } else {
        type = gl.UNSIGNED_SHORT;
      }
    } else if (array instanceof Int16Array) {
      type = gl.SHORT;
    } else if (array instanceof Uint32Array) {
      type = gl.UNSIGNED_INT;
    } else if (array instanceof Int32Array) {
      type = gl.INT;
    } else if (array instanceof Int8Array) {
      type = gl.BYTE;
    } else if (array instanceof Uint8Array) {
      type = gl.UNSIGNED_BYTE;
    } else if (array instanceof Uint8ClampedArray) {
      type = gl.UNSIGNED_BYTE;
    } else {
      throw new Error("THREE.WebGLAttributes: Unsupported buffer data format: " + array);
    }
    return {
      buffer,
      type,
      bytesPerElement: array.BYTES_PER_ELEMENT,
      version: attribute.version
    };
  }
  function updateBuffer(buffer, attribute, bufferType) {
    const array = attribute.array;
    const updateRange = attribute.updateRange;
    gl.bindBuffer(bufferType, buffer);
    if (updateRange.count === -1) {
      gl.bufferSubData(bufferType, 0, array);
    } else {
      if (isWebGL2) {
        gl.bufferSubData(
          bufferType,
          updateRange.offset * array.BYTES_PER_ELEMENT,
          array,
          updateRange.offset,
          updateRange.count
        );
      } else {
        gl.bufferSubData(
          bufferType,
          updateRange.offset * array.BYTES_PER_ELEMENT,
          array.subarray(updateRange.offset, updateRange.offset + updateRange.count)
        );
      }
      updateRange.count = -1;
    }
    attribute.onUploadCallback();
  }
  function get(attribute) {
    if (attribute.isInterleavedBufferAttribute) attribute = attribute.data;
    return buffers.get(attribute);
  }
  function remove(attribute) {
    if (attribute.isInterleavedBufferAttribute) attribute = attribute.data;
    const data = buffers.get(attribute);
    if (data) {
      gl.deleteBuffer(data.buffer);
      buffers.delete(attribute);
    }
  }
  function update(attribute, bufferType) {
    if (attribute.isGLBufferAttribute) {
      const cached = buffers.get(attribute);
      if (!cached || cached.version < attribute.version) {
        buffers.set(attribute, {
          buffer: attribute.buffer,
          type: attribute.type,
          bytesPerElement: attribute.elementSize,
          version: attribute.version
        });
      }
      return;
    }
    if (attribute.isInterleavedBufferAttribute) attribute = attribute.data;
    const data = buffers.get(attribute);
    if (data === void 0) {
      buffers.set(attribute, createBuffer(attribute, bufferType));
    } else if (data.version < attribute.version) {
      updateBuffer(data.buffer, attribute, bufferType);
      data.version = attribute.version;
    }
  }
  return {
    get,
    remove,
    update
  };
}
var PlaneGeometry = class _PlaneGeometry extends BufferGeometry {
  constructor(width = 1, height = 1, widthSegments = 1, heightSegments = 1) {
    super();
    this.type = "PlaneGeometry";
    this.parameters = {
      width,
      height,
      widthSegments,
      heightSegments
    };
    const width_half = width / 2;
    const height_half = height / 2;
    const gridX = Math.floor(widthSegments);
    const gridY = Math.floor(heightSegments);
    const gridX1 = gridX + 1;
    const gridY1 = gridY + 1;
    const segment_width = width / gridX;
    const segment_height = height / gridY;
    const indices = [];
    const vertices = [];
    const normals = [];
    const uvs = [];
    for (let iy = 0; iy < gridY1; iy++) {
      const y2 = iy * segment_height - height_half;
      for (let ix = 0; ix < gridX1; ix++) {
        const x3 = ix * segment_width - width_half;
        vertices.push(x3, -y2, 0);
        normals.push(0, 0, 1);
        uvs.push(ix / gridX);
        uvs.push(1 - iy / gridY);
      }
    }
    for (let iy = 0; iy < gridY; iy++) {
      for (let ix = 0; ix < gridX; ix++) {
        const a2 = ix + gridX1 * iy;
        const b2 = ix + gridX1 * (iy + 1);
        const c2 = ix + 1 + gridX1 * (iy + 1);
        const d2 = ix + 1 + gridX1 * iy;
        indices.push(a2, b2, d2);
        indices.push(b2, c2, d2);
      }
    }
    this.setIndex(indices);
    this.setAttribute("position", new Float32BufferAttribute(vertices, 3));
    this.setAttribute("normal", new Float32BufferAttribute(normals, 3));
    this.setAttribute("uv", new Float32BufferAttribute(uvs, 2));
  }
  copy(source) {
    super.copy(source);
    this.parameters = Object.assign({}, source.parameters);
    return this;
  }
  static fromJSON(data) {
    return new _PlaneGeometry(data.width, data.height, data.widthSegments, data.heightSegments);
  }
};
var alphamap_fragment = "#ifdef USE_ALPHAMAP\n	diffuseColor.a *= texture2D( alphaMap, vAlphaMapUv ).g;\n#endif";
var alphamap_pars_fragment = "#ifdef USE_ALPHAMAP\n	uniform sampler2D alphaMap;\n#endif";
var alphatest_fragment = "#ifdef USE_ALPHATEST\n	if ( diffuseColor.a < alphaTest ) discard;\n#endif";
var alphatest_pars_fragment = "#ifdef USE_ALPHATEST\n	uniform float alphaTest;\n#endif";
var aomap_fragment = "#ifdef USE_AOMAP\n	float ambientOcclusion = ( texture2D( aoMap, vAoMapUv ).r - 1.0 ) * aoMapIntensity + 1.0;\n	reflectedLight.indirectDiffuse *= ambientOcclusion;\n	#if defined( USE_ENVMAP ) && defined( STANDARD )\n		float dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n		reflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.roughness );\n	#endif\n#endif";
var aomap_pars_fragment = "#ifdef USE_AOMAP\n	uniform sampler2D aoMap;\n	uniform float aoMapIntensity;\n#endif";
var begin_vertex = "vec3 transformed = vec3( position );";
var beginnormal_vertex = "vec3 objectNormal = vec3( normal );\n#ifdef USE_TANGENT\n	vec3 objectTangent = vec3( tangent.xyz );\n#endif";
var bsdfs = "float G_BlinnPhong_Implicit( ) {\n	return 0.25;\n}\nfloat D_BlinnPhong( const in float shininess, const in float dotNH ) {\n	return RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );\n}\nvec3 BRDF_BlinnPhong( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float shininess ) {\n	vec3 halfDir = normalize( lightDir + viewDir );\n	float dotNH = saturate( dot( normal, halfDir ) );\n	float dotVH = saturate( dot( viewDir, halfDir ) );\n	vec3 F = F_Schlick( specularColor, 1.0, dotVH );\n	float G = G_BlinnPhong_Implicit( );\n	float D = D_BlinnPhong( shininess, dotNH );\n	return F * ( G * D );\n} // validated";
var iridescence_fragment = "#ifdef USE_IRIDESCENCE\n	const mat3 XYZ_TO_REC709 = mat3(\n		 3.2404542, -0.9692660,  0.0556434,\n		-1.5371385,  1.8760108, -0.2040259,\n		-0.4985314,  0.0415560,  1.0572252\n	);\n	vec3 Fresnel0ToIor( vec3 fresnel0 ) {\n		vec3 sqrtF0 = sqrt( fresnel0 );\n		return ( vec3( 1.0 ) + sqrtF0 ) / ( vec3( 1.0 ) - sqrtF0 );\n	}\n	vec3 IorToFresnel0( vec3 transmittedIor, float incidentIor ) {\n		return pow2( ( transmittedIor - vec3( incidentIor ) ) / ( transmittedIor + vec3( incidentIor ) ) );\n	}\n	float IorToFresnel0( float transmittedIor, float incidentIor ) {\n		return pow2( ( transmittedIor - incidentIor ) / ( transmittedIor + incidentIor ));\n	}\n	vec3 evalSensitivity( float OPD, vec3 shift ) {\n		float phase = 2.0 * PI * OPD * 1.0e-9;\n		vec3 val = vec3( 5.4856e-13, 4.4201e-13, 5.2481e-13 );\n		vec3 pos = vec3( 1.6810e+06, 1.7953e+06, 2.2084e+06 );\n		vec3 var = vec3( 4.3278e+09, 9.3046e+09, 6.6121e+09 );\n		vec3 xyz = val * sqrt( 2.0 * PI * var ) * cos( pos * phase + shift ) * exp( - pow2( phase ) * var );\n		xyz.x += 9.7470e-14 * sqrt( 2.0 * PI * 4.5282e+09 ) * cos( 2.2399e+06 * phase + shift[ 0 ] ) * exp( - 4.5282e+09 * pow2( phase ) );\n		xyz /= 1.0685e-7;\n		vec3 rgb = XYZ_TO_REC709 * xyz;\n		return rgb;\n	}\n	vec3 evalIridescence( float outsideIOR, float eta2, float cosTheta1, float thinFilmThickness, vec3 baseF0 ) {\n		vec3 I;\n		float iridescenceIOR = mix( outsideIOR, eta2, smoothstep( 0.0, 0.03, thinFilmThickness ) );\n		float sinTheta2Sq = pow2( outsideIOR / iridescenceIOR ) * ( 1.0 - pow2( cosTheta1 ) );\n		float cosTheta2Sq = 1.0 - sinTheta2Sq;\n		if ( cosTheta2Sq < 0.0 ) {\n			 return vec3( 1.0 );\n		}\n		float cosTheta2 = sqrt( cosTheta2Sq );\n		float R0 = IorToFresnel0( iridescenceIOR, outsideIOR );\n		float R12 = F_Schlick( R0, 1.0, cosTheta1 );\n		float R21 = R12;\n		float T121 = 1.0 - R12;\n		float phi12 = 0.0;\n		if ( iridescenceIOR < outsideIOR ) phi12 = PI;\n		float phi21 = PI - phi12;\n		vec3 baseIOR = Fresnel0ToIor( clamp( baseF0, 0.0, 0.9999 ) );		vec3 R1 = IorToFresnel0( baseIOR, iridescenceIOR );\n		vec3 R23 = F_Schlick( R1, 1.0, cosTheta2 );\n		vec3 phi23 = vec3( 0.0 );\n		if ( baseIOR[ 0 ] < iridescenceIOR ) phi23[ 0 ] = PI;\n		if ( baseIOR[ 1 ] < iridescenceIOR ) phi23[ 1 ] = PI;\n		if ( baseIOR[ 2 ] < iridescenceIOR ) phi23[ 2 ] = PI;\n		float OPD = 2.0 * iridescenceIOR * thinFilmThickness * cosTheta2;\n		vec3 phi = vec3( phi21 ) + phi23;\n		vec3 R123 = clamp( R12 * R23, 1e-5, 0.9999 );\n		vec3 r123 = sqrt( R123 );\n		vec3 Rs = pow2( T121 ) * R23 / ( vec3( 1.0 ) - R123 );\n		vec3 C0 = R12 + Rs;\n		I = C0;\n		vec3 Cm = Rs - T121;\n		for ( int m = 1; m <= 2; ++ m ) {\n			Cm *= r123;\n			vec3 Sm = 2.0 * evalSensitivity( float( m ) * OPD, float( m ) * phi );\n			I += Cm * Sm;\n		}\n		return max( I, vec3( 0.0 ) );\n	}\n#endif";
var bumpmap_pars_fragment = "#ifdef USE_BUMPMAP\n	uniform sampler2D bumpMap;\n	uniform float bumpScale;\n	vec2 dHdxy_fwd() {\n		vec2 dSTdx = dFdx( vBumpMapUv );\n		vec2 dSTdy = dFdy( vBumpMapUv );\n		float Hll = bumpScale * texture2D( bumpMap, vBumpMapUv ).x;\n		float dBx = bumpScale * texture2D( bumpMap, vBumpMapUv + dSTdx ).x - Hll;\n		float dBy = bumpScale * texture2D( bumpMap, vBumpMapUv + dSTdy ).x - Hll;\n		return vec2( dBx, dBy );\n	}\n	vec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy, float faceDirection ) {\n		vec3 vSigmaX = dFdx( surf_pos.xyz );\n		vec3 vSigmaY = dFdy( surf_pos.xyz );\n		vec3 vN = surf_norm;\n		vec3 R1 = cross( vSigmaY, vN );\n		vec3 R2 = cross( vN, vSigmaX );\n		float fDet = dot( vSigmaX, R1 ) * faceDirection;\n		vec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\n		return normalize( abs( fDet ) * surf_norm - vGrad );\n	}\n#endif";
var clipping_planes_fragment = "#if NUM_CLIPPING_PLANES > 0\n	vec4 plane;\n	#pragma unroll_loop_start\n	for ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {\n		plane = clippingPlanes[ i ];\n		if ( dot( vClipPosition, plane.xyz ) > plane.w ) discard;\n	}\n	#pragma unroll_loop_end\n	#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES\n		bool clipped = true;\n		#pragma unroll_loop_start\n		for ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {\n			plane = clippingPlanes[ i ];\n			clipped = ( dot( vClipPosition, plane.xyz ) > plane.w ) && clipped;\n		}\n		#pragma unroll_loop_end\n		if ( clipped ) discard;\n	#endif\n#endif";
var clipping_planes_pars_fragment = "#if NUM_CLIPPING_PLANES > 0\n	varying vec3 vClipPosition;\n	uniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];\n#endif";
var clipping_planes_pars_vertex = "#if NUM_CLIPPING_PLANES > 0\n	varying vec3 vClipPosition;\n#endif";
var clipping_planes_vertex = "#if NUM_CLIPPING_PLANES > 0\n	vClipPosition = - mvPosition.xyz;\n#endif";
var color_fragment = "#if defined( USE_COLOR_ALPHA )\n	diffuseColor *= vColor;\n#elif defined( USE_COLOR )\n	diffuseColor.rgb *= vColor;\n#endif";
var color_pars_fragment = "#if defined( USE_COLOR_ALPHA )\n	varying vec4 vColor;\n#elif defined( USE_COLOR )\n	varying vec3 vColor;\n#endif";
var color_pars_vertex = "#if defined( USE_COLOR_ALPHA )\n	varying vec4 vColor;\n#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )\n	varying vec3 vColor;\n#endif";
var color_vertex = "#if defined( USE_COLOR_ALPHA )\n	vColor = vec4( 1.0 );\n#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )\n	vColor = vec3( 1.0 );\n#endif\n#ifdef USE_COLOR\n	vColor *= color;\n#endif\n#ifdef USE_INSTANCING_COLOR\n	vColor.xyz *= instanceColor.xyz;\n#endif";
var common = "#define PI 3.141592653589793\n#define PI2 6.283185307179586\n#define PI_HALF 1.5707963267948966\n#define RECIPROCAL_PI 0.3183098861837907\n#define RECIPROCAL_PI2 0.15915494309189535\n#define EPSILON 1e-6\n#ifndef saturate\n#define saturate( a ) clamp( a, 0.0, 1.0 )\n#endif\n#define whiteComplement( a ) ( 1.0 - saturate( a ) )\nfloat pow2( const in float x ) { return x*x; }\nvec3 pow2( const in vec3 x ) { return x*x; }\nfloat pow3( const in float x ) { return x*x*x; }\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\nfloat max3( const in vec3 v ) { return max( max( v.x, v.y ), v.z ); }\nfloat average( const in vec3 v ) { return dot( v, vec3( 0.3333333 ) ); }\nhighp float rand( const in vec2 uv ) {\n	const highp float a = 12.9898, b = 78.233, c = 43758.5453;\n	highp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\n	return fract( sin( sn ) * c );\n}\n#ifdef HIGH_PRECISION\n	float precisionSafeLength( vec3 v ) { return length( v ); }\n#else\n	float precisionSafeLength( vec3 v ) {\n		float maxComponent = max3( abs( v ) );\n		return length( v / maxComponent ) * maxComponent;\n	}\n#endif\nstruct IncidentLight {\n	vec3 color;\n	vec3 direction;\n	bool visible;\n};\nstruct ReflectedLight {\n	vec3 directDiffuse;\n	vec3 directSpecular;\n	vec3 indirectDiffuse;\n	vec3 indirectSpecular;\n};\nstruct GeometricContext {\n	vec3 position;\n	vec3 normal;\n	vec3 viewDir;\n#ifdef USE_CLEARCOAT\n	vec3 clearcoatNormal;\n#endif\n};\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n	return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n}\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\n	return normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\n}\nmat3 transposeMat3( const in mat3 m ) {\n	mat3 tmp;\n	tmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );\n	tmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );\n	tmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );\n	return tmp;\n}\nfloat luminance( const in vec3 rgb ) {\n	const vec3 weights = vec3( 0.2126729, 0.7151522, 0.0721750 );\n	return dot( weights, rgb );\n}\nbool isPerspectiveMatrix( mat4 m ) {\n	return m[ 2 ][ 3 ] == - 1.0;\n}\nvec2 equirectUv( in vec3 dir ) {\n	float u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;\n	float v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n	return vec2( u, v );\n}\nvec3 BRDF_Lambert( const in vec3 diffuseColor ) {\n	return RECIPROCAL_PI * diffuseColor;\n}\nvec3 F_Schlick( const in vec3 f0, const in float f90, const in float dotVH ) {\n	float fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );\n	return f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );\n}\nfloat F_Schlick( const in float f0, const in float f90, const in float dotVH ) {\n	float fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );\n	return f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );\n} // validated";
var cube_uv_reflection_fragment = "#ifdef ENVMAP_TYPE_CUBE_UV\n	#define cubeUV_minMipLevel 4.0\n	#define cubeUV_minTileSize 16.0\n	float getFace( vec3 direction ) {\n		vec3 absDirection = abs( direction );\n		float face = - 1.0;\n		if ( absDirection.x > absDirection.z ) {\n			if ( absDirection.x > absDirection.y )\n				face = direction.x > 0.0 ? 0.0 : 3.0;\n			else\n				face = direction.y > 0.0 ? 1.0 : 4.0;\n		} else {\n			if ( absDirection.z > absDirection.y )\n				face = direction.z > 0.0 ? 2.0 : 5.0;\n			else\n				face = direction.y > 0.0 ? 1.0 : 4.0;\n		}\n		return face;\n	}\n	vec2 getUV( vec3 direction, float face ) {\n		vec2 uv;\n		if ( face == 0.0 ) {\n			uv = vec2( direction.z, direction.y ) / abs( direction.x );\n		} else if ( face == 1.0 ) {\n			uv = vec2( - direction.x, - direction.z ) / abs( direction.y );\n		} else if ( face == 2.0 ) {\n			uv = vec2( - direction.x, direction.y ) / abs( direction.z );\n		} else if ( face == 3.0 ) {\n			uv = vec2( - direction.z, direction.y ) / abs( direction.x );\n		} else if ( face == 4.0 ) {\n			uv = vec2( - direction.x, direction.z ) / abs( direction.y );\n		} else {\n			uv = vec2( direction.x, direction.y ) / abs( direction.z );\n		}\n		return 0.5 * ( uv + 1.0 );\n	}\n	vec3 bilinearCubeUV( sampler2D envMap, vec3 direction, float mipInt ) {\n		float face = getFace( direction );\n		float filterInt = max( cubeUV_minMipLevel - mipInt, 0.0 );\n		mipInt = max( mipInt, cubeUV_minMipLevel );\n		float faceSize = exp2( mipInt );\n		highp vec2 uv = getUV( direction, face ) * ( faceSize - 2.0 ) + 1.0;\n		if ( face > 2.0 ) {\n			uv.y += faceSize;\n			face -= 3.0;\n		}\n		uv.x += face * faceSize;\n		uv.x += filterInt * 3.0 * cubeUV_minTileSize;\n		uv.y += 4.0 * ( exp2( CUBEUV_MAX_MIP ) - faceSize );\n		uv.x *= CUBEUV_TEXEL_WIDTH;\n		uv.y *= CUBEUV_TEXEL_HEIGHT;\n		#ifdef texture2DGradEXT\n			return texture2DGradEXT( envMap, uv, vec2( 0.0 ), vec2( 0.0 ) ).rgb;\n		#else\n			return texture2D( envMap, uv ).rgb;\n		#endif\n	}\n	#define cubeUV_r0 1.0\n	#define cubeUV_v0 0.339\n	#define cubeUV_m0 - 2.0\n	#define cubeUV_r1 0.8\n	#define cubeUV_v1 0.276\n	#define cubeUV_m1 - 1.0\n	#define cubeUV_r4 0.4\n	#define cubeUV_v4 0.046\n	#define cubeUV_m4 2.0\n	#define cubeUV_r5 0.305\n	#define cubeUV_v5 0.016\n	#define cubeUV_m5 3.0\n	#define cubeUV_r6 0.21\n	#define cubeUV_v6 0.0038\n	#define cubeUV_m6 4.0\n	float roughnessToMip( float roughness ) {\n		float mip = 0.0;\n		if ( roughness >= cubeUV_r1 ) {\n			mip = ( cubeUV_r0 - roughness ) * ( cubeUV_m1 - cubeUV_m0 ) / ( cubeUV_r0 - cubeUV_r1 ) + cubeUV_m0;\n		} else if ( roughness >= cubeUV_r4 ) {\n			mip = ( cubeUV_r1 - roughness ) * ( cubeUV_m4 - cubeUV_m1 ) / ( cubeUV_r1 - cubeUV_r4 ) + cubeUV_m1;\n		} else if ( roughness >= cubeUV_r5 ) {\n			mip = ( cubeUV_r4 - roughness ) * ( cubeUV_m5 - cubeUV_m4 ) / ( cubeUV_r4 - cubeUV_r5 ) + cubeUV_m4;\n		} else if ( roughness >= cubeUV_r6 ) {\n			mip = ( cubeUV_r5 - roughness ) * ( cubeUV_m6 - cubeUV_m5 ) / ( cubeUV_r5 - cubeUV_r6 ) + cubeUV_m5;\n		} else {\n			mip = - 2.0 * log2( 1.16 * roughness );		}\n		return mip;\n	}\n	vec4 textureCubeUV( sampler2D envMap, vec3 sampleDir, float roughness ) {\n		float mip = clamp( roughnessToMip( roughness ), cubeUV_m0, CUBEUV_MAX_MIP );\n		float mipF = fract( mip );\n		float mipInt = floor( mip );\n		vec3 color0 = bilinearCubeUV( envMap, sampleDir, mipInt );\n		if ( mipF == 0.0 ) {\n			return vec4( color0, 1.0 );\n		} else {\n			vec3 color1 = bilinearCubeUV( envMap, sampleDir, mipInt + 1.0 );\n			return vec4( mix( color0, color1, mipF ), 1.0 );\n		}\n	}\n#endif";
var defaultnormal_vertex = "vec3 transformedNormal = objectNormal;\n#ifdef USE_INSTANCING\n	mat3 m = mat3( instanceMatrix );\n	transformedNormal /= vec3( dot( m[ 0 ], m[ 0 ] ), dot( m[ 1 ], m[ 1 ] ), dot( m[ 2 ], m[ 2 ] ) );\n	transformedNormal = m * transformedNormal;\n#endif\ntransformedNormal = normalMatrix * transformedNormal;\n#ifdef FLIP_SIDED\n	transformedNormal = - transformedNormal;\n#endif\n#ifdef USE_TANGENT\n	vec3 transformedTangent = ( modelViewMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n	#ifdef FLIP_SIDED\n		transformedTangent = - transformedTangent;\n	#endif\n#endif";
var displacementmap_pars_vertex = "#ifdef USE_DISPLACEMENTMAP\n	uniform sampler2D displacementMap;\n	uniform float displacementScale;\n	uniform float displacementBias;\n#endif";
var displacementmap_vertex = "#ifdef USE_DISPLACEMENTMAP\n	transformed += normalize( objectNormal ) * ( texture2D( displacementMap, vDisplacementMapUv ).x * displacementScale + displacementBias );\n#endif";
var emissivemap_fragment = "#ifdef USE_EMISSIVEMAP\n	vec4 emissiveColor = texture2D( emissiveMap, vEmissiveMapUv );\n	totalEmissiveRadiance *= emissiveColor.rgb;\n#endif";
var emissivemap_pars_fragment = "#ifdef USE_EMISSIVEMAP\n	uniform sampler2D emissiveMap;\n#endif";
var encodings_fragment = "gl_FragColor = linearToOutputTexel( gl_FragColor );";
var encodings_pars_fragment = "vec4 LinearToLinear( in vec4 value ) {\n	return value;\n}\nvec4 LinearTosRGB( in vec4 value ) {\n	return vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );\n}";
var envmap_fragment = "#ifdef USE_ENVMAP\n	#ifdef ENV_WORLDPOS\n		vec3 cameraToFrag;\n		if ( isOrthographic ) {\n			cameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n		} else {\n			cameraToFrag = normalize( vWorldPosition - cameraPosition );\n		}\n		vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n		#ifdef ENVMAP_MODE_REFLECTION\n			vec3 reflectVec = reflect( cameraToFrag, worldNormal );\n		#else\n			vec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );\n		#endif\n	#else\n		vec3 reflectVec = vReflect;\n	#endif\n	#ifdef ENVMAP_TYPE_CUBE\n		vec4 envColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\n	#else\n		vec4 envColor = vec4( 0.0 );\n	#endif\n	#ifdef ENVMAP_BLENDING_MULTIPLY\n		outgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );\n	#elif defined( ENVMAP_BLENDING_MIX )\n		outgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );\n	#elif defined( ENVMAP_BLENDING_ADD )\n		outgoingLight += envColor.xyz * specularStrength * reflectivity;\n	#endif\n#endif";
var envmap_common_pars_fragment = "#ifdef USE_ENVMAP\n	uniform float envMapIntensity;\n	uniform float flipEnvMap;\n	#ifdef ENVMAP_TYPE_CUBE\n		uniform samplerCube envMap;\n	#else\n		uniform sampler2D envMap;\n	#endif\n	\n#endif";
var envmap_pars_fragment = "#ifdef USE_ENVMAP\n	uniform float reflectivity;\n	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )\n		#define ENV_WORLDPOS\n	#endif\n	#ifdef ENV_WORLDPOS\n		varying vec3 vWorldPosition;\n		uniform float refractionRatio;\n	#else\n		varying vec3 vReflect;\n	#endif\n#endif";
var envmap_pars_vertex = "#ifdef USE_ENVMAP\n	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )\n		#define ENV_WORLDPOS\n	#endif\n	#ifdef ENV_WORLDPOS\n		\n		varying vec3 vWorldPosition;\n	#else\n		varying vec3 vReflect;\n		uniform float refractionRatio;\n	#endif\n#endif";
var envmap_vertex = "#ifdef USE_ENVMAP\n	#ifdef ENV_WORLDPOS\n		vWorldPosition = worldPosition.xyz;\n	#else\n		vec3 cameraToVertex;\n		if ( isOrthographic ) {\n			cameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n		} else {\n			cameraToVertex = normalize( worldPosition.xyz - cameraPosition );\n		}\n		vec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n		#ifdef ENVMAP_MODE_REFLECTION\n			vReflect = reflect( cameraToVertex, worldNormal );\n		#else\n			vReflect = refract( cameraToVertex, worldNormal, refractionRatio );\n		#endif\n	#endif\n#endif";
var fog_vertex = "#ifdef USE_FOG\n	vFogDepth = - mvPosition.z;\n#endif";
var fog_pars_vertex = "#ifdef USE_FOG\n	varying float vFogDepth;\n#endif";
var fog_fragment = "#ifdef USE_FOG\n	#ifdef FOG_EXP2\n		float fogFactor = 1.0 - exp( - fogDensity * fogDensity * vFogDepth * vFogDepth );\n	#else\n		float fogFactor = smoothstep( fogNear, fogFar, vFogDepth );\n	#endif\n	gl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );\n#endif";
var fog_pars_fragment = "#ifdef USE_FOG\n	uniform vec3 fogColor;\n	varying float vFogDepth;\n	#ifdef FOG_EXP2\n		uniform float fogDensity;\n	#else\n		uniform float fogNear;\n		uniform float fogFar;\n	#endif\n#endif";
var gradientmap_pars_fragment = "#ifdef USE_GRADIENTMAP\n	uniform sampler2D gradientMap;\n#endif\nvec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {\n	float dotNL = dot( normal, lightDirection );\n	vec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );\n	#ifdef USE_GRADIENTMAP\n		return vec3( texture2D( gradientMap, coord ).r );\n	#else\n		vec2 fw = fwidth( coord ) * 0.5;\n		return mix( vec3( 0.7 ), vec3( 1.0 ), smoothstep( 0.7 - fw.x, 0.7 + fw.x, coord.x ) );\n	#endif\n}";
var lightmap_fragment = "#ifdef USE_LIGHTMAP\n	vec4 lightMapTexel = texture2D( lightMap, vLightMapUv );\n	vec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;\n	reflectedLight.indirectDiffuse += lightMapIrradiance;\n#endif";
var lightmap_pars_fragment = "#ifdef USE_LIGHTMAP\n	uniform sampler2D lightMap;\n	uniform float lightMapIntensity;\n#endif";
var lights_lambert_fragment = "LambertMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;\nmaterial.specularStrength = specularStrength;";
var lights_lambert_pars_fragment = "varying vec3 vViewPosition;\nstruct LambertMaterial {\n	vec3 diffuseColor;\n	float specularStrength;\n};\nvoid RE_Direct_Lambert( const in IncidentLight directLight, const in GeometricContext geometry, const in LambertMaterial material, inout ReflectedLight reflectedLight ) {\n	float dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n	vec3 irradiance = dotNL * directLight.color;\n	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Lambert( const in vec3 irradiance, const in GeometricContext geometry, const in LambertMaterial material, inout ReflectedLight reflectedLight ) {\n	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\n#define RE_Direct				RE_Direct_Lambert\n#define RE_IndirectDiffuse		RE_IndirectDiffuse_Lambert";
var lights_pars_begin = "uniform bool receiveShadow;\nuniform vec3 ambientLightColor;\nuniform vec3 lightProbe[ 9 ];\nvec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {\n	float x = normal.x, y = normal.y, z = normal.z;\n	vec3 result = shCoefficients[ 0 ] * 0.886227;\n	result += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;\n	result += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;\n	result += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;\n	result += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;\n	result += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;\n	result += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );\n	result += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;\n	result += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );\n	return result;\n}\nvec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in vec3 normal ) {\n	vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n	vec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );\n	return irradiance;\n}\nvec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {\n	vec3 irradiance = ambientLightColor;\n	return irradiance;\n}\nfloat getDistanceAttenuation( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {\n	#if defined ( LEGACY_LIGHTS )\n		if ( cutoffDistance > 0.0 && decayExponent > 0.0 ) {\n			return pow( saturate( - lightDistance / cutoffDistance + 1.0 ), decayExponent );\n		}\n		return 1.0;\n	#else\n		float distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );\n		if ( cutoffDistance > 0.0 ) {\n			distanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );\n		}\n		return distanceFalloff;\n	#endif\n}\nfloat getSpotAttenuation( const in float coneCosine, const in float penumbraCosine, const in float angleCosine ) {\n	return smoothstep( coneCosine, penumbraCosine, angleCosine );\n}\n#if NUM_DIR_LIGHTS > 0\n	struct DirectionalLight {\n		vec3 direction;\n		vec3 color;\n	};\n	uniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\n	void getDirectionalLightInfo( const in DirectionalLight directionalLight, const in GeometricContext geometry, out IncidentLight light ) {\n		light.color = directionalLight.color;\n		light.direction = directionalLight.direction;\n		light.visible = true;\n	}\n#endif\n#if NUM_POINT_LIGHTS > 0\n	struct PointLight {\n		vec3 position;\n		vec3 color;\n		float distance;\n		float decay;\n	};\n	uniform PointLight pointLights[ NUM_POINT_LIGHTS ];\n	void getPointLightInfo( const in PointLight pointLight, const in GeometricContext geometry, out IncidentLight light ) {\n		vec3 lVector = pointLight.position - geometry.position;\n		light.direction = normalize( lVector );\n		float lightDistance = length( lVector );\n		light.color = pointLight.color;\n		light.color *= getDistanceAttenuation( lightDistance, pointLight.distance, pointLight.decay );\n		light.visible = ( light.color != vec3( 0.0 ) );\n	}\n#endif\n#if NUM_SPOT_LIGHTS > 0\n	struct SpotLight {\n		vec3 position;\n		vec3 direction;\n		vec3 color;\n		float distance;\n		float decay;\n		float coneCos;\n		float penumbraCos;\n	};\n	uniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];\n	void getSpotLightInfo( const in SpotLight spotLight, const in GeometricContext geometry, out IncidentLight light ) {\n		vec3 lVector = spotLight.position - geometry.position;\n		light.direction = normalize( lVector );\n		float angleCos = dot( light.direction, spotLight.direction );\n		float spotAttenuation = getSpotAttenuation( spotLight.coneCos, spotLight.penumbraCos, angleCos );\n		if ( spotAttenuation > 0.0 ) {\n			float lightDistance = length( lVector );\n			light.color = spotLight.color * spotAttenuation;\n			light.color *= getDistanceAttenuation( lightDistance, spotLight.distance, spotLight.decay );\n			light.visible = ( light.color != vec3( 0.0 ) );\n		} else {\n			light.color = vec3( 0.0 );\n			light.visible = false;\n		}\n	}\n#endif\n#if NUM_RECT_AREA_LIGHTS > 0\n	struct RectAreaLight {\n		vec3 color;\n		vec3 position;\n		vec3 halfWidth;\n		vec3 halfHeight;\n	};\n	uniform sampler2D ltc_1;	uniform sampler2D ltc_2;\n	uniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];\n#endif\n#if NUM_HEMI_LIGHTS > 0\n	struct HemisphereLight {\n		vec3 direction;\n		vec3 skyColor;\n		vec3 groundColor;\n	};\n	uniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];\n	vec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in vec3 normal ) {\n		float dotNL = dot( normal, hemiLight.direction );\n		float hemiDiffuseWeight = 0.5 * dotNL + 0.5;\n		vec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );\n		return irradiance;\n	}\n#endif";
var envmap_physical_pars_fragment = "#ifdef USE_ENVMAP\n	vec3 getIBLIrradiance( const in vec3 normal ) {\n		#ifdef ENVMAP_TYPE_CUBE_UV\n			vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n			vec4 envMapColor = textureCubeUV( envMap, worldNormal, 1.0 );\n			return PI * envMapColor.rgb * envMapIntensity;\n		#else\n			return vec3( 0.0 );\n		#endif\n	}\n	vec3 getIBLRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness ) {\n		#ifdef ENVMAP_TYPE_CUBE_UV\n			vec3 reflectVec = reflect( - viewDir, normal );\n			reflectVec = normalize( mix( reflectVec, normal, roughness * roughness) );\n			reflectVec = inverseTransformDirection( reflectVec, viewMatrix );\n			vec4 envMapColor = textureCubeUV( envMap, reflectVec, roughness );\n			return envMapColor.rgb * envMapIntensity;\n		#else\n			return vec3( 0.0 );\n		#endif\n	}\n	#ifdef USE_ANISOTROPY\n		vec3 getIBLAnisotropyRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness, const in vec3 bitangent, const in float anisotropy ) {\n			#ifdef ENVMAP_TYPE_CUBE_UV\n				vec3 bentNormal = cross( bitangent, viewDir );\n				bentNormal = normalize( cross( bentNormal, bitangent ) );\n				bentNormal = normalize( mix( bentNormal, normal, pow2( pow2( 1.0 - anisotropy * ( 1.0 - roughness ) ) ) ) );\n				return getIBLRadiance( viewDir, bentNormal, roughness );\n			#else\n				return vec3( 0.0 );\n			#endif\n		}\n	#endif\n#endif";
var lights_toon_fragment = "ToonMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;";
var lights_toon_pars_fragment = "varying vec3 vViewPosition;\nstruct ToonMaterial {\n	vec3 diffuseColor;\n};\nvoid RE_Direct_Toon( const in IncidentLight directLight, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n	vec3 irradiance = getGradientIrradiance( geometry.normal, directLight.direction ) * directLight.color;\n	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Toon( const in vec3 irradiance, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\n#define RE_Direct				RE_Direct_Toon\n#define RE_IndirectDiffuse		RE_IndirectDiffuse_Toon";
var lights_phong_fragment = "BlinnPhongMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;\nmaterial.specularColor = specular;\nmaterial.specularShininess = shininess;\nmaterial.specularStrength = specularStrength;";
var lights_phong_pars_fragment = "varying vec3 vViewPosition;\nstruct BlinnPhongMaterial {\n	vec3 diffuseColor;\n	vec3 specularColor;\n	float specularShininess;\n	float specularStrength;\n};\nvoid RE_Direct_BlinnPhong( const in IncidentLight directLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n	float dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n	vec3 irradiance = dotNL * directLight.color;\n	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n	reflectedLight.directSpecular += irradiance * BRDF_BlinnPhong( directLight.direction, geometry.viewDir, geometry.normal, material.specularColor, material.specularShininess ) * material.specularStrength;\n}\nvoid RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\n#define RE_Direct				RE_Direct_BlinnPhong\n#define RE_IndirectDiffuse		RE_IndirectDiffuse_BlinnPhong";
var lights_physical_fragment = "PhysicalMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );\nvec3 dxy = max( abs( dFdx( geometryNormal ) ), abs( dFdy( geometryNormal ) ) );\nfloat geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );\nmaterial.roughness = max( roughnessFactor, 0.0525 );material.roughness += geometryRoughness;\nmaterial.roughness = min( material.roughness, 1.0 );\n#ifdef IOR\n	material.ior = ior;\n	#ifdef USE_SPECULAR\n		float specularIntensityFactor = specularIntensity;\n		vec3 specularColorFactor = specularColor;\n		#ifdef USE_SPECULAR_COLORMAP\n			specularColorFactor *= texture2D( specularColorMap, vSpecularColorMapUv ).rgb;\n		#endif\n		#ifdef USE_SPECULAR_INTENSITYMAP\n			specularIntensityFactor *= texture2D( specularIntensityMap, vSpecularIntensityMapUv ).a;\n		#endif\n		material.specularF90 = mix( specularIntensityFactor, 1.0, metalnessFactor );\n	#else\n		float specularIntensityFactor = 1.0;\n		vec3 specularColorFactor = vec3( 1.0 );\n		material.specularF90 = 1.0;\n	#endif\n	material.specularColor = mix( min( pow2( ( material.ior - 1.0 ) / ( material.ior + 1.0 ) ) * specularColorFactor, vec3( 1.0 ) ) * specularIntensityFactor, diffuseColor.rgb, metalnessFactor );\n#else\n	material.specularColor = mix( vec3( 0.04 ), diffuseColor.rgb, metalnessFactor );\n	material.specularF90 = 1.0;\n#endif\n#ifdef USE_CLEARCOAT\n	material.clearcoat = clearcoat;\n	material.clearcoatRoughness = clearcoatRoughness;\n	material.clearcoatF0 = vec3( 0.04 );\n	material.clearcoatF90 = 1.0;\n	#ifdef USE_CLEARCOATMAP\n		material.clearcoat *= texture2D( clearcoatMap, vClearcoatMapUv ).x;\n	#endif\n	#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n		material.clearcoatRoughness *= texture2D( clearcoatRoughnessMap, vClearcoatRoughnessMapUv ).y;\n	#endif\n	material.clearcoat = saturate( material.clearcoat );	material.clearcoatRoughness = max( material.clearcoatRoughness, 0.0525 );\n	material.clearcoatRoughness += geometryRoughness;\n	material.clearcoatRoughness = min( material.clearcoatRoughness, 1.0 );\n#endif\n#ifdef USE_IRIDESCENCE\n	material.iridescence = iridescence;\n	material.iridescenceIOR = iridescenceIOR;\n	#ifdef USE_IRIDESCENCEMAP\n		material.iridescence *= texture2D( iridescenceMap, vIridescenceMapUv ).r;\n	#endif\n	#ifdef USE_IRIDESCENCE_THICKNESSMAP\n		material.iridescenceThickness = (iridescenceThicknessMaximum - iridescenceThicknessMinimum) * texture2D( iridescenceThicknessMap, vIridescenceThicknessMapUv ).g + iridescenceThicknessMinimum;\n	#else\n		material.iridescenceThickness = iridescenceThicknessMaximum;\n	#endif\n#endif\n#ifdef USE_SHEEN\n	material.sheenColor = sheenColor;\n	#ifdef USE_SHEEN_COLORMAP\n		material.sheenColor *= texture2D( sheenColorMap, vSheenColorMapUv ).rgb;\n	#endif\n	material.sheenRoughness = clamp( sheenRoughness, 0.07, 1.0 );\n	#ifdef USE_SHEEN_ROUGHNESSMAP\n		material.sheenRoughness *= texture2D( sheenRoughnessMap, vSheenRoughnessMapUv ).a;\n	#endif\n#endif\n#ifdef USE_ANISOTROPY\n	#ifdef USE_ANISOTROPYMAP\n		mat2 anisotropyMat = mat2( anisotropyVector.x, anisotropyVector.y, - anisotropyVector.y, anisotropyVector.x );\n		vec3 anisotropyPolar = texture2D( anisotropyMap, vAnisotropyMapUv ).rgb;\n		vec2 anisotropyV = anisotropyMat * normalize( 2.0 * anisotropyPolar.rg - vec2( 1.0 ) ) * anisotropyPolar.b;\n	#else\n		vec2 anisotropyV = anisotropyVector;\n	#endif\n	material.anisotropy = length( anisotropyV );\n	anisotropyV /= material.anisotropy;\n	material.anisotropy = saturate( material.anisotropy );\n	material.alphaT = mix( pow2( material.roughness ), 1.0, pow2( material.anisotropy ) );\n	material.anisotropyT = tbn[ 0 ] * anisotropyV.x - tbn[ 1 ] * anisotropyV.y;\n	material.anisotropyB = tbn[ 1 ] * anisotropyV.x + tbn[ 0 ] * anisotropyV.y;\n#endif";
var lights_physical_pars_fragment = "struct PhysicalMaterial {\n	vec3 diffuseColor;\n	float roughness;\n	vec3 specularColor;\n	float specularF90;\n	#ifdef USE_CLEARCOAT\n		float clearcoat;\n		float clearcoatRoughness;\n		vec3 clearcoatF0;\n		float clearcoatF90;\n	#endif\n	#ifdef USE_IRIDESCENCE\n		float iridescence;\n		float iridescenceIOR;\n		float iridescenceThickness;\n		vec3 iridescenceFresnel;\n		vec3 iridescenceF0;\n	#endif\n	#ifdef USE_SHEEN\n		vec3 sheenColor;\n		float sheenRoughness;\n	#endif\n	#ifdef IOR\n		float ior;\n	#endif\n	#ifdef USE_TRANSMISSION\n		float transmission;\n		float transmissionAlpha;\n		float thickness;\n		float attenuationDistance;\n		vec3 attenuationColor;\n	#endif\n	#ifdef USE_ANISOTROPY\n		float anisotropy;\n		float alphaT;\n		vec3 anisotropyT;\n		vec3 anisotropyB;\n	#endif\n};\nvec3 clearcoatSpecular = vec3( 0.0 );\nvec3 sheenSpecular = vec3( 0.0 );\nvec3 Schlick_to_F0( const in vec3 f, const in float f90, const in float dotVH ) {\n    float x = clamp( 1.0 - dotVH, 0.0, 1.0 );\n    float x2 = x * x;\n    float x5 = clamp( x * x2 * x2, 0.0, 0.9999 );\n    return ( f - vec3( f90 ) * x5 ) / ( 1.0 - x5 );\n}\nfloat V_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {\n	float a2 = pow2( alpha );\n	float gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n	float gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n	return 0.5 / max( gv + gl, EPSILON );\n}\nfloat D_GGX( const in float alpha, const in float dotNH ) {\n	float a2 = pow2( alpha );\n	float denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;\n	return RECIPROCAL_PI * a2 / pow2( denom );\n}\n#ifdef USE_ANISOTROPY\n	float V_GGX_SmithCorrelated_Anisotropic( const in float alphaT, const in float alphaB, const in float dotTV, const in float dotBV, const in float dotTL, const in float dotBL, const in float dotNV, const in float dotNL ) {\n		float gv = dotNL * length( vec3( alphaT * dotTV, alphaB * dotBV, dotNV ) );\n		float gl = dotNV * length( vec3( alphaT * dotTL, alphaB * dotBL, dotNL ) );\n		float v = 0.5 / ( gv + gl );\n		return saturate(v);\n	}\n	float D_GGX_Anisotropic( const in float alphaT, const in float alphaB, const in float dotNH, const in float dotTH, const in float dotBH ) {\n		float a2 = alphaT * alphaB;\n		highp vec3 v = vec3( alphaB * dotTH, alphaT * dotBH, a2 * dotNH );\n		highp float v2 = dot( v, v );\n		float w2 = a2 / v2;\n		return RECIPROCAL_PI * a2 * pow2 ( w2 );\n	}\n#endif\n#ifdef USE_CLEARCOAT\n	vec3 BRDF_GGX_Clearcoat( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in PhysicalMaterial material) {\n		vec3 f0 = material.clearcoatF0;\n		float f90 = material.clearcoatF90;\n		float roughness = material.clearcoatRoughness;\n		float alpha = pow2( roughness );\n		vec3 halfDir = normalize( lightDir + viewDir );\n		float dotNL = saturate( dot( normal, lightDir ) );\n		float dotNV = saturate( dot( normal, viewDir ) );\n		float dotNH = saturate( dot( normal, halfDir ) );\n		float dotVH = saturate( dot( viewDir, halfDir ) );\n		vec3 F = F_Schlick( f0, f90, dotVH );\n		float V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n		float D = D_GGX( alpha, dotNH );\n		return F * ( V * D );\n	}\n#endif\nvec3 BRDF_GGX( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in PhysicalMaterial material ) {\n	vec3 f0 = material.specularColor;\n	float f90 = material.specularF90;\n	float roughness = material.roughness;\n	float alpha = pow2( roughness );\n	vec3 halfDir = normalize( lightDir + viewDir );\n	float dotNL = saturate( dot( normal, lightDir ) );\n	float dotNV = saturate( dot( normal, viewDir ) );\n	float dotNH = saturate( dot( normal, halfDir ) );\n	float dotVH = saturate( dot( viewDir, halfDir ) );\n	vec3 F = F_Schlick( f0, f90, dotVH );\n	#ifdef USE_IRIDESCENCE\n		F = mix( F, material.iridescenceFresnel, material.iridescence );\n	#endif\n	#ifdef USE_ANISOTROPY\n		float dotTL = dot( material.anisotropyT, lightDir );\n		float dotTV = dot( material.anisotropyT, viewDir );\n		float dotTH = dot( material.anisotropyT, halfDir );\n		float dotBL = dot( material.anisotropyB, lightDir );\n		float dotBV = dot( material.anisotropyB, viewDir );\n		float dotBH = dot( material.anisotropyB, halfDir );\n		float V = V_GGX_SmithCorrelated_Anisotropic( material.alphaT, alpha, dotTV, dotBV, dotTL, dotBL, dotNV, dotNL );\n		float D = D_GGX_Anisotropic( material.alphaT, alpha, dotNH, dotTH, dotBH );\n	#else\n		float V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n		float D = D_GGX( alpha, dotNH );\n	#endif\n	return F * ( V * D );\n}\nvec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {\n	const float LUT_SIZE = 64.0;\n	const float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;\n	const float LUT_BIAS = 0.5 / LUT_SIZE;\n	float dotNV = saturate( dot( N, V ) );\n	vec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );\n	uv = uv * LUT_SCALE + LUT_BIAS;\n	return uv;\n}\nfloat LTC_ClippedSphereFormFactor( const in vec3 f ) {\n	float l = length( f );\n	return max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );\n}\nvec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {\n	float x = dot( v1, v2 );\n	float y = abs( x );\n	float a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;\n	float b = 3.4175940 + ( 4.1616724 + y ) * y;\n	float v = a / b;\n	float theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;\n	return cross( v1, v2 ) * theta_sintheta;\n}\nvec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {\n	vec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];\n	vec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];\n	vec3 lightNormal = cross( v1, v2 );\n	if( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );\n	vec3 T1, T2;\n	T1 = normalize( V - N * dot( V, N ) );\n	T2 = - cross( N, T1 );\n	mat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );\n	vec3 coords[ 4 ];\n	coords[ 0 ] = mat * ( rectCoords[ 0 ] - P );\n	coords[ 1 ] = mat * ( rectCoords[ 1 ] - P );\n	coords[ 2 ] = mat * ( rectCoords[ 2 ] - P );\n	coords[ 3 ] = mat * ( rectCoords[ 3 ] - P );\n	coords[ 0 ] = normalize( coords[ 0 ] );\n	coords[ 1 ] = normalize( coords[ 1 ] );\n	coords[ 2 ] = normalize( coords[ 2 ] );\n	coords[ 3 ] = normalize( coords[ 3 ] );\n	vec3 vectorFormFactor = vec3( 0.0 );\n	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );\n	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );\n	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );\n	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );\n	float result = LTC_ClippedSphereFormFactor( vectorFormFactor );\n	return vec3( result );\n}\n#if defined( USE_SHEEN )\nfloat D_Charlie( float roughness, float dotNH ) {\n	float alpha = pow2( roughness );\n	float invAlpha = 1.0 / alpha;\n	float cos2h = dotNH * dotNH;\n	float sin2h = max( 1.0 - cos2h, 0.0078125 );\n	return ( 2.0 + invAlpha ) * pow( sin2h, invAlpha * 0.5 ) / ( 2.0 * PI );\n}\nfloat V_Neubelt( float dotNV, float dotNL ) {\n	return saturate( 1.0 / ( 4.0 * ( dotNL + dotNV - dotNL * dotNV ) ) );\n}\nvec3 BRDF_Sheen( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, vec3 sheenColor, const in float sheenRoughness ) {\n	vec3 halfDir = normalize( lightDir + viewDir );\n	float dotNL = saturate( dot( normal, lightDir ) );\n	float dotNV = saturate( dot( normal, viewDir ) );\n	float dotNH = saturate( dot( normal, halfDir ) );\n	float D = D_Charlie( sheenRoughness, dotNH );\n	float V = V_Neubelt( dotNV, dotNL );\n	return sheenColor * ( D * V );\n}\n#endif\nfloat IBLSheenBRDF( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {\n	float dotNV = saturate( dot( normal, viewDir ) );\n	float r2 = roughness * roughness;\n	float a = roughness < 0.25 ? -339.2 * r2 + 161.4 * roughness - 25.9 : -8.48 * r2 + 14.3 * roughness - 9.95;\n	float b = roughness < 0.25 ? 44.0 * r2 - 23.7 * roughness + 3.26 : 1.97 * r2 - 3.27 * roughness + 0.72;\n	float DG = exp( a * dotNV + b ) + ( roughness < 0.25 ? 0.0 : 0.1 * ( roughness - 0.25 ) );\n	return saturate( DG * RECIPROCAL_PI );\n}\nvec2 DFGApprox( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {\n	float dotNV = saturate( dot( normal, viewDir ) );\n	const vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );\n	const vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );\n	vec4 r = roughness * c0 + c1;\n	float a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;\n	vec2 fab = vec2( - 1.04, 1.04 ) * a004 + r.zw;\n	return fab;\n}\nvec3 EnvironmentBRDF( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness ) {\n	vec2 fab = DFGApprox( normal, viewDir, roughness );\n	return specularColor * fab.x + specularF90 * fab.y;\n}\n#ifdef USE_IRIDESCENCE\nvoid computeMultiscatteringIridescence( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float iridescence, const in vec3 iridescenceF0, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {\n#else\nvoid computeMultiscattering( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {\n#endif\n	vec2 fab = DFGApprox( normal, viewDir, roughness );\n	#ifdef USE_IRIDESCENCE\n		vec3 Fr = mix( specularColor, iridescenceF0, iridescence );\n	#else\n		vec3 Fr = specularColor;\n	#endif\n	vec3 FssEss = Fr * fab.x + specularF90 * fab.y;\n	float Ess = fab.x + fab.y;\n	float Ems = 1.0 - Ess;\n	vec3 Favg = Fr + ( 1.0 - Fr ) * 0.047619;	vec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );\n	singleScatter += FssEss;\n	multiScatter += Fms * Ems;\n}\n#if NUM_RECT_AREA_LIGHTS > 0\n	void RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n		vec3 normal = geometry.normal;\n		vec3 viewDir = geometry.viewDir;\n		vec3 position = geometry.position;\n		vec3 lightPos = rectAreaLight.position;\n		vec3 halfWidth = rectAreaLight.halfWidth;\n		vec3 halfHeight = rectAreaLight.halfHeight;\n		vec3 lightColor = rectAreaLight.color;\n		float roughness = material.roughness;\n		vec3 rectCoords[ 4 ];\n		rectCoords[ 0 ] = lightPos + halfWidth - halfHeight;		rectCoords[ 1 ] = lightPos - halfWidth - halfHeight;\n		rectCoords[ 2 ] = lightPos - halfWidth + halfHeight;\n		rectCoords[ 3 ] = lightPos + halfWidth + halfHeight;\n		vec2 uv = LTC_Uv( normal, viewDir, roughness );\n		vec4 t1 = texture2D( ltc_1, uv );\n		vec4 t2 = texture2D( ltc_2, uv );\n		mat3 mInv = mat3(\n			vec3( t1.x, 0, t1.y ),\n			vec3(    0, 1,    0 ),\n			vec3( t1.z, 0, t1.w )\n		);\n		vec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );\n		reflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );\n		reflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );\n	}\n#endif\nvoid RE_Direct_Physical( const in IncidentLight directLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n	float dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n	vec3 irradiance = dotNL * directLight.color;\n	#ifdef USE_CLEARCOAT\n		float dotNLcc = saturate( dot( geometry.clearcoatNormal, directLight.direction ) );\n		vec3 ccIrradiance = dotNLcc * directLight.color;\n		clearcoatSpecular += ccIrradiance * BRDF_GGX_Clearcoat( directLight.direction, geometry.viewDir, geometry.clearcoatNormal, material );\n	#endif\n	#ifdef USE_SHEEN\n		sheenSpecular += irradiance * BRDF_Sheen( directLight.direction, geometry.viewDir, geometry.normal, material.sheenColor, material.sheenRoughness );\n	#endif\n	reflectedLight.directSpecular += irradiance * BRDF_GGX( directLight.direction, geometry.viewDir, geometry.normal, material );\n	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {\n	#ifdef USE_CLEARCOAT\n		clearcoatSpecular += clearcoatRadiance * EnvironmentBRDF( geometry.clearcoatNormal, geometry.viewDir, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );\n	#endif\n	#ifdef USE_SHEEN\n		sheenSpecular += irradiance * material.sheenColor * IBLSheenBRDF( geometry.normal, geometry.viewDir, material.sheenRoughness );\n	#endif\n	vec3 singleScattering = vec3( 0.0 );\n	vec3 multiScattering = vec3( 0.0 );\n	vec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;\n	#ifdef USE_IRIDESCENCE\n		computeMultiscatteringIridescence( geometry.normal, geometry.viewDir, material.specularColor, material.specularF90, material.iridescence, material.iridescenceFresnel, material.roughness, singleScattering, multiScattering );\n	#else\n		computeMultiscattering( geometry.normal, geometry.viewDir, material.specularColor, material.specularF90, material.roughness, singleScattering, multiScattering );\n	#endif\n	vec3 totalScattering = singleScattering + multiScattering;\n	vec3 diffuse = material.diffuseColor * ( 1.0 - max( max( totalScattering.r, totalScattering.g ), totalScattering.b ) );\n	reflectedLight.indirectSpecular += radiance * singleScattering;\n	reflectedLight.indirectSpecular += multiScattering * cosineWeightedIrradiance;\n	reflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;\n}\n#define RE_Direct				RE_Direct_Physical\n#define RE_Direct_RectArea		RE_Direct_RectArea_Physical\n#define RE_IndirectDiffuse		RE_IndirectDiffuse_Physical\n#define RE_IndirectSpecular		RE_IndirectSpecular_Physical\nfloat computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {\n	return saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );\n}";
var lights_fragment_begin = "\nGeometricContext geometry;\ngeometry.position = - vViewPosition;\ngeometry.normal = normal;\ngeometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );\n#ifdef USE_CLEARCOAT\n	geometry.clearcoatNormal = clearcoatNormal;\n#endif\n#ifdef USE_IRIDESCENCE\n	float dotNVi = saturate( dot( normal, geometry.viewDir ) );\n	if ( material.iridescenceThickness == 0.0 ) {\n		material.iridescence = 0.0;\n	} else {\n		material.iridescence = saturate( material.iridescence );\n	}\n	if ( material.iridescence > 0.0 ) {\n		material.iridescenceFresnel = evalIridescence( 1.0, material.iridescenceIOR, dotNVi, material.iridescenceThickness, material.specularColor );\n		material.iridescenceF0 = Schlick_to_F0( material.iridescenceFresnel, 1.0, dotNVi );\n	}\n#endif\nIncidentLight directLight;\n#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )\n	PointLight pointLight;\n	#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0\n	PointLightShadow pointLightShadow;\n	#endif\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n		pointLight = pointLights[ i ];\n		getPointLightInfo( pointLight, geometry, directLight );\n		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )\n		pointLightShadow = pointLightShadows[ i ];\n		directLight.color *= ( directLight.visible && receiveShadow ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;\n		#endif\n		RE_Direct( directLight, geometry, material, reflectedLight );\n	}\n	#pragma unroll_loop_end\n#endif\n#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )\n	SpotLight spotLight;\n	vec4 spotColor;\n	vec3 spotLightCoord;\n	bool inSpotLightMap;\n	#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0\n	SpotLightShadow spotLightShadow;\n	#endif\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n		spotLight = spotLights[ i ];\n		getSpotLightInfo( spotLight, geometry, directLight );\n		#if ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )\n		#define SPOT_LIGHT_MAP_INDEX UNROLLED_LOOP_INDEX\n		#elif ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )\n		#define SPOT_LIGHT_MAP_INDEX NUM_SPOT_LIGHT_MAPS\n		#else\n		#define SPOT_LIGHT_MAP_INDEX ( UNROLLED_LOOP_INDEX - NUM_SPOT_LIGHT_SHADOWS + NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )\n		#endif\n		#if ( SPOT_LIGHT_MAP_INDEX < NUM_SPOT_LIGHT_MAPS )\n			spotLightCoord = vSpotLightCoord[ i ].xyz / vSpotLightCoord[ i ].w;\n			inSpotLightMap = all( lessThan( abs( spotLightCoord * 2. - 1. ), vec3( 1.0 ) ) );\n			spotColor = texture2D( spotLightMap[ SPOT_LIGHT_MAP_INDEX ], spotLightCoord.xy );\n			directLight.color = inSpotLightMap ? directLight.color * spotColor.rgb : directLight.color;\n		#endif\n		#undef SPOT_LIGHT_MAP_INDEX\n		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )\n		spotLightShadow = spotLightShadows[ i ];\n		directLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;\n		#endif\n		RE_Direct( directLight, geometry, material, reflectedLight );\n	}\n	#pragma unroll_loop_end\n#endif\n#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )\n	DirectionalLight directionalLight;\n	#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0\n	DirectionalLightShadow directionalLightShadow;\n	#endif\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n		directionalLight = directionalLights[ i ];\n		getDirectionalLightInfo( directionalLight, geometry, directLight );\n		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )\n		directionalLightShadow = directionalLightShadows[ i ];\n		directLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n		#endif\n		RE_Direct( directLight, geometry, material, reflectedLight );\n	}\n	#pragma unroll_loop_end\n#endif\n#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )\n	RectAreaLight rectAreaLight;\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {\n		rectAreaLight = rectAreaLights[ i ];\n		RE_Direct_RectArea( rectAreaLight, geometry, material, reflectedLight );\n	}\n	#pragma unroll_loop_end\n#endif\n#if defined( RE_IndirectDiffuse )\n	vec3 iblIrradiance = vec3( 0.0 );\n	vec3 irradiance = getAmbientLightIrradiance( ambientLightColor );\n	irradiance += getLightProbeIrradiance( lightProbe, geometry.normal );\n	#if ( NUM_HEMI_LIGHTS > 0 )\n		#pragma unroll_loop_start\n		for ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n			irradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry.normal );\n		}\n		#pragma unroll_loop_end\n	#endif\n#endif\n#if defined( RE_IndirectSpecular )\n	vec3 radiance = vec3( 0.0 );\n	vec3 clearcoatRadiance = vec3( 0.0 );\n#endif";
var lights_fragment_maps = "#if defined( RE_IndirectDiffuse )\n	#ifdef USE_LIGHTMAP\n		vec4 lightMapTexel = texture2D( lightMap, vLightMapUv );\n		vec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;\n		irradiance += lightMapIrradiance;\n	#endif\n	#if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )\n		iblIrradiance += getIBLIrradiance( geometry.normal );\n	#endif\n#endif\n#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )\n	#ifdef USE_ANISOTROPY\n		radiance += getIBLAnisotropyRadiance( geometry.viewDir, geometry.normal, material.roughness, material.anisotropyB, material.anisotropy );\n	#else\n		radiance += getIBLRadiance( geometry.viewDir, geometry.normal, material.roughness );\n	#endif\n	#ifdef USE_CLEARCOAT\n		clearcoatRadiance += getIBLRadiance( geometry.viewDir, geometry.clearcoatNormal, material.clearcoatRoughness );\n	#endif\n#endif";
var lights_fragment_end = "#if defined( RE_IndirectDiffuse )\n	RE_IndirectDiffuse( irradiance, geometry, material, reflectedLight );\n#endif\n#if defined( RE_IndirectSpecular )\n	RE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometry, material, reflectedLight );\n#endif";
var logdepthbuf_fragment = "#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n	gl_FragDepthEXT = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;\n#endif";
var logdepthbuf_pars_fragment = "#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n	uniform float logDepthBufFC;\n	varying float vFragDepth;\n	varying float vIsPerspective;\n#endif";
var logdepthbuf_pars_vertex = "#ifdef USE_LOGDEPTHBUF\n	#ifdef USE_LOGDEPTHBUF_EXT\n		varying float vFragDepth;\n		varying float vIsPerspective;\n	#else\n		uniform float logDepthBufFC;\n	#endif\n#endif";
var logdepthbuf_vertex = "#ifdef USE_LOGDEPTHBUF\n	#ifdef USE_LOGDEPTHBUF_EXT\n		vFragDepth = 1.0 + gl_Position.w;\n		vIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );\n	#else\n		if ( isPerspectiveMatrix( projectionMatrix ) ) {\n			gl_Position.z = log2( max( EPSILON, gl_Position.w + 1.0 ) ) * logDepthBufFC - 1.0;\n			gl_Position.z *= gl_Position.w;\n		}\n	#endif\n#endif";
var map_fragment = "#ifdef USE_MAP\n	diffuseColor *= texture2D( map, vMapUv );\n#endif";
var map_pars_fragment = "#ifdef USE_MAP\n	uniform sampler2D map;\n#endif";
var map_particle_fragment = "#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n	#if defined( USE_POINTS_UV )\n		vec2 uv = vUv;\n	#else\n		vec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;\n	#endif\n#endif\n#ifdef USE_MAP\n	diffuseColor *= texture2D( map, uv );\n#endif\n#ifdef USE_ALPHAMAP\n	diffuseColor.a *= texture2D( alphaMap, uv ).g;\n#endif";
var map_particle_pars_fragment = "#if defined( USE_POINTS_UV )\n	varying vec2 vUv;\n#else\n	#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n		uniform mat3 uvTransform;\n	#endif\n#endif\n#ifdef USE_MAP\n	uniform sampler2D map;\n#endif\n#ifdef USE_ALPHAMAP\n	uniform sampler2D alphaMap;\n#endif";
var metalnessmap_fragment = "float metalnessFactor = metalness;\n#ifdef USE_METALNESSMAP\n	vec4 texelMetalness = texture2D( metalnessMap, vMetalnessMapUv );\n	metalnessFactor *= texelMetalness.b;\n#endif";
var metalnessmap_pars_fragment = "#ifdef USE_METALNESSMAP\n	uniform sampler2D metalnessMap;\n#endif";
var morphcolor_vertex = "#if defined( USE_MORPHCOLORS ) && defined( MORPHTARGETS_TEXTURE )\n	vColor *= morphTargetBaseInfluence;\n	for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n		#if defined( USE_COLOR_ALPHA )\n			if ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ) * morphTargetInfluences[ i ];\n		#elif defined( USE_COLOR )\n			if ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ).rgb * morphTargetInfluences[ i ];\n		#endif\n	}\n#endif";
var morphnormal_vertex = "#ifdef USE_MORPHNORMALS\n	objectNormal *= morphTargetBaseInfluence;\n	#ifdef MORPHTARGETS_TEXTURE\n		for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n			if ( morphTargetInfluences[ i ] != 0.0 ) objectNormal += getMorph( gl_VertexID, i, 1 ).xyz * morphTargetInfluences[ i ];\n		}\n	#else\n		objectNormal += morphNormal0 * morphTargetInfluences[ 0 ];\n		objectNormal += morphNormal1 * morphTargetInfluences[ 1 ];\n		objectNormal += morphNormal2 * morphTargetInfluences[ 2 ];\n		objectNormal += morphNormal3 * morphTargetInfluences[ 3 ];\n	#endif\n#endif";
var morphtarget_pars_vertex = "#ifdef USE_MORPHTARGETS\n	uniform float morphTargetBaseInfluence;\n	#ifdef MORPHTARGETS_TEXTURE\n		uniform float morphTargetInfluences[ MORPHTARGETS_COUNT ];\n		uniform sampler2DArray morphTargetsTexture;\n		uniform ivec2 morphTargetsTextureSize;\n		vec4 getMorph( const in int vertexIndex, const in int morphTargetIndex, const in int offset ) {\n			int texelIndex = vertexIndex * MORPHTARGETS_TEXTURE_STRIDE + offset;\n			int y = texelIndex / morphTargetsTextureSize.x;\n			int x = texelIndex - y * morphTargetsTextureSize.x;\n			ivec3 morphUV = ivec3( x, y, morphTargetIndex );\n			return texelFetch( morphTargetsTexture, morphUV, 0 );\n		}\n	#else\n		#ifndef USE_MORPHNORMALS\n			uniform float morphTargetInfluences[ 8 ];\n		#else\n			uniform float morphTargetInfluences[ 4 ];\n		#endif\n	#endif\n#endif";
var morphtarget_vertex = "#ifdef USE_MORPHTARGETS\n	transformed *= morphTargetBaseInfluence;\n	#ifdef MORPHTARGETS_TEXTURE\n		for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n			if ( morphTargetInfluences[ i ] != 0.0 ) transformed += getMorph( gl_VertexID, i, 0 ).xyz * morphTargetInfluences[ i ];\n		}\n	#else\n		transformed += morphTarget0 * morphTargetInfluences[ 0 ];\n		transformed += morphTarget1 * morphTargetInfluences[ 1 ];\n		transformed += morphTarget2 * morphTargetInfluences[ 2 ];\n		transformed += morphTarget3 * morphTargetInfluences[ 3 ];\n		#ifndef USE_MORPHNORMALS\n			transformed += morphTarget4 * morphTargetInfluences[ 4 ];\n			transformed += morphTarget5 * morphTargetInfluences[ 5 ];\n			transformed += morphTarget6 * morphTargetInfluences[ 6 ];\n			transformed += morphTarget7 * morphTargetInfluences[ 7 ];\n		#endif\n	#endif\n#endif";
var normal_fragment_begin = "float faceDirection = gl_FrontFacing ? 1.0 : - 1.0;\n#ifdef FLAT_SHADED\n	vec3 fdx = dFdx( vViewPosition );\n	vec3 fdy = dFdy( vViewPosition );\n	vec3 normal = normalize( cross( fdx, fdy ) );\n#else\n	vec3 normal = normalize( vNormal );\n	#ifdef DOUBLE_SIDED\n		normal *= faceDirection;\n	#endif\n#endif\n#if defined( USE_NORMALMAP_TANGENTSPACE ) || defined( USE_CLEARCOAT_NORMALMAP ) || defined( USE_ANISOTROPY )\n	#ifdef USE_TANGENT\n		mat3 tbn = mat3( normalize( vTangent ), normalize( vBitangent ), normal );\n	#else\n		mat3 tbn = getTangentFrame( - vViewPosition, normal, vNormalMapUv );\n	#endif\n	#if defined( DOUBLE_SIDED ) && ! defined( FLAT_SHADED )\n		tbn[0] *= faceDirection;\n		tbn[1] *= faceDirection;\n	#endif\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n	#ifdef USE_TANGENT\n		mat3 tbn2 = mat3( normalize( vTangent ), normalize( vBitangent ), normal );\n	#else\n		mat3 tbn2 = getTangentFrame( - vViewPosition, normal, vClearcoatNormalMapUv );\n	#endif\n	#if defined( DOUBLE_SIDED ) && ! defined( FLAT_SHADED )\n		tbn2[0] *= faceDirection;\n		tbn2[1] *= faceDirection;\n	#endif\n#endif\nvec3 geometryNormal = normal;";
var normal_fragment_maps = "#ifdef USE_NORMALMAP_OBJECTSPACE\n	normal = texture2D( normalMap, vNormalMapUv ).xyz * 2.0 - 1.0;\n	#ifdef FLIP_SIDED\n		normal = - normal;\n	#endif\n	#ifdef DOUBLE_SIDED\n		normal = normal * faceDirection;\n	#endif\n	normal = normalize( normalMatrix * normal );\n#elif defined( USE_NORMALMAP_TANGENTSPACE )\n	vec3 mapN = texture2D( normalMap, vNormalMapUv ).xyz * 2.0 - 1.0;\n	mapN.xy *= normalScale;\n	normal = normalize( tbn * mapN );\n#elif defined( USE_BUMPMAP )\n	normal = perturbNormalArb( - vViewPosition, normal, dHdxy_fwd(), faceDirection );\n#endif";
var normal_pars_fragment = "#ifndef FLAT_SHADED\n	varying vec3 vNormal;\n	#ifdef USE_TANGENT\n		varying vec3 vTangent;\n		varying vec3 vBitangent;\n	#endif\n#endif";
var normal_pars_vertex = "#ifndef FLAT_SHADED\n	varying vec3 vNormal;\n	#ifdef USE_TANGENT\n		varying vec3 vTangent;\n		varying vec3 vBitangent;\n	#endif\n#endif";
var normal_vertex = "#ifndef FLAT_SHADED\n	vNormal = normalize( transformedNormal );\n	#ifdef USE_TANGENT\n		vTangent = normalize( transformedTangent );\n		vBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );\n	#endif\n#endif";
var normalmap_pars_fragment = "#ifdef USE_NORMALMAP\n	uniform sampler2D normalMap;\n	uniform vec2 normalScale;\n#endif\n#ifdef USE_NORMALMAP_OBJECTSPACE\n	uniform mat3 normalMatrix;\n#endif\n#if ! defined ( USE_TANGENT ) && ( defined ( USE_NORMALMAP_TANGENTSPACE ) || defined ( USE_CLEARCOAT_NORMALMAP ) || defined( USE_ANISOTROPY ) )\n	mat3 getTangentFrame( vec3 eye_pos, vec3 surf_norm, vec2 uv ) {\n		vec3 q0 = dFdx( eye_pos.xyz );\n		vec3 q1 = dFdy( eye_pos.xyz );\n		vec2 st0 = dFdx( uv.st );\n		vec2 st1 = dFdy( uv.st );\n		vec3 N = surf_norm;\n		vec3 q1perp = cross( q1, N );\n		vec3 q0perp = cross( N, q0 );\n		vec3 T = q1perp * st0.x + q0perp * st1.x;\n		vec3 B = q1perp * st0.y + q0perp * st1.y;\n		float det = max( dot( T, T ), dot( B, B ) );\n		float scale = ( det == 0.0 ) ? 0.0 : inversesqrt( det );\n		return mat3( T * scale, B * scale, N );\n	}\n#endif";
var clearcoat_normal_fragment_begin = "#ifdef USE_CLEARCOAT\n	vec3 clearcoatNormal = geometryNormal;\n#endif";
var clearcoat_normal_fragment_maps = "#ifdef USE_CLEARCOAT_NORMALMAP\n	vec3 clearcoatMapN = texture2D( clearcoatNormalMap, vClearcoatNormalMapUv ).xyz * 2.0 - 1.0;\n	clearcoatMapN.xy *= clearcoatNormalScale;\n	clearcoatNormal = normalize( tbn2 * clearcoatMapN );\n#endif";
var clearcoat_pars_fragment = "#ifdef USE_CLEARCOATMAP\n	uniform sampler2D clearcoatMap;\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n	uniform sampler2D clearcoatNormalMap;\n	uniform vec2 clearcoatNormalScale;\n#endif\n#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n	uniform sampler2D clearcoatRoughnessMap;\n#endif";
var iridescence_pars_fragment = "#ifdef USE_IRIDESCENCEMAP\n	uniform sampler2D iridescenceMap;\n#endif\n#ifdef USE_IRIDESCENCE_THICKNESSMAP\n	uniform sampler2D iridescenceThicknessMap;\n#endif";
var output_fragment = "#ifdef OPAQUE\ndiffuseColor.a = 1.0;\n#endif\n#ifdef USE_TRANSMISSION\ndiffuseColor.a *= material.transmissionAlpha;\n#endif\ngl_FragColor = vec4( outgoingLight, diffuseColor.a );";
var packing = "vec3 packNormalToRGB( const in vec3 normal ) {\n	return normalize( normal ) * 0.5 + 0.5;\n}\nvec3 unpackRGBToNormal( const in vec3 rgb ) {\n	return 2.0 * rgb.xyz - 1.0;\n}\nconst float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;\nconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256., 256. );\nconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\nconst float ShiftRight8 = 1. / 256.;\nvec4 packDepthToRGBA( const in float v ) {\n	vec4 r = vec4( fract( v * PackFactors ), v );\n	r.yzw -= r.xyz * ShiftRight8;	return r * PackUpscale;\n}\nfloat unpackRGBAToDepth( const in vec4 v ) {\n	return dot( v, UnpackFactors );\n}\nvec2 packDepthToRG( in highp float v ) {\n	return packDepthToRGBA( v ).yx;\n}\nfloat unpackRGToDepth( const in highp vec2 v ) {\n	return unpackRGBAToDepth( vec4( v.xy, 0.0, 0.0 ) );\n}\nvec4 pack2HalfToRGBA( vec2 v ) {\n	vec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ) );\n	return vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w );\n}\nvec2 unpackRGBATo2Half( vec4 v ) {\n	return vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );\n}\nfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\n	return ( viewZ + near ) / ( near - far );\n}\nfloat orthographicDepthToViewZ( const in float depth, const in float near, const in float far ) {\n	return depth * ( near - far ) - near;\n}\nfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\n	return ( ( near + viewZ ) * far ) / ( ( far - near ) * viewZ );\n}\nfloat perspectiveDepthToViewZ( const in float depth, const in float near, const in float far ) {\n	return ( near * far ) / ( ( far - near ) * depth - far );\n}";
var premultiplied_alpha_fragment = "#ifdef PREMULTIPLIED_ALPHA\n	gl_FragColor.rgb *= gl_FragColor.a;\n#endif";
var project_vertex = "vec4 mvPosition = vec4( transformed, 1.0 );\n#ifdef USE_INSTANCING\n	mvPosition = instanceMatrix * mvPosition;\n#endif\nmvPosition = modelViewMatrix * mvPosition;\ngl_Position = projectionMatrix * mvPosition;";
var dithering_fragment = "#ifdef DITHERING\n	gl_FragColor.rgb = dithering( gl_FragColor.rgb );\n#endif";
var dithering_pars_fragment = "#ifdef DITHERING\n	vec3 dithering( vec3 color ) {\n		float grid_position = rand( gl_FragCoord.xy );\n		vec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );\n		dither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );\n		return color + dither_shift_RGB;\n	}\n#endif";
var roughnessmap_fragment = "float roughnessFactor = roughness;\n#ifdef USE_ROUGHNESSMAP\n	vec4 texelRoughness = texture2D( roughnessMap, vRoughnessMapUv );\n	roughnessFactor *= texelRoughness.g;\n#endif";
var roughnessmap_pars_fragment = "#ifdef USE_ROUGHNESSMAP\n	uniform sampler2D roughnessMap;\n#endif";
var shadowmap_pars_fragment = "#if NUM_SPOT_LIGHT_COORDS > 0\n	varying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_COORDS ];\n#endif\n#if NUM_SPOT_LIGHT_MAPS > 0\n	uniform sampler2D spotLightMap[ NUM_SPOT_LIGHT_MAPS ];\n#endif\n#ifdef USE_SHADOWMAP\n	#if NUM_DIR_LIGHT_SHADOWS > 0\n		uniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];\n		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n		struct DirectionalLightShadow {\n			float shadowBias;\n			float shadowNormalBias;\n			float shadowRadius;\n			vec2 shadowMapSize;\n		};\n		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\n	#endif\n	#if NUM_SPOT_LIGHT_SHADOWS > 0\n		uniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];\n		struct SpotLightShadow {\n			float shadowBias;\n			float shadowNormalBias;\n			float shadowRadius;\n			vec2 shadowMapSize;\n		};\n		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\n	#endif\n	#if NUM_POINT_LIGHT_SHADOWS > 0\n		uniform sampler2D pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];\n		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n		struct PointLightShadow {\n			float shadowBias;\n			float shadowNormalBias;\n			float shadowRadius;\n			vec2 shadowMapSize;\n			float shadowCameraNear;\n			float shadowCameraFar;\n		};\n		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\n	#endif\n	float texture2DCompare( sampler2D depths, vec2 uv, float compare ) {\n		return step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\n	}\n	vec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {\n		return unpackRGBATo2Half( texture2D( shadow, uv ) );\n	}\n	float VSMShadow (sampler2D shadow, vec2 uv, float compare ){\n		float occlusion = 1.0;\n		vec2 distribution = texture2DDistribution( shadow, uv );\n		float hard_shadow = step( compare , distribution.x );\n		if (hard_shadow != 1.0 ) {\n			float distance = compare - distribution.x ;\n			float variance = max( 0.00000, distribution.y * distribution.y );\n			float softness_probability = variance / (variance + distance * distance );			softness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 );			occlusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );\n		}\n		return occlusion;\n	}\n	float getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\n		float shadow = 1.0;\n		shadowCoord.xyz /= shadowCoord.w;\n		shadowCoord.z += shadowBias;\n		bool inFrustum = shadowCoord.x >= 0.0 && shadowCoord.x <= 1.0 && shadowCoord.y >= 0.0 && shadowCoord.y <= 1.0;\n		bool frustumTest = inFrustum && shadowCoord.z <= 1.0;\n		if ( frustumTest ) {\n		#if defined( SHADOWMAP_TYPE_PCF )\n			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n			float dx0 = - texelSize.x * shadowRadius;\n			float dy0 = - texelSize.y * shadowRadius;\n			float dx1 = + texelSize.x * shadowRadius;\n			float dy1 = + texelSize.y * shadowRadius;\n			float dx2 = dx0 / 2.0;\n			float dy2 = dy0 / 2.0;\n			float dx3 = dx1 / 2.0;\n			float dy3 = dy1 / 2.0;\n			shadow = (\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy2 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy2 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy2 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, 0.0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, 0.0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy3 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy3 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy3 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n			) * ( 1.0 / 17.0 );\n		#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\n			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n			float dx = texelSize.x;\n			float dy = texelSize.y;\n			vec2 uv = shadowCoord.xy;\n			vec2 f = fract( uv * shadowMapSize + 0.5 );\n			uv -= f * texelSize;\n			shadow = (\n				texture2DCompare( shadowMap, uv, shadowCoord.z ) +\n				texture2DCompare( shadowMap, uv + vec2( dx, 0.0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, uv + vec2( 0.0, dy ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, uv + texelSize, shadowCoord.z ) +\n				mix( texture2DCompare( shadowMap, uv + vec2( -dx, 0.0 ), shadowCoord.z ),\n					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 0.0 ), shadowCoord.z ),\n					 f.x ) +\n				mix( texture2DCompare( shadowMap, uv + vec2( -dx, dy ), shadowCoord.z ),\n					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, dy ), shadowCoord.z ),\n					 f.x ) +\n				mix( texture2DCompare( shadowMap, uv + vec2( 0.0, -dy ), shadowCoord.z ),\n					 texture2DCompare( shadowMap, uv + vec2( 0.0, 2.0 * dy ), shadowCoord.z ),\n					 f.y ) +\n				mix( texture2DCompare( shadowMap, uv + vec2( dx, -dy ), shadowCoord.z ),\n					 texture2DCompare( shadowMap, uv + vec2( dx, 2.0 * dy ), shadowCoord.z ),\n					 f.y ) +\n				mix( mix( texture2DCompare( shadowMap, uv + vec2( -dx, -dy ), shadowCoord.z ),\n						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, -dy ), shadowCoord.z ),\n						  f.x ),\n					 mix( texture2DCompare( shadowMap, uv + vec2( -dx, 2.0 * dy ), shadowCoord.z ),\n						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 2.0 * dy ), shadowCoord.z ),\n						  f.x ),\n					 f.y )\n			) * ( 1.0 / 9.0 );\n		#elif defined( SHADOWMAP_TYPE_VSM )\n			shadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );\n		#else\n			shadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\n		#endif\n		}\n		return shadow;\n	}\n	vec2 cubeToUV( vec3 v, float texelSizeY ) {\n		vec3 absV = abs( v );\n		float scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );\n		absV *= scaleToCube;\n		v *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );\n		vec2 planar = v.xy;\n		float almostATexel = 1.5 * texelSizeY;\n		float almostOne = 1.0 - almostATexel;\n		if ( absV.z >= almostOne ) {\n			if ( v.z > 0.0 )\n				planar.x = 4.0 - v.x;\n		} else if ( absV.x >= almostOne ) {\n			float signX = sign( v.x );\n			planar.x = v.z * signX + 2.0 * signX;\n		} else if ( absV.y >= almostOne ) {\n			float signY = sign( v.y );\n			planar.x = v.x + 2.0 * signY + 2.0;\n			planar.y = v.z * signY - 2.0;\n		}\n		return vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );\n	}\n	float getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {\n		vec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );\n		vec3 lightToPosition = shadowCoord.xyz;\n		float dp = ( length( lightToPosition ) - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );		dp += shadowBias;\n		vec3 bd3D = normalize( lightToPosition );\n		#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT ) || defined( SHADOWMAP_TYPE_VSM )\n			vec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;\n			return (\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )\n			) * ( 1.0 / 9.0 );\n		#else\n			return texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );\n		#endif\n	}\n#endif";
var shadowmap_pars_vertex = "#if NUM_SPOT_LIGHT_COORDS > 0\n	uniform mat4 spotLightMatrix[ NUM_SPOT_LIGHT_COORDS ];\n	varying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_COORDS ];\n#endif\n#ifdef USE_SHADOWMAP\n	#if NUM_DIR_LIGHT_SHADOWS > 0\n		uniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHT_SHADOWS ];\n		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n		struct DirectionalLightShadow {\n			float shadowBias;\n			float shadowNormalBias;\n			float shadowRadius;\n			vec2 shadowMapSize;\n		};\n		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\n	#endif\n	#if NUM_SPOT_LIGHT_SHADOWS > 0\n		struct SpotLightShadow {\n			float shadowBias;\n			float shadowNormalBias;\n			float shadowRadius;\n			vec2 shadowMapSize;\n		};\n		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\n	#endif\n	#if NUM_POINT_LIGHT_SHADOWS > 0\n		uniform mat4 pointShadowMatrix[ NUM_POINT_LIGHT_SHADOWS ];\n		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n		struct PointLightShadow {\n			float shadowBias;\n			float shadowNormalBias;\n			float shadowRadius;\n			vec2 shadowMapSize;\n			float shadowCameraNear;\n			float shadowCameraFar;\n		};\n		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\n	#endif\n#endif";
var shadowmap_vertex = "#if ( defined( USE_SHADOWMAP ) && ( NUM_DIR_LIGHT_SHADOWS > 0 || NUM_POINT_LIGHT_SHADOWS > 0 ) ) || ( NUM_SPOT_LIGHT_COORDS > 0 )\n	vec3 shadowWorldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n	vec4 shadowWorldPosition;\n#endif\n#if defined( USE_SHADOWMAP )\n	#if NUM_DIR_LIGHT_SHADOWS > 0\n		#pragma unroll_loop_start\n		for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n			shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * directionalLightShadows[ i ].shadowNormalBias, 0 );\n			vDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * shadowWorldPosition;\n		}\n		#pragma unroll_loop_end\n	#endif\n	#if NUM_POINT_LIGHT_SHADOWS > 0\n		#pragma unroll_loop_start\n		for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n			shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * pointLightShadows[ i ].shadowNormalBias, 0 );\n			vPointShadowCoord[ i ] = pointShadowMatrix[ i ] * shadowWorldPosition;\n		}\n		#pragma unroll_loop_end\n	#endif\n#endif\n#if NUM_SPOT_LIGHT_COORDS > 0\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_SPOT_LIGHT_COORDS; i ++ ) {\n		shadowWorldPosition = worldPosition;\n		#if ( defined( USE_SHADOWMAP ) && UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )\n			shadowWorldPosition.xyz += shadowWorldNormal * spotLightShadows[ i ].shadowNormalBias;\n		#endif\n		vSpotLightCoord[ i ] = spotLightMatrix[ i ] * shadowWorldPosition;\n	}\n	#pragma unroll_loop_end\n#endif";
var shadowmask_pars_fragment = "float getShadowMask() {\n	float shadow = 1.0;\n	#ifdef USE_SHADOWMAP\n	#if NUM_DIR_LIGHT_SHADOWS > 0\n	DirectionalLightShadow directionalLight;\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n		directionalLight = directionalLightShadows[ i ];\n		shadow *= receiveShadow ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n	}\n	#pragma unroll_loop_end\n	#endif\n	#if NUM_SPOT_LIGHT_SHADOWS > 0\n	SpotLightShadow spotLight;\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {\n		spotLight = spotLightShadows[ i ];\n		shadow *= receiveShadow ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;\n	}\n	#pragma unroll_loop_end\n	#endif\n	#if NUM_POINT_LIGHT_SHADOWS > 0\n	PointLightShadow pointLight;\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n		pointLight = pointLightShadows[ i ];\n		shadow *= receiveShadow ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;\n	}\n	#pragma unroll_loop_end\n	#endif\n	#endif\n	return shadow;\n}";
var skinbase_vertex = "#ifdef USE_SKINNING\n	mat4 boneMatX = getBoneMatrix( skinIndex.x );\n	mat4 boneMatY = getBoneMatrix( skinIndex.y );\n	mat4 boneMatZ = getBoneMatrix( skinIndex.z );\n	mat4 boneMatW = getBoneMatrix( skinIndex.w );\n#endif";
var skinning_pars_vertex = "#ifdef USE_SKINNING\n	uniform mat4 bindMatrix;\n	uniform mat4 bindMatrixInverse;\n	uniform highp sampler2D boneTexture;\n	uniform int boneTextureSize;\n	mat4 getBoneMatrix( const in float i ) {\n		float j = i * 4.0;\n		float x = mod( j, float( boneTextureSize ) );\n		float y = floor( j / float( boneTextureSize ) );\n		float dx = 1.0 / float( boneTextureSize );\n		float dy = 1.0 / float( boneTextureSize );\n		y = dy * ( y + 0.5 );\n		vec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );\n		vec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );\n		vec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );\n		vec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );\n		mat4 bone = mat4( v1, v2, v3, v4 );\n		return bone;\n	}\n#endif";
var skinning_vertex = "#ifdef USE_SKINNING\n	vec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );\n	vec4 skinned = vec4( 0.0 );\n	skinned += boneMatX * skinVertex * skinWeight.x;\n	skinned += boneMatY * skinVertex * skinWeight.y;\n	skinned += boneMatZ * skinVertex * skinWeight.z;\n	skinned += boneMatW * skinVertex * skinWeight.w;\n	transformed = ( bindMatrixInverse * skinned ).xyz;\n#endif";
var skinnormal_vertex = "#ifdef USE_SKINNING\n	mat4 skinMatrix = mat4( 0.0 );\n	skinMatrix += skinWeight.x * boneMatX;\n	skinMatrix += skinWeight.y * boneMatY;\n	skinMatrix += skinWeight.z * boneMatZ;\n	skinMatrix += skinWeight.w * boneMatW;\n	skinMatrix = bindMatrixInverse * skinMatrix * bindMatrix;\n	objectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;\n	#ifdef USE_TANGENT\n		objectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n	#endif\n#endif";
var specularmap_fragment = "float specularStrength;\n#ifdef USE_SPECULARMAP\n	vec4 texelSpecular = texture2D( specularMap, vSpecularMapUv );\n	specularStrength = texelSpecular.r;\n#else\n	specularStrength = 1.0;\n#endif";
var specularmap_pars_fragment = "#ifdef USE_SPECULARMAP\n	uniform sampler2D specularMap;\n#endif";
var tonemapping_fragment = "#if defined( TONE_MAPPING )\n	gl_FragColor.rgb = toneMapping( gl_FragColor.rgb );\n#endif";
var tonemapping_pars_fragment = "#ifndef saturate\n#define saturate( a ) clamp( a, 0.0, 1.0 )\n#endif\nuniform float toneMappingExposure;\nvec3 LinearToneMapping( vec3 color ) {\n	return saturate( toneMappingExposure * color );\n}\nvec3 ReinhardToneMapping( vec3 color ) {\n	color *= toneMappingExposure;\n	return saturate( color / ( vec3( 1.0 ) + color ) );\n}\nvec3 OptimizedCineonToneMapping( vec3 color ) {\n	color *= toneMappingExposure;\n	color = max( vec3( 0.0 ), color - 0.004 );\n	return pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );\n}\nvec3 RRTAndODTFit( vec3 v ) {\n	vec3 a = v * ( v + 0.0245786 ) - 0.000090537;\n	vec3 b = v * ( 0.983729 * v + 0.4329510 ) + 0.238081;\n	return a / b;\n}\nvec3 ACESFilmicToneMapping( vec3 color ) {\n	const mat3 ACESInputMat = mat3(\n		vec3( 0.59719, 0.07600, 0.02840 ),		vec3( 0.35458, 0.90834, 0.13383 ),\n		vec3( 0.04823, 0.01566, 0.83777 )\n	);\n	const mat3 ACESOutputMat = mat3(\n		vec3(  1.60475, -0.10208, -0.00327 ),		vec3( -0.53108,  1.10813, -0.07276 ),\n		vec3( -0.07367, -0.00605,  1.07602 )\n	);\n	color *= toneMappingExposure / 0.6;\n	color = ACESInputMat * color;\n	color = RRTAndODTFit( color );\n	color = ACESOutputMat * color;\n	return saturate( color );\n}\nvec3 CustomToneMapping( vec3 color ) { return color; }";
var transmission_fragment = "#ifdef USE_TRANSMISSION\n	material.transmission = transmission;\n	material.transmissionAlpha = 1.0;\n	material.thickness = thickness;\n	material.attenuationDistance = attenuationDistance;\n	material.attenuationColor = attenuationColor;\n	#ifdef USE_TRANSMISSIONMAP\n		material.transmission *= texture2D( transmissionMap, vTransmissionMapUv ).r;\n	#endif\n	#ifdef USE_THICKNESSMAP\n		material.thickness *= texture2D( thicknessMap, vThicknessMapUv ).g;\n	#endif\n	vec3 pos = vWorldPosition;\n	vec3 v = normalize( cameraPosition - pos );\n	vec3 n = inverseTransformDirection( normal, viewMatrix );\n	vec4 transmitted = getIBLVolumeRefraction(\n		n, v, material.roughness, material.diffuseColor, material.specularColor, material.specularF90,\n		pos, modelMatrix, viewMatrix, projectionMatrix, material.ior, material.thickness,\n		material.attenuationColor, material.attenuationDistance );\n	material.transmissionAlpha = mix( material.transmissionAlpha, transmitted.a, material.transmission );\n	totalDiffuse = mix( totalDiffuse, transmitted.rgb, material.transmission );\n#endif";
var transmission_pars_fragment = "#ifdef USE_TRANSMISSION\n	uniform float transmission;\n	uniform float thickness;\n	uniform float attenuationDistance;\n	uniform vec3 attenuationColor;\n	#ifdef USE_TRANSMISSIONMAP\n		uniform sampler2D transmissionMap;\n	#endif\n	#ifdef USE_THICKNESSMAP\n		uniform sampler2D thicknessMap;\n	#endif\n	uniform vec2 transmissionSamplerSize;\n	uniform sampler2D transmissionSamplerMap;\n	uniform mat4 modelMatrix;\n	uniform mat4 projectionMatrix;\n	varying vec3 vWorldPosition;\n	float w0( float a ) {\n		return ( 1.0 / 6.0 ) * ( a * ( a * ( - a + 3.0 ) - 3.0 ) + 1.0 );\n	}\n	float w1( float a ) {\n		return ( 1.0 / 6.0 ) * ( a *  a * ( 3.0 * a - 6.0 ) + 4.0 );\n	}\n	float w2( float a ){\n		return ( 1.0 / 6.0 ) * ( a * ( a * ( - 3.0 * a + 3.0 ) + 3.0 ) + 1.0 );\n	}\n	float w3( float a ) {\n		return ( 1.0 / 6.0 ) * ( a * a * a );\n	}\n	float g0( float a ) {\n		return w0( a ) + w1( a );\n	}\n	float g1( float a ) {\n		return w2( a ) + w3( a );\n	}\n	float h0( float a ) {\n		return - 1.0 + w1( a ) / ( w0( a ) + w1( a ) );\n	}\n	float h1( float a ) {\n		return 1.0 + w3( a ) / ( w2( a ) + w3( a ) );\n	}\n	vec4 bicubic( sampler2D tex, vec2 uv, vec4 texelSize, float lod ) {\n		uv = uv * texelSize.zw + 0.5;\n		vec2 iuv = floor( uv );\n		vec2 fuv = fract( uv );\n		float g0x = g0( fuv.x );\n		float g1x = g1( fuv.x );\n		float h0x = h0( fuv.x );\n		float h1x = h1( fuv.x );\n		float h0y = h0( fuv.y );\n		float h1y = h1( fuv.y );\n		vec2 p0 = ( vec2( iuv.x + h0x, iuv.y + h0y ) - 0.5 ) * texelSize.xy;\n		vec2 p1 = ( vec2( iuv.x + h1x, iuv.y + h0y ) - 0.5 ) * texelSize.xy;\n		vec2 p2 = ( vec2( iuv.x + h0x, iuv.y + h1y ) - 0.5 ) * texelSize.xy;\n		vec2 p3 = ( vec2( iuv.x + h1x, iuv.y + h1y ) - 0.5 ) * texelSize.xy;\n		return g0( fuv.y ) * ( g0x * textureLod( tex, p0, lod ) + g1x * textureLod( tex, p1, lod ) ) +\n			g1( fuv.y ) * ( g0x * textureLod( tex, p2, lod ) + g1x * textureLod( tex, p3, lod ) );\n	}\n	vec4 textureBicubic( sampler2D sampler, vec2 uv, float lod ) {\n		vec2 fLodSize = vec2( textureSize( sampler, int( lod ) ) );\n		vec2 cLodSize = vec2( textureSize( sampler, int( lod + 1.0 ) ) );\n		vec2 fLodSizeInv = 1.0 / fLodSize;\n		vec2 cLodSizeInv = 1.0 / cLodSize;\n		vec4 fSample = bicubic( sampler, uv, vec4( fLodSizeInv, fLodSize ), floor( lod ) );\n		vec4 cSample = bicubic( sampler, uv, vec4( cLodSizeInv, cLodSize ), ceil( lod ) );\n		return mix( fSample, cSample, fract( lod ) );\n	}\n	vec3 getVolumeTransmissionRay( const in vec3 n, const in vec3 v, const in float thickness, const in float ior, const in mat4 modelMatrix ) {\n		vec3 refractionVector = refract( - v, normalize( n ), 1.0 / ior );\n		vec3 modelScale;\n		modelScale.x = length( vec3( modelMatrix[ 0 ].xyz ) );\n		modelScale.y = length( vec3( modelMatrix[ 1 ].xyz ) );\n		modelScale.z = length( vec3( modelMatrix[ 2 ].xyz ) );\n		return normalize( refractionVector ) * thickness * modelScale;\n	}\n	float applyIorToRoughness( const in float roughness, const in float ior ) {\n		return roughness * clamp( ior * 2.0 - 2.0, 0.0, 1.0 );\n	}\n	vec4 getTransmissionSample( const in vec2 fragCoord, const in float roughness, const in float ior ) {\n		float lod = log2( transmissionSamplerSize.x ) * applyIorToRoughness( roughness, ior );\n		return textureBicubic( transmissionSamplerMap, fragCoord.xy, lod );\n	}\n	vec3 volumeAttenuation( const in float transmissionDistance, const in vec3 attenuationColor, const in float attenuationDistance ) {\n		if ( isinf( attenuationDistance ) ) {\n			return vec3( 1.0 );\n		} else {\n			vec3 attenuationCoefficient = -log( attenuationColor ) / attenuationDistance;\n			vec3 transmittance = exp( - attenuationCoefficient * transmissionDistance );			return transmittance;\n		}\n	}\n	vec4 getIBLVolumeRefraction( const in vec3 n, const in vec3 v, const in float roughness, const in vec3 diffuseColor,\n		const in vec3 specularColor, const in float specularF90, const in vec3 position, const in mat4 modelMatrix,\n		const in mat4 viewMatrix, const in mat4 projMatrix, const in float ior, const in float thickness,\n		const in vec3 attenuationColor, const in float attenuationDistance ) {\n		vec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, ior, modelMatrix );\n		vec3 refractedRayExit = position + transmissionRay;\n		vec4 ndcPos = projMatrix * viewMatrix * vec4( refractedRayExit, 1.0 );\n		vec2 refractionCoords = ndcPos.xy / ndcPos.w;\n		refractionCoords += 1.0;\n		refractionCoords /= 2.0;\n		vec4 transmittedLight = getTransmissionSample( refractionCoords, roughness, ior );\n		vec3 transmittance = diffuseColor * volumeAttenuation( length( transmissionRay ), attenuationColor, attenuationDistance );\n		vec3 attenuatedColor = transmittance * transmittedLight.rgb;\n		vec3 F = EnvironmentBRDF( n, v, specularColor, specularF90, roughness );\n		float transmittanceFactor = ( transmittance.r + transmittance.g + transmittance.b ) / 3.0;\n		return vec4( ( 1.0 - F ) * attenuatedColor, 1.0 - ( 1.0 - transmittedLight.a ) * transmittanceFactor );\n	}\n#endif";
var uv_pars_fragment = "#ifdef USE_UV\n	varying vec2 vUv;\n#endif\n#ifdef USE_MAP\n	varying vec2 vMapUv;\n#endif\n#ifdef USE_ALPHAMAP\n	varying vec2 vAlphaMapUv;\n#endif\n#ifdef USE_LIGHTMAP\n	varying vec2 vLightMapUv;\n#endif\n#ifdef USE_AOMAP\n	varying vec2 vAoMapUv;\n#endif\n#ifdef USE_BUMPMAP\n	varying vec2 vBumpMapUv;\n#endif\n#ifdef USE_NORMALMAP\n	varying vec2 vNormalMapUv;\n#endif\n#ifdef USE_EMISSIVEMAP\n	varying vec2 vEmissiveMapUv;\n#endif\n#ifdef USE_METALNESSMAP\n	varying vec2 vMetalnessMapUv;\n#endif\n#ifdef USE_ROUGHNESSMAP\n	varying vec2 vRoughnessMapUv;\n#endif\n#ifdef USE_ANISOTROPYMAP\n	varying vec2 vAnisotropyMapUv;\n#endif\n#ifdef USE_CLEARCOATMAP\n	varying vec2 vClearcoatMapUv;\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n	varying vec2 vClearcoatNormalMapUv;\n#endif\n#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n	varying vec2 vClearcoatRoughnessMapUv;\n#endif\n#ifdef USE_IRIDESCENCEMAP\n	varying vec2 vIridescenceMapUv;\n#endif\n#ifdef USE_IRIDESCENCE_THICKNESSMAP\n	varying vec2 vIridescenceThicknessMapUv;\n#endif\n#ifdef USE_SHEEN_COLORMAP\n	varying vec2 vSheenColorMapUv;\n#endif\n#ifdef USE_SHEEN_ROUGHNESSMAP\n	varying vec2 vSheenRoughnessMapUv;\n#endif\n#ifdef USE_SPECULARMAP\n	varying vec2 vSpecularMapUv;\n#endif\n#ifdef USE_SPECULAR_COLORMAP\n	varying vec2 vSpecularColorMapUv;\n#endif\n#ifdef USE_SPECULAR_INTENSITYMAP\n	varying vec2 vSpecularIntensityMapUv;\n#endif\n#ifdef USE_TRANSMISSIONMAP\n	uniform mat3 transmissionMapTransform;\n	varying vec2 vTransmissionMapUv;\n#endif\n#ifdef USE_THICKNESSMAP\n	uniform mat3 thicknessMapTransform;\n	varying vec2 vThicknessMapUv;\n#endif";
var uv_pars_vertex = "#ifdef USE_UV\n	varying vec2 vUv;\n#endif\n#ifdef USE_MAP\n	uniform mat3 mapTransform;\n	varying vec2 vMapUv;\n#endif\n#ifdef USE_ALPHAMAP\n	uniform mat3 alphaMapTransform;\n	varying vec2 vAlphaMapUv;\n#endif\n#ifdef USE_LIGHTMAP\n	uniform mat3 lightMapTransform;\n	varying vec2 vLightMapUv;\n#endif\n#ifdef USE_AOMAP\n	uniform mat3 aoMapTransform;\n	varying vec2 vAoMapUv;\n#endif\n#ifdef USE_BUMPMAP\n	uniform mat3 bumpMapTransform;\n	varying vec2 vBumpMapUv;\n#endif\n#ifdef USE_NORMALMAP\n	uniform mat3 normalMapTransform;\n	varying vec2 vNormalMapUv;\n#endif\n#ifdef USE_DISPLACEMENTMAP\n	uniform mat3 displacementMapTransform;\n	varying vec2 vDisplacementMapUv;\n#endif\n#ifdef USE_EMISSIVEMAP\n	uniform mat3 emissiveMapTransform;\n	varying vec2 vEmissiveMapUv;\n#endif\n#ifdef USE_METALNESSMAP\n	uniform mat3 metalnessMapTransform;\n	varying vec2 vMetalnessMapUv;\n#endif\n#ifdef USE_ROUGHNESSMAP\n	uniform mat3 roughnessMapTransform;\n	varying vec2 vRoughnessMapUv;\n#endif\n#ifdef USE_ANISOTROPYMAP\n	uniform mat3 anisotropyMapTransform;\n	varying vec2 vAnisotropyMapUv;\n#endif\n#ifdef USE_CLEARCOATMAP\n	uniform mat3 clearcoatMapTransform;\n	varying vec2 vClearcoatMapUv;\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n	uniform mat3 clearcoatNormalMapTransform;\n	varying vec2 vClearcoatNormalMapUv;\n#endif\n#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n	uniform mat3 clearcoatRoughnessMapTransform;\n	varying vec2 vClearcoatRoughnessMapUv;\n#endif\n#ifdef USE_SHEEN_COLORMAP\n	uniform mat3 sheenColorMapTransform;\n	varying vec2 vSheenColorMapUv;\n#endif\n#ifdef USE_SHEEN_ROUGHNESSMAP\n	uniform mat3 sheenRoughnessMapTransform;\n	varying vec2 vSheenRoughnessMapUv;\n#endif\n#ifdef USE_IRIDESCENCEMAP\n	uniform mat3 iridescenceMapTransform;\n	varying vec2 vIridescenceMapUv;\n#endif\n#ifdef USE_IRIDESCENCE_THICKNESSMAP\n	uniform mat3 iridescenceThicknessMapTransform;\n	varying vec2 vIridescenceThicknessMapUv;\n#endif\n#ifdef USE_SPECULARMAP\n	uniform mat3 specularMapTransform;\n	varying vec2 vSpecularMapUv;\n#endif\n#ifdef USE_SPECULAR_COLORMAP\n	uniform mat3 specularColorMapTransform;\n	varying vec2 vSpecularColorMapUv;\n#endif\n#ifdef USE_SPECULAR_INTENSITYMAP\n	uniform mat3 specularIntensityMapTransform;\n	varying vec2 vSpecularIntensityMapUv;\n#endif\n#ifdef USE_TRANSMISSIONMAP\n	uniform mat3 transmissionMapTransform;\n	varying vec2 vTransmissionMapUv;\n#endif\n#ifdef USE_THICKNESSMAP\n	uniform mat3 thicknessMapTransform;\n	varying vec2 vThicknessMapUv;\n#endif";
var uv_vertex = "#ifdef USE_UV\n	vUv = vec3( uv, 1 ).xy;\n#endif\n#ifdef USE_MAP\n	vMapUv = ( mapTransform * vec3( MAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_ALPHAMAP\n	vAlphaMapUv = ( alphaMapTransform * vec3( ALPHAMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_LIGHTMAP\n	vLightMapUv = ( lightMapTransform * vec3( LIGHTMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_AOMAP\n	vAoMapUv = ( aoMapTransform * vec3( AOMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_BUMPMAP\n	vBumpMapUv = ( bumpMapTransform * vec3( BUMPMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_NORMALMAP\n	vNormalMapUv = ( normalMapTransform * vec3( NORMALMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_DISPLACEMENTMAP\n	vDisplacementMapUv = ( displacementMapTransform * vec3( DISPLACEMENTMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_EMISSIVEMAP\n	vEmissiveMapUv = ( emissiveMapTransform * vec3( EMISSIVEMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_METALNESSMAP\n	vMetalnessMapUv = ( metalnessMapTransform * vec3( METALNESSMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_ROUGHNESSMAP\n	vRoughnessMapUv = ( roughnessMapTransform * vec3( ROUGHNESSMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_ANISOTROPYMAP\n	vAnisotropyMapUv = ( anisotropyMapTransform * vec3( ANISOTROPYMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_CLEARCOATMAP\n	vClearcoatMapUv = ( clearcoatMapTransform * vec3( CLEARCOATMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n	vClearcoatNormalMapUv = ( clearcoatNormalMapTransform * vec3( CLEARCOAT_NORMALMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n	vClearcoatRoughnessMapUv = ( clearcoatRoughnessMapTransform * vec3( CLEARCOAT_ROUGHNESSMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_IRIDESCENCEMAP\n	vIridescenceMapUv = ( iridescenceMapTransform * vec3( IRIDESCENCEMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_IRIDESCENCE_THICKNESSMAP\n	vIridescenceThicknessMapUv = ( iridescenceThicknessMapTransform * vec3( IRIDESCENCE_THICKNESSMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_SHEEN_COLORMAP\n	vSheenColorMapUv = ( sheenColorMapTransform * vec3( SHEEN_COLORMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_SHEEN_ROUGHNESSMAP\n	vSheenRoughnessMapUv = ( sheenRoughnessMapTransform * vec3( SHEEN_ROUGHNESSMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_SPECULARMAP\n	vSpecularMapUv = ( specularMapTransform * vec3( SPECULARMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_SPECULAR_COLORMAP\n	vSpecularColorMapUv = ( specularColorMapTransform * vec3( SPECULAR_COLORMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_SPECULAR_INTENSITYMAP\n	vSpecularIntensityMapUv = ( specularIntensityMapTransform * vec3( SPECULAR_INTENSITYMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_TRANSMISSIONMAP\n	vTransmissionMapUv = ( transmissionMapTransform * vec3( TRANSMISSIONMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_THICKNESSMAP\n	vThicknessMapUv = ( thicknessMapTransform * vec3( THICKNESSMAP_UV, 1 ) ).xy;\n#endif";
var worldpos_vertex = "#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP ) || defined ( USE_TRANSMISSION ) || NUM_SPOT_LIGHT_COORDS > 0\n	vec4 worldPosition = vec4( transformed, 1.0 );\n	#ifdef USE_INSTANCING\n		worldPosition = instanceMatrix * worldPosition;\n	#endif\n	worldPosition = modelMatrix * worldPosition;\n#endif";
var vertex$h = "varying vec2 vUv;\nuniform mat3 uvTransform;\nvoid main() {\n	vUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n	gl_Position = vec4( position.xy, 1.0, 1.0 );\n}";
var fragment$h = "uniform sampler2D t2D;\nuniform float backgroundIntensity;\nvarying vec2 vUv;\nvoid main() {\n	vec4 texColor = texture2D( t2D, vUv );\n	texColor.rgb *= backgroundIntensity;\n	gl_FragColor = texColor;\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n}";
var vertex$g = "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n	vWorldDirection = transformDirection( position, modelMatrix );\n	#include <begin_vertex>\n	#include <project_vertex>\n	gl_Position.z = gl_Position.w;\n}";
var fragment$g = "#ifdef ENVMAP_TYPE_CUBE\n	uniform samplerCube envMap;\n#elif defined( ENVMAP_TYPE_CUBE_UV )\n	uniform sampler2D envMap;\n#endif\nuniform float flipEnvMap;\nuniform float backgroundBlurriness;\nuniform float backgroundIntensity;\nvarying vec3 vWorldDirection;\n#include <cube_uv_reflection_fragment>\nvoid main() {\n	#ifdef ENVMAP_TYPE_CUBE\n		vec4 texColor = textureCube( envMap, vec3( flipEnvMap * vWorldDirection.x, vWorldDirection.yz ) );\n	#elif defined( ENVMAP_TYPE_CUBE_UV )\n		vec4 texColor = textureCubeUV( envMap, vWorldDirection, backgroundBlurriness );\n	#else\n		vec4 texColor = vec4( 0.0, 0.0, 0.0, 1.0 );\n	#endif\n	texColor.rgb *= backgroundIntensity;\n	gl_FragColor = texColor;\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n}";
var vertex$f = "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n	vWorldDirection = transformDirection( position, modelMatrix );\n	#include <begin_vertex>\n	#include <project_vertex>\n	gl_Position.z = gl_Position.w;\n}";
var fragment$f = "uniform samplerCube tCube;\nuniform float tFlip;\nuniform float opacity;\nvarying vec3 vWorldDirection;\nvoid main() {\n	vec4 texColor = textureCube( tCube, vec3( tFlip * vWorldDirection.x, vWorldDirection.yz ) );\n	gl_FragColor = texColor;\n	gl_FragColor.a *= opacity;\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n}";
var vertex$e = "#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvarying vec2 vHighPrecisionZW;\nvoid main() {\n	#include <uv_vertex>\n	#include <skinbase_vertex>\n	#ifdef USE_DISPLACEMENTMAP\n		#include <beginnormal_vertex>\n		#include <morphnormal_vertex>\n		#include <skinnormal_vertex>\n	#endif\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <displacementmap_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	vHighPrecisionZW = gl_Position.zw;\n}";
var fragment$e = "#if DEPTH_PACKING == 3200\n	uniform float opacity;\n#endif\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvarying vec2 vHighPrecisionZW;\nvoid main() {\n	#include <clipping_planes_fragment>\n	vec4 diffuseColor = vec4( 1.0 );\n	#if DEPTH_PACKING == 3200\n		diffuseColor.a = opacity;\n	#endif\n	#include <map_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <logdepthbuf_fragment>\n	float fragCoordZ = 0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5;\n	#if DEPTH_PACKING == 3200\n		gl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );\n	#elif DEPTH_PACKING == 3201\n		gl_FragColor = packDepthToRGBA( fragCoordZ );\n	#endif\n}";
var vertex$d = "#define DISTANCE\nvarying vec3 vWorldPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <skinbase_vertex>\n	#ifdef USE_DISPLACEMENTMAP\n		#include <beginnormal_vertex>\n		#include <morphnormal_vertex>\n		#include <skinnormal_vertex>\n	#endif\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <displacementmap_vertex>\n	#include <project_vertex>\n	#include <worldpos_vertex>\n	#include <clipping_planes_vertex>\n	vWorldPosition = worldPosition.xyz;\n}";
var fragment$d = "#define DISTANCE\nuniform vec3 referencePosition;\nuniform float nearDistance;\nuniform float farDistance;\nvarying vec3 vWorldPosition;\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main () {\n	#include <clipping_planes_fragment>\n	vec4 diffuseColor = vec4( 1.0 );\n	#include <map_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	float dist = length( vWorldPosition - referencePosition );\n	dist = ( dist - nearDistance ) / ( farDistance - nearDistance );\n	dist = saturate( dist );\n	gl_FragColor = packDepthToRGBA( dist );\n}";
var vertex$c = "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n	vWorldDirection = transformDirection( position, modelMatrix );\n	#include <begin_vertex>\n	#include <project_vertex>\n}";
var fragment$c = "uniform sampler2D tEquirect;\nvarying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n	vec3 direction = normalize( vWorldDirection );\n	vec2 sampleUV = equirectUv( direction );\n	gl_FragColor = texture2D( tEquirect, sampleUV );\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n}";
var vertex$b = "uniform float scale;\nattribute float lineDistance;\nvarying float vLineDistance;\n#include <common>\n#include <uv_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	vLineDistance = scale * lineDistance;\n	#include <uv_vertex>\n	#include <color_vertex>\n	#include <morphcolor_vertex>\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	#include <fog_vertex>\n}";
var fragment$b = "uniform vec3 diffuse;\nuniform float opacity;\nuniform float dashSize;\nuniform float totalSize;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	if ( mod( vLineDistance, totalSize ) > dashSize ) {\n		discard;\n	}\n	vec3 outgoingLight = vec3( 0.0 );\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <color_fragment>\n	outgoingLight = diffuseColor.rgb;\n	#include <output_fragment>\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n}";
var vertex$a = "#include <common>\n#include <uv_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <color_vertex>\n	#include <morphcolor_vertex>\n	#if defined ( USE_ENVMAP ) || defined ( USE_SKINNING )\n		#include <beginnormal_vertex>\n		#include <morphnormal_vertex>\n		#include <skinbase_vertex>\n		#include <skinnormal_vertex>\n		#include <defaultnormal_vertex>\n	#endif\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	#include <worldpos_vertex>\n	#include <envmap_vertex>\n	#include <fog_vertex>\n}";
var fragment$a = "uniform vec3 diffuse;\nuniform float opacity;\n#ifndef FLAT_SHADED\n	varying vec3 vNormal;\n#endif\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <color_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <specularmap_fragment>\n	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n	#ifdef USE_LIGHTMAP\n		vec4 lightMapTexel = texture2D( lightMap, vLightMapUv );\n		reflectedLight.indirectDiffuse += lightMapTexel.rgb * lightMapIntensity * RECIPROCAL_PI;\n	#else\n		reflectedLight.indirectDiffuse += vec3( 1.0 );\n	#endif\n	#include <aomap_fragment>\n	reflectedLight.indirectDiffuse *= diffuseColor.rgb;\n	vec3 outgoingLight = reflectedLight.indirectDiffuse;\n	#include <envmap_fragment>\n	#include <output_fragment>\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n	#include <dithering_fragment>\n}";
var vertex$9 = "#define LAMBERT\nvarying vec3 vViewPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <color_vertex>\n	#include <morphcolor_vertex>\n	#include <beginnormal_vertex>\n	#include <morphnormal_vertex>\n	#include <skinbase_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n	#include <normal_vertex>\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <displacementmap_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	vViewPosition = - mvPosition.xyz;\n	#include <worldpos_vertex>\n	#include <envmap_vertex>\n	#include <shadowmap_vertex>\n	#include <fog_vertex>\n}";
var fragment$9 = "#define LAMBERT\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_lambert_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n	vec3 totalEmissiveRadiance = emissive;\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <color_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <specularmap_fragment>\n	#include <normal_fragment_begin>\n	#include <normal_fragment_maps>\n	#include <emissivemap_fragment>\n	#include <lights_lambert_fragment>\n	#include <lights_fragment_begin>\n	#include <lights_fragment_maps>\n	#include <lights_fragment_end>\n	#include <aomap_fragment>\n	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n	#include <envmap_fragment>\n	#include <output_fragment>\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n	#include <dithering_fragment>\n}";
var vertex$8 = "#define MATCAP\nvarying vec3 vViewPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <color_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <color_vertex>\n	#include <morphcolor_vertex>\n	#include <beginnormal_vertex>\n	#include <morphnormal_vertex>\n	#include <skinbase_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n	#include <normal_vertex>\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <displacementmap_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	#include <fog_vertex>\n	vViewPosition = - mvPosition.xyz;\n}";
var fragment$8 = "#define MATCAP\nuniform vec3 diffuse;\nuniform float opacity;\nuniform sampler2D matcap;\nvarying vec3 vViewPosition;\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <fog_pars_fragment>\n#include <normal_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <color_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <normal_fragment_begin>\n	#include <normal_fragment_maps>\n	vec3 viewDir = normalize( vViewPosition );\n	vec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );\n	vec3 y = cross( viewDir, x );\n	vec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;\n	#ifdef USE_MATCAP\n		vec4 matcapColor = texture2D( matcap, uv );\n	#else\n		vec4 matcapColor = vec4( vec3( mix( 0.2, 0.8, uv.y ) ), 1.0 );\n	#endif\n	vec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;\n	#include <output_fragment>\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n	#include <dithering_fragment>\n}";
var vertex$7 = "#define NORMAL\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )\n	varying vec3 vViewPosition;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <beginnormal_vertex>\n	#include <morphnormal_vertex>\n	#include <skinbase_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n	#include <normal_vertex>\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <displacementmap_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )\n	vViewPosition = - mvPosition.xyz;\n#endif\n}";
var fragment$7 = "#define NORMAL\nuniform float opacity;\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )\n	varying vec3 vViewPosition;\n#endif\n#include <packing>\n#include <uv_pars_fragment>\n#include <normal_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	#include <logdepthbuf_fragment>\n	#include <normal_fragment_begin>\n	#include <normal_fragment_maps>\n	gl_FragColor = vec4( packNormalToRGB( normal ), opacity );\n	#ifdef OPAQUE\n		gl_FragColor.a = 1.0;\n	#endif\n}";
var vertex$6 = "#define PHONG\nvarying vec3 vViewPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <color_vertex>\n	#include <morphcolor_vertex>\n	#include <beginnormal_vertex>\n	#include <morphnormal_vertex>\n	#include <skinbase_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n	#include <normal_vertex>\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <displacementmap_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	vViewPosition = - mvPosition.xyz;\n	#include <worldpos_vertex>\n	#include <envmap_vertex>\n	#include <shadowmap_vertex>\n	#include <fog_vertex>\n}";
var fragment$6 = "#define PHONG\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform vec3 specular;\nuniform float shininess;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_phong_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n	vec3 totalEmissiveRadiance = emissive;\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <color_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <specularmap_fragment>\n	#include <normal_fragment_begin>\n	#include <normal_fragment_maps>\n	#include <emissivemap_fragment>\n	#include <lights_phong_fragment>\n	#include <lights_fragment_begin>\n	#include <lights_fragment_maps>\n	#include <lights_fragment_end>\n	#include <aomap_fragment>\n	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n	#include <envmap_fragment>\n	#include <output_fragment>\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n	#include <dithering_fragment>\n}";
var vertex$5 = "#define STANDARD\nvarying vec3 vViewPosition;\n#ifdef USE_TRANSMISSION\n	varying vec3 vWorldPosition;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <color_vertex>\n	#include <morphcolor_vertex>\n	#include <beginnormal_vertex>\n	#include <morphnormal_vertex>\n	#include <skinbase_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n	#include <normal_vertex>\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <displacementmap_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	vViewPosition = - mvPosition.xyz;\n	#include <worldpos_vertex>\n	#include <shadowmap_vertex>\n	#include <fog_vertex>\n#ifdef USE_TRANSMISSION\n	vWorldPosition = worldPosition.xyz;\n#endif\n}";
var fragment$5 = "#define STANDARD\n#ifdef PHYSICAL\n	#define IOR\n	#define USE_SPECULAR\n#endif\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float roughness;\nuniform float metalness;\nuniform float opacity;\n#ifdef IOR\n	uniform float ior;\n#endif\n#ifdef USE_SPECULAR\n	uniform float specularIntensity;\n	uniform vec3 specularColor;\n	#ifdef USE_SPECULAR_COLORMAP\n		uniform sampler2D specularColorMap;\n	#endif\n	#ifdef USE_SPECULAR_INTENSITYMAP\n		uniform sampler2D specularIntensityMap;\n	#endif\n#endif\n#ifdef USE_CLEARCOAT\n	uniform float clearcoat;\n	uniform float clearcoatRoughness;\n#endif\n#ifdef USE_IRIDESCENCE\n	uniform float iridescence;\n	uniform float iridescenceIOR;\n	uniform float iridescenceThicknessMinimum;\n	uniform float iridescenceThicknessMaximum;\n#endif\n#ifdef USE_SHEEN\n	uniform vec3 sheenColor;\n	uniform float sheenRoughness;\n	#ifdef USE_SHEEN_COLORMAP\n		uniform sampler2D sheenColorMap;\n	#endif\n	#ifdef USE_SHEEN_ROUGHNESSMAP\n		uniform sampler2D sheenRoughnessMap;\n	#endif\n#endif\n#ifdef USE_ANISOTROPY\n	uniform vec2 anisotropyVector;\n	#ifdef USE_ANISOTROPYMAP\n		uniform sampler2D anisotropyMap;\n	#endif\n#endif\nvarying vec3 vViewPosition;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <iridescence_fragment>\n#include <cube_uv_reflection_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_physical_pars_fragment>\n#include <fog_pars_fragment>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_physical_pars_fragment>\n#include <transmission_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <clearcoat_pars_fragment>\n#include <iridescence_pars_fragment>\n#include <roughnessmap_pars_fragment>\n#include <metalnessmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n	vec3 totalEmissiveRadiance = emissive;\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <color_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <roughnessmap_fragment>\n	#include <metalnessmap_fragment>\n	#include <normal_fragment_begin>\n	#include <normal_fragment_maps>\n	#include <clearcoat_normal_fragment_begin>\n	#include <clearcoat_normal_fragment_maps>\n	#include <emissivemap_fragment>\n	#include <lights_physical_fragment>\n	#include <lights_fragment_begin>\n	#include <lights_fragment_maps>\n	#include <lights_fragment_end>\n	#include <aomap_fragment>\n	vec3 totalDiffuse = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse;\n	vec3 totalSpecular = reflectedLight.directSpecular + reflectedLight.indirectSpecular;\n	#include <transmission_fragment>\n	vec3 outgoingLight = totalDiffuse + totalSpecular + totalEmissiveRadiance;\n	#ifdef USE_SHEEN\n		float sheenEnergyComp = 1.0 - 0.157 * max3( material.sheenColor );\n		outgoingLight = outgoingLight * sheenEnergyComp + sheenSpecular;\n	#endif\n	#ifdef USE_CLEARCOAT\n		float dotNVcc = saturate( dot( geometry.clearcoatNormal, geometry.viewDir ) );\n		vec3 Fcc = F_Schlick( material.clearcoatF0, material.clearcoatF90, dotNVcc );\n		outgoingLight = outgoingLight * ( 1.0 - material.clearcoat * Fcc ) + clearcoatSpecular * material.clearcoat;\n	#endif\n	#include <output_fragment>\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n	#include <dithering_fragment>\n}";
var vertex$4 = "#define TOON\nvarying vec3 vViewPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <color_vertex>\n	#include <morphcolor_vertex>\n	#include <beginnormal_vertex>\n	#include <morphnormal_vertex>\n	#include <skinbase_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n	#include <normal_vertex>\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <displacementmap_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	vViewPosition = - mvPosition.xyz;\n	#include <worldpos_vertex>\n	#include <shadowmap_vertex>\n	#include <fog_vertex>\n}";
var fragment$4 = "#define TOON\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <gradientmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_toon_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n	vec3 totalEmissiveRadiance = emissive;\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <color_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <normal_fragment_begin>\n	#include <normal_fragment_maps>\n	#include <emissivemap_fragment>\n	#include <lights_toon_fragment>\n	#include <lights_fragment_begin>\n	#include <lights_fragment_maps>\n	#include <lights_fragment_end>\n	#include <aomap_fragment>\n	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n	#include <output_fragment>\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n	#include <dithering_fragment>\n}";
var vertex$3 = "uniform float size;\nuniform float scale;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\n#ifdef USE_POINTS_UV\n	varying vec2 vUv;\n	uniform mat3 uvTransform;\n#endif\nvoid main() {\n	#ifdef USE_POINTS_UV\n		vUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n	#endif\n	#include <color_vertex>\n	#include <morphcolor_vertex>\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <project_vertex>\n	gl_PointSize = size;\n	#ifdef USE_SIZEATTENUATION\n		bool isPerspective = isPerspectiveMatrix( projectionMatrix );\n		if ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );\n	#endif\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	#include <worldpos_vertex>\n	#include <fog_vertex>\n}";
var fragment$3 = "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <color_pars_fragment>\n#include <map_particle_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	vec3 outgoingLight = vec3( 0.0 );\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	#include <logdepthbuf_fragment>\n	#include <map_particle_fragment>\n	#include <color_fragment>\n	#include <alphatest_fragment>\n	outgoingLight = diffuseColor.rgb;\n	#include <output_fragment>\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n}";
var vertex$2 = "#include <common>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <shadowmap_pars_vertex>\nvoid main() {\n	#include <beginnormal_vertex>\n	#include <morphnormal_vertex>\n	#include <skinbase_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <worldpos_vertex>\n	#include <shadowmap_vertex>\n	#include <fog_vertex>\n}";
var fragment$2 = "uniform vec3 color;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <logdepthbuf_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\nvoid main() {\n	#include <logdepthbuf_fragment>\n	gl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n}";
var vertex$1 = "uniform float rotation;\nuniform vec2 center;\n#include <common>\n#include <uv_pars_vertex>\n#include <fog_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	vec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );\n	vec2 scale;\n	scale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );\n	scale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );\n	#ifndef USE_SIZEATTENUATION\n		bool isPerspective = isPerspectiveMatrix( projectionMatrix );\n		if ( isPerspective ) scale *= - mvPosition.z;\n	#endif\n	vec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;\n	vec2 rotatedPosition;\n	rotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;\n	rotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;\n	mvPosition.xy += rotatedPosition;\n	gl_Position = projectionMatrix * mvPosition;\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	#include <fog_vertex>\n}";
var fragment$1 = "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	vec3 outgoingLight = vec3( 0.0 );\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	outgoingLight = diffuseColor.rgb;\n	#include <output_fragment>\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n}";
var ShaderChunk = {
  alphamap_fragment,
  alphamap_pars_fragment,
  alphatest_fragment,
  alphatest_pars_fragment,
  aomap_fragment,
  aomap_pars_fragment,
  begin_vertex,
  beginnormal_vertex,
  bsdfs,
  iridescence_fragment,
  bumpmap_pars_fragment,
  clipping_planes_fragment,
  clipping_planes_pars_fragment,
  clipping_planes_pars_vertex,
  clipping_planes_vertex,
  color_fragment,
  color_pars_fragment,
  color_pars_vertex,
  color_vertex,
  common,
  cube_uv_reflection_fragment,
  defaultnormal_vertex,
  displacementmap_pars_vertex,
  displacementmap_vertex,
  emissivemap_fragment,
  emissivemap_pars_fragment,
  encodings_fragment,
  encodings_pars_fragment,
  envmap_fragment,
  envmap_common_pars_fragment,
  envmap_pars_fragment,
  envmap_pars_vertex,
  envmap_physical_pars_fragment,
  envmap_vertex,
  fog_vertex,
  fog_pars_vertex,
  fog_fragment,
  fog_pars_fragment,
  gradientmap_pars_fragment,
  lightmap_fragment,
  lightmap_pars_fragment,
  lights_lambert_fragment,
  lights_lambert_pars_fragment,
  lights_pars_begin,
  lights_toon_fragment,
  lights_toon_pars_fragment,
  lights_phong_fragment,
  lights_phong_pars_fragment,
  lights_physical_fragment,
  lights_physical_pars_fragment,
  lights_fragment_begin,
  lights_fragment_maps,
  lights_fragment_end,
  logdepthbuf_fragment,
  logdepthbuf_pars_fragment,
  logdepthbuf_pars_vertex,
  logdepthbuf_vertex,
  map_fragment,
  map_pars_fragment,
  map_particle_fragment,
  map_particle_pars_fragment,
  metalnessmap_fragment,
  metalnessmap_pars_fragment,
  morphcolor_vertex,
  morphnormal_vertex,
  morphtarget_pars_vertex,
  morphtarget_vertex,
  normal_fragment_begin,
  normal_fragment_maps,
  normal_pars_fragment,
  normal_pars_vertex,
  normal_vertex,
  normalmap_pars_fragment,
  clearcoat_normal_fragment_begin,
  clearcoat_normal_fragment_maps,
  clearcoat_pars_fragment,
  iridescence_pars_fragment,
  output_fragment,
  packing,
  premultiplied_alpha_fragment,
  project_vertex,
  dithering_fragment,
  dithering_pars_fragment,
  roughnessmap_fragment,
  roughnessmap_pars_fragment,
  shadowmap_pars_fragment,
  shadowmap_pars_vertex,
  shadowmap_vertex,
  shadowmask_pars_fragment,
  skinbase_vertex,
  skinning_pars_vertex,
  skinning_vertex,
  skinnormal_vertex,
  specularmap_fragment,
  specularmap_pars_fragment,
  tonemapping_fragment,
  tonemapping_pars_fragment,
  transmission_fragment,
  transmission_pars_fragment,
  uv_pars_fragment,
  uv_pars_vertex,
  uv_vertex,
  worldpos_vertex,
  background_vert: vertex$h,
  background_frag: fragment$h,
  backgroundCube_vert: vertex$g,
  backgroundCube_frag: fragment$g,
  cube_vert: vertex$f,
  cube_frag: fragment$f,
  depth_vert: vertex$e,
  depth_frag: fragment$e,
  distanceRGBA_vert: vertex$d,
  distanceRGBA_frag: fragment$d,
  equirect_vert: vertex$c,
  equirect_frag: fragment$c,
  linedashed_vert: vertex$b,
  linedashed_frag: fragment$b,
  meshbasic_vert: vertex$a,
  meshbasic_frag: fragment$a,
  meshlambert_vert: vertex$9,
  meshlambert_frag: fragment$9,
  meshmatcap_vert: vertex$8,
  meshmatcap_frag: fragment$8,
  meshnormal_vert: vertex$7,
  meshnormal_frag: fragment$7,
  meshphong_vert: vertex$6,
  meshphong_frag: fragment$6,
  meshphysical_vert: vertex$5,
  meshphysical_frag: fragment$5,
  meshtoon_vert: vertex$4,
  meshtoon_frag: fragment$4,
  points_vert: vertex$3,
  points_frag: fragment$3,
  shadow_vert: vertex$2,
  shadow_frag: fragment$2,
  sprite_vert: vertex$1,
  sprite_frag: fragment$1
};
var UniformsLib = {
  common: {
    diffuse: { value: new Color(16777215) },
    opacity: { value: 1 },
    map: { value: null },
    mapTransform: { value: new Matrix3() },
    alphaMap: { value: null },
    alphaMapTransform: { value: new Matrix3() },
    alphaTest: { value: 0 }
  },
  specularmap: {
    specularMap: { value: null },
    specularMapTransform: { value: new Matrix3() }
  },
  envmap: {
    envMap: { value: null },
    flipEnvMap: { value: -1 },
    reflectivity: { value: 1 },
    // basic, lambert, phong
    ior: { value: 1.5 },
    // physical
    refractionRatio: { value: 0.98 }
    // basic, lambert, phong
  },
  aomap: {
    aoMap: { value: null },
    aoMapIntensity: { value: 1 },
    aoMapTransform: { value: new Matrix3() }
  },
  lightmap: {
    lightMap: { value: null },
    lightMapIntensity: { value: 1 },
    lightMapTransform: { value: new Matrix3() }
  },
  bumpmap: {
    bumpMap: { value: null },
    bumpMapTransform: { value: new Matrix3() },
    bumpScale: { value: 1 }
  },
  normalmap: {
    normalMap: { value: null },
    normalMapTransform: { value: new Matrix3() },
    normalScale: { value: new Vector2(1, 1) }
  },
  displacementmap: {
    displacementMap: { value: null },
    displacementMapTransform: { value: new Matrix3() },
    displacementScale: { value: 1 },
    displacementBias: { value: 0 }
  },
  emissivemap: {
    emissiveMap: { value: null },
    emissiveMapTransform: { value: new Matrix3() }
  },
  metalnessmap: {
    metalnessMap: { value: null },
    metalnessMapTransform: { value: new Matrix3() }
  },
  roughnessmap: {
    roughnessMap: { value: null },
    roughnessMapTransform: { value: new Matrix3() }
  },
  gradientmap: {
    gradientMap: { value: null }
  },
  fog: {
    fogDensity: { value: 25e-5 },
    fogNear: { value: 1 },
    fogFar: { value: 2e3 },
    fogColor: { value: new Color(16777215) }
  },
  lights: {
    ambientLightColor: { value: [] },
    lightProbe: { value: [] },
    directionalLights: { value: [], properties: {
      direction: {},
      color: {}
    } },
    directionalLightShadows: { value: [], properties: {
      shadowBias: {},
      shadowNormalBias: {},
      shadowRadius: {},
      shadowMapSize: {}
    } },
    directionalShadowMap: { value: [] },
    directionalShadowMatrix: { value: [] },
    spotLights: { value: [], properties: {
      color: {},
      position: {},
      direction: {},
      distance: {},
      coneCos: {},
      penumbraCos: {},
      decay: {}
    } },
    spotLightShadows: { value: [], properties: {
      shadowBias: {},
      shadowNormalBias: {},
      shadowRadius: {},
      shadowMapSize: {}
    } },
    spotLightMap: { value: [] },
    spotShadowMap: { value: [] },
    spotLightMatrix: { value: [] },
    pointLights: { value: [], properties: {
      color: {},
      position: {},
      decay: {},
      distance: {}
    } },
    pointLightShadows: { value: [], properties: {
      shadowBias: {},
      shadowNormalBias: {},
      shadowRadius: {},
      shadowMapSize: {},
      shadowCameraNear: {},
      shadowCameraFar: {}
    } },
    pointShadowMap: { value: [] },
    pointShadowMatrix: { value: [] },
    hemisphereLights: { value: [], properties: {
      direction: {},
      skyColor: {},
      groundColor: {}
    } },
    // TODO (abelnation): RectAreaLight BRDF data needs to be moved from example to main src
    rectAreaLights: { value: [], properties: {
      color: {},
      position: {},
      width: {},
      height: {}
    } },
    ltc_1: { value: null },
    ltc_2: { value: null }
  },
  points: {
    diffuse: { value: new Color(16777215) },
    opacity: { value: 1 },
    size: { value: 1 },
    scale: { value: 1 },
    map: { value: null },
    alphaMap: { value: null },
    alphaMapTransform: { value: new Matrix3() },
    alphaTest: { value: 0 },
    uvTransform: { value: new Matrix3() }
  },
  sprite: {
    diffuse: { value: new Color(16777215) },
    opacity: { value: 1 },
    center: { value: new Vector2(0.5, 0.5) },
    rotation: { value: 0 },
    map: { value: null },
    mapTransform: { value: new Matrix3() },
    alphaMap: { value: null },
    alphaMapTransform: { value: new Matrix3() },
    alphaTest: { value: 0 }
  }
};
var ShaderLib = {
  basic: {
    uniforms: mergeUniforms([
      UniformsLib.common,
      UniformsLib.specularmap,
      UniformsLib.envmap,
      UniformsLib.aomap,
      UniformsLib.lightmap,
      UniformsLib.fog
    ]),
    vertexShader: ShaderChunk.meshbasic_vert,
    fragmentShader: ShaderChunk.meshbasic_frag
  },
  lambert: {
    uniforms: mergeUniforms([
      UniformsLib.common,
      UniformsLib.specularmap,
      UniformsLib.envmap,
      UniformsLib.aomap,
      UniformsLib.lightmap,
      UniformsLib.emissivemap,
      UniformsLib.bumpmap,
      UniformsLib.normalmap,
      UniformsLib.displacementmap,
      UniformsLib.fog,
      UniformsLib.lights,
      {
        emissive: { value: new Color(0) }
      }
    ]),
    vertexShader: ShaderChunk.meshlambert_vert,
    fragmentShader: ShaderChunk.meshlambert_frag
  },
  phong: {
    uniforms: mergeUniforms([
      UniformsLib.common,
      UniformsLib.specularmap,
      UniformsLib.envmap,
      UniformsLib.aomap,
      UniformsLib.lightmap,
      UniformsLib.emissivemap,
      UniformsLib.bumpmap,
      UniformsLib.normalmap,
      UniformsLib.displacementmap,
      UniformsLib.fog,
      UniformsLib.lights,
      {
        emissive: { value: new Color(0) },
        specular: { value: new Color(1118481) },
        shininess: { value: 30 }
      }
    ]),
    vertexShader: ShaderChunk.meshphong_vert,
    fragmentShader: ShaderChunk.meshphong_frag
  },
  standard: {
    uniforms: mergeUniforms([
      UniformsLib.common,
      UniformsLib.envmap,
      UniformsLib.aomap,
      UniformsLib.lightmap,
      UniformsLib.emissivemap,
      UniformsLib.bumpmap,
      UniformsLib.normalmap,
      UniformsLib.displacementmap,
      UniformsLib.roughnessmap,
      UniformsLib.metalnessmap,
      UniformsLib.fog,
      UniformsLib.lights,
      {
        emissive: { value: new Color(0) },
        roughness: { value: 1 },
        metalness: { value: 0 },
        envMapIntensity: { value: 1 }
        // temporary
      }
    ]),
    vertexShader: ShaderChunk.meshphysical_vert,
    fragmentShader: ShaderChunk.meshphysical_frag
  },
  toon: {
    uniforms: mergeUniforms([
      UniformsLib.common,
      UniformsLib.aomap,
      UniformsLib.lightmap,
      UniformsLib.emissivemap,
      UniformsLib.bumpmap,
      UniformsLib.normalmap,
      UniformsLib.displacementmap,
      UniformsLib.gradientmap,
      UniformsLib.fog,
      UniformsLib.lights,
      {
        emissive: { value: new Color(0) }
      }
    ]),
    vertexShader: ShaderChunk.meshtoon_vert,
    fragmentShader: ShaderChunk.meshtoon_frag
  },
  matcap: {
    uniforms: mergeUniforms([
      UniformsLib.common,
      UniformsLib.bumpmap,
      UniformsLib.normalmap,
      UniformsLib.displacementmap,
      UniformsLib.fog,
      {
        matcap: { value: null }
      }
    ]),
    vertexShader: ShaderChunk.meshmatcap_vert,
    fragmentShader: ShaderChunk.meshmatcap_frag
  },
  points: {
    uniforms: mergeUniforms([
      UniformsLib.points,
      UniformsLib.fog
    ]),
    vertexShader: ShaderChunk.points_vert,
    fragmentShader: ShaderChunk.points_frag
  },
  dashed: {
    uniforms: mergeUniforms([
      UniformsLib.common,
      UniformsLib.fog,
      {
        scale: { value: 1 },
        dashSize: { value: 1 },
        totalSize: { value: 2 }
      }
    ]),
    vertexShader: ShaderChunk.linedashed_vert,
    fragmentShader: ShaderChunk.linedashed_frag
  },
  depth: {
    uniforms: mergeUniforms([
      UniformsLib.common,
      UniformsLib.displacementmap
    ]),
    vertexShader: ShaderChunk.depth_vert,
    fragmentShader: ShaderChunk.depth_frag
  },
  normal: {
    uniforms: mergeUniforms([
      UniformsLib.common,
      UniformsLib.bumpmap,
      UniformsLib.normalmap,
      UniformsLib.displacementmap,
      {
        opacity: { value: 1 }
      }
    ]),
    vertexShader: ShaderChunk.meshnormal_vert,
    fragmentShader: ShaderChunk.meshnormal_frag
  },
  sprite: {
    uniforms: mergeUniforms([
      UniformsLib.sprite,
      UniformsLib.fog
    ]),
    vertexShader: ShaderChunk.sprite_vert,
    fragmentShader: ShaderChunk.sprite_frag
  },
  background: {
    uniforms: {
      uvTransform: { value: new Matrix3() },
      t2D: { value: null },
      backgroundIntensity: { value: 1 }
    },
    vertexShader: ShaderChunk.background_vert,
    fragmentShader: ShaderChunk.background_frag
  },
  backgroundCube: {
    uniforms: {
      envMap: { value: null },
      flipEnvMap: { value: -1 },
      backgroundBlurriness: { value: 0 },
      backgroundIntensity: { value: 1 }
    },
    vertexShader: ShaderChunk.backgroundCube_vert,
    fragmentShader: ShaderChunk.backgroundCube_frag
  },
  cube: {
    uniforms: {
      tCube: { value: null },
      tFlip: { value: -1 },
      opacity: { value: 1 }
    },
    vertexShader: ShaderChunk.cube_vert,
    fragmentShader: ShaderChunk.cube_frag
  },
  equirect: {
    uniforms: {
      tEquirect: { value: null }
    },
    vertexShader: ShaderChunk.equirect_vert,
    fragmentShader: ShaderChunk.equirect_frag
  },
  distanceRGBA: {
    uniforms: mergeUniforms([
      UniformsLib.common,
      UniformsLib.displacementmap,
      {
        referencePosition: { value: new Vector3() },
        nearDistance: { value: 1 },
        farDistance: { value: 1e3 }
      }
    ]),
    vertexShader: ShaderChunk.distanceRGBA_vert,
    fragmentShader: ShaderChunk.distanceRGBA_frag
  },
  shadow: {
    uniforms: mergeUniforms([
      UniformsLib.lights,
      UniformsLib.fog,
      {
        color: { value: new Color(0) },
        opacity: { value: 1 }
      }
    ]),
    vertexShader: ShaderChunk.shadow_vert,
    fragmentShader: ShaderChunk.shadow_frag
  }
};
ShaderLib.physical = {
  uniforms: mergeUniforms([
    ShaderLib.standard.uniforms,
    {
      clearcoat: { value: 0 },
      clearcoatMap: { value: null },
      clearcoatMapTransform: { value: new Matrix3() },
      clearcoatNormalMap: { value: null },
      clearcoatNormalMapTransform: { value: new Matrix3() },
      clearcoatNormalScale: { value: new Vector2(1, 1) },
      clearcoatRoughness: { value: 0 },
      clearcoatRoughnessMap: { value: null },
      clearcoatRoughnessMapTransform: { value: new Matrix3() },
      iridescence: { value: 0 },
      iridescenceMap: { value: null },
      iridescenceMapTransform: { value: new Matrix3() },
      iridescenceIOR: { value: 1.3 },
      iridescenceThicknessMinimum: { value: 100 },
      iridescenceThicknessMaximum: { value: 400 },
      iridescenceThicknessMap: { value: null },
      iridescenceThicknessMapTransform: { value: new Matrix3() },
      sheen: { value: 0 },
      sheenColor: { value: new Color(0) },
      sheenColorMap: { value: null },
      sheenColorMapTransform: { value: new Matrix3() },
      sheenRoughness: { value: 1 },
      sheenRoughnessMap: { value: null },
      sheenRoughnessMapTransform: { value: new Matrix3() },
      transmission: { value: 0 },
      transmissionMap: { value: null },
      transmissionMapTransform: { value: new Matrix3() },
      transmissionSamplerSize: { value: new Vector2() },
      transmissionSamplerMap: { value: null },
      thickness: { value: 0 },
      thicknessMap: { value: null },
      thicknessMapTransform: { value: new Matrix3() },
      attenuationDistance: { value: 0 },
      attenuationColor: { value: new Color(0) },
      specularColor: { value: new Color(1, 1, 1) },
      specularColorMap: { value: null },
      specularColorMapTransform: { value: new Matrix3() },
      specularIntensity: { value: 1 },
      specularIntensityMap: { value: null },
      specularIntensityMapTransform: { value: new Matrix3() },
      anisotropyVector: { value: new Vector2() },
      anisotropyMap: { value: null },
      anisotropyMapTransform: { value: new Matrix3() }
    }
  ]),
  vertexShader: ShaderChunk.meshphysical_vert,
  fragmentShader: ShaderChunk.meshphysical_frag
};
var _rgb = { r: 0, b: 0, g: 0 };
function WebGLBackground(renderer, cubemaps, cubeuvmaps, state, objects, alpha, premultipliedAlpha) {
  const clearColor = new Color(0);
  let clearAlpha = alpha === true ? 0 : 1;
  let planeMesh;
  let boxMesh;
  let currentBackground = null;
  let currentBackgroundVersion = 0;
  let currentTonemapping = null;
  function render(renderList, scene) {
    let forceClear = false;
    let background = scene.isScene === true ? scene.background : null;
    if (background && background.isTexture) {
      const usePMREM = scene.backgroundBlurriness > 0;
      background = (usePMREM ? cubeuvmaps : cubemaps).get(background);
    }
    if (background === null) {
      setClear(clearColor, clearAlpha);
    } else if (background && background.isColor) {
      setClear(background, 1);
      forceClear = true;
    }
    const xr = renderer.xr;
    const environmentBlendMode = xr.getEnvironmentBlendMode();
    switch (environmentBlendMode) {
      case "opaque":
        forceClear = true;
        break;
      case "additive":
        state.buffers.color.setClear(0, 0, 0, 1, premultipliedAlpha);
        forceClear = true;
        break;
      case "alpha-blend":
        state.buffers.color.setClear(0, 0, 0, 0, premultipliedAlpha);
        forceClear = true;
        break;
    }
    if (renderer.autoClear || forceClear) {
      renderer.clear(renderer.autoClearColor, renderer.autoClearDepth, renderer.autoClearStencil);
    }
    if (background && (background.isCubeTexture || background.mapping === CubeUVReflectionMapping)) {
      if (boxMesh === void 0) {
        boxMesh = new Mesh(
          new BoxGeometry(1, 1, 1),
          new ShaderMaterial({
            name: "BackgroundCubeMaterial",
            uniforms: cloneUniforms(ShaderLib.backgroundCube.uniforms),
            vertexShader: ShaderLib.backgroundCube.vertexShader,
            fragmentShader: ShaderLib.backgroundCube.fragmentShader,
            side: BackSide,
            depthTest: false,
            depthWrite: false,
            fog: false
          })
        );
        boxMesh.geometry.deleteAttribute("normal");
        boxMesh.geometry.deleteAttribute("uv");
        boxMesh.onBeforeRender = function(renderer2, scene2, camera) {
          this.matrixWorld.copyPosition(camera.matrixWorld);
        };
        Object.defineProperty(boxMesh.material, "envMap", {
          get: function() {
            return this.uniforms.envMap.value;
          }
        });
        objects.update(boxMesh);
      }
      boxMesh.material.uniforms.envMap.value = background;
      boxMesh.material.uniforms.flipEnvMap.value = background.isCubeTexture && background.isRenderTargetTexture === false ? -1 : 1;
      boxMesh.material.uniforms.backgroundBlurriness.value = scene.backgroundBlurriness;
      boxMesh.material.uniforms.backgroundIntensity.value = scene.backgroundIntensity;
      boxMesh.material.toneMapped = background.colorSpace === SRGBColorSpace ? false : true;
      if (currentBackground !== background || currentBackgroundVersion !== background.version || currentTonemapping !== renderer.toneMapping) {
        boxMesh.material.needsUpdate = true;
        currentBackground = background;
        currentBackgroundVersion = background.version;
        currentTonemapping = renderer.toneMapping;
      }
      boxMesh.layers.enableAll();
      renderList.unshift(boxMesh, boxMesh.geometry, boxMesh.material, 0, 0, null);
    } else if (background && background.isTexture) {
      if (planeMesh === void 0) {
        planeMesh = new Mesh(
          new PlaneGeometry(2, 2),
          new ShaderMaterial({
            name: "BackgroundMaterial",
            uniforms: cloneUniforms(ShaderLib.background.uniforms),
            vertexShader: ShaderLib.background.vertexShader,
            fragmentShader: ShaderLib.background.fragmentShader,
            side: FrontSide,
            depthTest: false,
            depthWrite: false,
            fog: false
          })
        );
        planeMesh.geometry.deleteAttribute("normal");
        Object.defineProperty(planeMesh.material, "map", {
          get: function() {
            return this.uniforms.t2D.value;
          }
        });
        objects.update(planeMesh);
      }
      planeMesh.material.uniforms.t2D.value = background;
      planeMesh.material.uniforms.backgroundIntensity.value = scene.backgroundIntensity;
      planeMesh.material.toneMapped = background.colorSpace === SRGBColorSpace ? false : true;
      if (background.matrixAutoUpdate === true) {
        background.updateMatrix();
      }
      planeMesh.material.uniforms.uvTransform.value.copy(background.matrix);
      if (currentBackground !== background || currentBackgroundVersion !== background.version || currentTonemapping !== renderer.toneMapping) {
        planeMesh.material.needsUpdate = true;
        currentBackground = background;
        currentBackgroundVersion = background.version;
        currentTonemapping = renderer.toneMapping;
      }
      planeMesh.layers.enableAll();
      renderList.unshift(planeMesh, planeMesh.geometry, planeMesh.material, 0, 0, null);
    }
  }
  function setClear(color, alpha2) {
    color.getRGB(_rgb, getUnlitUniformColorSpace(renderer));
    state.buffers.color.setClear(_rgb.r, _rgb.g, _rgb.b, alpha2, premultipliedAlpha);
  }
  return {
    getClearColor: function() {
      return clearColor;
    },
    setClearColor: function(color, alpha2 = 1) {
      clearColor.set(color);
      clearAlpha = alpha2;
      setClear(clearColor, clearAlpha);
    },
    getClearAlpha: function() {
      return clearAlpha;
    },
    setClearAlpha: function(alpha2) {
      clearAlpha = alpha2;
      setClear(clearColor, clearAlpha);
    },
    render
  };
}
function WebGLBindingStates(gl, extensions, attributes, capabilities2) {
  const maxVertexAttributes = gl.getParameter(gl.MAX_VERTEX_ATTRIBS);
  const extension = capabilities2.isWebGL2 ? null : extensions.get("OES_vertex_array_object");
  const vaoAvailable = capabilities2.isWebGL2 || extension !== null;
  const bindingStates = {};
  const defaultState = createBindingState(null);
  let currentState = defaultState;
  let forceUpdate = false;
  function setup(object, material, program, geometry, index) {
    let updateBuffers = false;
    if (vaoAvailable) {
      const state = getBindingState(geometry, program, material);
      if (currentState !== state) {
        currentState = state;
        bindVertexArrayObject(currentState.object);
      }
      updateBuffers = needsUpdate(object, geometry, program, index);
      if (updateBuffers) saveCache(object, geometry, program, index);
    } else {
      const wireframe = material.wireframe === true;
      if (currentState.geometry !== geometry.id || currentState.program !== program.id || currentState.wireframe !== wireframe) {
        currentState.geometry = geometry.id;
        currentState.program = program.id;
        currentState.wireframe = wireframe;
        updateBuffers = true;
      }
    }
    if (index !== null) {
      attributes.update(index, gl.ELEMENT_ARRAY_BUFFER);
    }
    if (updateBuffers || forceUpdate) {
      forceUpdate = false;
      setupVertexAttributes(object, material, program, geometry);
      if (index !== null) {
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, attributes.get(index).buffer);
      }
    }
  }
  function createVertexArrayObject() {
    if (capabilities2.isWebGL2) return gl.createVertexArray();
    return extension.createVertexArrayOES();
  }
  function bindVertexArrayObject(vao) {
    if (capabilities2.isWebGL2) return gl.bindVertexArray(vao);
    return extension.bindVertexArrayOES(vao);
  }
  function deleteVertexArrayObject(vao) {
    if (capabilities2.isWebGL2) return gl.deleteVertexArray(vao);
    return extension.deleteVertexArrayOES(vao);
  }
  function getBindingState(geometry, program, material) {
    const wireframe = material.wireframe === true;
    let programMap = bindingStates[geometry.id];
    if (programMap === void 0) {
      programMap = {};
      bindingStates[geometry.id] = programMap;
    }
    let stateMap = programMap[program.id];
    if (stateMap === void 0) {
      stateMap = {};
      programMap[program.id] = stateMap;
    }
    let state = stateMap[wireframe];
    if (state === void 0) {
      state = createBindingState(createVertexArrayObject());
      stateMap[wireframe] = state;
    }
    return state;
  }
  function createBindingState(vao) {
    const newAttributes = [];
    const enabledAttributes = [];
    const attributeDivisors = [];
    for (let i2 = 0; i2 < maxVertexAttributes; i2++) {
      newAttributes[i2] = 0;
      enabledAttributes[i2] = 0;
      attributeDivisors[i2] = 0;
    }
    return {
      // for backward compatibility on non-VAO support browser
      geometry: null,
      program: null,
      wireframe: false,
      newAttributes,
      enabledAttributes,
      attributeDivisors,
      object: vao,
      attributes: {},
      index: null
    };
  }
  function needsUpdate(object, geometry, program, index) {
    const cachedAttributes = currentState.attributes;
    const geometryAttributes = geometry.attributes;
    let attributesNum = 0;
    const programAttributes = program.getAttributes();
    for (const name in programAttributes) {
      const programAttribute = programAttributes[name];
      if (programAttribute.location >= 0) {
        const cachedAttribute = cachedAttributes[name];
        let geometryAttribute = geometryAttributes[name];
        if (geometryAttribute === void 0) {
          if (name === "instanceMatrix" && object.instanceMatrix) geometryAttribute = object.instanceMatrix;
          if (name === "instanceColor" && object.instanceColor) geometryAttribute = object.instanceColor;
        }
        if (cachedAttribute === void 0) return true;
        if (cachedAttribute.attribute !== geometryAttribute) return true;
        if (geometryAttribute && cachedAttribute.data !== geometryAttribute.data) return true;
        attributesNum++;
      }
    }
    if (currentState.attributesNum !== attributesNum) return true;
    if (currentState.index !== index) return true;
    return false;
  }
  function saveCache(object, geometry, program, index) {
    const cache = {};
    const attributes2 = geometry.attributes;
    let attributesNum = 0;
    const programAttributes = program.getAttributes();
    for (const name in programAttributes) {
      const programAttribute = programAttributes[name];
      if (programAttribute.location >= 0) {
        let attribute = attributes2[name];
        if (attribute === void 0) {
          if (name === "instanceMatrix" && object.instanceMatrix) attribute = object.instanceMatrix;
          if (name === "instanceColor" && object.instanceColor) attribute = object.instanceColor;
        }
        const data = {};
        data.attribute = attribute;
        if (attribute && attribute.data) {
          data.data = attribute.data;
        }
        cache[name] = data;
        attributesNum++;
      }
    }
    currentState.attributes = cache;
    currentState.attributesNum = attributesNum;
    currentState.index = index;
  }
  function initAttributes() {
    const newAttributes = currentState.newAttributes;
    for (let i2 = 0, il = newAttributes.length; i2 < il; i2++) {
      newAttributes[i2] = 0;
    }
  }
  function enableAttribute(attribute) {
    enableAttributeAndDivisor(attribute, 0);
  }
  function enableAttributeAndDivisor(attribute, meshPerAttribute) {
    const newAttributes = currentState.newAttributes;
    const enabledAttributes = currentState.enabledAttributes;
    const attributeDivisors = currentState.attributeDivisors;
    newAttributes[attribute] = 1;
    if (enabledAttributes[attribute] === 0) {
      gl.enableVertexAttribArray(attribute);
      enabledAttributes[attribute] = 1;
    }
    if (attributeDivisors[attribute] !== meshPerAttribute) {
      const extension2 = capabilities2.isWebGL2 ? gl : extensions.get("ANGLE_instanced_arrays");
      extension2[capabilities2.isWebGL2 ? "vertexAttribDivisor" : "vertexAttribDivisorANGLE"](attribute, meshPerAttribute);
      attributeDivisors[attribute] = meshPerAttribute;
    }
  }
  function disableUnusedAttributes() {
    const newAttributes = currentState.newAttributes;
    const enabledAttributes = currentState.enabledAttributes;
    for (let i2 = 0, il = enabledAttributes.length; i2 < il; i2++) {
      if (enabledAttributes[i2] !== newAttributes[i2]) {
        gl.disableVertexAttribArray(i2);
        enabledAttributes[i2] = 0;
      }
    }
  }
  function vertexAttribPointer(index, size, type, normalized, stride, offset, integer) {
    if (integer === true) {
      gl.vertexAttribIPointer(index, size, type, stride, offset);
    } else {
      gl.vertexAttribPointer(index, size, type, normalized, stride, offset);
    }
  }
  function setupVertexAttributes(object, material, program, geometry) {
    if (capabilities2.isWebGL2 === false && (object.isInstancedMesh || geometry.isInstancedBufferGeometry)) {
      if (extensions.get("ANGLE_instanced_arrays") === null) return;
    }
    initAttributes();
    const geometryAttributes = geometry.attributes;
    const programAttributes = program.getAttributes();
    const materialDefaultAttributeValues = material.defaultAttributeValues;
    for (const name in programAttributes) {
      const programAttribute = programAttributes[name];
      if (programAttribute.location >= 0) {
        let geometryAttribute = geometryAttributes[name];
        if (geometryAttribute === void 0) {
          if (name === "instanceMatrix" && object.instanceMatrix) geometryAttribute = object.instanceMatrix;
          if (name === "instanceColor" && object.instanceColor) geometryAttribute = object.instanceColor;
        }
        if (geometryAttribute !== void 0) {
          const normalized = geometryAttribute.normalized;
          const size = geometryAttribute.itemSize;
          const attribute = attributes.get(geometryAttribute);
          if (attribute === void 0) continue;
          const buffer = attribute.buffer;
          const type = attribute.type;
          const bytesPerElement = attribute.bytesPerElement;
          const integer = capabilities2.isWebGL2 === true && (type === gl.INT || type === gl.UNSIGNED_INT || geometryAttribute.gpuType === IntType);
          if (geometryAttribute.isInterleavedBufferAttribute) {
            const data = geometryAttribute.data;
            const stride = data.stride;
            const offset = geometryAttribute.offset;
            if (data.isInstancedInterleavedBuffer) {
              for (let i2 = 0; i2 < programAttribute.locationSize; i2++) {
                enableAttributeAndDivisor(programAttribute.location + i2, data.meshPerAttribute);
              }
              if (object.isInstancedMesh !== true && geometry._maxInstanceCount === void 0) {
                geometry._maxInstanceCount = data.meshPerAttribute * data.count;
              }
            } else {
              for (let i2 = 0; i2 < programAttribute.locationSize; i2++) {
                enableAttribute(programAttribute.location + i2);
              }
            }
            gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
            for (let i2 = 0; i2 < programAttribute.locationSize; i2++) {
              vertexAttribPointer(
                programAttribute.location + i2,
                size / programAttribute.locationSize,
                type,
                normalized,
                stride * bytesPerElement,
                (offset + size / programAttribute.locationSize * i2) * bytesPerElement,
                integer
              );
            }
          } else {
            if (geometryAttribute.isInstancedBufferAttribute) {
              for (let i2 = 0; i2 < programAttribute.locationSize; i2++) {
                enableAttributeAndDivisor(programAttribute.location + i2, geometryAttribute.meshPerAttribute);
              }
              if (object.isInstancedMesh !== true && geometry._maxInstanceCount === void 0) {
                geometry._maxInstanceCount = geometryAttribute.meshPerAttribute * geometryAttribute.count;
              }
            } else {
              for (let i2 = 0; i2 < programAttribute.locationSize; i2++) {
                enableAttribute(programAttribute.location + i2);
              }
            }
            gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
            for (let i2 = 0; i2 < programAttribute.locationSize; i2++) {
              vertexAttribPointer(
                programAttribute.location + i2,
                size / programAttribute.locationSize,
                type,
                normalized,
                size * bytesPerElement,
                size / programAttribute.locationSize * i2 * bytesPerElement,
                integer
              );
            }
          }
        } else if (materialDefaultAttributeValues !== void 0) {
          const value = materialDefaultAttributeValues[name];
          if (value !== void 0) {
            switch (value.length) {
              case 2:
                gl.vertexAttrib2fv(programAttribute.location, value);
                break;
              case 3:
                gl.vertexAttrib3fv(programAttribute.location, value);
                break;
              case 4:
                gl.vertexAttrib4fv(programAttribute.location, value);
                break;
              default:
                gl.vertexAttrib1fv(programAttribute.location, value);
            }
          }
        }
      }
    }
    disableUnusedAttributes();
  }
  function dispose() {
    reset();
    for (const geometryId in bindingStates) {
      const programMap = bindingStates[geometryId];
      for (const programId in programMap) {
        const stateMap = programMap[programId];
        for (const wireframe in stateMap) {
          deleteVertexArrayObject(stateMap[wireframe].object);
          delete stateMap[wireframe];
        }
        delete programMap[programId];
      }
      delete bindingStates[geometryId];
    }
  }
  function releaseStatesOfGeometry(geometry) {
    if (bindingStates[geometry.id] === void 0) return;
    const programMap = bindingStates[geometry.id];
    for (const programId in programMap) {
      const stateMap = programMap[programId];
      for (const wireframe in stateMap) {
        deleteVertexArrayObject(stateMap[wireframe].object);
        delete stateMap[wireframe];
      }
      delete programMap[programId];
    }
    delete bindingStates[geometry.id];
  }
  function releaseStatesOfProgram(program) {
    for (const geometryId in bindingStates) {
      const programMap = bindingStates[geometryId];
      if (programMap[program.id] === void 0) continue;
      const stateMap = programMap[program.id];
      for (const wireframe in stateMap) {
        deleteVertexArrayObject(stateMap[wireframe].object);
        delete stateMap[wireframe];
      }
      delete programMap[program.id];
    }
  }
  function reset() {
    resetDefaultState();
    forceUpdate = true;
    if (currentState === defaultState) return;
    currentState = defaultState;
    bindVertexArrayObject(currentState.object);
  }
  function resetDefaultState() {
    defaultState.geometry = null;
    defaultState.program = null;
    defaultState.wireframe = false;
  }
  return {
    setup,
    reset,
    resetDefaultState,
    dispose,
    releaseStatesOfGeometry,
    releaseStatesOfProgram,
    initAttributes,
    enableAttribute,
    disableUnusedAttributes
  };
}
function WebGLBufferRenderer(gl, extensions, info, capabilities2) {
  const isWebGL2 = capabilities2.isWebGL2;
  let mode;
  function setMode(value) {
    mode = value;
  }
  function render(start, count) {
    gl.drawArrays(mode, start, count);
    info.update(count, mode, 1);
  }
  function renderInstances(start, count, primcount) {
    if (primcount === 0) return;
    let extension, methodName;
    if (isWebGL2) {
      extension = gl;
      methodName = "drawArraysInstanced";
    } else {
      extension = extensions.get("ANGLE_instanced_arrays");
      methodName = "drawArraysInstancedANGLE";
      if (extension === null) {
        console.error("THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");
        return;
      }
    }
    extension[methodName](mode, start, count, primcount);
    info.update(count, mode, primcount);
  }
  this.setMode = setMode;
  this.render = render;
  this.renderInstances = renderInstances;
}
function WebGLCapabilities(gl, extensions, parameters) {
  let maxAnisotropy;
  function getMaxAnisotropy() {
    if (maxAnisotropy !== void 0) return maxAnisotropy;
    if (extensions.has("EXT_texture_filter_anisotropic") === true) {
      const extension = extensions.get("EXT_texture_filter_anisotropic");
      maxAnisotropy = gl.getParameter(extension.MAX_TEXTURE_MAX_ANISOTROPY_EXT);
    } else {
      maxAnisotropy = 0;
    }
    return maxAnisotropy;
  }
  function getMaxPrecision(precision2) {
    if (precision2 === "highp") {
      if (gl.getShaderPrecisionFormat(gl.VERTEX_SHADER, gl.HIGH_FLOAT).precision > 0 && gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, gl.HIGH_FLOAT).precision > 0) {
        return "highp";
      }
      precision2 = "mediump";
    }
    if (precision2 === "mediump") {
      if (gl.getShaderPrecisionFormat(gl.VERTEX_SHADER, gl.MEDIUM_FLOAT).precision > 0 && gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, gl.MEDIUM_FLOAT).precision > 0) {
        return "mediump";
      }
    }
    return "lowp";
  }
  const isWebGL2 = typeof WebGL2RenderingContext !== "undefined" && gl.constructor.name === "WebGL2RenderingContext";
  let precision = parameters.precision !== void 0 ? parameters.precision : "highp";
  const maxPrecision = getMaxPrecision(precision);
  if (maxPrecision !== precision) {
    console.warn("THREE.WebGLRenderer:", precision, "not supported, using", maxPrecision, "instead.");
    precision = maxPrecision;
  }
  const drawBuffers = isWebGL2 || extensions.has("WEBGL_draw_buffers");
  const logarithmicDepthBuffer = parameters.logarithmicDepthBuffer === true;
  const maxTextures = gl.getParameter(gl.MAX_TEXTURE_IMAGE_UNITS);
  const maxVertexTextures = gl.getParameter(gl.MAX_VERTEX_TEXTURE_IMAGE_UNITS);
  const maxTextureSize = gl.getParameter(gl.MAX_TEXTURE_SIZE);
  const maxCubemapSize = gl.getParameter(gl.MAX_CUBE_MAP_TEXTURE_SIZE);
  const maxAttributes = gl.getParameter(gl.MAX_VERTEX_ATTRIBS);
  const maxVertexUniforms = gl.getParameter(gl.MAX_VERTEX_UNIFORM_VECTORS);
  const maxVaryings = gl.getParameter(gl.MAX_VARYING_VECTORS);
  const maxFragmentUniforms = gl.getParameter(gl.MAX_FRAGMENT_UNIFORM_VECTORS);
  const vertexTextures = maxVertexTextures > 0;
  const floatFragmentTextures = isWebGL2 || extensions.has("OES_texture_float");
  const floatVertexTextures = vertexTextures && floatFragmentTextures;
  const maxSamples = isWebGL2 ? gl.getParameter(gl.MAX_SAMPLES) : 0;
  return {
    isWebGL2,
    drawBuffers,
    getMaxAnisotropy,
    getMaxPrecision,
    precision,
    logarithmicDepthBuffer,
    maxTextures,
    maxVertexTextures,
    maxTextureSize,
    maxCubemapSize,
    maxAttributes,
    maxVertexUniforms,
    maxVaryings,
    maxFragmentUniforms,
    vertexTextures,
    floatFragmentTextures,
    floatVertexTextures,
    maxSamples
  };
}
function WebGLClipping(properties) {
  const scope = this;
  let globalState = null, numGlobalPlanes = 0, localClippingEnabled = false, renderingShadows = false;
  const plane = new Plane(), viewNormalMatrix = new Matrix3(), uniform = { value: null, needsUpdate: false };
  this.uniform = uniform;
  this.numPlanes = 0;
  this.numIntersection = 0;
  this.init = function(planes, enableLocalClipping) {
    const enabled = planes.length !== 0 || enableLocalClipping || // enable state of previous frame - the clipping code has to
    // run another frame in order to reset the state:
    numGlobalPlanes !== 0 || localClippingEnabled;
    localClippingEnabled = enableLocalClipping;
    numGlobalPlanes = planes.length;
    return enabled;
  };
  this.beginShadows = function() {
    renderingShadows = true;
    projectPlanes(null);
  };
  this.endShadows = function() {
    renderingShadows = false;
  };
  this.setGlobalState = function(planes, camera) {
    globalState = projectPlanes(planes, camera, 0);
  };
  this.setState = function(material, camera, useCache) {
    const planes = material.clippingPlanes, clipIntersection = material.clipIntersection, clipShadows = material.clipShadows;
    const materialProperties = properties.get(material);
    if (!localClippingEnabled || planes === null || planes.length === 0 || renderingShadows && !clipShadows) {
      if (renderingShadows) {
        projectPlanes(null);
      } else {
        resetGlobalState();
      }
    } else {
      const nGlobal = renderingShadows ? 0 : numGlobalPlanes, lGlobal = nGlobal * 4;
      let dstArray = materialProperties.clippingState || null;
      uniform.value = dstArray;
      dstArray = projectPlanes(planes, camera, lGlobal, useCache);
      for (let i2 = 0; i2 !== lGlobal; ++i2) {
        dstArray[i2] = globalState[i2];
      }
      materialProperties.clippingState = dstArray;
      this.numIntersection = clipIntersection ? this.numPlanes : 0;
      this.numPlanes += nGlobal;
    }
  };
  function resetGlobalState() {
    if (uniform.value !== globalState) {
      uniform.value = globalState;
      uniform.needsUpdate = numGlobalPlanes > 0;
    }
    scope.numPlanes = numGlobalPlanes;
    scope.numIntersection = 0;
  }
  function projectPlanes(planes, camera, dstOffset, skipTransform) {
    const nPlanes = planes !== null ? planes.length : 0;
    let dstArray = null;
    if (nPlanes !== 0) {
      dstArray = uniform.value;
      if (skipTransform !== true || dstArray === null) {
        const flatSize = dstOffset + nPlanes * 4, viewMatrix = camera.matrixWorldInverse;
        viewNormalMatrix.getNormalMatrix(viewMatrix);
        if (dstArray === null || dstArray.length < flatSize) {
          dstArray = new Float32Array(flatSize);
        }
        for (let i2 = 0, i4 = dstOffset; i2 !== nPlanes; ++i2, i4 += 4) {
          plane.copy(planes[i2]).applyMatrix4(viewMatrix, viewNormalMatrix);
          plane.normal.toArray(dstArray, i4);
          dstArray[i4 + 3] = plane.constant;
        }
      }
      uniform.value = dstArray;
      uniform.needsUpdate = true;
    }
    scope.numPlanes = nPlanes;
    scope.numIntersection = 0;
    return dstArray;
  }
}
function WebGLCubeMaps(renderer) {
  let cubemaps = /* @__PURE__ */ new WeakMap();
  function mapTextureMapping(texture, mapping) {
    if (mapping === EquirectangularReflectionMapping) {
      texture.mapping = CubeReflectionMapping;
    } else if (mapping === EquirectangularRefractionMapping) {
      texture.mapping = CubeRefractionMapping;
    }
    return texture;
  }
  function get(texture) {
    if (texture && texture.isTexture && texture.isRenderTargetTexture === false) {
      const mapping = texture.mapping;
      if (mapping === EquirectangularReflectionMapping || mapping === EquirectangularRefractionMapping) {
        if (cubemaps.has(texture)) {
          const cubemap = cubemaps.get(texture).texture;
          return mapTextureMapping(cubemap, texture.mapping);
        } else {
          const image = texture.image;
          if (image && image.height > 0) {
            const renderTarget = new WebGLCubeRenderTarget(image.height / 2);
            renderTarget.fromEquirectangularTexture(renderer, texture);
            cubemaps.set(texture, renderTarget);
            texture.addEventListener("dispose", onTextureDispose);
            return mapTextureMapping(renderTarget.texture, texture.mapping);
          } else {
            return null;
          }
        }
      }
    }
    return texture;
  }
  function onTextureDispose(event) {
    const texture = event.target;
    texture.removeEventListener("dispose", onTextureDispose);
    const cubemap = cubemaps.get(texture);
    if (cubemap !== void 0) {
      cubemaps.delete(texture);
      cubemap.dispose();
    }
  }
  function dispose() {
    cubemaps = /* @__PURE__ */ new WeakMap();
  }
  return {
    get,
    dispose
  };
}
var OrthographicCamera = class extends Camera {
  constructor(left = -1, right = 1, top = 1, bottom = -1, near = 0.1, far = 2e3) {
    super();
    this.isOrthographicCamera = true;
    this.type = "OrthographicCamera";
    this.zoom = 1;
    this.view = null;
    this.left = left;
    this.right = right;
    this.top = top;
    this.bottom = bottom;
    this.near = near;
    this.far = far;
    this.updateProjectionMatrix();
  }
  copy(source, recursive) {
    super.copy(source, recursive);
    this.left = source.left;
    this.right = source.right;
    this.top = source.top;
    this.bottom = source.bottom;
    this.near = source.near;
    this.far = source.far;
    this.zoom = source.zoom;
    this.view = source.view === null ? null : Object.assign({}, source.view);
    return this;
  }
  setViewOffset(fullWidth, fullHeight, x3, y2, width, height) {
    if (this.view === null) {
      this.view = {
        enabled: true,
        fullWidth: 1,
        fullHeight: 1,
        offsetX: 0,
        offsetY: 0,
        width: 1,
        height: 1
      };
    }
    this.view.enabled = true;
    this.view.fullWidth = fullWidth;
    this.view.fullHeight = fullHeight;
    this.view.offsetX = x3;
    this.view.offsetY = y2;
    this.view.width = width;
    this.view.height = height;
    this.updateProjectionMatrix();
  }
  clearViewOffset() {
    if (this.view !== null) {
      this.view.enabled = false;
    }
    this.updateProjectionMatrix();
  }
  updateProjectionMatrix() {
    const dx = (this.right - this.left) / (2 * this.zoom);
    const dy = (this.top - this.bottom) / (2 * this.zoom);
    const cx = (this.right + this.left) / 2;
    const cy = (this.top + this.bottom) / 2;
    let left = cx - dx;
    let right = cx + dx;
    let top = cy + dy;
    let bottom = cy - dy;
    if (this.view !== null && this.view.enabled) {
      const scaleW = (this.right - this.left) / this.view.fullWidth / this.zoom;
      const scaleH = (this.top - this.bottom) / this.view.fullHeight / this.zoom;
      left += scaleW * this.view.offsetX;
      right = left + scaleW * this.view.width;
      top -= scaleH * this.view.offsetY;
      bottom = top - scaleH * this.view.height;
    }
    this.projectionMatrix.makeOrthographic(left, right, top, bottom, this.near, this.far, this.coordinateSystem);
    this.projectionMatrixInverse.copy(this.projectionMatrix).invert();
  }
  toJSON(meta) {
    const data = super.toJSON(meta);
    data.object.zoom = this.zoom;
    data.object.left = this.left;
    data.object.right = this.right;
    data.object.top = this.top;
    data.object.bottom = this.bottom;
    data.object.near = this.near;
    data.object.far = this.far;
    if (this.view !== null) data.object.view = Object.assign({}, this.view);
    return data;
  }
};
var LOD_MIN = 4;
var EXTRA_LOD_SIGMA = [0.125, 0.215, 0.35, 0.446, 0.526, 0.582];
var MAX_SAMPLES = 20;
var _flatCamera = new OrthographicCamera();
var _clearColor = new Color();
var _oldTarget = null;
var PHI = (1 + Math.sqrt(5)) / 2;
var INV_PHI = 1 / PHI;
var _axisDirections = [
  new Vector3(1, 1, 1),
  new Vector3(-1, 1, 1),
  new Vector3(1, 1, -1),
  new Vector3(-1, 1, -1),
  new Vector3(0, PHI, INV_PHI),
  new Vector3(0, PHI, -INV_PHI),
  new Vector3(INV_PHI, 0, PHI),
  new Vector3(-INV_PHI, 0, PHI),
  new Vector3(PHI, INV_PHI, 0),
  new Vector3(-PHI, INV_PHI, 0)
];
var PMREMGenerator = class {
  constructor(renderer) {
    this._renderer = renderer;
    this._pingPongRenderTarget = null;
    this._lodMax = 0;
    this._cubeSize = 0;
    this._lodPlanes = [];
    this._sizeLods = [];
    this._sigmas = [];
    this._blurMaterial = null;
    this._cubemapMaterial = null;
    this._equirectMaterial = null;
    this._compileMaterial(this._blurMaterial);
  }
  /**
   * Generates a PMREM from a supplied Scene, which can be faster than using an
   * image if networking bandwidth is low. Optional sigma specifies a blur radius
   * in radians to be applied to the scene before PMREM generation. Optional near
   * and far planes ensure the scene is rendered in its entirety (the cubeCamera
   * is placed at the origin).
   */
  fromScene(scene, sigma = 0, near = 0.1, far = 100) {
    _oldTarget = this._renderer.getRenderTarget();
    this._setSize(256);
    const cubeUVRenderTarget = this._allocateTargets();
    cubeUVRenderTarget.depthBuffer = true;
    this._sceneToCubeUV(scene, near, far, cubeUVRenderTarget);
    if (sigma > 0) {
      this._blur(cubeUVRenderTarget, 0, 0, sigma);
    }
    this._applyPMREM(cubeUVRenderTarget);
    this._cleanup(cubeUVRenderTarget);
    return cubeUVRenderTarget;
  }
  /**
   * Generates a PMREM from an equirectangular texture, which can be either LDR
   * or HDR. The ideal input image size is 1k (1024 x 512),
   * as this matches best with the 256 x 256 cubemap output.
   */
  fromEquirectangular(equirectangular, renderTarget = null) {
    return this._fromTexture(equirectangular, renderTarget);
  }
  /**
   * Generates a PMREM from an cubemap texture, which can be either LDR
   * or HDR. The ideal input cube size is 256 x 256,
   * as this matches best with the 256 x 256 cubemap output.
   */
  fromCubemap(cubemap, renderTarget = null) {
    return this._fromTexture(cubemap, renderTarget);
  }
  /**
   * Pre-compiles the cubemap shader. You can get faster start-up by invoking this method during
   * your texture's network fetch for increased concurrency.
   */
  compileCubemapShader() {
    if (this._cubemapMaterial === null) {
      this._cubemapMaterial = _getCubemapMaterial();
      this._compileMaterial(this._cubemapMaterial);
    }
  }
  /**
   * Pre-compiles the equirectangular shader. You can get faster start-up by invoking this method during
   * your texture's network fetch for increased concurrency.
   */
  compileEquirectangularShader() {
    if (this._equirectMaterial === null) {
      this._equirectMaterial = _getEquirectMaterial();
      this._compileMaterial(this._equirectMaterial);
    }
  }
  /**
   * Disposes of the PMREMGenerator's internal memory. Note that PMREMGenerator is a static class,
   * so you should not need more than one PMREMGenerator object. If you do, calling dispose() on
   * one of them will cause any others to also become unusable.
   */
  dispose() {
    this._dispose();
    if (this._cubemapMaterial !== null) this._cubemapMaterial.dispose();
    if (this._equirectMaterial !== null) this._equirectMaterial.dispose();
  }
  // private interface
  _setSize(cubeSize) {
    this._lodMax = Math.floor(Math.log2(cubeSize));
    this._cubeSize = Math.pow(2, this._lodMax);
  }
  _dispose() {
    if (this._blurMaterial !== null) this._blurMaterial.dispose();
    if (this._pingPongRenderTarget !== null) this._pingPongRenderTarget.dispose();
    for (let i2 = 0; i2 < this._lodPlanes.length; i2++) {
      this._lodPlanes[i2].dispose();
    }
  }
  _cleanup(outputTarget) {
    this._renderer.setRenderTarget(_oldTarget);
    outputTarget.scissorTest = false;
    _setViewport(outputTarget, 0, 0, outputTarget.width, outputTarget.height);
  }
  _fromTexture(texture, renderTarget) {
    if (texture.mapping === CubeReflectionMapping || texture.mapping === CubeRefractionMapping) {
      this._setSize(texture.image.length === 0 ? 16 : texture.image[0].width || texture.image[0].image.width);
    } else {
      this._setSize(texture.image.width / 4);
    }
    _oldTarget = this._renderer.getRenderTarget();
    const cubeUVRenderTarget = renderTarget || this._allocateTargets();
    this._textureToCubeUV(texture, cubeUVRenderTarget);
    this._applyPMREM(cubeUVRenderTarget);
    this._cleanup(cubeUVRenderTarget);
    return cubeUVRenderTarget;
  }
  _allocateTargets() {
    const width = 3 * Math.max(this._cubeSize, 16 * 7);
    const height = 4 * this._cubeSize;
    const params = {
      magFilter: LinearFilter,
      minFilter: LinearFilter,
      generateMipmaps: false,
      type: HalfFloatType,
      format: RGBAFormat,
      colorSpace: LinearSRGBColorSpace,
      depthBuffer: false
    };
    const cubeUVRenderTarget = _createRenderTarget(width, height, params);
    if (this._pingPongRenderTarget === null || this._pingPongRenderTarget.width !== width || this._pingPongRenderTarget.height !== height) {
      if (this._pingPongRenderTarget !== null) {
        this._dispose();
      }
      this._pingPongRenderTarget = _createRenderTarget(width, height, params);
      const { _lodMax } = this;
      ({ sizeLods: this._sizeLods, lodPlanes: this._lodPlanes, sigmas: this._sigmas } = _createPlanes(_lodMax));
      this._blurMaterial = _getBlurShader(_lodMax, width, height);
    }
    return cubeUVRenderTarget;
  }
  _compileMaterial(material) {
    const tmpMesh = new Mesh(this._lodPlanes[0], material);
    this._renderer.compile(tmpMesh, _flatCamera);
  }
  _sceneToCubeUV(scene, near, far, cubeUVRenderTarget) {
    const fov2 = 90;
    const aspect2 = 1;
    const cubeCamera = new PerspectiveCamera(fov2, aspect2, near, far);
    const upSign = [1, -1, 1, 1, 1, 1];
    const forwardSign = [1, 1, 1, -1, -1, -1];
    const renderer = this._renderer;
    const originalAutoClear = renderer.autoClear;
    const toneMapping = renderer.toneMapping;
    renderer.getClearColor(_clearColor);
    renderer.toneMapping = NoToneMapping;
    renderer.autoClear = false;
    const backgroundMaterial = new MeshBasicMaterial({
      name: "PMREM.Background",
      side: BackSide,
      depthWrite: false,
      depthTest: false
    });
    const backgroundBox = new Mesh(new BoxGeometry(), backgroundMaterial);
    let useSolidColor = false;
    const background = scene.background;
    if (background) {
      if (background.isColor) {
        backgroundMaterial.color.copy(background);
        scene.background = null;
        useSolidColor = true;
      }
    } else {
      backgroundMaterial.color.copy(_clearColor);
      useSolidColor = true;
    }
    for (let i2 = 0; i2 < 6; i2++) {
      const col = i2 % 3;
      if (col === 0) {
        cubeCamera.up.set(0, upSign[i2], 0);
        cubeCamera.lookAt(forwardSign[i2], 0, 0);
      } else if (col === 1) {
        cubeCamera.up.set(0, 0, upSign[i2]);
        cubeCamera.lookAt(0, forwardSign[i2], 0);
      } else {
        cubeCamera.up.set(0, upSign[i2], 0);
        cubeCamera.lookAt(0, 0, forwardSign[i2]);
      }
      const size = this._cubeSize;
      _setViewport(cubeUVRenderTarget, col * size, i2 > 2 ? size : 0, size, size);
      renderer.setRenderTarget(cubeUVRenderTarget);
      if (useSolidColor) {
        renderer.render(backgroundBox, cubeCamera);
      }
      renderer.render(scene, cubeCamera);
    }
    backgroundBox.geometry.dispose();
    backgroundBox.material.dispose();
    renderer.toneMapping = toneMapping;
    renderer.autoClear = originalAutoClear;
    scene.background = background;
  }
  _textureToCubeUV(texture, cubeUVRenderTarget) {
    const renderer = this._renderer;
    const isCubeTexture = texture.mapping === CubeReflectionMapping || texture.mapping === CubeRefractionMapping;
    if (isCubeTexture) {
      if (this._cubemapMaterial === null) {
        this._cubemapMaterial = _getCubemapMaterial();
      }
      this._cubemapMaterial.uniforms.flipEnvMap.value = texture.isRenderTargetTexture === false ? -1 : 1;
    } else {
      if (this._equirectMaterial === null) {
        this._equirectMaterial = _getEquirectMaterial();
      }
    }
    const material = isCubeTexture ? this._cubemapMaterial : this._equirectMaterial;
    const mesh = new Mesh(this._lodPlanes[0], material);
    const uniforms = material.uniforms;
    uniforms["envMap"].value = texture;
    const size = this._cubeSize;
    _setViewport(cubeUVRenderTarget, 0, 0, 3 * size, 2 * size);
    renderer.setRenderTarget(cubeUVRenderTarget);
    renderer.render(mesh, _flatCamera);
  }
  _applyPMREM(cubeUVRenderTarget) {
    const renderer = this._renderer;
    const autoClear = renderer.autoClear;
    renderer.autoClear = false;
    for (let i2 = 1; i2 < this._lodPlanes.length; i2++) {
      const sigma = Math.sqrt(this._sigmas[i2] * this._sigmas[i2] - this._sigmas[i2 - 1] * this._sigmas[i2 - 1]);
      const poleAxis = _axisDirections[(i2 - 1) % _axisDirections.length];
      this._blur(cubeUVRenderTarget, i2 - 1, i2, sigma, poleAxis);
    }
    renderer.autoClear = autoClear;
  }
  /**
   * This is a two-pass Gaussian blur for a cubemap. Normally this is done
   * vertically and horizontally, but this breaks down on a cube. Here we apply
   * the blur latitudinally (around the poles), and then longitudinally (towards
   * the poles) to approximate the orthogonally-separable blur. It is least
   * accurate at the poles, but still does a decent job.
   */
  _blur(cubeUVRenderTarget, lodIn, lodOut, sigma, poleAxis) {
    const pingPongRenderTarget = this._pingPongRenderTarget;
    this._halfBlur(
      cubeUVRenderTarget,
      pingPongRenderTarget,
      lodIn,
      lodOut,
      sigma,
      "latitudinal",
      poleAxis
    );
    this._halfBlur(
      pingPongRenderTarget,
      cubeUVRenderTarget,
      lodOut,
      lodOut,
      sigma,
      "longitudinal",
      poleAxis
    );
  }
  _halfBlur(targetIn, targetOut, lodIn, lodOut, sigmaRadians, direction2, poleAxis) {
    const renderer = this._renderer;
    const blurMaterial = this._blurMaterial;
    if (direction2 !== "latitudinal" && direction2 !== "longitudinal") {
      console.error(
        "blur direction must be either latitudinal or longitudinal!"
      );
    }
    const STANDARD_DEVIATIONS = 3;
    const blurMesh = new Mesh(this._lodPlanes[lodOut], blurMaterial);
    const blurUniforms = blurMaterial.uniforms;
    const pixels = this._sizeLods[lodIn] - 1;
    const radiansPerPixel = isFinite(sigmaRadians) ? Math.PI / (2 * pixels) : 2 * Math.PI / (2 * MAX_SAMPLES - 1);
    const sigmaPixels = sigmaRadians / radiansPerPixel;
    const samples = isFinite(sigmaRadians) ? 1 + Math.floor(STANDARD_DEVIATIONS * sigmaPixels) : MAX_SAMPLES;
    if (samples > MAX_SAMPLES) {
      console.warn(`sigmaRadians, ${sigmaRadians}, is too large and will clip, as it requested ${samples} samples when the maximum is set to ${MAX_SAMPLES}`);
    }
    const weights = [];
    let sum = 0;
    for (let i2 = 0; i2 < MAX_SAMPLES; ++i2) {
      const x4 = i2 / sigmaPixels;
      const weight = Math.exp(-x4 * x4 / 2);
      weights.push(weight);
      if (i2 === 0) {
        sum += weight;
      } else if (i2 < samples) {
        sum += 2 * weight;
      }
    }
    for (let i2 = 0; i2 < weights.length; i2++) {
      weights[i2] = weights[i2] / sum;
    }
    blurUniforms["envMap"].value = targetIn.texture;
    blurUniforms["samples"].value = samples;
    blurUniforms["weights"].value = weights;
    blurUniforms["latitudinal"].value = direction2 === "latitudinal";
    if (poleAxis) {
      blurUniforms["poleAxis"].value = poleAxis;
    }
    const { _lodMax } = this;
    blurUniforms["dTheta"].value = radiansPerPixel;
    blurUniforms["mipInt"].value = _lodMax - lodIn;
    const outputSize = this._sizeLods[lodOut];
    const x3 = 3 * outputSize * (lodOut > _lodMax - LOD_MIN ? lodOut - _lodMax + LOD_MIN : 0);
    const y2 = 4 * (this._cubeSize - outputSize);
    _setViewport(targetOut, x3, y2, 3 * outputSize, 2 * outputSize);
    renderer.setRenderTarget(targetOut);
    renderer.render(blurMesh, _flatCamera);
  }
};
function _createPlanes(lodMax) {
  const lodPlanes = [];
  const sizeLods = [];
  const sigmas = [];
  let lod = lodMax;
  const totalLods = lodMax - LOD_MIN + 1 + EXTRA_LOD_SIGMA.length;
  for (let i2 = 0; i2 < totalLods; i2++) {
    const sizeLod = Math.pow(2, lod);
    sizeLods.push(sizeLod);
    let sigma = 1 / sizeLod;
    if (i2 > lodMax - LOD_MIN) {
      sigma = EXTRA_LOD_SIGMA[i2 - lodMax + LOD_MIN - 1];
    } else if (i2 === 0) {
      sigma = 0;
    }
    sigmas.push(sigma);
    const texelSize = 1 / (sizeLod - 2);
    const min = -texelSize;
    const max = 1 + texelSize;
    const uv1 = [min, min, max, min, max, max, min, min, max, max, min, max];
    const cubeFaces = 6;
    const vertices = 6;
    const positionSize = 3;
    const uvSize = 2;
    const faceIndexSize = 1;
    const position = new Float32Array(positionSize * vertices * cubeFaces);
    const uv = new Float32Array(uvSize * vertices * cubeFaces);
    const faceIndex = new Float32Array(faceIndexSize * vertices * cubeFaces);
    for (let face = 0; face < cubeFaces; face++) {
      const x3 = face % 3 * 2 / 3 - 1;
      const y2 = face > 2 ? 0 : -1;
      const coordinates = [
        x3,
        y2,
        0,
        x3 + 2 / 3,
        y2,
        0,
        x3 + 2 / 3,
        y2 + 1,
        0,
        x3,
        y2,
        0,
        x3 + 2 / 3,
        y2 + 1,
        0,
        x3,
        y2 + 1,
        0
      ];
      position.set(coordinates, positionSize * vertices * face);
      uv.set(uv1, uvSize * vertices * face);
      const fill = [face, face, face, face, face, face];
      faceIndex.set(fill, faceIndexSize * vertices * face);
    }
    const planes = new BufferGeometry();
    planes.setAttribute("position", new BufferAttribute(position, positionSize));
    planes.setAttribute("uv", new BufferAttribute(uv, uvSize));
    planes.setAttribute("faceIndex", new BufferAttribute(faceIndex, faceIndexSize));
    lodPlanes.push(planes);
    if (lod > LOD_MIN) {
      lod--;
    }
  }
  return { lodPlanes, sizeLods, sigmas };
}
function _createRenderTarget(width, height, params) {
  const cubeUVRenderTarget = new WebGLRenderTarget(width, height, params);
  cubeUVRenderTarget.texture.mapping = CubeUVReflectionMapping;
  cubeUVRenderTarget.texture.name = "PMREM.cubeUv";
  cubeUVRenderTarget.scissorTest = true;
  return cubeUVRenderTarget;
}
function _setViewport(target, x3, y2, width, height) {
  target.viewport.set(x3, y2, width, height);
  target.scissor.set(x3, y2, width, height);
}
function _getBlurShader(lodMax, width, height) {
  const weights = new Float32Array(MAX_SAMPLES);
  const poleAxis = new Vector3(0, 1, 0);
  const shaderMaterial = new ShaderMaterial({
    name: "SphericalGaussianBlur",
    defines: {
      "n": MAX_SAMPLES,
      "CUBEUV_TEXEL_WIDTH": 1 / width,
      "CUBEUV_TEXEL_HEIGHT": 1 / height,
      "CUBEUV_MAX_MIP": `${lodMax}.0`
    },
    uniforms: {
      "envMap": { value: null },
      "samples": { value: 1 },
      "weights": { value: weights },
      "latitudinal": { value: false },
      "dTheta": { value: 0 },
      "mipInt": { value: 0 },
      "poleAxis": { value: poleAxis }
    },
    vertexShader: _getCommonVertexShader(),
    fragmentShader: (
      /* glsl */
      `

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;
			uniform int samples;
			uniform float weights[ n ];
			uniform bool latitudinal;
			uniform float dTheta;
			uniform float mipInt;
			uniform vec3 poleAxis;

			#define ENVMAP_TYPE_CUBE_UV
			#include <cube_uv_reflection_fragment>

			vec3 getSample( float theta, vec3 axis ) {

				float cosTheta = cos( theta );
				// Rodrigues' axis-angle rotation
				vec3 sampleDirection = vOutputDirection * cosTheta
					+ cross( axis, vOutputDirection ) * sin( theta )
					+ axis * dot( axis, vOutputDirection ) * ( 1.0 - cosTheta );

				return bilinearCubeUV( envMap, sampleDirection, mipInt );

			}

			void main() {

				vec3 axis = latitudinal ? poleAxis : cross( poleAxis, vOutputDirection );

				if ( all( equal( axis, vec3( 0.0 ) ) ) ) {

					axis = vec3( vOutputDirection.z, 0.0, - vOutputDirection.x );

				}

				axis = normalize( axis );

				gl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );
				gl_FragColor.rgb += weights[ 0 ] * getSample( 0.0, axis );

				for ( int i = 1; i < n; i++ ) {

					if ( i >= samples ) {

						break;

					}

					float theta = dTheta * float( i );
					gl_FragColor.rgb += weights[ i ] * getSample( -1.0 * theta, axis );
					gl_FragColor.rgb += weights[ i ] * getSample( theta, axis );

				}

			}
		`
    ),
    blending: NoBlending,
    depthTest: false,
    depthWrite: false
  });
  return shaderMaterial;
}
function _getEquirectMaterial() {
  return new ShaderMaterial({
    name: "EquirectangularToCubeUV",
    uniforms: {
      "envMap": { value: null }
    },
    vertexShader: _getCommonVertexShader(),
    fragmentShader: (
      /* glsl */
      `

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;

			#include <common>

			void main() {

				vec3 outputDirection = normalize( vOutputDirection );
				vec2 uv = equirectUv( outputDirection );

				gl_FragColor = vec4( texture2D ( envMap, uv ).rgb, 1.0 );

			}
		`
    ),
    blending: NoBlending,
    depthTest: false,
    depthWrite: false
  });
}
function _getCubemapMaterial() {
  return new ShaderMaterial({
    name: "CubemapToCubeUV",
    uniforms: {
      "envMap": { value: null },
      "flipEnvMap": { value: -1 }
    },
    vertexShader: _getCommonVertexShader(),
    fragmentShader: (
      /* glsl */
      `

			precision mediump float;
			precision mediump int;

			uniform float flipEnvMap;

			varying vec3 vOutputDirection;

			uniform samplerCube envMap;

			void main() {

				gl_FragColor = textureCube( envMap, vec3( flipEnvMap * vOutputDirection.x, vOutputDirection.yz ) );

			}
		`
    ),
    blending: NoBlending,
    depthTest: false,
    depthWrite: false
  });
}
function _getCommonVertexShader() {
  return (
    /* glsl */
    `

		precision mediump float;
		precision mediump int;

		attribute float faceIndex;

		varying vec3 vOutputDirection;

		// RH coordinate system; PMREM face-indexing convention
		vec3 getDirection( vec2 uv, float face ) {

			uv = 2.0 * uv - 1.0;

			vec3 direction = vec3( uv, 1.0 );

			if ( face == 0.0 ) {

				direction = direction.zyx; // ( 1, v, u ) pos x

			} else if ( face == 1.0 ) {

				direction = direction.xzy;
				direction.xz *= -1.0; // ( -u, 1, -v ) pos y

			} else if ( face == 2.0 ) {

				direction.x *= -1.0; // ( -u, v, 1 ) pos z

			} else if ( face == 3.0 ) {

				direction = direction.zyx;
				direction.xz *= -1.0; // ( -1, v, -u ) neg x

			} else if ( face == 4.0 ) {

				direction = direction.xzy;
				direction.xy *= -1.0; // ( -u, -1, v ) neg y

			} else if ( face == 5.0 ) {

				direction.z *= -1.0; // ( u, v, -1 ) neg z

			}

			return direction;

		}

		void main() {

			vOutputDirection = getDirection( uv, faceIndex );
			gl_Position = vec4( position, 1.0 );

		}
	`
  );
}
function WebGLCubeUVMaps(renderer) {
  let cubeUVmaps = /* @__PURE__ */ new WeakMap();
  let pmremGenerator = null;
  function get(texture) {
    if (texture && texture.isTexture) {
      const mapping = texture.mapping;
      const isEquirectMap = mapping === EquirectangularReflectionMapping || mapping === EquirectangularRefractionMapping;
      const isCubeMap = mapping === CubeReflectionMapping || mapping === CubeRefractionMapping;
      if (isEquirectMap || isCubeMap) {
        if (texture.isRenderTargetTexture && texture.needsPMREMUpdate === true) {
          texture.needsPMREMUpdate = false;
          let renderTarget = cubeUVmaps.get(texture);
          if (pmremGenerator === null) pmremGenerator = new PMREMGenerator(renderer);
          renderTarget = isEquirectMap ? pmremGenerator.fromEquirectangular(texture, renderTarget) : pmremGenerator.fromCubemap(texture, renderTarget);
          cubeUVmaps.set(texture, renderTarget);
          return renderTarget.texture;
        } else {
          if (cubeUVmaps.has(texture)) {
            return cubeUVmaps.get(texture).texture;
          } else {
            const image = texture.image;
            if (isEquirectMap && image && image.height > 0 || isCubeMap && image && isCubeTextureComplete(image)) {
              if (pmremGenerator === null) pmremGenerator = new PMREMGenerator(renderer);
              const renderTarget = isEquirectMap ? pmremGenerator.fromEquirectangular(texture) : pmremGenerator.fromCubemap(texture);
              cubeUVmaps.set(texture, renderTarget);
              texture.addEventListener("dispose", onTextureDispose);
              return renderTarget.texture;
            } else {
              return null;
            }
          }
        }
      }
    }
    return texture;
  }
  function isCubeTextureComplete(image) {
    let count = 0;
    const length = 6;
    for (let i2 = 0; i2 < length; i2++) {
      if (image[i2] !== void 0) count++;
    }
    return count === length;
  }
  function onTextureDispose(event) {
    const texture = event.target;
    texture.removeEventListener("dispose", onTextureDispose);
    const cubemapUV = cubeUVmaps.get(texture);
    if (cubemapUV !== void 0) {
      cubeUVmaps.delete(texture);
      cubemapUV.dispose();
    }
  }
  function dispose() {
    cubeUVmaps = /* @__PURE__ */ new WeakMap();
    if (pmremGenerator !== null) {
      pmremGenerator.dispose();
      pmremGenerator = null;
    }
  }
  return {
    get,
    dispose
  };
}
function WebGLExtensions(gl) {
  const extensions = {};
  function getExtension(name) {
    if (extensions[name] !== void 0) {
      return extensions[name];
    }
    let extension;
    switch (name) {
      case "WEBGL_depth_texture":
        extension = gl.getExtension("WEBGL_depth_texture") || gl.getExtension("MOZ_WEBGL_depth_texture") || gl.getExtension("WEBKIT_WEBGL_depth_texture");
        break;
      case "EXT_texture_filter_anisotropic":
        extension = gl.getExtension("EXT_texture_filter_anisotropic") || gl.getExtension("MOZ_EXT_texture_filter_anisotropic") || gl.getExtension("WEBKIT_EXT_texture_filter_anisotropic");
        break;
      case "WEBGL_compressed_texture_s3tc":
        extension = gl.getExtension("WEBGL_compressed_texture_s3tc") || gl.getExtension("MOZ_WEBGL_compressed_texture_s3tc") || gl.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc");
        break;
      case "WEBGL_compressed_texture_pvrtc":
        extension = gl.getExtension("WEBGL_compressed_texture_pvrtc") || gl.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc");
        break;
      default:
        extension = gl.getExtension(name);
    }
    extensions[name] = extension;
    return extension;
  }
  return {
    has: function(name) {
      return getExtension(name) !== null;
    },
    init: function(capabilities2) {
      if (capabilities2.isWebGL2) {
        getExtension("EXT_color_buffer_float");
      } else {
        getExtension("WEBGL_depth_texture");
        getExtension("OES_texture_float");
        getExtension("OES_texture_half_float");
        getExtension("OES_texture_half_float_linear");
        getExtension("OES_standard_derivatives");
        getExtension("OES_element_index_uint");
        getExtension("OES_vertex_array_object");
        getExtension("ANGLE_instanced_arrays");
      }
      getExtension("OES_texture_float_linear");
      getExtension("EXT_color_buffer_half_float");
      getExtension("WEBGL_multisampled_render_to_texture");
    },
    get: function(name) {
      const extension = getExtension(name);
      if (extension === null) {
        console.warn("THREE.WebGLRenderer: " + name + " extension not supported.");
      }
      return extension;
    }
  };
}
function WebGLGeometries(gl, attributes, info, bindingStates) {
  const geometries2 = {};
  const wireframeAttributes = /* @__PURE__ */ new WeakMap();
  function onGeometryDispose(event) {
    const geometry = event.target;
    if (geometry.index !== null) {
      attributes.remove(geometry.index);
    }
    for (const name in geometry.attributes) {
      attributes.remove(geometry.attributes[name]);
    }
    for (const name in geometry.morphAttributes) {
      const array = geometry.morphAttributes[name];
      for (let i2 = 0, l2 = array.length; i2 < l2; i2++) {
        attributes.remove(array[i2]);
      }
    }
    geometry.removeEventListener("dispose", onGeometryDispose);
    delete geometries2[geometry.id];
    const attribute = wireframeAttributes.get(geometry);
    if (attribute) {
      attributes.remove(attribute);
      wireframeAttributes.delete(geometry);
    }
    bindingStates.releaseStatesOfGeometry(geometry);
    if (geometry.isInstancedBufferGeometry === true) {
      delete geometry._maxInstanceCount;
    }
    info.memory.geometries--;
  }
  function get(object, geometry) {
    if (geometries2[geometry.id] === true) return geometry;
    geometry.addEventListener("dispose", onGeometryDispose);
    geometries2[geometry.id] = true;
    info.memory.geometries++;
    return geometry;
  }
  function update(geometry) {
    const geometryAttributes = geometry.attributes;
    for (const name in geometryAttributes) {
      attributes.update(geometryAttributes[name], gl.ARRAY_BUFFER);
    }
    const morphAttributes = geometry.morphAttributes;
    for (const name in morphAttributes) {
      const array = morphAttributes[name];
      for (let i2 = 0, l2 = array.length; i2 < l2; i2++) {
        attributes.update(array[i2], gl.ARRAY_BUFFER);
      }
    }
  }
  function updateWireframeAttribute(geometry) {
    const indices = [];
    const geometryIndex = geometry.index;
    const geometryPosition = geometry.attributes.position;
    let version = 0;
    if (geometryIndex !== null) {
      const array = geometryIndex.array;
      version = geometryIndex.version;
      for (let i2 = 0, l2 = array.length; i2 < l2; i2 += 3) {
        const a2 = array[i2 + 0];
        const b2 = array[i2 + 1];
        const c2 = array[i2 + 2];
        indices.push(a2, b2, b2, c2, c2, a2);
      }
    } else {
      const array = geometryPosition.array;
      version = geometryPosition.version;
      for (let i2 = 0, l2 = array.length / 3 - 1; i2 < l2; i2 += 3) {
        const a2 = i2 + 0;
        const b2 = i2 + 1;
        const c2 = i2 + 2;
        indices.push(a2, b2, b2, c2, c2, a2);
      }
    }
    const attribute = new (arrayNeedsUint32(indices) ? Uint32BufferAttribute : Uint16BufferAttribute)(indices, 1);
    attribute.version = version;
    const previousAttribute = wireframeAttributes.get(geometry);
    if (previousAttribute) attributes.remove(previousAttribute);
    wireframeAttributes.set(geometry, attribute);
  }
  function getWireframeAttribute(geometry) {
    const currentAttribute = wireframeAttributes.get(geometry);
    if (currentAttribute) {
      const geometryIndex = geometry.index;
      if (geometryIndex !== null) {
        if (currentAttribute.version < geometryIndex.version) {
          updateWireframeAttribute(geometry);
        }
      }
    } else {
      updateWireframeAttribute(geometry);
    }
    return wireframeAttributes.get(geometry);
  }
  return {
    get,
    update,
    getWireframeAttribute
  };
}
function WebGLIndexedBufferRenderer(gl, extensions, info, capabilities2) {
  const isWebGL2 = capabilities2.isWebGL2;
  let mode;
  function setMode(value) {
    mode = value;
  }
  let type, bytesPerElement;
  function setIndex(value) {
    type = value.type;
    bytesPerElement = value.bytesPerElement;
  }
  function render(start, count) {
    gl.drawElements(mode, count, type, start * bytesPerElement);
    info.update(count, mode, 1);
  }
  function renderInstances(start, count, primcount) {
    if (primcount === 0) return;
    let extension, methodName;
    if (isWebGL2) {
      extension = gl;
      methodName = "drawElementsInstanced";
    } else {
      extension = extensions.get("ANGLE_instanced_arrays");
      methodName = "drawElementsInstancedANGLE";
      if (extension === null) {
        console.error("THREE.WebGLIndexedBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");
        return;
      }
    }
    extension[methodName](mode, count, type, start * bytesPerElement, primcount);
    info.update(count, mode, primcount);
  }
  this.setMode = setMode;
  this.setIndex = setIndex;
  this.render = render;
  this.renderInstances = renderInstances;
}
function WebGLInfo(gl) {
  const memory = {
    geometries: 0,
    textures: 0
  };
  const render = {
    frame: 0,
    calls: 0,
    triangles: 0,
    points: 0,
    lines: 0
  };
  function update(count, mode, instanceCount) {
    render.calls++;
    switch (mode) {
      case gl.TRIANGLES:
        render.triangles += instanceCount * (count / 3);
        break;
      case gl.LINES:
        render.lines += instanceCount * (count / 2);
        break;
      case gl.LINE_STRIP:
        render.lines += instanceCount * (count - 1);
        break;
      case gl.LINE_LOOP:
        render.lines += instanceCount * count;
        break;
      case gl.POINTS:
        render.points += instanceCount * count;
        break;
      default:
        console.error("THREE.WebGLInfo: Unknown draw mode:", mode);
        break;
    }
  }
  function reset() {
    render.calls = 0;
    render.triangles = 0;
    render.points = 0;
    render.lines = 0;
  }
  return {
    memory,
    render,
    programs: null,
    autoReset: true,
    reset,
    update
  };
}
function numericalSort(a2, b2) {
  return a2[0] - b2[0];
}
function absNumericalSort(a2, b2) {
  return Math.abs(b2[1]) - Math.abs(a2[1]);
}
function WebGLMorphtargets(gl, capabilities2, textures) {
  const influencesList = {};
  const morphInfluences = new Float32Array(8);
  const morphTextures = /* @__PURE__ */ new WeakMap();
  const morph = new Vector4();
  const workInfluences = [];
  for (let i2 = 0; i2 < 8; i2++) {
    workInfluences[i2] = [i2, 0];
  }
  function update(object, geometry, program) {
    const objectInfluences = object.morphTargetInfluences;
    if (capabilities2.isWebGL2 === true) {
      const morphAttribute = geometry.morphAttributes.position || geometry.morphAttributes.normal || geometry.morphAttributes.color;
      const morphTargetsCount = morphAttribute !== void 0 ? morphAttribute.length : 0;
      let entry = morphTextures.get(geometry);
      if (entry === void 0 || entry.count !== morphTargetsCount) {
        let disposeTexture = function() {
          texture.dispose();
          morphTextures.delete(geometry);
          geometry.removeEventListener("dispose", disposeTexture);
        };
        if (entry !== void 0) entry.texture.dispose();
        const hasMorphPosition = geometry.morphAttributes.position !== void 0;
        const hasMorphNormals = geometry.morphAttributes.normal !== void 0;
        const hasMorphColors = geometry.morphAttributes.color !== void 0;
        const morphTargets = geometry.morphAttributes.position || [];
        const morphNormals = geometry.morphAttributes.normal || [];
        const morphColors = geometry.morphAttributes.color || [];
        let vertexDataCount = 0;
        if (hasMorphPosition === true) vertexDataCount = 1;
        if (hasMorphNormals === true) vertexDataCount = 2;
        if (hasMorphColors === true) vertexDataCount = 3;
        let width = geometry.attributes.position.count * vertexDataCount;
        let height = 1;
        if (width > capabilities2.maxTextureSize) {
          height = Math.ceil(width / capabilities2.maxTextureSize);
          width = capabilities2.maxTextureSize;
        }
        const buffer = new Float32Array(width * height * 4 * morphTargetsCount);
        const texture = new DataArrayTexture(buffer, width, height, morphTargetsCount);
        texture.type = FloatType;
        texture.needsUpdate = true;
        const vertexDataStride = vertexDataCount * 4;
        for (let i2 = 0; i2 < morphTargetsCount; i2++) {
          const morphTarget = morphTargets[i2];
          const morphNormal = morphNormals[i2];
          const morphColor = morphColors[i2];
          const offset = width * height * 4 * i2;
          for (let j = 0; j < morphTarget.count; j++) {
            const stride = j * vertexDataStride;
            if (hasMorphPosition === true) {
              morph.fromBufferAttribute(morphTarget, j);
              buffer[offset + stride + 0] = morph.x;
              buffer[offset + stride + 1] = morph.y;
              buffer[offset + stride + 2] = morph.z;
              buffer[offset + stride + 3] = 0;
            }
            if (hasMorphNormals === true) {
              morph.fromBufferAttribute(morphNormal, j);
              buffer[offset + stride + 4] = morph.x;
              buffer[offset + stride + 5] = morph.y;
              buffer[offset + stride + 6] = morph.z;
              buffer[offset + stride + 7] = 0;
            }
            if (hasMorphColors === true) {
              morph.fromBufferAttribute(morphColor, j);
              buffer[offset + stride + 8] = morph.x;
              buffer[offset + stride + 9] = morph.y;
              buffer[offset + stride + 10] = morph.z;
              buffer[offset + stride + 11] = morphColor.itemSize === 4 ? morph.w : 1;
            }
          }
        }
        entry = {
          count: morphTargetsCount,
          texture,
          size: new Vector2(width, height)
        };
        morphTextures.set(geometry, entry);
        geometry.addEventListener("dispose", disposeTexture);
      }
      let morphInfluencesSum = 0;
      for (let i2 = 0; i2 < objectInfluences.length; i2++) {
        morphInfluencesSum += objectInfluences[i2];
      }
      const morphBaseInfluence = geometry.morphTargetsRelative ? 1 : 1 - morphInfluencesSum;
      program.getUniforms().setValue(gl, "morphTargetBaseInfluence", morphBaseInfluence);
      program.getUniforms().setValue(gl, "morphTargetInfluences", objectInfluences);
      program.getUniforms().setValue(gl, "morphTargetsTexture", entry.texture, textures);
      program.getUniforms().setValue(gl, "morphTargetsTextureSize", entry.size);
    } else {
      const length = objectInfluences === void 0 ? 0 : objectInfluences.length;
      let influences = influencesList[geometry.id];
      if (influences === void 0 || influences.length !== length) {
        influences = [];
        for (let i2 = 0; i2 < length; i2++) {
          influences[i2] = [i2, 0];
        }
        influencesList[geometry.id] = influences;
      }
      for (let i2 = 0; i2 < length; i2++) {
        const influence = influences[i2];
        influence[0] = i2;
        influence[1] = objectInfluences[i2];
      }
      influences.sort(absNumericalSort);
      for (let i2 = 0; i2 < 8; i2++) {
        if (i2 < length && influences[i2][1]) {
          workInfluences[i2][0] = influences[i2][0];
          workInfluences[i2][1] = influences[i2][1];
        } else {
          workInfluences[i2][0] = Number.MAX_SAFE_INTEGER;
          workInfluences[i2][1] = 0;
        }
      }
      workInfluences.sort(numericalSort);
      const morphTargets = geometry.morphAttributes.position;
      const morphNormals = geometry.morphAttributes.normal;
      let morphInfluencesSum = 0;
      for (let i2 = 0; i2 < 8; i2++) {
        const influence = workInfluences[i2];
        const index = influence[0];
        const value = influence[1];
        if (index !== Number.MAX_SAFE_INTEGER && value) {
          if (morphTargets && geometry.getAttribute("morphTarget" + i2) !== morphTargets[index]) {
            geometry.setAttribute("morphTarget" + i2, morphTargets[index]);
          }
          if (morphNormals && geometry.getAttribute("morphNormal" + i2) !== morphNormals[index]) {
            geometry.setAttribute("morphNormal" + i2, morphNormals[index]);
          }
          morphInfluences[i2] = value;
          morphInfluencesSum += value;
        } else {
          if (morphTargets && geometry.hasAttribute("morphTarget" + i2) === true) {
            geometry.deleteAttribute("morphTarget" + i2);
          }
          if (morphNormals && geometry.hasAttribute("morphNormal" + i2) === true) {
            geometry.deleteAttribute("morphNormal" + i2);
          }
          morphInfluences[i2] = 0;
        }
      }
      const morphBaseInfluence = geometry.morphTargetsRelative ? 1 : 1 - morphInfluencesSum;
      program.getUniforms().setValue(gl, "morphTargetBaseInfluence", morphBaseInfluence);
      program.getUniforms().setValue(gl, "morphTargetInfluences", morphInfluences);
    }
  }
  return {
    update
  };
}
function WebGLObjects(gl, geometries2, attributes, info) {
  let updateMap = /* @__PURE__ */ new WeakMap();
  function update(object) {
    const frame = info.render.frame;
    const geometry = object.geometry;
    const buffergeometry = geometries2.get(object, geometry);
    if (updateMap.get(buffergeometry) !== frame) {
      geometries2.update(buffergeometry);
      updateMap.set(buffergeometry, frame);
    }
    if (object.isInstancedMesh) {
      if (object.hasEventListener("dispose", onInstancedMeshDispose) === false) {
        object.addEventListener("dispose", onInstancedMeshDispose);
      }
      attributes.update(object.instanceMatrix, gl.ARRAY_BUFFER);
      if (object.instanceColor !== null) {
        attributes.update(object.instanceColor, gl.ARRAY_BUFFER);
      }
    }
    return buffergeometry;
  }
  function dispose() {
    updateMap = /* @__PURE__ */ new WeakMap();
  }
  function onInstancedMeshDispose(event) {
    const instancedMesh = event.target;
    instancedMesh.removeEventListener("dispose", onInstancedMeshDispose);
    attributes.remove(instancedMesh.instanceMatrix);
    if (instancedMesh.instanceColor !== null) attributes.remove(instancedMesh.instanceColor);
  }
  return {
    update,
    dispose
  };
}
var emptyTexture = new Texture();
var emptyArrayTexture = new DataArrayTexture();
var empty3dTexture = new Data3DTexture();
var emptyCubeTexture = new CubeTexture();
var arrayCacheF32 = [];
var arrayCacheI32 = [];
var mat4array = new Float32Array(16);
var mat3array = new Float32Array(9);
var mat2array = new Float32Array(4);
function flatten(array, nBlocks, blockSize) {
  const firstElem = array[0];
  if (firstElem <= 0 || firstElem > 0) return array;
  const n = nBlocks * blockSize;
  let r2 = arrayCacheF32[n];
  if (r2 === void 0) {
    r2 = new Float32Array(n);
    arrayCacheF32[n] = r2;
  }
  if (nBlocks !== 0) {
    firstElem.toArray(r2, 0);
    for (let i2 = 1, offset = 0; i2 !== nBlocks; ++i2) {
      offset += blockSize;
      array[i2].toArray(r2, offset);
    }
  }
  return r2;
}
function arraysEqual(a2, b2) {
  if (a2.length !== b2.length) return false;
  for (let i2 = 0, l2 = a2.length; i2 < l2; i2++) {
    if (a2[i2] !== b2[i2]) return false;
  }
  return true;
}
function copyArray(a2, b2) {
  for (let i2 = 0, l2 = b2.length; i2 < l2; i2++) {
    a2[i2] = b2[i2];
  }
}
function allocTexUnits(textures, n) {
  let r2 = arrayCacheI32[n];
  if (r2 === void 0) {
    r2 = new Int32Array(n);
    arrayCacheI32[n] = r2;
  }
  for (let i2 = 0; i2 !== n; ++i2) {
    r2[i2] = textures.allocateTextureUnit();
  }
  return r2;
}
function setValueV1f(gl, v2) {
  const cache = this.cache;
  if (cache[0] === v2) return;
  gl.uniform1f(this.addr, v2);
  cache[0] = v2;
}
function setValueV2f(gl, v2) {
  const cache = this.cache;
  if (v2.x !== void 0) {
    if (cache[0] !== v2.x || cache[1] !== v2.y) {
      gl.uniform2f(this.addr, v2.x, v2.y);
      cache[0] = v2.x;
      cache[1] = v2.y;
    }
  } else {
    if (arraysEqual(cache, v2)) return;
    gl.uniform2fv(this.addr, v2);
    copyArray(cache, v2);
  }
}
function setValueV3f(gl, v2) {
  const cache = this.cache;
  if (v2.x !== void 0) {
    if (cache[0] !== v2.x || cache[1] !== v2.y || cache[2] !== v2.z) {
      gl.uniform3f(this.addr, v2.x, v2.y, v2.z);
      cache[0] = v2.x;
      cache[1] = v2.y;
      cache[2] = v2.z;
    }
  } else if (v2.r !== void 0) {
    if (cache[0] !== v2.r || cache[1] !== v2.g || cache[2] !== v2.b) {
      gl.uniform3f(this.addr, v2.r, v2.g, v2.b);
      cache[0] = v2.r;
      cache[1] = v2.g;
      cache[2] = v2.b;
    }
  } else {
    if (arraysEqual(cache, v2)) return;
    gl.uniform3fv(this.addr, v2);
    copyArray(cache, v2);
  }
}
function setValueV4f(gl, v2) {
  const cache = this.cache;
  if (v2.x !== void 0) {
    if (cache[0] !== v2.x || cache[1] !== v2.y || cache[2] !== v2.z || cache[3] !== v2.w) {
      gl.uniform4f(this.addr, v2.x, v2.y, v2.z, v2.w);
      cache[0] = v2.x;
      cache[1] = v2.y;
      cache[2] = v2.z;
      cache[3] = v2.w;
    }
  } else {
    if (arraysEqual(cache, v2)) return;
    gl.uniform4fv(this.addr, v2);
    copyArray(cache, v2);
  }
}
function setValueM2(gl, v2) {
  const cache = this.cache;
  const elements = v2.elements;
  if (elements === void 0) {
    if (arraysEqual(cache, v2)) return;
    gl.uniformMatrix2fv(this.addr, false, v2);
    copyArray(cache, v2);
  } else {
    if (arraysEqual(cache, elements)) return;
    mat2array.set(elements);
    gl.uniformMatrix2fv(this.addr, false, mat2array);
    copyArray(cache, elements);
  }
}
function setValueM3(gl, v2) {
  const cache = this.cache;
  const elements = v2.elements;
  if (elements === void 0) {
    if (arraysEqual(cache, v2)) return;
    gl.uniformMatrix3fv(this.addr, false, v2);
    copyArray(cache, v2);
  } else {
    if (arraysEqual(cache, elements)) return;
    mat3array.set(elements);
    gl.uniformMatrix3fv(this.addr, false, mat3array);
    copyArray(cache, elements);
  }
}
function setValueM4(gl, v2) {
  const cache = this.cache;
  const elements = v2.elements;
  if (elements === void 0) {
    if (arraysEqual(cache, v2)) return;
    gl.uniformMatrix4fv(this.addr, false, v2);
    copyArray(cache, v2);
  } else {
    if (arraysEqual(cache, elements)) return;
    mat4array.set(elements);
    gl.uniformMatrix4fv(this.addr, false, mat4array);
    copyArray(cache, elements);
  }
}
function setValueV1i(gl, v2) {
  const cache = this.cache;
  if (cache[0] === v2) return;
  gl.uniform1i(this.addr, v2);
  cache[0] = v2;
}
function setValueV2i(gl, v2) {
  const cache = this.cache;
  if (v2.x !== void 0) {
    if (cache[0] !== v2.x || cache[1] !== v2.y) {
      gl.uniform2i(this.addr, v2.x, v2.y);
      cache[0] = v2.x;
      cache[1] = v2.y;
    }
  } else {
    if (arraysEqual(cache, v2)) return;
    gl.uniform2iv(this.addr, v2);
    copyArray(cache, v2);
  }
}
function setValueV3i(gl, v2) {
  const cache = this.cache;
  if (v2.x !== void 0) {
    if (cache[0] !== v2.x || cache[1] !== v2.y || cache[2] !== v2.z) {
      gl.uniform3i(this.addr, v2.x, v2.y, v2.z);
      cache[0] = v2.x;
      cache[1] = v2.y;
      cache[2] = v2.z;
    }
  } else {
    if (arraysEqual(cache, v2)) return;
    gl.uniform3iv(this.addr, v2);
    copyArray(cache, v2);
  }
}
function setValueV4i(gl, v2) {
  const cache = this.cache;
  if (v2.x !== void 0) {
    if (cache[0] !== v2.x || cache[1] !== v2.y || cache[2] !== v2.z || cache[3] !== v2.w) {
      gl.uniform4i(this.addr, v2.x, v2.y, v2.z, v2.w);
      cache[0] = v2.x;
      cache[1] = v2.y;
      cache[2] = v2.z;
      cache[3] = v2.w;
    }
  } else {
    if (arraysEqual(cache, v2)) return;
    gl.uniform4iv(this.addr, v2);
    copyArray(cache, v2);
  }
}
function setValueV1ui(gl, v2) {
  const cache = this.cache;
  if (cache[0] === v2) return;
  gl.uniform1ui(this.addr, v2);
  cache[0] = v2;
}
function setValueV2ui(gl, v2) {
  const cache = this.cache;
  if (v2.x !== void 0) {
    if (cache[0] !== v2.x || cache[1] !== v2.y) {
      gl.uniform2ui(this.addr, v2.x, v2.y);
      cache[0] = v2.x;
      cache[1] = v2.y;
    }
  } else {
    if (arraysEqual(cache, v2)) return;
    gl.uniform2uiv(this.addr, v2);
    copyArray(cache, v2);
  }
}
function setValueV3ui(gl, v2) {
  const cache = this.cache;
  if (v2.x !== void 0) {
    if (cache[0] !== v2.x || cache[1] !== v2.y || cache[2] !== v2.z) {
      gl.uniform3ui(this.addr, v2.x, v2.y, v2.z);
      cache[0] = v2.x;
      cache[1] = v2.y;
      cache[2] = v2.z;
    }
  } else {
    if (arraysEqual(cache, v2)) return;
    gl.uniform3uiv(this.addr, v2);
    copyArray(cache, v2);
  }
}
function setValueV4ui(gl, v2) {
  const cache = this.cache;
  if (v2.x !== void 0) {
    if (cache[0] !== v2.x || cache[1] !== v2.y || cache[2] !== v2.z || cache[3] !== v2.w) {
      gl.uniform4ui(this.addr, v2.x, v2.y, v2.z, v2.w);
      cache[0] = v2.x;
      cache[1] = v2.y;
      cache[2] = v2.z;
      cache[3] = v2.w;
    }
  } else {
    if (arraysEqual(cache, v2)) return;
    gl.uniform4uiv(this.addr, v2);
    copyArray(cache, v2);
  }
}
function setValueT1(gl, v2, textures) {
  const cache = this.cache;
  const unit = textures.allocateTextureUnit();
  if (cache[0] !== unit) {
    gl.uniform1i(this.addr, unit);
    cache[0] = unit;
  }
  textures.setTexture2D(v2 || emptyTexture, unit);
}
function setValueT3D1(gl, v2, textures) {
  const cache = this.cache;
  const unit = textures.allocateTextureUnit();
  if (cache[0] !== unit) {
    gl.uniform1i(this.addr, unit);
    cache[0] = unit;
  }
  textures.setTexture3D(v2 || empty3dTexture, unit);
}
function setValueT6(gl, v2, textures) {
  const cache = this.cache;
  const unit = textures.allocateTextureUnit();
  if (cache[0] !== unit) {
    gl.uniform1i(this.addr, unit);
    cache[0] = unit;
  }
  textures.setTextureCube(v2 || emptyCubeTexture, unit);
}
function setValueT2DArray1(gl, v2, textures) {
  const cache = this.cache;
  const unit = textures.allocateTextureUnit();
  if (cache[0] !== unit) {
    gl.uniform1i(this.addr, unit);
    cache[0] = unit;
  }
  textures.setTexture2DArray(v2 || emptyArrayTexture, unit);
}
function getSingularSetter(type) {
  switch (type) {
    case 5126:
      return setValueV1f;
    case 35664:
      return setValueV2f;
    case 35665:
      return setValueV3f;
    case 35666:
      return setValueV4f;
    case 35674:
      return setValueM2;
    case 35675:
      return setValueM3;
    case 35676:
      return setValueM4;
    case 5124:
    case 35670:
      return setValueV1i;
    case 35667:
    case 35671:
      return setValueV2i;
    case 35668:
    case 35672:
      return setValueV3i;
    case 35669:
    case 35673:
      return setValueV4i;
    case 5125:
      return setValueV1ui;
    case 36294:
      return setValueV2ui;
    case 36295:
      return setValueV3ui;
    case 36296:
      return setValueV4ui;
    case 35678:
    case 36198:
    case 36298:
    case 36306:
    case 35682:
      return setValueT1;
    case 35679:
    case 36299:
    case 36307:
      return setValueT3D1;
    case 35680:
    case 36300:
    case 36308:
    case 36293:
      return setValueT6;
    case 36289:
    case 36303:
    case 36311:
    case 36292:
      return setValueT2DArray1;
  }
}
function setValueV1fArray(gl, v2) {
  gl.uniform1fv(this.addr, v2);
}
function setValueV2fArray(gl, v2) {
  const data = flatten(v2, this.size, 2);
  gl.uniform2fv(this.addr, data);
}
function setValueV3fArray(gl, v2) {
  const data = flatten(v2, this.size, 3);
  gl.uniform3fv(this.addr, data);
}
function setValueV4fArray(gl, v2) {
  const data = flatten(v2, this.size, 4);
  gl.uniform4fv(this.addr, data);
}
function setValueM2Array(gl, v2) {
  const data = flatten(v2, this.size, 4);
  gl.uniformMatrix2fv(this.addr, false, data);
}
function setValueM3Array(gl, v2) {
  const data = flatten(v2, this.size, 9);
  gl.uniformMatrix3fv(this.addr, false, data);
}
function setValueM4Array(gl, v2) {
  const data = flatten(v2, this.size, 16);
  gl.uniformMatrix4fv(this.addr, false, data);
}
function setValueV1iArray(gl, v2) {
  gl.uniform1iv(this.addr, v2);
}
function setValueV2iArray(gl, v2) {
  gl.uniform2iv(this.addr, v2);
}
function setValueV3iArray(gl, v2) {
  gl.uniform3iv(this.addr, v2);
}
function setValueV4iArray(gl, v2) {
  gl.uniform4iv(this.addr, v2);
}
function setValueV1uiArray(gl, v2) {
  gl.uniform1uiv(this.addr, v2);
}
function setValueV2uiArray(gl, v2) {
  gl.uniform2uiv(this.addr, v2);
}
function setValueV3uiArray(gl, v2) {
  gl.uniform3uiv(this.addr, v2);
}
function setValueV4uiArray(gl, v2) {
  gl.uniform4uiv(this.addr, v2);
}
function setValueT1Array(gl, v2, textures) {
  const cache = this.cache;
  const n = v2.length;
  const units = allocTexUnits(textures, n);
  if (!arraysEqual(cache, units)) {
    gl.uniform1iv(this.addr, units);
    copyArray(cache, units);
  }
  for (let i2 = 0; i2 !== n; ++i2) {
    textures.setTexture2D(v2[i2] || emptyTexture, units[i2]);
  }
}
function setValueT3DArray(gl, v2, textures) {
  const cache = this.cache;
  const n = v2.length;
  const units = allocTexUnits(textures, n);
  if (!arraysEqual(cache, units)) {
    gl.uniform1iv(this.addr, units);
    copyArray(cache, units);
  }
  for (let i2 = 0; i2 !== n; ++i2) {
    textures.setTexture3D(v2[i2] || empty3dTexture, units[i2]);
  }
}
function setValueT6Array(gl, v2, textures) {
  const cache = this.cache;
  const n = v2.length;
  const units = allocTexUnits(textures, n);
  if (!arraysEqual(cache, units)) {
    gl.uniform1iv(this.addr, units);
    copyArray(cache, units);
  }
  for (let i2 = 0; i2 !== n; ++i2) {
    textures.setTextureCube(v2[i2] || emptyCubeTexture, units[i2]);
  }
}
function setValueT2DArrayArray(gl, v2, textures) {
  const cache = this.cache;
  const n = v2.length;
  const units = allocTexUnits(textures, n);
  if (!arraysEqual(cache, units)) {
    gl.uniform1iv(this.addr, units);
    copyArray(cache, units);
  }
  for (let i2 = 0; i2 !== n; ++i2) {
    textures.setTexture2DArray(v2[i2] || emptyArrayTexture, units[i2]);
  }
}
function getPureArraySetter(type) {
  switch (type) {
    case 5126:
      return setValueV1fArray;
    case 35664:
      return setValueV2fArray;
    case 35665:
      return setValueV3fArray;
    case 35666:
      return setValueV4fArray;
    case 35674:
      return setValueM2Array;
    case 35675:
      return setValueM3Array;
    case 35676:
      return setValueM4Array;
    case 5124:
    case 35670:
      return setValueV1iArray;
    case 35667:
    case 35671:
      return setValueV2iArray;
    case 35668:
    case 35672:
      return setValueV3iArray;
    case 35669:
    case 35673:
      return setValueV4iArray;
    case 5125:
      return setValueV1uiArray;
    case 36294:
      return setValueV2uiArray;
    case 36295:
      return setValueV3uiArray;
    case 36296:
      return setValueV4uiArray;
    case 35678:
    case 36198:
    case 36298:
    case 36306:
    case 35682:
      return setValueT1Array;
    case 35679:
    case 36299:
    case 36307:
      return setValueT3DArray;
    case 35680:
    case 36300:
    case 36308:
    case 36293:
      return setValueT6Array;
    case 36289:
    case 36303:
    case 36311:
    case 36292:
      return setValueT2DArrayArray;
  }
}
var SingleUniform = class {
  constructor(id2, activeInfo, addr) {
    this.id = id2;
    this.addr = addr;
    this.cache = [];
    this.setValue = getSingularSetter(activeInfo.type);
  }
};
var PureArrayUniform = class {
  constructor(id2, activeInfo, addr) {
    this.id = id2;
    this.addr = addr;
    this.cache = [];
    this.size = activeInfo.size;
    this.setValue = getPureArraySetter(activeInfo.type);
  }
};
var StructuredUniform = class {
  constructor(id2) {
    this.id = id2;
    this.seq = [];
    this.map = {};
  }
  setValue(gl, value, textures) {
    const seq = this.seq;
    for (let i2 = 0, n = seq.length; i2 !== n; ++i2) {
      const u2 = seq[i2];
      u2.setValue(gl, value[u2.id], textures);
    }
  }
};
var RePathPart = /(\w+)(\])?(\[|\.)?/g;
function addUniform(container, uniformObject) {
  container.seq.push(uniformObject);
  container.map[uniformObject.id] = uniformObject;
}
function parseUniform(activeInfo, addr, container) {
  const path = activeInfo.name, pathLength = path.length;
  RePathPart.lastIndex = 0;
  while (true) {
    const match = RePathPart.exec(path), matchEnd = RePathPart.lastIndex;
    let id2 = match[1];
    const idIsIndex = match[2] === "]", subscript = match[3];
    if (idIsIndex) id2 = id2 | 0;
    if (subscript === void 0 || subscript === "[" && matchEnd + 2 === pathLength) {
      addUniform(container, subscript === void 0 ? new SingleUniform(id2, activeInfo, addr) : new PureArrayUniform(id2, activeInfo, addr));
      break;
    } else {
      const map = container.map;
      let next = map[id2];
      if (next === void 0) {
        next = new StructuredUniform(id2);
        addUniform(container, next);
      }
      container = next;
    }
  }
}
var WebGLUniforms = class {
  constructor(gl, program) {
    this.seq = [];
    this.map = {};
    const n = gl.getProgramParameter(program, gl.ACTIVE_UNIFORMS);
    for (let i2 = 0; i2 < n; ++i2) {
      const info = gl.getActiveUniform(program, i2), addr = gl.getUniformLocation(program, info.name);
      parseUniform(info, addr, this);
    }
  }
  setValue(gl, name, value, textures) {
    const u2 = this.map[name];
    if (u2 !== void 0) u2.setValue(gl, value, textures);
  }
  setOptional(gl, object, name) {
    const v2 = object[name];
    if (v2 !== void 0) this.setValue(gl, name, v2);
  }
  static upload(gl, seq, values, textures) {
    for (let i2 = 0, n = seq.length; i2 !== n; ++i2) {
      const u2 = seq[i2], v2 = values[u2.id];
      if (v2.needsUpdate !== false) {
        u2.setValue(gl, v2.value, textures);
      }
    }
  }
  static seqWithValue(seq, values) {
    const r2 = [];
    for (let i2 = 0, n = seq.length; i2 !== n; ++i2) {
      const u2 = seq[i2];
      if (u2.id in values) r2.push(u2);
    }
    return r2;
  }
};
function WebGLShader(gl, type, string) {
  const shader = gl.createShader(type);
  gl.shaderSource(shader, string);
  gl.compileShader(shader);
  return shader;
}
var programIdCount = 0;
function handleSource(string, errorLine) {
  const lines = string.split("\n");
  const lines2 = [];
  const from = Math.max(errorLine - 6, 0);
  const to = Math.min(errorLine + 6, lines.length);
  for (let i2 = from; i2 < to; i2++) {
    const line = i2 + 1;
    lines2.push(`${line === errorLine ? ">" : " "} ${line}: ${lines[i2]}`);
  }
  return lines2.join("\n");
}
function getEncodingComponents(colorSpace) {
  switch (colorSpace) {
    case LinearSRGBColorSpace:
      return ["Linear", "( value )"];
    case SRGBColorSpace:
      return ["sRGB", "( value )"];
    default:
      console.warn("THREE.WebGLProgram: Unsupported color space:", colorSpace);
      return ["Linear", "( value )"];
  }
}
function getShaderErrors(gl, shader, type) {
  const status = gl.getShaderParameter(shader, gl.COMPILE_STATUS);
  const errors = gl.getShaderInfoLog(shader).trim();
  if (status && errors === "") return "";
  const errorMatches = /ERROR: 0:(\d+)/.exec(errors);
  if (errorMatches) {
    const errorLine = parseInt(errorMatches[1]);
    return type.toUpperCase() + "\n\n" + errors + "\n\n" + handleSource(gl.getShaderSource(shader), errorLine);
  } else {
    return errors;
  }
}
function getTexelEncodingFunction(functionName, colorSpace) {
  const components = getEncodingComponents(colorSpace);
  return "vec4 " + functionName + "( vec4 value ) { return LinearTo" + components[0] + components[1] + "; }";
}
function getToneMappingFunction(functionName, toneMapping) {
  let toneMappingName;
  switch (toneMapping) {
    case LinearToneMapping:
      toneMappingName = "Linear";
      break;
    case ReinhardToneMapping:
      toneMappingName = "Reinhard";
      break;
    case CineonToneMapping:
      toneMappingName = "OptimizedCineon";
      break;
    case ACESFilmicToneMapping:
      toneMappingName = "ACESFilmic";
      break;
    case CustomToneMapping:
      toneMappingName = "Custom";
      break;
    default:
      console.warn("THREE.WebGLProgram: Unsupported toneMapping:", toneMapping);
      toneMappingName = "Linear";
  }
  return "vec3 " + functionName + "( vec3 color ) { return " + toneMappingName + "ToneMapping( color ); }";
}
function generateExtensions(parameters) {
  const chunks = [
    parameters.extensionDerivatives || !!parameters.envMapCubeUVHeight || parameters.bumpMap || parameters.normalMapTangentSpace || parameters.clearcoatNormalMap || parameters.flatShading || parameters.shaderID === "physical" ? "#extension GL_OES_standard_derivatives : enable" : "",
    (parameters.extensionFragDepth || parameters.logarithmicDepthBuffer) && parameters.rendererExtensionFragDepth ? "#extension GL_EXT_frag_depth : enable" : "",
    parameters.extensionDrawBuffers && parameters.rendererExtensionDrawBuffers ? "#extension GL_EXT_draw_buffers : require" : "",
    (parameters.extensionShaderTextureLOD || parameters.envMap || parameters.transmission) && parameters.rendererExtensionShaderTextureLod ? "#extension GL_EXT_shader_texture_lod : enable" : ""
  ];
  return chunks.filter(filterEmptyLine).join("\n");
}
function generateDefines(defines) {
  const chunks = [];
  for (const name in defines) {
    const value = defines[name];
    if (value === false) continue;
    chunks.push("#define " + name + " " + value);
  }
  return chunks.join("\n");
}
function fetchAttributeLocations(gl, program) {
  const attributes = {};
  const n = gl.getProgramParameter(program, gl.ACTIVE_ATTRIBUTES);
  for (let i2 = 0; i2 < n; i2++) {
    const info = gl.getActiveAttrib(program, i2);
    const name = info.name;
    let locationSize = 1;
    if (info.type === gl.FLOAT_MAT2) locationSize = 2;
    if (info.type === gl.FLOAT_MAT3) locationSize = 3;
    if (info.type === gl.FLOAT_MAT4) locationSize = 4;
    attributes[name] = {
      type: info.type,
      location: gl.getAttribLocation(program, name),
      locationSize
    };
  }
  return attributes;
}
function filterEmptyLine(string) {
  return string !== "";
}
function replaceLightNums(string, parameters) {
  const numSpotLightCoords = parameters.numSpotLightShadows + parameters.numSpotLightMaps - parameters.numSpotLightShadowsWithMaps;
  return string.replace(/NUM_DIR_LIGHTS/g, parameters.numDirLights).replace(/NUM_SPOT_LIGHTS/g, parameters.numSpotLights).replace(/NUM_SPOT_LIGHT_MAPS/g, parameters.numSpotLightMaps).replace(/NUM_SPOT_LIGHT_COORDS/g, numSpotLightCoords).replace(/NUM_RECT_AREA_LIGHTS/g, parameters.numRectAreaLights).replace(/NUM_POINT_LIGHTS/g, parameters.numPointLights).replace(/NUM_HEMI_LIGHTS/g, parameters.numHemiLights).replace(/NUM_DIR_LIGHT_SHADOWS/g, parameters.numDirLightShadows).replace(/NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS/g, parameters.numSpotLightShadowsWithMaps).replace(/NUM_SPOT_LIGHT_SHADOWS/g, parameters.numSpotLightShadows).replace(/NUM_POINT_LIGHT_SHADOWS/g, parameters.numPointLightShadows);
}
function replaceClippingPlaneNums(string, parameters) {
  return string.replace(/NUM_CLIPPING_PLANES/g, parameters.numClippingPlanes).replace(/UNION_CLIPPING_PLANES/g, parameters.numClippingPlanes - parameters.numClipIntersection);
}
var includePattern = /^[ \t]*#include +<([\w\d./]+)>/gm;
function resolveIncludes(string) {
  return string.replace(includePattern, includeReplacer);
}
function includeReplacer(match, include) {
  const string = ShaderChunk[include];
  if (string === void 0) {
    throw new Error("Can not resolve #include <" + include + ">");
  }
  return resolveIncludes(string);
}
var unrollLoopPattern = /#pragma unroll_loop_start\s+for\s*\(\s*int\s+i\s*=\s*(\d+)\s*;\s*i\s*<\s*(\d+)\s*;\s*i\s*\+\+\s*\)\s*{([\s\S]+?)}\s+#pragma unroll_loop_end/g;
function unrollLoops(string) {
  return string.replace(unrollLoopPattern, loopReplacer);
}
function loopReplacer(match, start, end, snippet) {
  let string = "";
  for (let i2 = parseInt(start); i2 < parseInt(end); i2++) {
    string += snippet.replace(/\[\s*i\s*\]/g, "[ " + i2 + " ]").replace(/UNROLLED_LOOP_INDEX/g, i2);
  }
  return string;
}
function generatePrecision(parameters) {
  let precisionstring = "precision " + parameters.precision + " float;\nprecision " + parameters.precision + " int;";
  if (parameters.precision === "highp") {
    precisionstring += "\n#define HIGH_PRECISION";
  } else if (parameters.precision === "mediump") {
    precisionstring += "\n#define MEDIUM_PRECISION";
  } else if (parameters.precision === "lowp") {
    precisionstring += "\n#define LOW_PRECISION";
  }
  return precisionstring;
}
function generateShadowMapTypeDefine(parameters) {
  let shadowMapTypeDefine = "SHADOWMAP_TYPE_BASIC";
  if (parameters.shadowMapType === PCFShadowMap) {
    shadowMapTypeDefine = "SHADOWMAP_TYPE_PCF";
  } else if (parameters.shadowMapType === PCFSoftShadowMap) {
    shadowMapTypeDefine = "SHADOWMAP_TYPE_PCF_SOFT";
  } else if (parameters.shadowMapType === VSMShadowMap) {
    shadowMapTypeDefine = "SHADOWMAP_TYPE_VSM";
  }
  return shadowMapTypeDefine;
}
function generateEnvMapTypeDefine(parameters) {
  let envMapTypeDefine = "ENVMAP_TYPE_CUBE";
  if (parameters.envMap) {
    switch (parameters.envMapMode) {
      case CubeReflectionMapping:
      case CubeRefractionMapping:
        envMapTypeDefine = "ENVMAP_TYPE_CUBE";
        break;
      case CubeUVReflectionMapping:
        envMapTypeDefine = "ENVMAP_TYPE_CUBE_UV";
        break;
    }
  }
  return envMapTypeDefine;
}
function generateEnvMapModeDefine(parameters) {
  let envMapModeDefine = "ENVMAP_MODE_REFLECTION";
  if (parameters.envMap) {
    switch (parameters.envMapMode) {
      case CubeRefractionMapping:
        envMapModeDefine = "ENVMAP_MODE_REFRACTION";
        break;
    }
  }
  return envMapModeDefine;
}
function generateEnvMapBlendingDefine(parameters) {
  let envMapBlendingDefine = "ENVMAP_BLENDING_NONE";
  if (parameters.envMap) {
    switch (parameters.combine) {
      case MultiplyOperation:
        envMapBlendingDefine = "ENVMAP_BLENDING_MULTIPLY";
        break;
      case MixOperation:
        envMapBlendingDefine = "ENVMAP_BLENDING_MIX";
        break;
      case AddOperation:
        envMapBlendingDefine = "ENVMAP_BLENDING_ADD";
        break;
    }
  }
  return envMapBlendingDefine;
}
function generateCubeUVSize(parameters) {
  const imageHeight = parameters.envMapCubeUVHeight;
  if (imageHeight === null) return null;
  const maxMip = Math.log2(imageHeight) - 2;
  const texelHeight = 1 / imageHeight;
  const texelWidth = 1 / (3 * Math.max(Math.pow(2, maxMip), 7 * 16));
  return { texelWidth, texelHeight, maxMip };
}
function WebGLProgram(renderer, cacheKey, parameters, bindingStates) {
  const gl = renderer.getContext();
  const defines = parameters.defines;
  let vertexShader = parameters.vertexShader;
  let fragmentShader = parameters.fragmentShader;
  const shadowMapTypeDefine = generateShadowMapTypeDefine(parameters);
  const envMapTypeDefine = generateEnvMapTypeDefine(parameters);
  const envMapModeDefine = generateEnvMapModeDefine(parameters);
  const envMapBlendingDefine = generateEnvMapBlendingDefine(parameters);
  const envMapCubeUVSize = generateCubeUVSize(parameters);
  const customExtensions = parameters.isWebGL2 ? "" : generateExtensions(parameters);
  const customDefines = generateDefines(defines);
  const program = gl.createProgram();
  let prefixVertex, prefixFragment;
  let versionString = parameters.glslVersion ? "#version " + parameters.glslVersion + "\n" : "";
  if (parameters.isRawShaderMaterial) {
    prefixVertex = [
      "#define SHADER_TYPE " + parameters.shaderType,
      "#define SHADER_NAME " + parameters.shaderName,
      customDefines
    ].filter(filterEmptyLine).join("\n");
    if (prefixVertex.length > 0) {
      prefixVertex += "\n";
    }
    prefixFragment = [
      customExtensions,
      "#define SHADER_TYPE " + parameters.shaderType,
      "#define SHADER_NAME " + parameters.shaderName,
      customDefines
    ].filter(filterEmptyLine).join("\n");
    if (prefixFragment.length > 0) {
      prefixFragment += "\n";
    }
  } else {
    prefixVertex = [
      generatePrecision(parameters),
      "#define SHADER_TYPE " + parameters.shaderType,
      "#define SHADER_NAME " + parameters.shaderName,
      customDefines,
      parameters.instancing ? "#define USE_INSTANCING" : "",
      parameters.instancingColor ? "#define USE_INSTANCING_COLOR" : "",
      parameters.useFog && parameters.fog ? "#define USE_FOG" : "",
      parameters.useFog && parameters.fogExp2 ? "#define FOG_EXP2" : "",
      parameters.map ? "#define USE_MAP" : "",
      parameters.envMap ? "#define USE_ENVMAP" : "",
      parameters.envMap ? "#define " + envMapModeDefine : "",
      parameters.lightMap ? "#define USE_LIGHTMAP" : "",
      parameters.aoMap ? "#define USE_AOMAP" : "",
      parameters.bumpMap ? "#define USE_BUMPMAP" : "",
      parameters.normalMap ? "#define USE_NORMALMAP" : "",
      parameters.normalMapObjectSpace ? "#define USE_NORMALMAP_OBJECTSPACE" : "",
      parameters.normalMapTangentSpace ? "#define USE_NORMALMAP_TANGENTSPACE" : "",
      parameters.displacementMap ? "#define USE_DISPLACEMENTMAP" : "",
      parameters.emissiveMap ? "#define USE_EMISSIVEMAP" : "",
      parameters.anisotropyMap ? "#define USE_ANISOTROPYMAP" : "",
      parameters.clearcoatMap ? "#define USE_CLEARCOATMAP" : "",
      parameters.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "",
      parameters.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "",
      parameters.iridescenceMap ? "#define USE_IRIDESCENCEMAP" : "",
      parameters.iridescenceThicknessMap ? "#define USE_IRIDESCENCE_THICKNESSMAP" : "",
      parameters.specularMap ? "#define USE_SPECULARMAP" : "",
      parameters.specularColorMap ? "#define USE_SPECULAR_COLORMAP" : "",
      parameters.specularIntensityMap ? "#define USE_SPECULAR_INTENSITYMAP" : "",
      parameters.roughnessMap ? "#define USE_ROUGHNESSMAP" : "",
      parameters.metalnessMap ? "#define USE_METALNESSMAP" : "",
      parameters.alphaMap ? "#define USE_ALPHAMAP" : "",
      parameters.transmission ? "#define USE_TRANSMISSION" : "",
      parameters.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "",
      parameters.thicknessMap ? "#define USE_THICKNESSMAP" : "",
      parameters.sheenColorMap ? "#define USE_SHEEN_COLORMAP" : "",
      parameters.sheenRoughnessMap ? "#define USE_SHEEN_ROUGHNESSMAP" : "",
      //
      parameters.mapUv ? "#define MAP_UV " + parameters.mapUv : "",
      parameters.alphaMapUv ? "#define ALPHAMAP_UV " + parameters.alphaMapUv : "",
      parameters.lightMapUv ? "#define LIGHTMAP_UV " + parameters.lightMapUv : "",
      parameters.aoMapUv ? "#define AOMAP_UV " + parameters.aoMapUv : "",
      parameters.emissiveMapUv ? "#define EMISSIVEMAP_UV " + parameters.emissiveMapUv : "",
      parameters.bumpMapUv ? "#define BUMPMAP_UV " + parameters.bumpMapUv : "",
      parameters.normalMapUv ? "#define NORMALMAP_UV " + parameters.normalMapUv : "",
      parameters.displacementMapUv ? "#define DISPLACEMENTMAP_UV " + parameters.displacementMapUv : "",
      parameters.metalnessMapUv ? "#define METALNESSMAP_UV " + parameters.metalnessMapUv : "",
      parameters.roughnessMapUv ? "#define ROUGHNESSMAP_UV " + parameters.roughnessMapUv : "",
      parameters.anisotropyMapUv ? "#define ANISOTROPYMAP_UV " + parameters.anisotropyMapUv : "",
      parameters.clearcoatMapUv ? "#define CLEARCOATMAP_UV " + parameters.clearcoatMapUv : "",
      parameters.clearcoatNormalMapUv ? "#define CLEARCOAT_NORMALMAP_UV " + parameters.clearcoatNormalMapUv : "",
      parameters.clearcoatRoughnessMapUv ? "#define CLEARCOAT_ROUGHNESSMAP_UV " + parameters.clearcoatRoughnessMapUv : "",
      parameters.iridescenceMapUv ? "#define IRIDESCENCEMAP_UV " + parameters.iridescenceMapUv : "",
      parameters.iridescenceThicknessMapUv ? "#define IRIDESCENCE_THICKNESSMAP_UV " + parameters.iridescenceThicknessMapUv : "",
      parameters.sheenColorMapUv ? "#define SHEEN_COLORMAP_UV " + parameters.sheenColorMapUv : "",
      parameters.sheenRoughnessMapUv ? "#define SHEEN_ROUGHNESSMAP_UV " + parameters.sheenRoughnessMapUv : "",
      parameters.specularMapUv ? "#define SPECULARMAP_UV " + parameters.specularMapUv : "",
      parameters.specularColorMapUv ? "#define SPECULAR_COLORMAP_UV " + parameters.specularColorMapUv : "",
      parameters.specularIntensityMapUv ? "#define SPECULAR_INTENSITYMAP_UV " + parameters.specularIntensityMapUv : "",
      parameters.transmissionMapUv ? "#define TRANSMISSIONMAP_UV " + parameters.transmissionMapUv : "",
      parameters.thicknessMapUv ? "#define THICKNESSMAP_UV " + parameters.thicknessMapUv : "",
      //
      parameters.vertexTangents ? "#define USE_TANGENT" : "",
      parameters.vertexColors ? "#define USE_COLOR" : "",
      parameters.vertexAlphas ? "#define USE_COLOR_ALPHA" : "",
      parameters.vertexUv1s ? "#define USE_UV1" : "",
      parameters.vertexUv2s ? "#define USE_UV2" : "",
      parameters.vertexUv3s ? "#define USE_UV3" : "",
      parameters.pointsUvs ? "#define USE_POINTS_UV" : "",
      parameters.flatShading ? "#define FLAT_SHADED" : "",
      parameters.skinning ? "#define USE_SKINNING" : "",
      parameters.morphTargets ? "#define USE_MORPHTARGETS" : "",
      parameters.morphNormals && parameters.flatShading === false ? "#define USE_MORPHNORMALS" : "",
      parameters.morphColors && parameters.isWebGL2 ? "#define USE_MORPHCOLORS" : "",
      parameters.morphTargetsCount > 0 && parameters.isWebGL2 ? "#define MORPHTARGETS_TEXTURE" : "",
      parameters.morphTargetsCount > 0 && parameters.isWebGL2 ? "#define MORPHTARGETS_TEXTURE_STRIDE " + parameters.morphTextureStride : "",
      parameters.morphTargetsCount > 0 && parameters.isWebGL2 ? "#define MORPHTARGETS_COUNT " + parameters.morphTargetsCount : "",
      parameters.doubleSided ? "#define DOUBLE_SIDED" : "",
      parameters.flipSided ? "#define FLIP_SIDED" : "",
      parameters.shadowMapEnabled ? "#define USE_SHADOWMAP" : "",
      parameters.shadowMapEnabled ? "#define " + shadowMapTypeDefine : "",
      parameters.sizeAttenuation ? "#define USE_SIZEATTENUATION" : "",
      parameters.useLegacyLights ? "#define LEGACY_LIGHTS" : "",
      parameters.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "",
      parameters.logarithmicDepthBuffer && parameters.rendererExtensionFragDepth ? "#define USE_LOGDEPTHBUF_EXT" : "",
      "uniform mat4 modelMatrix;",
      "uniform mat4 modelViewMatrix;",
      "uniform mat4 projectionMatrix;",
      "uniform mat4 viewMatrix;",
      "uniform mat3 normalMatrix;",
      "uniform vec3 cameraPosition;",
      "uniform bool isOrthographic;",
      "#ifdef USE_INSTANCING",
      "	attribute mat4 instanceMatrix;",
      "#endif",
      "#ifdef USE_INSTANCING_COLOR",
      "	attribute vec3 instanceColor;",
      "#endif",
      "attribute vec3 position;",
      "attribute vec3 normal;",
      "attribute vec2 uv;",
      "#ifdef USE_UV1",
      "	attribute vec2 uv1;",
      "#endif",
      "#ifdef USE_UV2",
      "	attribute vec2 uv2;",
      "#endif",
      "#ifdef USE_UV3",
      "	attribute vec2 uv3;",
      "#endif",
      "#ifdef USE_TANGENT",
      "	attribute vec4 tangent;",
      "#endif",
      "#if defined( USE_COLOR_ALPHA )",
      "	attribute vec4 color;",
      "#elif defined( USE_COLOR )",
      "	attribute vec3 color;",
      "#endif",
      "#if ( defined( USE_MORPHTARGETS ) && ! defined( MORPHTARGETS_TEXTURE ) )",
      "	attribute vec3 morphTarget0;",
      "	attribute vec3 morphTarget1;",
      "	attribute vec3 morphTarget2;",
      "	attribute vec3 morphTarget3;",
      "	#ifdef USE_MORPHNORMALS",
      "		attribute vec3 morphNormal0;",
      "		attribute vec3 morphNormal1;",
      "		attribute vec3 morphNormal2;",
      "		attribute vec3 morphNormal3;",
      "	#else",
      "		attribute vec3 morphTarget4;",
      "		attribute vec3 morphTarget5;",
      "		attribute vec3 morphTarget6;",
      "		attribute vec3 morphTarget7;",
      "	#endif",
      "#endif",
      "#ifdef USE_SKINNING",
      "	attribute vec4 skinIndex;",
      "	attribute vec4 skinWeight;",
      "#endif",
      "\n"
    ].filter(filterEmptyLine).join("\n");
    prefixFragment = [
      customExtensions,
      generatePrecision(parameters),
      "#define SHADER_TYPE " + parameters.shaderType,
      "#define SHADER_NAME " + parameters.shaderName,
      customDefines,
      parameters.useFog && parameters.fog ? "#define USE_FOG" : "",
      parameters.useFog && parameters.fogExp2 ? "#define FOG_EXP2" : "",
      parameters.map ? "#define USE_MAP" : "",
      parameters.matcap ? "#define USE_MATCAP" : "",
      parameters.envMap ? "#define USE_ENVMAP" : "",
      parameters.envMap ? "#define " + envMapTypeDefine : "",
      parameters.envMap ? "#define " + envMapModeDefine : "",
      parameters.envMap ? "#define " + envMapBlendingDefine : "",
      envMapCubeUVSize ? "#define CUBEUV_TEXEL_WIDTH " + envMapCubeUVSize.texelWidth : "",
      envMapCubeUVSize ? "#define CUBEUV_TEXEL_HEIGHT " + envMapCubeUVSize.texelHeight : "",
      envMapCubeUVSize ? "#define CUBEUV_MAX_MIP " + envMapCubeUVSize.maxMip + ".0" : "",
      parameters.lightMap ? "#define USE_LIGHTMAP" : "",
      parameters.aoMap ? "#define USE_AOMAP" : "",
      parameters.bumpMap ? "#define USE_BUMPMAP" : "",
      parameters.normalMap ? "#define USE_NORMALMAP" : "",
      parameters.normalMapObjectSpace ? "#define USE_NORMALMAP_OBJECTSPACE" : "",
      parameters.normalMapTangentSpace ? "#define USE_NORMALMAP_TANGENTSPACE" : "",
      parameters.emissiveMap ? "#define USE_EMISSIVEMAP" : "",
      parameters.anisotropy ? "#define USE_ANISOTROPY" : "",
      parameters.anisotropyMap ? "#define USE_ANISOTROPYMAP" : "",
      parameters.clearcoat ? "#define USE_CLEARCOAT" : "",
      parameters.clearcoatMap ? "#define USE_CLEARCOATMAP" : "",
      parameters.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "",
      parameters.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "",
      parameters.iridescence ? "#define USE_IRIDESCENCE" : "",
      parameters.iridescenceMap ? "#define USE_IRIDESCENCEMAP" : "",
      parameters.iridescenceThicknessMap ? "#define USE_IRIDESCENCE_THICKNESSMAP" : "",
      parameters.specularMap ? "#define USE_SPECULARMAP" : "",
      parameters.specularColorMap ? "#define USE_SPECULAR_COLORMAP" : "",
      parameters.specularIntensityMap ? "#define USE_SPECULAR_INTENSITYMAP" : "",
      parameters.roughnessMap ? "#define USE_ROUGHNESSMAP" : "",
      parameters.metalnessMap ? "#define USE_METALNESSMAP" : "",
      parameters.alphaMap ? "#define USE_ALPHAMAP" : "",
      parameters.alphaTest ? "#define USE_ALPHATEST" : "",
      parameters.sheen ? "#define USE_SHEEN" : "",
      parameters.sheenColorMap ? "#define USE_SHEEN_COLORMAP" : "",
      parameters.sheenRoughnessMap ? "#define USE_SHEEN_ROUGHNESSMAP" : "",
      parameters.transmission ? "#define USE_TRANSMISSION" : "",
      parameters.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "",
      parameters.thicknessMap ? "#define USE_THICKNESSMAP" : "",
      parameters.vertexTangents ? "#define USE_TANGENT" : "",
      parameters.vertexColors || parameters.instancingColor ? "#define USE_COLOR" : "",
      parameters.vertexAlphas ? "#define USE_COLOR_ALPHA" : "",
      parameters.vertexUv1s ? "#define USE_UV1" : "",
      parameters.vertexUv2s ? "#define USE_UV2" : "",
      parameters.vertexUv3s ? "#define USE_UV3" : "",
      parameters.pointsUvs ? "#define USE_POINTS_UV" : "",
      parameters.gradientMap ? "#define USE_GRADIENTMAP" : "",
      parameters.flatShading ? "#define FLAT_SHADED" : "",
      parameters.doubleSided ? "#define DOUBLE_SIDED" : "",
      parameters.flipSided ? "#define FLIP_SIDED" : "",
      parameters.shadowMapEnabled ? "#define USE_SHADOWMAP" : "",
      parameters.shadowMapEnabled ? "#define " + shadowMapTypeDefine : "",
      parameters.premultipliedAlpha ? "#define PREMULTIPLIED_ALPHA" : "",
      parameters.useLegacyLights ? "#define LEGACY_LIGHTS" : "",
      parameters.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "",
      parameters.logarithmicDepthBuffer && parameters.rendererExtensionFragDepth ? "#define USE_LOGDEPTHBUF_EXT" : "",
      "uniform mat4 viewMatrix;",
      "uniform vec3 cameraPosition;",
      "uniform bool isOrthographic;",
      parameters.toneMapping !== NoToneMapping ? "#define TONE_MAPPING" : "",
      parameters.toneMapping !== NoToneMapping ? ShaderChunk["tonemapping_pars_fragment"] : "",
      // this code is required here because it is used by the toneMapping() function defined below
      parameters.toneMapping !== NoToneMapping ? getToneMappingFunction("toneMapping", parameters.toneMapping) : "",
      parameters.dithering ? "#define DITHERING" : "",
      parameters.opaque ? "#define OPAQUE" : "",
      ShaderChunk["encodings_pars_fragment"],
      // this code is required here because it is used by the various encoding/decoding function defined below
      getTexelEncodingFunction("linearToOutputTexel", parameters.outputColorSpace),
      parameters.useDepthPacking ? "#define DEPTH_PACKING " + parameters.depthPacking : "",
      "\n"
    ].filter(filterEmptyLine).join("\n");
  }
  vertexShader = resolveIncludes(vertexShader);
  vertexShader = replaceLightNums(vertexShader, parameters);
  vertexShader = replaceClippingPlaneNums(vertexShader, parameters);
  fragmentShader = resolveIncludes(fragmentShader);
  fragmentShader = replaceLightNums(fragmentShader, parameters);
  fragmentShader = replaceClippingPlaneNums(fragmentShader, parameters);
  vertexShader = unrollLoops(vertexShader);
  fragmentShader = unrollLoops(fragmentShader);
  if (parameters.isWebGL2 && parameters.isRawShaderMaterial !== true) {
    versionString = "#version 300 es\n";
    prefixVertex = [
      "precision mediump sampler2DArray;",
      "#define attribute in",
      "#define varying out",
      "#define texture2D texture"
    ].join("\n") + "\n" + prefixVertex;
    prefixFragment = [
      "#define varying in",
      parameters.glslVersion === GLSL3 ? "" : "layout(location = 0) out highp vec4 pc_fragColor;",
      parameters.glslVersion === GLSL3 ? "" : "#define gl_FragColor pc_fragColor",
      "#define gl_FragDepthEXT gl_FragDepth",
      "#define texture2D texture",
      "#define textureCube texture",
      "#define texture2DProj textureProj",
      "#define texture2DLodEXT textureLod",
      "#define texture2DProjLodEXT textureProjLod",
      "#define textureCubeLodEXT textureLod",
      "#define texture2DGradEXT textureGrad",
      "#define texture2DProjGradEXT textureProjGrad",
      "#define textureCubeGradEXT textureGrad"
    ].join("\n") + "\n" + prefixFragment;
  }
  const vertexGlsl = versionString + prefixVertex + vertexShader;
  const fragmentGlsl = versionString + prefixFragment + fragmentShader;
  const glVertexShader = WebGLShader(gl, gl.VERTEX_SHADER, vertexGlsl);
  const glFragmentShader = WebGLShader(gl, gl.FRAGMENT_SHADER, fragmentGlsl);
  gl.attachShader(program, glVertexShader);
  gl.attachShader(program, glFragmentShader);
  if (parameters.index0AttributeName !== void 0) {
    gl.bindAttribLocation(program, 0, parameters.index0AttributeName);
  } else if (parameters.morphTargets === true) {
    gl.bindAttribLocation(program, 0, "position");
  }
  gl.linkProgram(program);
  if (renderer.debug.checkShaderErrors) {
    const programLog = gl.getProgramInfoLog(program).trim();
    const vertexLog = gl.getShaderInfoLog(glVertexShader).trim();
    const fragmentLog = gl.getShaderInfoLog(glFragmentShader).trim();
    let runnable = true;
    let haveDiagnostics = true;
    if (gl.getProgramParameter(program, gl.LINK_STATUS) === false) {
      runnable = false;
      if (typeof renderer.debug.onShaderError === "function") {
        renderer.debug.onShaderError(gl, program, glVertexShader, glFragmentShader);
      } else {
        const vertexErrors = getShaderErrors(gl, glVertexShader, "vertex");
        const fragmentErrors = getShaderErrors(gl, glFragmentShader, "fragment");
        console.error(
          "THREE.WebGLProgram: Shader Error " + gl.getError() + " - VALIDATE_STATUS " + gl.getProgramParameter(program, gl.VALIDATE_STATUS) + "\n\nProgram Info Log: " + programLog + "\n" + vertexErrors + "\n" + fragmentErrors
        );
      }
    } else if (programLog !== "") {
      console.warn("THREE.WebGLProgram: Program Info Log:", programLog);
    } else if (vertexLog === "" || fragmentLog === "") {
      haveDiagnostics = false;
    }
    if (haveDiagnostics) {
      this.diagnostics = {
        runnable,
        programLog,
        vertexShader: {
          log: vertexLog,
          prefix: prefixVertex
        },
        fragmentShader: {
          log: fragmentLog,
          prefix: prefixFragment
        }
      };
    }
  }
  gl.deleteShader(glVertexShader);
  gl.deleteShader(glFragmentShader);
  let cachedUniforms;
  this.getUniforms = function() {
    if (cachedUniforms === void 0) {
      cachedUniforms = new WebGLUniforms(gl, program);
    }
    return cachedUniforms;
  };
  let cachedAttributes;
  this.getAttributes = function() {
    if (cachedAttributes === void 0) {
      cachedAttributes = fetchAttributeLocations(gl, program);
    }
    return cachedAttributes;
  };
  this.destroy = function() {
    bindingStates.releaseStatesOfProgram(this);
    gl.deleteProgram(program);
    this.program = void 0;
  };
  this.type = parameters.shaderType;
  this.name = parameters.shaderName;
  this.id = programIdCount++;
  this.cacheKey = cacheKey;
  this.usedTimes = 1;
  this.program = program;
  this.vertexShader = glVertexShader;
  this.fragmentShader = glFragmentShader;
  return this;
}
var _id = 0;
var WebGLShaderCache = class {
  constructor() {
    this.shaderCache = /* @__PURE__ */ new Map();
    this.materialCache = /* @__PURE__ */ new Map();
  }
  update(material) {
    const vertexShader = material.vertexShader;
    const fragmentShader = material.fragmentShader;
    const vertexShaderStage = this._getShaderStage(vertexShader);
    const fragmentShaderStage = this._getShaderStage(fragmentShader);
    const materialShaders = this._getShaderCacheForMaterial(material);
    if (materialShaders.has(vertexShaderStage) === false) {
      materialShaders.add(vertexShaderStage);
      vertexShaderStage.usedTimes++;
    }
    if (materialShaders.has(fragmentShaderStage) === false) {
      materialShaders.add(fragmentShaderStage);
      fragmentShaderStage.usedTimes++;
    }
    return this;
  }
  remove(material) {
    const materialShaders = this.materialCache.get(material);
    for (const shaderStage of materialShaders) {
      shaderStage.usedTimes--;
      if (shaderStage.usedTimes === 0) this.shaderCache.delete(shaderStage.code);
    }
    this.materialCache.delete(material);
    return this;
  }
  getVertexShaderID(material) {
    return this._getShaderStage(material.vertexShader).id;
  }
  getFragmentShaderID(material) {
    return this._getShaderStage(material.fragmentShader).id;
  }
  dispose() {
    this.shaderCache.clear();
    this.materialCache.clear();
  }
  _getShaderCacheForMaterial(material) {
    const cache = this.materialCache;
    let set = cache.get(material);
    if (set === void 0) {
      set = /* @__PURE__ */ new Set();
      cache.set(material, set);
    }
    return set;
  }
  _getShaderStage(code) {
    const cache = this.shaderCache;
    let stage = cache.get(code);
    if (stage === void 0) {
      stage = new WebGLShaderStage(code);
      cache.set(code, stage);
    }
    return stage;
  }
};
var WebGLShaderStage = class {
  constructor(code) {
    this.id = _id++;
    this.code = code;
    this.usedTimes = 0;
  }
};
function WebGLPrograms(renderer, cubemaps, cubeuvmaps, extensions, capabilities2, bindingStates, clipping) {
  const _programLayers = new Layers();
  const _customShaders = new WebGLShaderCache();
  const programs = [];
  const IS_WEBGL2 = capabilities2.isWebGL2;
  const logarithmicDepthBuffer = capabilities2.logarithmicDepthBuffer;
  const SUPPORTS_VERTEX_TEXTURES = capabilities2.vertexTextures;
  let precision = capabilities2.precision;
  const shaderIDs = {
    MeshDepthMaterial: "depth",
    MeshDistanceMaterial: "distanceRGBA",
    MeshNormalMaterial: "normal",
    MeshBasicMaterial: "basic",
    MeshLambertMaterial: "lambert",
    MeshPhongMaterial: "phong",
    MeshToonMaterial: "toon",
    MeshStandardMaterial: "physical",
    MeshPhysicalMaterial: "physical",
    MeshMatcapMaterial: "matcap",
    LineBasicMaterial: "basic",
    LineDashedMaterial: "dashed",
    PointsMaterial: "points",
    ShadowMaterial: "shadow",
    SpriteMaterial: "sprite"
  };
  function getChannel(value) {
    if (value === 0) return "uv";
    return `uv${value}`;
  }
  function getParameters(material, lights, shadows, scene, object) {
    const fog = scene.fog;
    const geometry = object.geometry;
    const environment = material.isMeshStandardMaterial ? scene.environment : null;
    const envMap = (material.isMeshStandardMaterial ? cubeuvmaps : cubemaps).get(material.envMap || environment);
    const envMapCubeUVHeight = !!envMap && envMap.mapping === CubeUVReflectionMapping ? envMap.image.height : null;
    const shaderID = shaderIDs[material.type];
    if (material.precision !== null) {
      precision = capabilities2.getMaxPrecision(material.precision);
      if (precision !== material.precision) {
        console.warn("THREE.WebGLProgram.getParameters:", material.precision, "not supported, using", precision, "instead.");
      }
    }
    const morphAttribute = geometry.morphAttributes.position || geometry.morphAttributes.normal || geometry.morphAttributes.color;
    const morphTargetsCount = morphAttribute !== void 0 ? morphAttribute.length : 0;
    let morphTextureStride = 0;
    if (geometry.morphAttributes.position !== void 0) morphTextureStride = 1;
    if (geometry.morphAttributes.normal !== void 0) morphTextureStride = 2;
    if (geometry.morphAttributes.color !== void 0) morphTextureStride = 3;
    let vertexShader, fragmentShader;
    let customVertexShaderID, customFragmentShaderID;
    if (shaderID) {
      const shader = ShaderLib[shaderID];
      vertexShader = shader.vertexShader;
      fragmentShader = shader.fragmentShader;
    } else {
      vertexShader = material.vertexShader;
      fragmentShader = material.fragmentShader;
      _customShaders.update(material);
      customVertexShaderID = _customShaders.getVertexShaderID(material);
      customFragmentShaderID = _customShaders.getFragmentShaderID(material);
    }
    const currentRenderTarget = renderer.getRenderTarget();
    const IS_INSTANCEDMESH = object.isInstancedMesh === true;
    const HAS_MAP = !!material.map;
    const HAS_MATCAP = !!material.matcap;
    const HAS_ENVMAP = !!envMap;
    const HAS_AOMAP = !!material.aoMap;
    const HAS_LIGHTMAP = !!material.lightMap;
    const HAS_BUMPMAP = !!material.bumpMap;
    const HAS_NORMALMAP = !!material.normalMap;
    const HAS_DISPLACEMENTMAP = !!material.displacementMap;
    const HAS_EMISSIVEMAP = !!material.emissiveMap;
    const HAS_METALNESSMAP = !!material.metalnessMap;
    const HAS_ROUGHNESSMAP = !!material.roughnessMap;
    const HAS_ANISOTROPY = material.anisotropy > 0;
    const HAS_CLEARCOAT = material.clearcoat > 0;
    const HAS_IRIDESCENCE = material.iridescence > 0;
    const HAS_SHEEN = material.sheen > 0;
    const HAS_TRANSMISSION = material.transmission > 0;
    const HAS_ANISOTROPYMAP = HAS_ANISOTROPY && !!material.anisotropyMap;
    const HAS_CLEARCOATMAP = HAS_CLEARCOAT && !!material.clearcoatMap;
    const HAS_CLEARCOAT_NORMALMAP = HAS_CLEARCOAT && !!material.clearcoatNormalMap;
    const HAS_CLEARCOAT_ROUGHNESSMAP = HAS_CLEARCOAT && !!material.clearcoatRoughnessMap;
    const HAS_IRIDESCENCEMAP = HAS_IRIDESCENCE && !!material.iridescenceMap;
    const HAS_IRIDESCENCE_THICKNESSMAP = HAS_IRIDESCENCE && !!material.iridescenceThicknessMap;
    const HAS_SHEEN_COLORMAP = HAS_SHEEN && !!material.sheenColorMap;
    const HAS_SHEEN_ROUGHNESSMAP = HAS_SHEEN && !!material.sheenRoughnessMap;
    const HAS_SPECULARMAP = !!material.specularMap;
    const HAS_SPECULAR_COLORMAP = !!material.specularColorMap;
    const HAS_SPECULAR_INTENSITYMAP = !!material.specularIntensityMap;
    const HAS_TRANSMISSIONMAP = HAS_TRANSMISSION && !!material.transmissionMap;
    const HAS_THICKNESSMAP = HAS_TRANSMISSION && !!material.thicknessMap;
    const HAS_GRADIENTMAP = !!material.gradientMap;
    const HAS_ALPHAMAP = !!material.alphaMap;
    const HAS_ALPHATEST = material.alphaTest > 0;
    const HAS_EXTENSIONS = !!material.extensions;
    const HAS_ATTRIBUTE_UV1 = !!geometry.attributes.uv1;
    const HAS_ATTRIBUTE_UV2 = !!geometry.attributes.uv2;
    const HAS_ATTRIBUTE_UV3 = !!geometry.attributes.uv3;
    const parameters = {
      isWebGL2: IS_WEBGL2,
      shaderID,
      shaderType: material.type,
      shaderName: material.name,
      vertexShader,
      fragmentShader,
      defines: material.defines,
      customVertexShaderID,
      customFragmentShaderID,
      isRawShaderMaterial: material.isRawShaderMaterial === true,
      glslVersion: material.glslVersion,
      precision,
      instancing: IS_INSTANCEDMESH,
      instancingColor: IS_INSTANCEDMESH && object.instanceColor !== null,
      supportsVertexTextures: SUPPORTS_VERTEX_TEXTURES,
      outputColorSpace: currentRenderTarget === null ? renderer.outputColorSpace : currentRenderTarget.isXRRenderTarget === true ? currentRenderTarget.texture.colorSpace : LinearSRGBColorSpace,
      map: HAS_MAP,
      matcap: HAS_MATCAP,
      envMap: HAS_ENVMAP,
      envMapMode: HAS_ENVMAP && envMap.mapping,
      envMapCubeUVHeight,
      aoMap: HAS_AOMAP,
      lightMap: HAS_LIGHTMAP,
      bumpMap: HAS_BUMPMAP,
      normalMap: HAS_NORMALMAP,
      displacementMap: SUPPORTS_VERTEX_TEXTURES && HAS_DISPLACEMENTMAP,
      emissiveMap: HAS_EMISSIVEMAP,
      normalMapObjectSpace: HAS_NORMALMAP && material.normalMapType === ObjectSpaceNormalMap,
      normalMapTangentSpace: HAS_NORMALMAP && material.normalMapType === TangentSpaceNormalMap,
      metalnessMap: HAS_METALNESSMAP,
      roughnessMap: HAS_ROUGHNESSMAP,
      anisotropy: HAS_ANISOTROPY,
      anisotropyMap: HAS_ANISOTROPYMAP,
      clearcoat: HAS_CLEARCOAT,
      clearcoatMap: HAS_CLEARCOATMAP,
      clearcoatNormalMap: HAS_CLEARCOAT_NORMALMAP,
      clearcoatRoughnessMap: HAS_CLEARCOAT_ROUGHNESSMAP,
      iridescence: HAS_IRIDESCENCE,
      iridescenceMap: HAS_IRIDESCENCEMAP,
      iridescenceThicknessMap: HAS_IRIDESCENCE_THICKNESSMAP,
      sheen: HAS_SHEEN,
      sheenColorMap: HAS_SHEEN_COLORMAP,
      sheenRoughnessMap: HAS_SHEEN_ROUGHNESSMAP,
      specularMap: HAS_SPECULARMAP,
      specularColorMap: HAS_SPECULAR_COLORMAP,
      specularIntensityMap: HAS_SPECULAR_INTENSITYMAP,
      transmission: HAS_TRANSMISSION,
      transmissionMap: HAS_TRANSMISSIONMAP,
      thicknessMap: HAS_THICKNESSMAP,
      gradientMap: HAS_GRADIENTMAP,
      opaque: material.transparent === false && material.blending === NormalBlending,
      alphaMap: HAS_ALPHAMAP,
      alphaTest: HAS_ALPHATEST,
      combine: material.combine,
      //
      mapUv: HAS_MAP && getChannel(material.map.channel),
      aoMapUv: HAS_AOMAP && getChannel(material.aoMap.channel),
      lightMapUv: HAS_LIGHTMAP && getChannel(material.lightMap.channel),
      bumpMapUv: HAS_BUMPMAP && getChannel(material.bumpMap.channel),
      normalMapUv: HAS_NORMALMAP && getChannel(material.normalMap.channel),
      displacementMapUv: HAS_DISPLACEMENTMAP && getChannel(material.displacementMap.channel),
      emissiveMapUv: HAS_EMISSIVEMAP && getChannel(material.emissiveMap.channel),
      metalnessMapUv: HAS_METALNESSMAP && getChannel(material.metalnessMap.channel),
      roughnessMapUv: HAS_ROUGHNESSMAP && getChannel(material.roughnessMap.channel),
      anisotropyMapUv: HAS_ANISOTROPYMAP && getChannel(material.anisotropyMap.channel),
      clearcoatMapUv: HAS_CLEARCOATMAP && getChannel(material.clearcoatMap.channel),
      clearcoatNormalMapUv: HAS_CLEARCOAT_NORMALMAP && getChannel(material.clearcoatNormalMap.channel),
      clearcoatRoughnessMapUv: HAS_CLEARCOAT_ROUGHNESSMAP && getChannel(material.clearcoatRoughnessMap.channel),
      iridescenceMapUv: HAS_IRIDESCENCEMAP && getChannel(material.iridescenceMap.channel),
      iridescenceThicknessMapUv: HAS_IRIDESCENCE_THICKNESSMAP && getChannel(material.iridescenceThicknessMap.channel),
      sheenColorMapUv: HAS_SHEEN_COLORMAP && getChannel(material.sheenColorMap.channel),
      sheenRoughnessMapUv: HAS_SHEEN_ROUGHNESSMAP && getChannel(material.sheenRoughnessMap.channel),
      specularMapUv: HAS_SPECULARMAP && getChannel(material.specularMap.channel),
      specularColorMapUv: HAS_SPECULAR_COLORMAP && getChannel(material.specularColorMap.channel),
      specularIntensityMapUv: HAS_SPECULAR_INTENSITYMAP && getChannel(material.specularIntensityMap.channel),
      transmissionMapUv: HAS_TRANSMISSIONMAP && getChannel(material.transmissionMap.channel),
      thicknessMapUv: HAS_THICKNESSMAP && getChannel(material.thicknessMap.channel),
      alphaMapUv: HAS_ALPHAMAP && getChannel(material.alphaMap.channel),
      //
      vertexTangents: !!geometry.attributes.tangent && (HAS_NORMALMAP || HAS_ANISOTROPY),
      vertexColors: material.vertexColors,
      vertexAlphas: material.vertexColors === true && !!geometry.attributes.color && geometry.attributes.color.itemSize === 4,
      vertexUv1s: HAS_ATTRIBUTE_UV1,
      vertexUv2s: HAS_ATTRIBUTE_UV2,
      vertexUv3s: HAS_ATTRIBUTE_UV3,
      pointsUvs: object.isPoints === true && !!geometry.attributes.uv && (HAS_MAP || HAS_ALPHAMAP),
      fog: !!fog,
      useFog: material.fog === true,
      fogExp2: fog && fog.isFogExp2,
      flatShading: material.flatShading === true,
      sizeAttenuation: material.sizeAttenuation === true,
      logarithmicDepthBuffer,
      skinning: object.isSkinnedMesh === true,
      morphTargets: geometry.morphAttributes.position !== void 0,
      morphNormals: geometry.morphAttributes.normal !== void 0,
      morphColors: geometry.morphAttributes.color !== void 0,
      morphTargetsCount,
      morphTextureStride,
      numDirLights: lights.directional.length,
      numPointLights: lights.point.length,
      numSpotLights: lights.spot.length,
      numSpotLightMaps: lights.spotLightMap.length,
      numRectAreaLights: lights.rectArea.length,
      numHemiLights: lights.hemi.length,
      numDirLightShadows: lights.directionalShadowMap.length,
      numPointLightShadows: lights.pointShadowMap.length,
      numSpotLightShadows: lights.spotShadowMap.length,
      numSpotLightShadowsWithMaps: lights.numSpotLightShadowsWithMaps,
      numClippingPlanes: clipping.numPlanes,
      numClipIntersection: clipping.numIntersection,
      dithering: material.dithering,
      shadowMapEnabled: renderer.shadowMap.enabled && shadows.length > 0,
      shadowMapType: renderer.shadowMap.type,
      toneMapping: material.toneMapped ? renderer.toneMapping : NoToneMapping,
      useLegacyLights: renderer.useLegacyLights,
      premultipliedAlpha: material.premultipliedAlpha,
      doubleSided: material.side === DoubleSide,
      flipSided: material.side === BackSide,
      useDepthPacking: material.depthPacking >= 0,
      depthPacking: material.depthPacking || 0,
      index0AttributeName: material.index0AttributeName,
      extensionDerivatives: HAS_EXTENSIONS && material.extensions.derivatives === true,
      extensionFragDepth: HAS_EXTENSIONS && material.extensions.fragDepth === true,
      extensionDrawBuffers: HAS_EXTENSIONS && material.extensions.drawBuffers === true,
      extensionShaderTextureLOD: HAS_EXTENSIONS && material.extensions.shaderTextureLOD === true,
      rendererExtensionFragDepth: IS_WEBGL2 || extensions.has("EXT_frag_depth"),
      rendererExtensionDrawBuffers: IS_WEBGL2 || extensions.has("WEBGL_draw_buffers"),
      rendererExtensionShaderTextureLod: IS_WEBGL2 || extensions.has("EXT_shader_texture_lod"),
      customProgramCacheKey: material.customProgramCacheKey()
    };
    return parameters;
  }
  function getProgramCacheKey(parameters) {
    const array = [];
    if (parameters.shaderID) {
      array.push(parameters.shaderID);
    } else {
      array.push(parameters.customVertexShaderID);
      array.push(parameters.customFragmentShaderID);
    }
    if (parameters.defines !== void 0) {
      for (const name in parameters.defines) {
        array.push(name);
        array.push(parameters.defines[name]);
      }
    }
    if (parameters.isRawShaderMaterial === false) {
      getProgramCacheKeyParameters(array, parameters);
      getProgramCacheKeyBooleans(array, parameters);
      array.push(renderer.outputColorSpace);
    }
    array.push(parameters.customProgramCacheKey);
    return array.join();
  }
  function getProgramCacheKeyParameters(array, parameters) {
    array.push(parameters.precision);
    array.push(parameters.outputColorSpace);
    array.push(parameters.envMapMode);
    array.push(parameters.envMapCubeUVHeight);
    array.push(parameters.mapUv);
    array.push(parameters.alphaMapUv);
    array.push(parameters.lightMapUv);
    array.push(parameters.aoMapUv);
    array.push(parameters.bumpMapUv);
    array.push(parameters.normalMapUv);
    array.push(parameters.displacementMapUv);
    array.push(parameters.emissiveMapUv);
    array.push(parameters.metalnessMapUv);
    array.push(parameters.roughnessMapUv);
    array.push(parameters.anisotropyMapUv);
    array.push(parameters.clearcoatMapUv);
    array.push(parameters.clearcoatNormalMapUv);
    array.push(parameters.clearcoatRoughnessMapUv);
    array.push(parameters.iridescenceMapUv);
    array.push(parameters.iridescenceThicknessMapUv);
    array.push(parameters.sheenColorMapUv);
    array.push(parameters.sheenRoughnessMapUv);
    array.push(parameters.specularMapUv);
    array.push(parameters.specularColorMapUv);
    array.push(parameters.specularIntensityMapUv);
    array.push(parameters.transmissionMapUv);
    array.push(parameters.thicknessMapUv);
    array.push(parameters.combine);
    array.push(parameters.fogExp2);
    array.push(parameters.sizeAttenuation);
    array.push(parameters.morphTargetsCount);
    array.push(parameters.morphAttributeCount);
    array.push(parameters.numDirLights);
    array.push(parameters.numPointLights);
    array.push(parameters.numSpotLights);
    array.push(parameters.numSpotLightMaps);
    array.push(parameters.numHemiLights);
    array.push(parameters.numRectAreaLights);
    array.push(parameters.numDirLightShadows);
    array.push(parameters.numPointLightShadows);
    array.push(parameters.numSpotLightShadows);
    array.push(parameters.numSpotLightShadowsWithMaps);
    array.push(parameters.shadowMapType);
    array.push(parameters.toneMapping);
    array.push(parameters.numClippingPlanes);
    array.push(parameters.numClipIntersection);
    array.push(parameters.depthPacking);
  }
  function getProgramCacheKeyBooleans(array, parameters) {
    _programLayers.disableAll();
    if (parameters.isWebGL2)
      _programLayers.enable(0);
    if (parameters.supportsVertexTextures)
      _programLayers.enable(1);
    if (parameters.instancing)
      _programLayers.enable(2);
    if (parameters.instancingColor)
      _programLayers.enable(3);
    if (parameters.matcap)
      _programLayers.enable(4);
    if (parameters.envMap)
      _programLayers.enable(5);
    if (parameters.normalMapObjectSpace)
      _programLayers.enable(6);
    if (parameters.normalMapTangentSpace)
      _programLayers.enable(7);
    if (parameters.clearcoat)
      _programLayers.enable(8);
    if (parameters.iridescence)
      _programLayers.enable(9);
    if (parameters.alphaTest)
      _programLayers.enable(10);
    if (parameters.vertexColors)
      _programLayers.enable(11);
    if (parameters.vertexAlphas)
      _programLayers.enable(12);
    if (parameters.vertexUv1s)
      _programLayers.enable(13);
    if (parameters.vertexUv2s)
      _programLayers.enable(14);
    if (parameters.vertexUv3s)
      _programLayers.enable(15);
    if (parameters.vertexTangents)
      _programLayers.enable(16);
    if (parameters.anisotropy)
      _programLayers.enable(17);
    array.push(_programLayers.mask);
    _programLayers.disableAll();
    if (parameters.fog)
      _programLayers.enable(0);
    if (parameters.useFog)
      _programLayers.enable(1);
    if (parameters.flatShading)
      _programLayers.enable(2);
    if (parameters.logarithmicDepthBuffer)
      _programLayers.enable(3);
    if (parameters.skinning)
      _programLayers.enable(4);
    if (parameters.morphTargets)
      _programLayers.enable(5);
    if (parameters.morphNormals)
      _programLayers.enable(6);
    if (parameters.morphColors)
      _programLayers.enable(7);
    if (parameters.premultipliedAlpha)
      _programLayers.enable(8);
    if (parameters.shadowMapEnabled)
      _programLayers.enable(9);
    if (parameters.useLegacyLights)
      _programLayers.enable(10);
    if (parameters.doubleSided)
      _programLayers.enable(11);
    if (parameters.flipSided)
      _programLayers.enable(12);
    if (parameters.useDepthPacking)
      _programLayers.enable(13);
    if (parameters.dithering)
      _programLayers.enable(14);
    if (parameters.transmission)
      _programLayers.enable(15);
    if (parameters.sheen)
      _programLayers.enable(16);
    if (parameters.opaque)
      _programLayers.enable(17);
    if (parameters.pointsUvs)
      _programLayers.enable(18);
    array.push(_programLayers.mask);
  }
  function getUniforms(material) {
    const shaderID = shaderIDs[material.type];
    let uniforms;
    if (shaderID) {
      const shader = ShaderLib[shaderID];
      uniforms = UniformsUtils.clone(shader.uniforms);
    } else {
      uniforms = material.uniforms;
    }
    return uniforms;
  }
  function acquireProgram(parameters, cacheKey) {
    let program;
    for (let p2 = 0, pl = programs.length; p2 < pl; p2++) {
      const preexistingProgram = programs[p2];
      if (preexistingProgram.cacheKey === cacheKey) {
        program = preexistingProgram;
        ++program.usedTimes;
        break;
      }
    }
    if (program === void 0) {
      program = new WebGLProgram(renderer, cacheKey, parameters, bindingStates);
      programs.push(program);
    }
    return program;
  }
  function releaseProgram(program) {
    if (--program.usedTimes === 0) {
      const i2 = programs.indexOf(program);
      programs[i2] = programs[programs.length - 1];
      programs.pop();
      program.destroy();
    }
  }
  function releaseShaderCache(material) {
    _customShaders.remove(material);
  }
  function dispose() {
    _customShaders.dispose();
  }
  return {
    getParameters,
    getProgramCacheKey,
    getUniforms,
    acquireProgram,
    releaseProgram,
    releaseShaderCache,
    // Exposed for resource monitoring & error feedback via renderer.info:
    programs,
    dispose
  };
}
function WebGLProperties() {
  let properties = /* @__PURE__ */ new WeakMap();
  function get(object) {
    let map = properties.get(object);
    if (map === void 0) {
      map = {};
      properties.set(object, map);
    }
    return map;
  }
  function remove(object) {
    properties.delete(object);
  }
  function update(object, key, value) {
    properties.get(object)[key] = value;
  }
  function dispose() {
    properties = /* @__PURE__ */ new WeakMap();
  }
  return {
    get,
    remove,
    update,
    dispose
  };
}
function painterSortStable(a2, b2) {
  if (a2.groupOrder !== b2.groupOrder) {
    return a2.groupOrder - b2.groupOrder;
  } else if (a2.renderOrder !== b2.renderOrder) {
    return a2.renderOrder - b2.renderOrder;
  } else if (a2.material.id !== b2.material.id) {
    return a2.material.id - b2.material.id;
  } else if (a2.z !== b2.z) {
    return a2.z - b2.z;
  } else {
    return a2.id - b2.id;
  }
}
function reversePainterSortStable(a2, b2) {
  if (a2.groupOrder !== b2.groupOrder) {
    return a2.groupOrder - b2.groupOrder;
  } else if (a2.renderOrder !== b2.renderOrder) {
    return a2.renderOrder - b2.renderOrder;
  } else if (a2.z !== b2.z) {
    return b2.z - a2.z;
  } else {
    return a2.id - b2.id;
  }
}
function WebGLRenderList() {
  const renderItems = [];
  let renderItemsIndex = 0;
  const opaque = [];
  const transmissive = [];
  const transparent = [];
  function init() {
    renderItemsIndex = 0;
    opaque.length = 0;
    transmissive.length = 0;
    transparent.length = 0;
  }
  function getNextRenderItem(object, geometry, material, groupOrder, z, group) {
    let renderItem = renderItems[renderItemsIndex];
    if (renderItem === void 0) {
      renderItem = {
        id: object.id,
        object,
        geometry,
        material,
        groupOrder,
        renderOrder: object.renderOrder,
        z,
        group
      };
      renderItems[renderItemsIndex] = renderItem;
    } else {
      renderItem.id = object.id;
      renderItem.object = object;
      renderItem.geometry = geometry;
      renderItem.material = material;
      renderItem.groupOrder = groupOrder;
      renderItem.renderOrder = object.renderOrder;
      renderItem.z = z;
      renderItem.group = group;
    }
    renderItemsIndex++;
    return renderItem;
  }
  function push(object, geometry, material, groupOrder, z, group) {
    const renderItem = getNextRenderItem(object, geometry, material, groupOrder, z, group);
    if (material.transmission > 0) {
      transmissive.push(renderItem);
    } else if (material.transparent === true) {
      transparent.push(renderItem);
    } else {
      opaque.push(renderItem);
    }
  }
  function unshift(object, geometry, material, groupOrder, z, group) {
    const renderItem = getNextRenderItem(object, geometry, material, groupOrder, z, group);
    if (material.transmission > 0) {
      transmissive.unshift(renderItem);
    } else if (material.transparent === true) {
      transparent.unshift(renderItem);
    } else {
      opaque.unshift(renderItem);
    }
  }
  function sort(customOpaqueSort, customTransparentSort) {
    if (opaque.length > 1) opaque.sort(customOpaqueSort || painterSortStable);
    if (transmissive.length > 1) transmissive.sort(customTransparentSort || reversePainterSortStable);
    if (transparent.length > 1) transparent.sort(customTransparentSort || reversePainterSortStable);
  }
  function finish() {
    for (let i2 = renderItemsIndex, il = renderItems.length; i2 < il; i2++) {
      const renderItem = renderItems[i2];
      if (renderItem.id === null) break;
      renderItem.id = null;
      renderItem.object = null;
      renderItem.geometry = null;
      renderItem.material = null;
      renderItem.group = null;
    }
  }
  return {
    opaque,
    transmissive,
    transparent,
    init,
    push,
    unshift,
    finish,
    sort
  };
}
function WebGLRenderLists() {
  let lists = /* @__PURE__ */ new WeakMap();
  function get(scene, renderCallDepth) {
    const listArray = lists.get(scene);
    let list;
    if (listArray === void 0) {
      list = new WebGLRenderList();
      lists.set(scene, [list]);
    } else {
      if (renderCallDepth >= listArray.length) {
        list = new WebGLRenderList();
        listArray.push(list);
      } else {
        list = listArray[renderCallDepth];
      }
    }
    return list;
  }
  function dispose() {
    lists = /* @__PURE__ */ new WeakMap();
  }
  return {
    get,
    dispose
  };
}
function UniformsCache() {
  const lights = {};
  return {
    get: function(light) {
      if (lights[light.id] !== void 0) {
        return lights[light.id];
      }
      let uniforms;
      switch (light.type) {
        case "DirectionalLight":
          uniforms = {
            direction: new Vector3(),
            color: new Color()
          };
          break;
        case "SpotLight":
          uniforms = {
            position: new Vector3(),
            direction: new Vector3(),
            color: new Color(),
            distance: 0,
            coneCos: 0,
            penumbraCos: 0,
            decay: 0
          };
          break;
        case "PointLight":
          uniforms = {
            position: new Vector3(),
            color: new Color(),
            distance: 0,
            decay: 0
          };
          break;
        case "HemisphereLight":
          uniforms = {
            direction: new Vector3(),
            skyColor: new Color(),
            groundColor: new Color()
          };
          break;
        case "RectAreaLight":
          uniforms = {
            color: new Color(),
            position: new Vector3(),
            halfWidth: new Vector3(),
            halfHeight: new Vector3()
          };
          break;
      }
      lights[light.id] = uniforms;
      return uniforms;
    }
  };
}
function ShadowUniformsCache() {
  const lights = {};
  return {
    get: function(light) {
      if (lights[light.id] !== void 0) {
        return lights[light.id];
      }
      let uniforms;
      switch (light.type) {
        case "DirectionalLight":
          uniforms = {
            shadowBias: 0,
            shadowNormalBias: 0,
            shadowRadius: 1,
            shadowMapSize: new Vector2()
          };
          break;
        case "SpotLight":
          uniforms = {
            shadowBias: 0,
            shadowNormalBias: 0,
            shadowRadius: 1,
            shadowMapSize: new Vector2()
          };
          break;
        case "PointLight":
          uniforms = {
            shadowBias: 0,
            shadowNormalBias: 0,
            shadowRadius: 1,
            shadowMapSize: new Vector2(),
            shadowCameraNear: 1,
            shadowCameraFar: 1e3
          };
          break;
      }
      lights[light.id] = uniforms;
      return uniforms;
    }
  };
}
var nextVersion = 0;
function shadowCastingAndTexturingLightsFirst(lightA, lightB) {
  return (lightB.castShadow ? 2 : 0) - (lightA.castShadow ? 2 : 0) + (lightB.map ? 1 : 0) - (lightA.map ? 1 : 0);
}
function WebGLLights(extensions, capabilities2) {
  const cache = new UniformsCache();
  const shadowCache = ShadowUniformsCache();
  const state = {
    version: 0,
    hash: {
      directionalLength: -1,
      pointLength: -1,
      spotLength: -1,
      rectAreaLength: -1,
      hemiLength: -1,
      numDirectionalShadows: -1,
      numPointShadows: -1,
      numSpotShadows: -1,
      numSpotMaps: -1
    },
    ambient: [0, 0, 0],
    probe: [],
    directional: [],
    directionalShadow: [],
    directionalShadowMap: [],
    directionalShadowMatrix: [],
    spot: [],
    spotLightMap: [],
    spotShadow: [],
    spotShadowMap: [],
    spotLightMatrix: [],
    rectArea: [],
    rectAreaLTC1: null,
    rectAreaLTC2: null,
    point: [],
    pointShadow: [],
    pointShadowMap: [],
    pointShadowMatrix: [],
    hemi: [],
    numSpotLightShadowsWithMaps: 0
  };
  for (let i2 = 0; i2 < 9; i2++) state.probe.push(new Vector3());
  const vector3 = new Vector3();
  const matrix42 = new Matrix4();
  const matrix422 = new Matrix4();
  function setup(lights, useLegacyLights) {
    let r2 = 0, g2 = 0, b2 = 0;
    for (let i2 = 0; i2 < 9; i2++) state.probe[i2].set(0, 0, 0);
    let directionalLength = 0;
    let pointLength = 0;
    let spotLength = 0;
    let rectAreaLength = 0;
    let hemiLength = 0;
    let numDirectionalShadows = 0;
    let numPointShadows = 0;
    let numSpotShadows = 0;
    let numSpotMaps = 0;
    let numSpotShadowsWithMaps = 0;
    lights.sort(shadowCastingAndTexturingLightsFirst);
    const scaleFactor = useLegacyLights === true ? Math.PI : 1;
    for (let i2 = 0, l2 = lights.length; i2 < l2; i2++) {
      const light = lights[i2];
      const color = light.color;
      const intensity = light.intensity;
      const distance = light.distance;
      const shadowMap = light.shadow && light.shadow.map ? light.shadow.map.texture : null;
      if (light.isAmbientLight) {
        r2 += color.r * intensity * scaleFactor;
        g2 += color.g * intensity * scaleFactor;
        b2 += color.b * intensity * scaleFactor;
      } else if (light.isLightProbe) {
        for (let j = 0; j < 9; j++) {
          state.probe[j].addScaledVector(light.sh.coefficients[j], intensity);
        }
      } else if (light.isDirectionalLight) {
        const uniforms = cache.get(light);
        uniforms.color.copy(light.color).multiplyScalar(light.intensity * scaleFactor);
        if (light.castShadow) {
          const shadow = light.shadow;
          const shadowUniforms = shadowCache.get(light);
          shadowUniforms.shadowBias = shadow.bias;
          shadowUniforms.shadowNormalBias = shadow.normalBias;
          shadowUniforms.shadowRadius = shadow.radius;
          shadowUniforms.shadowMapSize = shadow.mapSize;
          state.directionalShadow[directionalLength] = shadowUniforms;
          state.directionalShadowMap[directionalLength] = shadowMap;
          state.directionalShadowMatrix[directionalLength] = light.shadow.matrix;
          numDirectionalShadows++;
        }
        state.directional[directionalLength] = uniforms;
        directionalLength++;
      } else if (light.isSpotLight) {
        const uniforms = cache.get(light);
        uniforms.position.setFromMatrixPosition(light.matrixWorld);
        uniforms.color.copy(color).multiplyScalar(intensity * scaleFactor);
        uniforms.distance = distance;
        uniforms.coneCos = Math.cos(light.angle);
        uniforms.penumbraCos = Math.cos(light.angle * (1 - light.penumbra));
        uniforms.decay = light.decay;
        state.spot[spotLength] = uniforms;
        const shadow = light.shadow;
        if (light.map) {
          state.spotLightMap[numSpotMaps] = light.map;
          numSpotMaps++;
          shadow.updateMatrices(light);
          if (light.castShadow) numSpotShadowsWithMaps++;
        }
        state.spotLightMatrix[spotLength] = shadow.matrix;
        if (light.castShadow) {
          const shadowUniforms = shadowCache.get(light);
          shadowUniforms.shadowBias = shadow.bias;
          shadowUniforms.shadowNormalBias = shadow.normalBias;
          shadowUniforms.shadowRadius = shadow.radius;
          shadowUniforms.shadowMapSize = shadow.mapSize;
          state.spotShadow[spotLength] = shadowUniforms;
          state.spotShadowMap[spotLength] = shadowMap;
          numSpotShadows++;
        }
        spotLength++;
      } else if (light.isRectAreaLight) {
        const uniforms = cache.get(light);
        uniforms.color.copy(color).multiplyScalar(intensity);
        uniforms.halfWidth.set(light.width * 0.5, 0, 0);
        uniforms.halfHeight.set(0, light.height * 0.5, 0);
        state.rectArea[rectAreaLength] = uniforms;
        rectAreaLength++;
      } else if (light.isPointLight) {
        const uniforms = cache.get(light);
        uniforms.color.copy(light.color).multiplyScalar(light.intensity * scaleFactor);
        uniforms.distance = light.distance;
        uniforms.decay = light.decay;
        if (light.castShadow) {
          const shadow = light.shadow;
          const shadowUniforms = shadowCache.get(light);
          shadowUniforms.shadowBias = shadow.bias;
          shadowUniforms.shadowNormalBias = shadow.normalBias;
          shadowUniforms.shadowRadius = shadow.radius;
          shadowUniforms.shadowMapSize = shadow.mapSize;
          shadowUniforms.shadowCameraNear = shadow.camera.near;
          shadowUniforms.shadowCameraFar = shadow.camera.far;
          state.pointShadow[pointLength] = shadowUniforms;
          state.pointShadowMap[pointLength] = shadowMap;
          state.pointShadowMatrix[pointLength] = light.shadow.matrix;
          numPointShadows++;
        }
        state.point[pointLength] = uniforms;
        pointLength++;
      } else if (light.isHemisphereLight) {
        const uniforms = cache.get(light);
        uniforms.skyColor.copy(light.color).multiplyScalar(intensity * scaleFactor);
        uniforms.groundColor.copy(light.groundColor).multiplyScalar(intensity * scaleFactor);
        state.hemi[hemiLength] = uniforms;
        hemiLength++;
      }
    }
    if (rectAreaLength > 0) {
      if (capabilities2.isWebGL2) {
        state.rectAreaLTC1 = UniformsLib.LTC_FLOAT_1;
        state.rectAreaLTC2 = UniformsLib.LTC_FLOAT_2;
      } else {
        if (extensions.has("OES_texture_float_linear") === true) {
          state.rectAreaLTC1 = UniformsLib.LTC_FLOAT_1;
          state.rectAreaLTC2 = UniformsLib.LTC_FLOAT_2;
        } else if (extensions.has("OES_texture_half_float_linear") === true) {
          state.rectAreaLTC1 = UniformsLib.LTC_HALF_1;
          state.rectAreaLTC2 = UniformsLib.LTC_HALF_2;
        } else {
          console.error("THREE.WebGLRenderer: Unable to use RectAreaLight. Missing WebGL extensions.");
        }
      }
    }
    state.ambient[0] = r2;
    state.ambient[1] = g2;
    state.ambient[2] = b2;
    const hash = state.hash;
    if (hash.directionalLength !== directionalLength || hash.pointLength !== pointLength || hash.spotLength !== spotLength || hash.rectAreaLength !== rectAreaLength || hash.hemiLength !== hemiLength || hash.numDirectionalShadows !== numDirectionalShadows || hash.numPointShadows !== numPointShadows || hash.numSpotShadows !== numSpotShadows || hash.numSpotMaps !== numSpotMaps) {
      state.directional.length = directionalLength;
      state.spot.length = spotLength;
      state.rectArea.length = rectAreaLength;
      state.point.length = pointLength;
      state.hemi.length = hemiLength;
      state.directionalShadow.length = numDirectionalShadows;
      state.directionalShadowMap.length = numDirectionalShadows;
      state.pointShadow.length = numPointShadows;
      state.pointShadowMap.length = numPointShadows;
      state.spotShadow.length = numSpotShadows;
      state.spotShadowMap.length = numSpotShadows;
      state.directionalShadowMatrix.length = numDirectionalShadows;
      state.pointShadowMatrix.length = numPointShadows;
      state.spotLightMatrix.length = numSpotShadows + numSpotMaps - numSpotShadowsWithMaps;
      state.spotLightMap.length = numSpotMaps;
      state.numSpotLightShadowsWithMaps = numSpotShadowsWithMaps;
      hash.directionalLength = directionalLength;
      hash.pointLength = pointLength;
      hash.spotLength = spotLength;
      hash.rectAreaLength = rectAreaLength;
      hash.hemiLength = hemiLength;
      hash.numDirectionalShadows = numDirectionalShadows;
      hash.numPointShadows = numPointShadows;
      hash.numSpotShadows = numSpotShadows;
      hash.numSpotMaps = numSpotMaps;
      state.version = nextVersion++;
    }
  }
  function setupView(lights, camera) {
    let directionalLength = 0;
    let pointLength = 0;
    let spotLength = 0;
    let rectAreaLength = 0;
    let hemiLength = 0;
    const viewMatrix = camera.matrixWorldInverse;
    for (let i2 = 0, l2 = lights.length; i2 < l2; i2++) {
      const light = lights[i2];
      if (light.isDirectionalLight) {
        const uniforms = state.directional[directionalLength];
        uniforms.direction.setFromMatrixPosition(light.matrixWorld);
        vector3.setFromMatrixPosition(light.target.matrixWorld);
        uniforms.direction.sub(vector3);
        uniforms.direction.transformDirection(viewMatrix);
        directionalLength++;
      } else if (light.isSpotLight) {
        const uniforms = state.spot[spotLength];
        uniforms.position.setFromMatrixPosition(light.matrixWorld);
        uniforms.position.applyMatrix4(viewMatrix);
        uniforms.direction.setFromMatrixPosition(light.matrixWorld);
        vector3.setFromMatrixPosition(light.target.matrixWorld);
        uniforms.direction.sub(vector3);
        uniforms.direction.transformDirection(viewMatrix);
        spotLength++;
      } else if (light.isRectAreaLight) {
        const uniforms = state.rectArea[rectAreaLength];
        uniforms.position.setFromMatrixPosition(light.matrixWorld);
        uniforms.position.applyMatrix4(viewMatrix);
        matrix422.identity();
        matrix42.copy(light.matrixWorld);
        matrix42.premultiply(viewMatrix);
        matrix422.extractRotation(matrix42);
        uniforms.halfWidth.set(light.width * 0.5, 0, 0);
        uniforms.halfHeight.set(0, light.height * 0.5, 0);
        uniforms.halfWidth.applyMatrix4(matrix422);
        uniforms.halfHeight.applyMatrix4(matrix422);
        rectAreaLength++;
      } else if (light.isPointLight) {
        const uniforms = state.point[pointLength];
        uniforms.position.setFromMatrixPosition(light.matrixWorld);
        uniforms.position.applyMatrix4(viewMatrix);
        pointLength++;
      } else if (light.isHemisphereLight) {
        const uniforms = state.hemi[hemiLength];
        uniforms.direction.setFromMatrixPosition(light.matrixWorld);
        uniforms.direction.transformDirection(viewMatrix);
        hemiLength++;
      }
    }
  }
  return {
    setup,
    setupView,
    state
  };
}
function WebGLRenderState(extensions, capabilities2) {
  const lights = new WebGLLights(extensions, capabilities2);
  const lightsArray = [];
  const shadowsArray = [];
  function init() {
    lightsArray.length = 0;
    shadowsArray.length = 0;
  }
  function pushLight(light) {
    lightsArray.push(light);
  }
  function pushShadow(shadowLight) {
    shadowsArray.push(shadowLight);
  }
  function setupLights(useLegacyLights) {
    lights.setup(lightsArray, useLegacyLights);
  }
  function setupLightsView(camera) {
    lights.setupView(lightsArray, camera);
  }
  const state = {
    lightsArray,
    shadowsArray,
    lights
  };
  return {
    init,
    state,
    setupLights,
    setupLightsView,
    pushLight,
    pushShadow
  };
}
function WebGLRenderStates(extensions, capabilities2) {
  let renderStates = /* @__PURE__ */ new WeakMap();
  function get(scene, renderCallDepth = 0) {
    const renderStateArray = renderStates.get(scene);
    let renderState;
    if (renderStateArray === void 0) {
      renderState = new WebGLRenderState(extensions, capabilities2);
      renderStates.set(scene, [renderState]);
    } else {
      if (renderCallDepth >= renderStateArray.length) {
        renderState = new WebGLRenderState(extensions, capabilities2);
        renderStateArray.push(renderState);
      } else {
        renderState = renderStateArray[renderCallDepth];
      }
    }
    return renderState;
  }
  function dispose() {
    renderStates = /* @__PURE__ */ new WeakMap();
  }
  return {
    get,
    dispose
  };
}
var MeshDepthMaterial = class extends Material {
  constructor(parameters) {
    super();
    this.isMeshDepthMaterial = true;
    this.type = "MeshDepthMaterial";
    this.depthPacking = BasicDepthPacking;
    this.map = null;
    this.alphaMap = null;
    this.displacementMap = null;
    this.displacementScale = 1;
    this.displacementBias = 0;
    this.wireframe = false;
    this.wireframeLinewidth = 1;
    this.setValues(parameters);
  }
  copy(source) {
    super.copy(source);
    this.depthPacking = source.depthPacking;
    this.map = source.map;
    this.alphaMap = source.alphaMap;
    this.displacementMap = source.displacementMap;
    this.displacementScale = source.displacementScale;
    this.displacementBias = source.displacementBias;
    this.wireframe = source.wireframe;
    this.wireframeLinewidth = source.wireframeLinewidth;
    return this;
  }
};
var MeshDistanceMaterial = class extends Material {
  constructor(parameters) {
    super();
    this.isMeshDistanceMaterial = true;
    this.type = "MeshDistanceMaterial";
    this.map = null;
    this.alphaMap = null;
    this.displacementMap = null;
    this.displacementScale = 1;
    this.displacementBias = 0;
    this.setValues(parameters);
  }
  copy(source) {
    super.copy(source);
    this.map = source.map;
    this.alphaMap = source.alphaMap;
    this.displacementMap = source.displacementMap;
    this.displacementScale = source.displacementScale;
    this.displacementBias = source.displacementBias;
    return this;
  }
};
var vertex = "void main() {\n	gl_Position = vec4( position, 1.0 );\n}";
var fragment = "uniform sampler2D shadow_pass;\nuniform vec2 resolution;\nuniform float radius;\n#include <packing>\nvoid main() {\n	const float samples = float( VSM_SAMPLES );\n	float mean = 0.0;\n	float squared_mean = 0.0;\n	float uvStride = samples <= 1.0 ? 0.0 : 2.0 / ( samples - 1.0 );\n	float uvStart = samples <= 1.0 ? 0.0 : - 1.0;\n	for ( float i = 0.0; i < samples; i ++ ) {\n		float uvOffset = uvStart + i * uvStride;\n		#ifdef HORIZONTAL_PASS\n			vec2 distribution = unpackRGBATo2Half( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( uvOffset, 0.0 ) * radius ) / resolution ) );\n			mean += distribution.x;\n			squared_mean += distribution.y * distribution.y + distribution.x * distribution.x;\n		#else\n			float depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( 0.0, uvOffset ) * radius ) / resolution ) );\n			mean += depth;\n			squared_mean += depth * depth;\n		#endif\n	}\n	mean = mean / samples;\n	squared_mean = squared_mean / samples;\n	float std_dev = sqrt( squared_mean - mean * mean );\n	gl_FragColor = pack2HalfToRGBA( vec2( mean, std_dev ) );\n}";
function WebGLShadowMap(_renderer, _objects, _capabilities) {
  let _frustum = new Frustum();
  const _shadowMapSize = new Vector2(), _viewportSize = new Vector2(), _viewport2 = new Vector4(), _depthMaterial = new MeshDepthMaterial({ depthPacking: RGBADepthPacking }), _distanceMaterial = new MeshDistanceMaterial(), _materialCache = {}, _maxTextureSize = _capabilities.maxTextureSize;
  const shadowSide = { [FrontSide]: BackSide, [BackSide]: FrontSide, [DoubleSide]: DoubleSide };
  const shadowMaterialVertical = new ShaderMaterial({
    defines: {
      VSM_SAMPLES: 8
    },
    uniforms: {
      shadow_pass: { value: null },
      resolution: { value: new Vector2() },
      radius: { value: 4 }
    },
    vertexShader: vertex,
    fragmentShader: fragment
  });
  const shadowMaterialHorizontal = shadowMaterialVertical.clone();
  shadowMaterialHorizontal.defines.HORIZONTAL_PASS = 1;
  const fullScreenTri = new BufferGeometry();
  fullScreenTri.setAttribute(
    "position",
    new BufferAttribute(
      new Float32Array([-1, -1, 0.5, 3, -1, 0.5, -1, 3, 0.5]),
      3
    )
  );
  const fullScreenMesh = new Mesh(fullScreenTri, shadowMaterialVertical);
  const scope = this;
  this.enabled = false;
  this.autoUpdate = true;
  this.needsUpdate = false;
  this.type = PCFShadowMap;
  let _previousType = this.type;
  this.render = function(lights, scene, camera) {
    if (scope.enabled === false) return;
    if (scope.autoUpdate === false && scope.needsUpdate === false) return;
    if (lights.length === 0) return;
    const currentRenderTarget = _renderer.getRenderTarget();
    const activeCubeFace = _renderer.getActiveCubeFace();
    const activeMipmapLevel = _renderer.getActiveMipmapLevel();
    const _state = _renderer.state;
    _state.setBlending(NoBlending);
    _state.buffers.color.setClear(1, 1, 1, 1);
    _state.buffers.depth.setTest(true);
    _state.setScissorTest(false);
    const toVSM = _previousType !== VSMShadowMap && this.type === VSMShadowMap;
    const fromVSM = _previousType === VSMShadowMap && this.type !== VSMShadowMap;
    for (let i2 = 0, il = lights.length; i2 < il; i2++) {
      const light = lights[i2];
      const shadow = light.shadow;
      if (shadow === void 0) {
        console.warn("THREE.WebGLShadowMap:", light, "has no shadow.");
        continue;
      }
      if (shadow.autoUpdate === false && shadow.needsUpdate === false) continue;
      _shadowMapSize.copy(shadow.mapSize);
      const shadowFrameExtents = shadow.getFrameExtents();
      _shadowMapSize.multiply(shadowFrameExtents);
      _viewportSize.copy(shadow.mapSize);
      if (_shadowMapSize.x > _maxTextureSize || _shadowMapSize.y > _maxTextureSize) {
        if (_shadowMapSize.x > _maxTextureSize) {
          _viewportSize.x = Math.floor(_maxTextureSize / shadowFrameExtents.x);
          _shadowMapSize.x = _viewportSize.x * shadowFrameExtents.x;
          shadow.mapSize.x = _viewportSize.x;
        }
        if (_shadowMapSize.y > _maxTextureSize) {
          _viewportSize.y = Math.floor(_maxTextureSize / shadowFrameExtents.y);
          _shadowMapSize.y = _viewportSize.y * shadowFrameExtents.y;
          shadow.mapSize.y = _viewportSize.y;
        }
      }
      if (shadow.map === null || toVSM === true || fromVSM === true) {
        const pars = this.type !== VSMShadowMap ? { minFilter: NearestFilter, magFilter: NearestFilter } : {};
        if (shadow.map !== null) {
          shadow.map.dispose();
        }
        shadow.map = new WebGLRenderTarget(_shadowMapSize.x, _shadowMapSize.y, pars);
        shadow.map.texture.name = light.name + ".shadowMap";
        shadow.camera.updateProjectionMatrix();
      }
      _renderer.setRenderTarget(shadow.map);
      _renderer.clear();
      const viewportCount = shadow.getViewportCount();
      for (let vp = 0; vp < viewportCount; vp++) {
        const viewport = shadow.getViewport(vp);
        _viewport2.set(
          _viewportSize.x * viewport.x,
          _viewportSize.y * viewport.y,
          _viewportSize.x * viewport.z,
          _viewportSize.y * viewport.w
        );
        _state.viewport(_viewport2);
        shadow.updateMatrices(light, vp);
        _frustum = shadow.getFrustum();
        renderObject(scene, camera, shadow.camera, light, this.type);
      }
      if (shadow.isPointLightShadow !== true && this.type === VSMShadowMap) {
        VSMPass(shadow, camera);
      }
      shadow.needsUpdate = false;
    }
    _previousType = this.type;
    scope.needsUpdate = false;
    _renderer.setRenderTarget(currentRenderTarget, activeCubeFace, activeMipmapLevel);
  };
  function VSMPass(shadow, camera) {
    const geometry = _objects.update(fullScreenMesh);
    if (shadowMaterialVertical.defines.VSM_SAMPLES !== shadow.blurSamples) {
      shadowMaterialVertical.defines.VSM_SAMPLES = shadow.blurSamples;
      shadowMaterialHorizontal.defines.VSM_SAMPLES = shadow.blurSamples;
      shadowMaterialVertical.needsUpdate = true;
      shadowMaterialHorizontal.needsUpdate = true;
    }
    if (shadow.mapPass === null) {
      shadow.mapPass = new WebGLRenderTarget(_shadowMapSize.x, _shadowMapSize.y);
    }
    shadowMaterialVertical.uniforms.shadow_pass.value = shadow.map.texture;
    shadowMaterialVertical.uniforms.resolution.value = shadow.mapSize;
    shadowMaterialVertical.uniforms.radius.value = shadow.radius;
    _renderer.setRenderTarget(shadow.mapPass);
    _renderer.clear();
    _renderer.renderBufferDirect(camera, null, geometry, shadowMaterialVertical, fullScreenMesh, null);
    shadowMaterialHorizontal.uniforms.shadow_pass.value = shadow.mapPass.texture;
    shadowMaterialHorizontal.uniforms.resolution.value = shadow.mapSize;
    shadowMaterialHorizontal.uniforms.radius.value = shadow.radius;
    _renderer.setRenderTarget(shadow.map);
    _renderer.clear();
    _renderer.renderBufferDirect(camera, null, geometry, shadowMaterialHorizontal, fullScreenMesh, null);
  }
  function getDepthMaterial(object, material, light, type) {
    let result = null;
    const customMaterial = light.isPointLight === true ? object.customDistanceMaterial : object.customDepthMaterial;
    if (customMaterial !== void 0) {
      result = customMaterial;
    } else {
      result = light.isPointLight === true ? _distanceMaterial : _depthMaterial;
      if (_renderer.localClippingEnabled && material.clipShadows === true && Array.isArray(material.clippingPlanes) && material.clippingPlanes.length !== 0 || material.displacementMap && material.displacementScale !== 0 || material.alphaMap && material.alphaTest > 0 || material.map && material.alphaTest > 0) {
        const keyA = result.uuid, keyB = material.uuid;
        let materialsForVariant = _materialCache[keyA];
        if (materialsForVariant === void 0) {
          materialsForVariant = {};
          _materialCache[keyA] = materialsForVariant;
        }
        let cachedMaterial = materialsForVariant[keyB];
        if (cachedMaterial === void 0) {
          cachedMaterial = result.clone();
          materialsForVariant[keyB] = cachedMaterial;
        }
        result = cachedMaterial;
      }
    }
    result.visible = material.visible;
    result.wireframe = material.wireframe;
    if (type === VSMShadowMap) {
      result.side = material.shadowSide !== null ? material.shadowSide : material.side;
    } else {
      result.side = material.shadowSide !== null ? material.shadowSide : shadowSide[material.side];
    }
    result.alphaMap = material.alphaMap;
    result.alphaTest = material.alphaTest;
    result.map = material.map;
    result.clipShadows = material.clipShadows;
    result.clippingPlanes = material.clippingPlanes;
    result.clipIntersection = material.clipIntersection;
    result.displacementMap = material.displacementMap;
    result.displacementScale = material.displacementScale;
    result.displacementBias = material.displacementBias;
    result.wireframeLinewidth = material.wireframeLinewidth;
    result.linewidth = material.linewidth;
    if (light.isPointLight === true && result.isMeshDistanceMaterial === true) {
      const materialProperties = _renderer.properties.get(result);
      materialProperties.light = light;
    }
    return result;
  }
  function renderObject(object, camera, shadowCamera, light, type) {
    if (object.visible === false) return;
    const visible = object.layers.test(camera.layers);
    if (visible && (object.isMesh || object.isLine || object.isPoints)) {
      if ((object.castShadow || object.receiveShadow && type === VSMShadowMap) && (!object.frustumCulled || _frustum.intersectsObject(object))) {
        object.modelViewMatrix.multiplyMatrices(shadowCamera.matrixWorldInverse, object.matrixWorld);
        const geometry = _objects.update(object);
        const material = object.material;
        if (Array.isArray(material)) {
          const groups2 = geometry.groups;
          for (let k2 = 0, kl = groups2.length; k2 < kl; k2++) {
            const group = groups2[k2];
            const groupMaterial = material[group.materialIndex];
            if (groupMaterial && groupMaterial.visible) {
              const depthMaterial = getDepthMaterial(object, groupMaterial, light, type);
              _renderer.renderBufferDirect(shadowCamera, null, geometry, depthMaterial, object, group);
            }
          }
        } else if (material.visible) {
          const depthMaterial = getDepthMaterial(object, material, light, type);
          _renderer.renderBufferDirect(shadowCamera, null, geometry, depthMaterial, object, null);
        }
      }
    }
    const children = object.children;
    for (let i2 = 0, l2 = children.length; i2 < l2; i2++) {
      renderObject(children[i2], camera, shadowCamera, light, type);
    }
  }
}
function WebGLState(gl, extensions, capabilities2) {
  const isWebGL2 = capabilities2.isWebGL2;
  function ColorBuffer() {
    let locked = false;
    const color = new Vector4();
    let currentColorMask = null;
    const currentColorClear = new Vector4(0, 0, 0, 0);
    return {
      setMask: function(colorMask) {
        if (currentColorMask !== colorMask && !locked) {
          gl.colorMask(colorMask, colorMask, colorMask, colorMask);
          currentColorMask = colorMask;
        }
      },
      setLocked: function(lock) {
        locked = lock;
      },
      setClear: function(r2, g2, b2, a2, premultipliedAlpha) {
        if (premultipliedAlpha === true) {
          r2 *= a2;
          g2 *= a2;
          b2 *= a2;
        }
        color.set(r2, g2, b2, a2);
        if (currentColorClear.equals(color) === false) {
          gl.clearColor(r2, g2, b2, a2);
          currentColorClear.copy(color);
        }
      },
      reset: function() {
        locked = false;
        currentColorMask = null;
        currentColorClear.set(-1, 0, 0, 0);
      }
    };
  }
  function DepthBuffer() {
    let locked = false;
    let currentDepthMask = null;
    let currentDepthFunc = null;
    let currentDepthClear = null;
    return {
      setTest: function(depthTest) {
        if (depthTest) {
          enable(gl.DEPTH_TEST);
        } else {
          disable(gl.DEPTH_TEST);
        }
      },
      setMask: function(depthMask) {
        if (currentDepthMask !== depthMask && !locked) {
          gl.depthMask(depthMask);
          currentDepthMask = depthMask;
        }
      },
      setFunc: function(depthFunc) {
        if (currentDepthFunc !== depthFunc) {
          switch (depthFunc) {
            case NeverDepth:
              gl.depthFunc(gl.NEVER);
              break;
            case AlwaysDepth:
              gl.depthFunc(gl.ALWAYS);
              break;
            case LessDepth:
              gl.depthFunc(gl.LESS);
              break;
            case LessEqualDepth:
              gl.depthFunc(gl.LEQUAL);
              break;
            case EqualDepth:
              gl.depthFunc(gl.EQUAL);
              break;
            case GreaterEqualDepth:
              gl.depthFunc(gl.GEQUAL);
              break;
            case GreaterDepth:
              gl.depthFunc(gl.GREATER);
              break;
            case NotEqualDepth:
              gl.depthFunc(gl.NOTEQUAL);
              break;
            default:
              gl.depthFunc(gl.LEQUAL);
          }
          currentDepthFunc = depthFunc;
        }
      },
      setLocked: function(lock) {
        locked = lock;
      },
      setClear: function(depth) {
        if (currentDepthClear !== depth) {
          gl.clearDepth(depth);
          currentDepthClear = depth;
        }
      },
      reset: function() {
        locked = false;
        currentDepthMask = null;
        currentDepthFunc = null;
        currentDepthClear = null;
      }
    };
  }
  function StencilBuffer() {
    let locked = false;
    let currentStencilMask = null;
    let currentStencilFunc = null;
    let currentStencilRef = null;
    let currentStencilFuncMask = null;
    let currentStencilFail = null;
    let currentStencilZFail = null;
    let currentStencilZPass = null;
    let currentStencilClear = null;
    return {
      setTest: function(stencilTest) {
        if (!locked) {
          if (stencilTest) {
            enable(gl.STENCIL_TEST);
          } else {
            disable(gl.STENCIL_TEST);
          }
        }
      },
      setMask: function(stencilMask) {
        if (currentStencilMask !== stencilMask && !locked) {
          gl.stencilMask(stencilMask);
          currentStencilMask = stencilMask;
        }
      },
      setFunc: function(stencilFunc, stencilRef, stencilMask) {
        if (currentStencilFunc !== stencilFunc || currentStencilRef !== stencilRef || currentStencilFuncMask !== stencilMask) {
          gl.stencilFunc(stencilFunc, stencilRef, stencilMask);
          currentStencilFunc = stencilFunc;
          currentStencilRef = stencilRef;
          currentStencilFuncMask = stencilMask;
        }
      },
      setOp: function(stencilFail, stencilZFail, stencilZPass) {
        if (currentStencilFail !== stencilFail || currentStencilZFail !== stencilZFail || currentStencilZPass !== stencilZPass) {
          gl.stencilOp(stencilFail, stencilZFail, stencilZPass);
          currentStencilFail = stencilFail;
          currentStencilZFail = stencilZFail;
          currentStencilZPass = stencilZPass;
        }
      },
      setLocked: function(lock) {
        locked = lock;
      },
      setClear: function(stencil) {
        if (currentStencilClear !== stencil) {
          gl.clearStencil(stencil);
          currentStencilClear = stencil;
        }
      },
      reset: function() {
        locked = false;
        currentStencilMask = null;
        currentStencilFunc = null;
        currentStencilRef = null;
        currentStencilFuncMask = null;
        currentStencilFail = null;
        currentStencilZFail = null;
        currentStencilZPass = null;
        currentStencilClear = null;
      }
    };
  }
  const colorBuffer = new ColorBuffer();
  const depthBuffer = new DepthBuffer();
  const stencilBuffer = new StencilBuffer();
  const uboBindings = /* @__PURE__ */ new WeakMap();
  const uboProgramMap = /* @__PURE__ */ new WeakMap();
  let enabledCapabilities = {};
  let currentBoundFramebuffers = {};
  let currentDrawbuffers = /* @__PURE__ */ new WeakMap();
  let defaultDrawbuffers = [];
  let currentProgram = null;
  let currentBlendingEnabled = false;
  let currentBlending = null;
  let currentBlendEquation = null;
  let currentBlendSrc = null;
  let currentBlendDst = null;
  let currentBlendEquationAlpha = null;
  let currentBlendSrcAlpha = null;
  let currentBlendDstAlpha = null;
  let currentPremultipledAlpha = false;
  let currentFlipSided = null;
  let currentCullFace = null;
  let currentLineWidth = null;
  let currentPolygonOffsetFactor = null;
  let currentPolygonOffsetUnits = null;
  const maxTextures = gl.getParameter(gl.MAX_COMBINED_TEXTURE_IMAGE_UNITS);
  let lineWidthAvailable = false;
  let version = 0;
  const glVersion = gl.getParameter(gl.VERSION);
  if (glVersion.indexOf("WebGL") !== -1) {
    version = parseFloat(/^WebGL (\d)/.exec(glVersion)[1]);
    lineWidthAvailable = version >= 1;
  } else if (glVersion.indexOf("OpenGL ES") !== -1) {
    version = parseFloat(/^OpenGL ES (\d)/.exec(glVersion)[1]);
    lineWidthAvailable = version >= 2;
  }
  let currentTextureSlot = null;
  let currentBoundTextures = {};
  const scissorParam = gl.getParameter(gl.SCISSOR_BOX);
  const viewportParam = gl.getParameter(gl.VIEWPORT);
  const currentScissor = new Vector4().fromArray(scissorParam);
  const currentViewport = new Vector4().fromArray(viewportParam);
  function createTexture(type, target, count, dimensions) {
    const data = new Uint8Array(4);
    const texture = gl.createTexture();
    gl.bindTexture(type, texture);
    gl.texParameteri(type, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
    gl.texParameteri(type, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
    for (let i2 = 0; i2 < count; i2++) {
      if (isWebGL2 && (type === gl.TEXTURE_3D || type === gl.TEXTURE_2D_ARRAY)) {
        gl.texImage3D(target, 0, gl.RGBA, 1, 1, dimensions, 0, gl.RGBA, gl.UNSIGNED_BYTE, data);
      } else {
        gl.texImage2D(target + i2, 0, gl.RGBA, 1, 1, 0, gl.RGBA, gl.UNSIGNED_BYTE, data);
      }
    }
    return texture;
  }
  const emptyTextures = {};
  emptyTextures[gl.TEXTURE_2D] = createTexture(gl.TEXTURE_2D, gl.TEXTURE_2D, 1);
  emptyTextures[gl.TEXTURE_CUBE_MAP] = createTexture(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_CUBE_MAP_POSITIVE_X, 6);
  if (isWebGL2) {
    emptyTextures[gl.TEXTURE_2D_ARRAY] = createTexture(gl.TEXTURE_2D_ARRAY, gl.TEXTURE_2D_ARRAY, 1, 1);
    emptyTextures[gl.TEXTURE_3D] = createTexture(gl.TEXTURE_3D, gl.TEXTURE_3D, 1, 1);
  }
  colorBuffer.setClear(0, 0, 0, 1);
  depthBuffer.setClear(1);
  stencilBuffer.setClear(0);
  enable(gl.DEPTH_TEST);
  depthBuffer.setFunc(LessEqualDepth);
  setFlipSided(false);
  setCullFace(CullFaceBack);
  enable(gl.CULL_FACE);
  setBlending(NoBlending);
  function enable(id2) {
    if (enabledCapabilities[id2] !== true) {
      gl.enable(id2);
      enabledCapabilities[id2] = true;
    }
  }
  function disable(id2) {
    if (enabledCapabilities[id2] !== false) {
      gl.disable(id2);
      enabledCapabilities[id2] = false;
    }
  }
  function bindFramebuffer(target, framebuffer) {
    if (currentBoundFramebuffers[target] !== framebuffer) {
      gl.bindFramebuffer(target, framebuffer);
      currentBoundFramebuffers[target] = framebuffer;
      if (isWebGL2) {
        if (target === gl.DRAW_FRAMEBUFFER) {
          currentBoundFramebuffers[gl.FRAMEBUFFER] = framebuffer;
        }
        if (target === gl.FRAMEBUFFER) {
          currentBoundFramebuffers[gl.DRAW_FRAMEBUFFER] = framebuffer;
        }
      }
      return true;
    }
    return false;
  }
  function drawBuffers(renderTarget, framebuffer) {
    let drawBuffers2 = defaultDrawbuffers;
    let needsUpdate = false;
    if (renderTarget) {
      drawBuffers2 = currentDrawbuffers.get(framebuffer);
      if (drawBuffers2 === void 0) {
        drawBuffers2 = [];
        currentDrawbuffers.set(framebuffer, drawBuffers2);
      }
      if (renderTarget.isWebGLMultipleRenderTargets) {
        const textures = renderTarget.texture;
        if (drawBuffers2.length !== textures.length || drawBuffers2[0] !== gl.COLOR_ATTACHMENT0) {
          for (let i2 = 0, il = textures.length; i2 < il; i2++) {
            drawBuffers2[i2] = gl.COLOR_ATTACHMENT0 + i2;
          }
          drawBuffers2.length = textures.length;
          needsUpdate = true;
        }
      } else {
        if (drawBuffers2[0] !== gl.COLOR_ATTACHMENT0) {
          drawBuffers2[0] = gl.COLOR_ATTACHMENT0;
          needsUpdate = true;
        }
      }
    } else {
      if (drawBuffers2[0] !== gl.BACK) {
        drawBuffers2[0] = gl.BACK;
        needsUpdate = true;
      }
    }
    if (needsUpdate) {
      if (capabilities2.isWebGL2) {
        gl.drawBuffers(drawBuffers2);
      } else {
        extensions.get("WEBGL_draw_buffers").drawBuffersWEBGL(drawBuffers2);
      }
    }
  }
  function useProgram(program) {
    if (currentProgram !== program) {
      gl.useProgram(program);
      currentProgram = program;
      return true;
    }
    return false;
  }
  const equationToGL = {
    [AddEquation]: gl.FUNC_ADD,
    [SubtractEquation]: gl.FUNC_SUBTRACT,
    [ReverseSubtractEquation]: gl.FUNC_REVERSE_SUBTRACT
  };
  if (isWebGL2) {
    equationToGL[MinEquation] = gl.MIN;
    equationToGL[MaxEquation] = gl.MAX;
  } else {
    const extension = extensions.get("EXT_blend_minmax");
    if (extension !== null) {
      equationToGL[MinEquation] = extension.MIN_EXT;
      equationToGL[MaxEquation] = extension.MAX_EXT;
    }
  }
  const factorToGL = {
    [ZeroFactor]: gl.ZERO,
    [OneFactor]: gl.ONE,
    [SrcColorFactor]: gl.SRC_COLOR,
    [SrcAlphaFactor]: gl.SRC_ALPHA,
    [SrcAlphaSaturateFactor]: gl.SRC_ALPHA_SATURATE,
    [DstColorFactor]: gl.DST_COLOR,
    [DstAlphaFactor]: gl.DST_ALPHA,
    [OneMinusSrcColorFactor]: gl.ONE_MINUS_SRC_COLOR,
    [OneMinusSrcAlphaFactor]: gl.ONE_MINUS_SRC_ALPHA,
    [OneMinusDstColorFactor]: gl.ONE_MINUS_DST_COLOR,
    [OneMinusDstAlphaFactor]: gl.ONE_MINUS_DST_ALPHA
  };
  function setBlending(blending, blendEquation, blendSrc, blendDst, blendEquationAlpha, blendSrcAlpha, blendDstAlpha, premultipliedAlpha) {
    if (blending === NoBlending) {
      if (currentBlendingEnabled === true) {
        disable(gl.BLEND);
        currentBlendingEnabled = false;
      }
      return;
    }
    if (currentBlendingEnabled === false) {
      enable(gl.BLEND);
      currentBlendingEnabled = true;
    }
    if (blending !== CustomBlending) {
      if (blending !== currentBlending || premultipliedAlpha !== currentPremultipledAlpha) {
        if (currentBlendEquation !== AddEquation || currentBlendEquationAlpha !== AddEquation) {
          gl.blendEquation(gl.FUNC_ADD);
          currentBlendEquation = AddEquation;
          currentBlendEquationAlpha = AddEquation;
        }
        if (premultipliedAlpha) {
          switch (blending) {
            case NormalBlending:
              gl.blendFuncSeparate(gl.ONE, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE_MINUS_SRC_ALPHA);
              break;
            case AdditiveBlending:
              gl.blendFunc(gl.ONE, gl.ONE);
              break;
            case SubtractiveBlending:
              gl.blendFuncSeparate(gl.ZERO, gl.ONE_MINUS_SRC_COLOR, gl.ZERO, gl.ONE);
              break;
            case MultiplyBlending:
              gl.blendFuncSeparate(gl.ZERO, gl.SRC_COLOR, gl.ZERO, gl.SRC_ALPHA);
              break;
            default:
              console.error("THREE.WebGLState: Invalid blending: ", blending);
              break;
          }
        } else {
          switch (blending) {
            case NormalBlending:
              gl.blendFuncSeparate(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE_MINUS_SRC_ALPHA);
              break;
            case AdditiveBlending:
              gl.blendFunc(gl.SRC_ALPHA, gl.ONE);
              break;
            case SubtractiveBlending:
              gl.blendFuncSeparate(gl.ZERO, gl.ONE_MINUS_SRC_COLOR, gl.ZERO, gl.ONE);
              break;
            case MultiplyBlending:
              gl.blendFunc(gl.ZERO, gl.SRC_COLOR);
              break;
            default:
              console.error("THREE.WebGLState: Invalid blending: ", blending);
              break;
          }
        }
        currentBlendSrc = null;
        currentBlendDst = null;
        currentBlendSrcAlpha = null;
        currentBlendDstAlpha = null;
        currentBlending = blending;
        currentPremultipledAlpha = premultipliedAlpha;
      }
      return;
    }
    blendEquationAlpha = blendEquationAlpha || blendEquation;
    blendSrcAlpha = blendSrcAlpha || blendSrc;
    blendDstAlpha = blendDstAlpha || blendDst;
    if (blendEquation !== currentBlendEquation || blendEquationAlpha !== currentBlendEquationAlpha) {
      gl.blendEquationSeparate(equationToGL[blendEquation], equationToGL[blendEquationAlpha]);
      currentBlendEquation = blendEquation;
      currentBlendEquationAlpha = blendEquationAlpha;
    }
    if (blendSrc !== currentBlendSrc || blendDst !== currentBlendDst || blendSrcAlpha !== currentBlendSrcAlpha || blendDstAlpha !== currentBlendDstAlpha) {
      gl.blendFuncSeparate(factorToGL[blendSrc], factorToGL[blendDst], factorToGL[blendSrcAlpha], factorToGL[blendDstAlpha]);
      currentBlendSrc = blendSrc;
      currentBlendDst = blendDst;
      currentBlendSrcAlpha = blendSrcAlpha;
      currentBlendDstAlpha = blendDstAlpha;
    }
    currentBlending = blending;
    currentPremultipledAlpha = false;
  }
  function setMaterial(material, frontFaceCW) {
    material.side === DoubleSide ? disable(gl.CULL_FACE) : enable(gl.CULL_FACE);
    let flipSided = material.side === BackSide;
    if (frontFaceCW) flipSided = !flipSided;
    setFlipSided(flipSided);
    material.blending === NormalBlending && material.transparent === false ? setBlending(NoBlending) : setBlending(material.blending, material.blendEquation, material.blendSrc, material.blendDst, material.blendEquationAlpha, material.blendSrcAlpha, material.blendDstAlpha, material.premultipliedAlpha);
    depthBuffer.setFunc(material.depthFunc);
    depthBuffer.setTest(material.depthTest);
    depthBuffer.setMask(material.depthWrite);
    colorBuffer.setMask(material.colorWrite);
    const stencilWrite = material.stencilWrite;
    stencilBuffer.setTest(stencilWrite);
    if (stencilWrite) {
      stencilBuffer.setMask(material.stencilWriteMask);
      stencilBuffer.setFunc(material.stencilFunc, material.stencilRef, material.stencilFuncMask);
      stencilBuffer.setOp(material.stencilFail, material.stencilZFail, material.stencilZPass);
    }
    setPolygonOffset(material.polygonOffset, material.polygonOffsetFactor, material.polygonOffsetUnits);
    material.alphaToCoverage === true ? enable(gl.SAMPLE_ALPHA_TO_COVERAGE) : disable(gl.SAMPLE_ALPHA_TO_COVERAGE);
  }
  function setFlipSided(flipSided) {
    if (currentFlipSided !== flipSided) {
      if (flipSided) {
        gl.frontFace(gl.CW);
      } else {
        gl.frontFace(gl.CCW);
      }
      currentFlipSided = flipSided;
    }
  }
  function setCullFace(cullFace) {
    if (cullFace !== CullFaceNone) {
      enable(gl.CULL_FACE);
      if (cullFace !== currentCullFace) {
        if (cullFace === CullFaceBack) {
          gl.cullFace(gl.BACK);
        } else if (cullFace === CullFaceFront) {
          gl.cullFace(gl.FRONT);
        } else {
          gl.cullFace(gl.FRONT_AND_BACK);
        }
      }
    } else {
      disable(gl.CULL_FACE);
    }
    currentCullFace = cullFace;
  }
  function setLineWidth(width) {
    if (width !== currentLineWidth) {
      if (lineWidthAvailable) gl.lineWidth(width);
      currentLineWidth = width;
    }
  }
  function setPolygonOffset(polygonOffset, factor, units) {
    if (polygonOffset) {
      enable(gl.POLYGON_OFFSET_FILL);
      if (currentPolygonOffsetFactor !== factor || currentPolygonOffsetUnits !== units) {
        gl.polygonOffset(factor, units);
        currentPolygonOffsetFactor = factor;
        currentPolygonOffsetUnits = units;
      }
    } else {
      disable(gl.POLYGON_OFFSET_FILL);
    }
  }
  function setScissorTest(scissorTest) {
    if (scissorTest) {
      enable(gl.SCISSOR_TEST);
    } else {
      disable(gl.SCISSOR_TEST);
    }
  }
  function activeTexture(webglSlot) {
    if (webglSlot === void 0) webglSlot = gl.TEXTURE0 + maxTextures - 1;
    if (currentTextureSlot !== webglSlot) {
      gl.activeTexture(webglSlot);
      currentTextureSlot = webglSlot;
    }
  }
  function bindTexture(webglType, webglTexture, webglSlot) {
    if (webglSlot === void 0) {
      if (currentTextureSlot === null) {
        webglSlot = gl.TEXTURE0 + maxTextures - 1;
      } else {
        webglSlot = currentTextureSlot;
      }
    }
    let boundTexture = currentBoundTextures[webglSlot];
    if (boundTexture === void 0) {
      boundTexture = { type: void 0, texture: void 0 };
      currentBoundTextures[webglSlot] = boundTexture;
    }
    if (boundTexture.type !== webglType || boundTexture.texture !== webglTexture) {
      if (currentTextureSlot !== webglSlot) {
        gl.activeTexture(webglSlot);
        currentTextureSlot = webglSlot;
      }
      gl.bindTexture(webglType, webglTexture || emptyTextures[webglType]);
      boundTexture.type = webglType;
      boundTexture.texture = webglTexture;
    }
  }
  function unbindTexture() {
    const boundTexture = currentBoundTextures[currentTextureSlot];
    if (boundTexture !== void 0 && boundTexture.type !== void 0) {
      gl.bindTexture(boundTexture.type, null);
      boundTexture.type = void 0;
      boundTexture.texture = void 0;
    }
  }
  function compressedTexImage2D() {
    try {
      gl.compressedTexImage2D.apply(gl, arguments);
    } catch (error) {
      console.error("THREE.WebGLState:", error);
    }
  }
  function compressedTexImage3D() {
    try {
      gl.compressedTexImage3D.apply(gl, arguments);
    } catch (error) {
      console.error("THREE.WebGLState:", error);
    }
  }
  function texSubImage2D() {
    try {
      gl.texSubImage2D.apply(gl, arguments);
    } catch (error) {
      console.error("THREE.WebGLState:", error);
    }
  }
  function texSubImage3D() {
    try {
      gl.texSubImage3D.apply(gl, arguments);
    } catch (error) {
      console.error("THREE.WebGLState:", error);
    }
  }
  function compressedTexSubImage2D() {
    try {
      gl.compressedTexSubImage2D.apply(gl, arguments);
    } catch (error) {
      console.error("THREE.WebGLState:", error);
    }
  }
  function compressedTexSubImage3D() {
    try {
      gl.compressedTexSubImage3D.apply(gl, arguments);
    } catch (error) {
      console.error("THREE.WebGLState:", error);
    }
  }
  function texStorage2D() {
    try {
      gl.texStorage2D.apply(gl, arguments);
    } catch (error) {
      console.error("THREE.WebGLState:", error);
    }
  }
  function texStorage3D() {
    try {
      gl.texStorage3D.apply(gl, arguments);
    } catch (error) {
      console.error("THREE.WebGLState:", error);
    }
  }
  function texImage2D() {
    try {
      gl.texImage2D.apply(gl, arguments);
    } catch (error) {
      console.error("THREE.WebGLState:", error);
    }
  }
  function texImage3D() {
    try {
      gl.texImage3D.apply(gl, arguments);
    } catch (error) {
      console.error("THREE.WebGLState:", error);
    }
  }
  function scissor(scissor2) {
    if (currentScissor.equals(scissor2) === false) {
      gl.scissor(scissor2.x, scissor2.y, scissor2.z, scissor2.w);
      currentScissor.copy(scissor2);
    }
  }
  function viewport(viewport2) {
    if (currentViewport.equals(viewport2) === false) {
      gl.viewport(viewport2.x, viewport2.y, viewport2.z, viewport2.w);
      currentViewport.copy(viewport2);
    }
  }
  function updateUBOMapping(uniformsGroup, program) {
    let mapping = uboProgramMap.get(program);
    if (mapping === void 0) {
      mapping = /* @__PURE__ */ new WeakMap();
      uboProgramMap.set(program, mapping);
    }
    let blockIndex = mapping.get(uniformsGroup);
    if (blockIndex === void 0) {
      blockIndex = gl.getUniformBlockIndex(program, uniformsGroup.name);
      mapping.set(uniformsGroup, blockIndex);
    }
  }
  function uniformBlockBinding(uniformsGroup, program) {
    const mapping = uboProgramMap.get(program);
    const blockIndex = mapping.get(uniformsGroup);
    if (uboBindings.get(program) !== blockIndex) {
      gl.uniformBlockBinding(program, blockIndex, uniformsGroup.__bindingPointIndex);
      uboBindings.set(program, blockIndex);
    }
  }
  function reset() {
    gl.disable(gl.BLEND);
    gl.disable(gl.CULL_FACE);
    gl.disable(gl.DEPTH_TEST);
    gl.disable(gl.POLYGON_OFFSET_FILL);
    gl.disable(gl.SCISSOR_TEST);
    gl.disable(gl.STENCIL_TEST);
    gl.disable(gl.SAMPLE_ALPHA_TO_COVERAGE);
    gl.blendEquation(gl.FUNC_ADD);
    gl.blendFunc(gl.ONE, gl.ZERO);
    gl.blendFuncSeparate(gl.ONE, gl.ZERO, gl.ONE, gl.ZERO);
    gl.colorMask(true, true, true, true);
    gl.clearColor(0, 0, 0, 0);
    gl.depthMask(true);
    gl.depthFunc(gl.LESS);
    gl.clearDepth(1);
    gl.stencilMask(4294967295);
    gl.stencilFunc(gl.ALWAYS, 0, 4294967295);
    gl.stencilOp(gl.KEEP, gl.KEEP, gl.KEEP);
    gl.clearStencil(0);
    gl.cullFace(gl.BACK);
    gl.frontFace(gl.CCW);
    gl.polygonOffset(0, 0);
    gl.activeTexture(gl.TEXTURE0);
    gl.bindFramebuffer(gl.FRAMEBUFFER, null);
    if (isWebGL2 === true) {
      gl.bindFramebuffer(gl.DRAW_FRAMEBUFFER, null);
      gl.bindFramebuffer(gl.READ_FRAMEBUFFER, null);
    }
    gl.useProgram(null);
    gl.lineWidth(1);
    gl.scissor(0, 0, gl.canvas.width, gl.canvas.height);
    gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);
    enabledCapabilities = {};
    currentTextureSlot = null;
    currentBoundTextures = {};
    currentBoundFramebuffers = {};
    currentDrawbuffers = /* @__PURE__ */ new WeakMap();
    defaultDrawbuffers = [];
    currentProgram = null;
    currentBlendingEnabled = false;
    currentBlending = null;
    currentBlendEquation = null;
    currentBlendSrc = null;
    currentBlendDst = null;
    currentBlendEquationAlpha = null;
    currentBlendSrcAlpha = null;
    currentBlendDstAlpha = null;
    currentPremultipledAlpha = false;
    currentFlipSided = null;
    currentCullFace = null;
    currentLineWidth = null;
    currentPolygonOffsetFactor = null;
    currentPolygonOffsetUnits = null;
    currentScissor.set(0, 0, gl.canvas.width, gl.canvas.height);
    currentViewport.set(0, 0, gl.canvas.width, gl.canvas.height);
    colorBuffer.reset();
    depthBuffer.reset();
    stencilBuffer.reset();
  }
  return {
    buffers: {
      color: colorBuffer,
      depth: depthBuffer,
      stencil: stencilBuffer
    },
    enable,
    disable,
    bindFramebuffer,
    drawBuffers,
    useProgram,
    setBlending,
    setMaterial,
    setFlipSided,
    setCullFace,
    setLineWidth,
    setPolygonOffset,
    setScissorTest,
    activeTexture,
    bindTexture,
    unbindTexture,
    compressedTexImage2D,
    compressedTexImage3D,
    texImage2D,
    texImage3D,
    updateUBOMapping,
    uniformBlockBinding,
    texStorage2D,
    texStorage3D,
    texSubImage2D,
    texSubImage3D,
    compressedTexSubImage2D,
    compressedTexSubImage3D,
    scissor,
    viewport,
    reset
  };
}
function WebGLTextures(_gl, extensions, state, properties, capabilities2, utils2, info) {
  const isWebGL2 = capabilities2.isWebGL2;
  const maxTextures = capabilities2.maxTextures;
  const maxCubemapSize = capabilities2.maxCubemapSize;
  const maxTextureSize = capabilities2.maxTextureSize;
  const maxSamples = capabilities2.maxSamples;
  const multisampledRTTExt = extensions.has("WEBGL_multisampled_render_to_texture") ? extensions.get("WEBGL_multisampled_render_to_texture") : null;
  const supportsInvalidateFramebuffer = typeof navigator === "undefined" ? false : /OculusBrowser/g.test(navigator.userAgent);
  const _videoTextures = /* @__PURE__ */ new WeakMap();
  let _canvas2;
  const _sources = /* @__PURE__ */ new WeakMap();
  let useOffscreenCanvas = false;
  try {
    useOffscreenCanvas = typeof OffscreenCanvas !== "undefined" && new OffscreenCanvas(1, 1).getContext("2d") !== null;
  } catch (err) {
  }
  function createCanvas(width, height) {
    return useOffscreenCanvas ? (
      // eslint-disable-next-line compat/compat
      new OffscreenCanvas(width, height)
    ) : createElementNS("canvas");
  }
  function resizeImage(image, needsPowerOfTwo, needsNewCanvas, maxSize) {
    let scale = 1;
    if (image.width > maxSize || image.height > maxSize) {
      scale = maxSize / Math.max(image.width, image.height);
    }
    if (scale < 1 || needsPowerOfTwo === true) {
      if (typeof HTMLImageElement !== "undefined" && image instanceof HTMLImageElement || typeof HTMLCanvasElement !== "undefined" && image instanceof HTMLCanvasElement || typeof ImageBitmap !== "undefined" && image instanceof ImageBitmap) {
        const floor = needsPowerOfTwo ? floorPowerOfTwo : Math.floor;
        const width = floor(scale * image.width);
        const height = floor(scale * image.height);
        if (_canvas2 === void 0) _canvas2 = createCanvas(width, height);
        const canvas = needsNewCanvas ? createCanvas(width, height) : _canvas2;
        canvas.width = width;
        canvas.height = height;
        const context = canvas.getContext("2d");
        context.drawImage(image, 0, 0, width, height);
        console.warn("THREE.WebGLRenderer: Texture has been resized from (" + image.width + "x" + image.height + ") to (" + width + "x" + height + ").");
        return canvas;
      } else {
        if ("data" in image) {
          console.warn("THREE.WebGLRenderer: Image in DataTexture is too big (" + image.width + "x" + image.height + ").");
        }
        return image;
      }
    }
    return image;
  }
  function isPowerOfTwo$1(image) {
    return isPowerOfTwo(image.width) && isPowerOfTwo(image.height);
  }
  function textureNeedsPowerOfTwo(texture) {
    if (isWebGL2) return false;
    return texture.wrapS !== ClampToEdgeWrapping || texture.wrapT !== ClampToEdgeWrapping || texture.minFilter !== NearestFilter && texture.minFilter !== LinearFilter;
  }
  function textureNeedsGenerateMipmaps(texture, supportsMips) {
    return texture.generateMipmaps && supportsMips && texture.minFilter !== NearestFilter && texture.minFilter !== LinearFilter;
  }
  function generateMipmap(target) {
    _gl.generateMipmap(target);
  }
  function getInternalFormat(internalFormatName, glFormat, glType, colorSpace, forceLinearTransfer = false) {
    if (isWebGL2 === false) return glFormat;
    if (internalFormatName !== null) {
      if (_gl[internalFormatName] !== void 0) return _gl[internalFormatName];
      console.warn("THREE.WebGLRenderer: Attempt to use non-existing WebGL internal format '" + internalFormatName + "'");
    }
    let internalFormat = glFormat;
    if (glFormat === _gl.RED) {
      if (glType === _gl.FLOAT) internalFormat = _gl.R32F;
      if (glType === _gl.HALF_FLOAT) internalFormat = _gl.R16F;
      if (glType === _gl.UNSIGNED_BYTE) internalFormat = _gl.R8;
    }
    if (glFormat === _gl.RG) {
      if (glType === _gl.FLOAT) internalFormat = _gl.RG32F;
      if (glType === _gl.HALF_FLOAT) internalFormat = _gl.RG16F;
      if (glType === _gl.UNSIGNED_BYTE) internalFormat = _gl.RG8;
    }
    if (glFormat === _gl.RGBA) {
      if (glType === _gl.FLOAT) internalFormat = _gl.RGBA32F;
      if (glType === _gl.HALF_FLOAT) internalFormat = _gl.RGBA16F;
      if (glType === _gl.UNSIGNED_BYTE) internalFormat = colorSpace === SRGBColorSpace && forceLinearTransfer === false ? _gl.SRGB8_ALPHA8 : _gl.RGBA8;
      if (glType === _gl.UNSIGNED_SHORT_4_4_4_4) internalFormat = _gl.RGBA4;
      if (glType === _gl.UNSIGNED_SHORT_5_5_5_1) internalFormat = _gl.RGB5_A1;
    }
    if (internalFormat === _gl.R16F || internalFormat === _gl.R32F || internalFormat === _gl.RG16F || internalFormat === _gl.RG32F || internalFormat === _gl.RGBA16F || internalFormat === _gl.RGBA32F) {
      extensions.get("EXT_color_buffer_float");
    }
    return internalFormat;
  }
  function getMipLevels(texture, image, supportsMips) {
    if (textureNeedsGenerateMipmaps(texture, supportsMips) === true || texture.isFramebufferTexture && texture.minFilter !== NearestFilter && texture.minFilter !== LinearFilter) {
      return Math.log2(Math.max(image.width, image.height)) + 1;
    } else if (texture.mipmaps !== void 0 && texture.mipmaps.length > 0) {
      return texture.mipmaps.length;
    } else if (texture.isCompressedTexture && Array.isArray(texture.image)) {
      return image.mipmaps.length;
    } else {
      return 1;
    }
  }
  function filterFallback(f2) {
    if (f2 === NearestFilter || f2 === NearestMipmapNearestFilter || f2 === NearestMipmapLinearFilter) {
      return _gl.NEAREST;
    }
    return _gl.LINEAR;
  }
  function onTextureDispose(event) {
    const texture = event.target;
    texture.removeEventListener("dispose", onTextureDispose);
    deallocateTexture(texture);
    if (texture.isVideoTexture) {
      _videoTextures.delete(texture);
    }
  }
  function onRenderTargetDispose(event) {
    const renderTarget = event.target;
    renderTarget.removeEventListener("dispose", onRenderTargetDispose);
    deallocateRenderTarget(renderTarget);
  }
  function deallocateTexture(texture) {
    const textureProperties = properties.get(texture);
    if (textureProperties.__webglInit === void 0) return;
    const source = texture.source;
    const webglTextures = _sources.get(source);
    if (webglTextures) {
      const webglTexture = webglTextures[textureProperties.__cacheKey];
      webglTexture.usedTimes--;
      if (webglTexture.usedTimes === 0) {
        deleteTexture(texture);
      }
      if (Object.keys(webglTextures).length === 0) {
        _sources.delete(source);
      }
    }
    properties.remove(texture);
  }
  function deleteTexture(texture) {
    const textureProperties = properties.get(texture);
    _gl.deleteTexture(textureProperties.__webglTexture);
    const source = texture.source;
    const webglTextures = _sources.get(source);
    delete webglTextures[textureProperties.__cacheKey];
    info.memory.textures--;
  }
  function deallocateRenderTarget(renderTarget) {
    const texture = renderTarget.texture;
    const renderTargetProperties = properties.get(renderTarget);
    const textureProperties = properties.get(texture);
    if (textureProperties.__webglTexture !== void 0) {
      _gl.deleteTexture(textureProperties.__webglTexture);
      info.memory.textures--;
    }
    if (renderTarget.depthTexture) {
      renderTarget.depthTexture.dispose();
    }
    if (renderTarget.isWebGLCubeRenderTarget) {
      for (let i2 = 0; i2 < 6; i2++) {
        _gl.deleteFramebuffer(renderTargetProperties.__webglFramebuffer[i2]);
        if (renderTargetProperties.__webglDepthbuffer) _gl.deleteRenderbuffer(renderTargetProperties.__webglDepthbuffer[i2]);
      }
    } else {
      _gl.deleteFramebuffer(renderTargetProperties.__webglFramebuffer);
      if (renderTargetProperties.__webglDepthbuffer) _gl.deleteRenderbuffer(renderTargetProperties.__webglDepthbuffer);
      if (renderTargetProperties.__webglMultisampledFramebuffer) _gl.deleteFramebuffer(renderTargetProperties.__webglMultisampledFramebuffer);
      if (renderTargetProperties.__webglColorRenderbuffer) {
        for (let i2 = 0; i2 < renderTargetProperties.__webglColorRenderbuffer.length; i2++) {
          if (renderTargetProperties.__webglColorRenderbuffer[i2]) _gl.deleteRenderbuffer(renderTargetProperties.__webglColorRenderbuffer[i2]);
        }
      }
      if (renderTargetProperties.__webglDepthRenderbuffer) _gl.deleteRenderbuffer(renderTargetProperties.__webglDepthRenderbuffer);
    }
    if (renderTarget.isWebGLMultipleRenderTargets) {
      for (let i2 = 0, il = texture.length; i2 < il; i2++) {
        const attachmentProperties = properties.get(texture[i2]);
        if (attachmentProperties.__webglTexture) {
          _gl.deleteTexture(attachmentProperties.__webglTexture);
          info.memory.textures--;
        }
        properties.remove(texture[i2]);
      }
    }
    properties.remove(texture);
    properties.remove(renderTarget);
  }
  let textureUnits = 0;
  function resetTextureUnits() {
    textureUnits = 0;
  }
  function allocateTextureUnit() {
    const textureUnit = textureUnits;
    if (textureUnit >= maxTextures) {
      console.warn("THREE.WebGLTextures: Trying to use " + textureUnit + " texture units while this GPU supports only " + maxTextures);
    }
    textureUnits += 1;
    return textureUnit;
  }
  function getTextureCacheKey(texture) {
    const array = [];
    array.push(texture.wrapS);
    array.push(texture.wrapT);
    array.push(texture.wrapR || 0);
    array.push(texture.magFilter);
    array.push(texture.minFilter);
    array.push(texture.anisotropy);
    array.push(texture.internalFormat);
    array.push(texture.format);
    array.push(texture.type);
    array.push(texture.generateMipmaps);
    array.push(texture.premultiplyAlpha);
    array.push(texture.flipY);
    array.push(texture.unpackAlignment);
    array.push(texture.colorSpace);
    return array.join();
  }
  function setTexture2D(texture, slot) {
    const textureProperties = properties.get(texture);
    if (texture.isVideoTexture) updateVideoTexture(texture);
    if (texture.isRenderTargetTexture === false && texture.version > 0 && textureProperties.__version !== texture.version) {
      const image = texture.image;
      if (image === null) {
        console.warn("THREE.WebGLRenderer: Texture marked for update but no image data found.");
      } else if (image.complete === false) {
        console.warn("THREE.WebGLRenderer: Texture marked for update but image is incomplete");
      } else {
        uploadTexture(textureProperties, texture, slot);
        return;
      }
    }
    state.bindTexture(_gl.TEXTURE_2D, textureProperties.__webglTexture, _gl.TEXTURE0 + slot);
  }
  function setTexture2DArray(texture, slot) {
    const textureProperties = properties.get(texture);
    if (texture.version > 0 && textureProperties.__version !== texture.version) {
      uploadTexture(textureProperties, texture, slot);
      return;
    }
    state.bindTexture(_gl.TEXTURE_2D_ARRAY, textureProperties.__webglTexture, _gl.TEXTURE0 + slot);
  }
  function setTexture3D(texture, slot) {
    const textureProperties = properties.get(texture);
    if (texture.version > 0 && textureProperties.__version !== texture.version) {
      uploadTexture(textureProperties, texture, slot);
      return;
    }
    state.bindTexture(_gl.TEXTURE_3D, textureProperties.__webglTexture, _gl.TEXTURE0 + slot);
  }
  function setTextureCube(texture, slot) {
    const textureProperties = properties.get(texture);
    if (texture.version > 0 && textureProperties.__version !== texture.version) {
      uploadCubeTexture(textureProperties, texture, slot);
      return;
    }
    state.bindTexture(_gl.TEXTURE_CUBE_MAP, textureProperties.__webglTexture, _gl.TEXTURE0 + slot);
  }
  const wrappingToGL = {
    [RepeatWrapping]: _gl.REPEAT,
    [ClampToEdgeWrapping]: _gl.CLAMP_TO_EDGE,
    [MirroredRepeatWrapping]: _gl.MIRRORED_REPEAT
  };
  const filterToGL = {
    [NearestFilter]: _gl.NEAREST,
    [NearestMipmapNearestFilter]: _gl.NEAREST_MIPMAP_NEAREST,
    [NearestMipmapLinearFilter]: _gl.NEAREST_MIPMAP_LINEAR,
    [LinearFilter]: _gl.LINEAR,
    [LinearMipmapNearestFilter]: _gl.LINEAR_MIPMAP_NEAREST,
    [LinearMipmapLinearFilter]: _gl.LINEAR_MIPMAP_LINEAR
  };
  const compareToGL = {
    [NeverCompare]: _gl.NEVER,
    [AlwaysCompare]: _gl.ALWAYS,
    [LessCompare]: _gl.LESS,
    [LessEqualCompare]: _gl.LEQUAL,
    [EqualCompare]: _gl.EQUAL,
    [GreaterEqualCompare]: _gl.GEQUAL,
    [GreaterCompare]: _gl.GREATER,
    [NotEqualCompare]: _gl.NOTEQUAL
  };
  function setTextureParameters(textureType, texture, supportsMips) {
    if (supportsMips) {
      _gl.texParameteri(textureType, _gl.TEXTURE_WRAP_S, wrappingToGL[texture.wrapS]);
      _gl.texParameteri(textureType, _gl.TEXTURE_WRAP_T, wrappingToGL[texture.wrapT]);
      if (textureType === _gl.TEXTURE_3D || textureType === _gl.TEXTURE_2D_ARRAY) {
        _gl.texParameteri(textureType, _gl.TEXTURE_WRAP_R, wrappingToGL[texture.wrapR]);
      }
      _gl.texParameteri(textureType, _gl.TEXTURE_MAG_FILTER, filterToGL[texture.magFilter]);
      _gl.texParameteri(textureType, _gl.TEXTURE_MIN_FILTER, filterToGL[texture.minFilter]);
    } else {
      _gl.texParameteri(textureType, _gl.TEXTURE_WRAP_S, _gl.CLAMP_TO_EDGE);
      _gl.texParameteri(textureType, _gl.TEXTURE_WRAP_T, _gl.CLAMP_TO_EDGE);
      if (textureType === _gl.TEXTURE_3D || textureType === _gl.TEXTURE_2D_ARRAY) {
        _gl.texParameteri(textureType, _gl.TEXTURE_WRAP_R, _gl.CLAMP_TO_EDGE);
      }
      if (texture.wrapS !== ClampToEdgeWrapping || texture.wrapT !== ClampToEdgeWrapping) {
        console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping.");
      }
      _gl.texParameteri(textureType, _gl.TEXTURE_MAG_FILTER, filterFallback(texture.magFilter));
      _gl.texParameteri(textureType, _gl.TEXTURE_MIN_FILTER, filterFallback(texture.minFilter));
      if (texture.minFilter !== NearestFilter && texture.minFilter !== LinearFilter) {
        console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter.");
      }
    }
    if (texture.compareFunction) {
      _gl.texParameteri(textureType, _gl.TEXTURE_COMPARE_MODE, _gl.COMPARE_REF_TO_TEXTURE);
      _gl.texParameteri(textureType, _gl.TEXTURE_COMPARE_FUNC, compareToGL[texture.compareFunction]);
    }
    if (extensions.has("EXT_texture_filter_anisotropic") === true) {
      const extension = extensions.get("EXT_texture_filter_anisotropic");
      if (texture.magFilter === NearestFilter) return;
      if (texture.minFilter !== NearestMipmapLinearFilter && texture.minFilter !== LinearMipmapLinearFilter) return;
      if (texture.type === FloatType && extensions.has("OES_texture_float_linear") === false) return;
      if (isWebGL2 === false && (texture.type === HalfFloatType && extensions.has("OES_texture_half_float_linear") === false)) return;
      if (texture.anisotropy > 1 || properties.get(texture).__currentAnisotropy) {
        _gl.texParameterf(textureType, extension.TEXTURE_MAX_ANISOTROPY_EXT, Math.min(texture.anisotropy, capabilities2.getMaxAnisotropy()));
        properties.get(texture).__currentAnisotropy = texture.anisotropy;
      }
    }
  }
  function initTexture(textureProperties, texture) {
    let forceUpload = false;
    if (textureProperties.__webglInit === void 0) {
      textureProperties.__webglInit = true;
      texture.addEventListener("dispose", onTextureDispose);
    }
    const source = texture.source;
    let webglTextures = _sources.get(source);
    if (webglTextures === void 0) {
      webglTextures = {};
      _sources.set(source, webglTextures);
    }
    const textureCacheKey = getTextureCacheKey(texture);
    if (textureCacheKey !== textureProperties.__cacheKey) {
      if (webglTextures[textureCacheKey] === void 0) {
        webglTextures[textureCacheKey] = {
          texture: _gl.createTexture(),
          usedTimes: 0
        };
        info.memory.textures++;
        forceUpload = true;
      }
      webglTextures[textureCacheKey].usedTimes++;
      const webglTexture = webglTextures[textureProperties.__cacheKey];
      if (webglTexture !== void 0) {
        webglTextures[textureProperties.__cacheKey].usedTimes--;
        if (webglTexture.usedTimes === 0) {
          deleteTexture(texture);
        }
      }
      textureProperties.__cacheKey = textureCacheKey;
      textureProperties.__webglTexture = webglTextures[textureCacheKey].texture;
    }
    return forceUpload;
  }
  function uploadTexture(textureProperties, texture, slot) {
    let textureType = _gl.TEXTURE_2D;
    if (texture.isDataArrayTexture || texture.isCompressedArrayTexture) textureType = _gl.TEXTURE_2D_ARRAY;
    if (texture.isData3DTexture) textureType = _gl.TEXTURE_3D;
    const forceUpload = initTexture(textureProperties, texture);
    const source = texture.source;
    state.bindTexture(textureType, textureProperties.__webglTexture, _gl.TEXTURE0 + slot);
    const sourceProperties = properties.get(source);
    if (source.version !== sourceProperties.__version || forceUpload === true) {
      state.activeTexture(_gl.TEXTURE0 + slot);
      _gl.pixelStorei(_gl.UNPACK_FLIP_Y_WEBGL, texture.flipY);
      _gl.pixelStorei(_gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, texture.premultiplyAlpha);
      _gl.pixelStorei(_gl.UNPACK_ALIGNMENT, texture.unpackAlignment);
      _gl.pixelStorei(_gl.UNPACK_COLORSPACE_CONVERSION_WEBGL, _gl.NONE);
      const needsPowerOfTwo = textureNeedsPowerOfTwo(texture) && isPowerOfTwo$1(texture.image) === false;
      let image = resizeImage(texture.image, needsPowerOfTwo, false, maxTextureSize);
      image = verifyColorSpace(texture, image);
      const supportsMips = isPowerOfTwo$1(image) || isWebGL2, glFormat = utils2.convert(texture.format, texture.colorSpace);
      let glType = utils2.convert(texture.type), glInternalFormat = getInternalFormat(texture.internalFormat, glFormat, glType, texture.colorSpace);
      setTextureParameters(textureType, texture, supportsMips);
      let mipmap;
      const mipmaps = texture.mipmaps;
      const useTexStorage = isWebGL2 && texture.isVideoTexture !== true;
      const allocateMemory = sourceProperties.__version === void 0 || forceUpload === true;
      const levels = getMipLevels(texture, image, supportsMips);
      if (texture.isDepthTexture) {
        glInternalFormat = _gl.DEPTH_COMPONENT;
        if (isWebGL2) {
          if (texture.type === FloatType) {
            glInternalFormat = _gl.DEPTH_COMPONENT32F;
          } else if (texture.type === UnsignedIntType) {
            glInternalFormat = _gl.DEPTH_COMPONENT24;
          } else if (texture.type === UnsignedInt248Type) {
            glInternalFormat = _gl.DEPTH24_STENCIL8;
          } else {
            glInternalFormat = _gl.DEPTH_COMPONENT16;
          }
        } else {
          if (texture.type === FloatType) {
            console.error("WebGLRenderer: Floating point depth texture requires WebGL2.");
          }
        }
        if (texture.format === DepthFormat && glInternalFormat === _gl.DEPTH_COMPONENT) {
          if (texture.type !== UnsignedShortType && texture.type !== UnsignedIntType) {
            console.warn("THREE.WebGLRenderer: Use UnsignedShortType or UnsignedIntType for DepthFormat DepthTexture.");
            texture.type = UnsignedIntType;
            glType = utils2.convert(texture.type);
          }
        }
        if (texture.format === DepthStencilFormat && glInternalFormat === _gl.DEPTH_COMPONENT) {
          glInternalFormat = _gl.DEPTH_STENCIL;
          if (texture.type !== UnsignedInt248Type) {
            console.warn("THREE.WebGLRenderer: Use UnsignedInt248Type for DepthStencilFormat DepthTexture.");
            texture.type = UnsignedInt248Type;
            glType = utils2.convert(texture.type);
          }
        }
        if (allocateMemory) {
          if (useTexStorage) {
            state.texStorage2D(_gl.TEXTURE_2D, 1, glInternalFormat, image.width, image.height);
          } else {
            state.texImage2D(_gl.TEXTURE_2D, 0, glInternalFormat, image.width, image.height, 0, glFormat, glType, null);
          }
        }
      } else if (texture.isDataTexture) {
        if (mipmaps.length > 0 && supportsMips) {
          if (useTexStorage && allocateMemory) {
            state.texStorage2D(_gl.TEXTURE_2D, levels, glInternalFormat, mipmaps[0].width, mipmaps[0].height);
          }
          for (let i2 = 0, il = mipmaps.length; i2 < il; i2++) {
            mipmap = mipmaps[i2];
            if (useTexStorage) {
              state.texSubImage2D(_gl.TEXTURE_2D, i2, 0, 0, mipmap.width, mipmap.height, glFormat, glType, mipmap.data);
            } else {
              state.texImage2D(_gl.TEXTURE_2D, i2, glInternalFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data);
            }
          }
          texture.generateMipmaps = false;
        } else {
          if (useTexStorage) {
            if (allocateMemory) {
              state.texStorage2D(_gl.TEXTURE_2D, levels, glInternalFormat, image.width, image.height);
            }
            state.texSubImage2D(_gl.TEXTURE_2D, 0, 0, 0, image.width, image.height, glFormat, glType, image.data);
          } else {
            state.texImage2D(_gl.TEXTURE_2D, 0, glInternalFormat, image.width, image.height, 0, glFormat, glType, image.data);
          }
        }
      } else if (texture.isCompressedTexture) {
        if (texture.isCompressedArrayTexture) {
          if (useTexStorage && allocateMemory) {
            state.texStorage3D(_gl.TEXTURE_2D_ARRAY, levels, glInternalFormat, mipmaps[0].width, mipmaps[0].height, image.depth);
          }
          for (let i2 = 0, il = mipmaps.length; i2 < il; i2++) {
            mipmap = mipmaps[i2];
            if (texture.format !== RGBAFormat) {
              if (glFormat !== null) {
                if (useTexStorage) {
                  state.compressedTexSubImage3D(_gl.TEXTURE_2D_ARRAY, i2, 0, 0, 0, mipmap.width, mipmap.height, image.depth, glFormat, mipmap.data, 0, 0);
                } else {
                  state.compressedTexImage3D(_gl.TEXTURE_2D_ARRAY, i2, glInternalFormat, mipmap.width, mipmap.height, image.depth, 0, mipmap.data, 0, 0);
                }
              } else {
                console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()");
              }
            } else {
              if (useTexStorage) {
                state.texSubImage3D(_gl.TEXTURE_2D_ARRAY, i2, 0, 0, 0, mipmap.width, mipmap.height, image.depth, glFormat, glType, mipmap.data);
              } else {
                state.texImage3D(_gl.TEXTURE_2D_ARRAY, i2, glInternalFormat, mipmap.width, mipmap.height, image.depth, 0, glFormat, glType, mipmap.data);
              }
            }
          }
        } else {
          if (useTexStorage && allocateMemory) {
            state.texStorage2D(_gl.TEXTURE_2D, levels, glInternalFormat, mipmaps[0].width, mipmaps[0].height);
          }
          for (let i2 = 0, il = mipmaps.length; i2 < il; i2++) {
            mipmap = mipmaps[i2];
            if (texture.format !== RGBAFormat) {
              if (glFormat !== null) {
                if (useTexStorage) {
                  state.compressedTexSubImage2D(_gl.TEXTURE_2D, i2, 0, 0, mipmap.width, mipmap.height, glFormat, mipmap.data);
                } else {
                  state.compressedTexImage2D(_gl.TEXTURE_2D, i2, glInternalFormat, mipmap.width, mipmap.height, 0, mipmap.data);
                }
              } else {
                console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()");
              }
            } else {
              if (useTexStorage) {
                state.texSubImage2D(_gl.TEXTURE_2D, i2, 0, 0, mipmap.width, mipmap.height, glFormat, glType, mipmap.data);
              } else {
                state.texImage2D(_gl.TEXTURE_2D, i2, glInternalFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data);
              }
            }
          }
        }
      } else if (texture.isDataArrayTexture) {
        if (useTexStorage) {
          if (allocateMemory) {
            state.texStorage3D(_gl.TEXTURE_2D_ARRAY, levels, glInternalFormat, image.width, image.height, image.depth);
          }
          state.texSubImage3D(_gl.TEXTURE_2D_ARRAY, 0, 0, 0, 0, image.width, image.height, image.depth, glFormat, glType, image.data);
        } else {
          state.texImage3D(_gl.TEXTURE_2D_ARRAY, 0, glInternalFormat, image.width, image.height, image.depth, 0, glFormat, glType, image.data);
        }
      } else if (texture.isData3DTexture) {
        if (useTexStorage) {
          if (allocateMemory) {
            state.texStorage3D(_gl.TEXTURE_3D, levels, glInternalFormat, image.width, image.height, image.depth);
          }
          state.texSubImage3D(_gl.TEXTURE_3D, 0, 0, 0, 0, image.width, image.height, image.depth, glFormat, glType, image.data);
        } else {
          state.texImage3D(_gl.TEXTURE_3D, 0, glInternalFormat, image.width, image.height, image.depth, 0, glFormat, glType, image.data);
        }
      } else if (texture.isFramebufferTexture) {
        if (allocateMemory) {
          if (useTexStorage) {
            state.texStorage2D(_gl.TEXTURE_2D, levels, glInternalFormat, image.width, image.height);
          } else {
            let width = image.width, height = image.height;
            for (let i2 = 0; i2 < levels; i2++) {
              state.texImage2D(_gl.TEXTURE_2D, i2, glInternalFormat, width, height, 0, glFormat, glType, null);
              width >>= 1;
              height >>= 1;
            }
          }
        }
      } else {
        if (mipmaps.length > 0 && supportsMips) {
          if (useTexStorage && allocateMemory) {
            state.texStorage2D(_gl.TEXTURE_2D, levels, glInternalFormat, mipmaps[0].width, mipmaps[0].height);
          }
          for (let i2 = 0, il = mipmaps.length; i2 < il; i2++) {
            mipmap = mipmaps[i2];
            if (useTexStorage) {
              state.texSubImage2D(_gl.TEXTURE_2D, i2, 0, 0, glFormat, glType, mipmap);
            } else {
              state.texImage2D(_gl.TEXTURE_2D, i2, glInternalFormat, glFormat, glType, mipmap);
            }
          }
          texture.generateMipmaps = false;
        } else {
          if (useTexStorage) {
            if (allocateMemory) {
              state.texStorage2D(_gl.TEXTURE_2D, levels, glInternalFormat, image.width, image.height);
            }
            state.texSubImage2D(_gl.TEXTURE_2D, 0, 0, 0, glFormat, glType, image);
          } else {
            state.texImage2D(_gl.TEXTURE_2D, 0, glInternalFormat, glFormat, glType, image);
          }
        }
      }
      if (textureNeedsGenerateMipmaps(texture, supportsMips)) {
        generateMipmap(textureType);
      }
      sourceProperties.__version = source.version;
      if (texture.onUpdate) texture.onUpdate(texture);
    }
    textureProperties.__version = texture.version;
  }
  function uploadCubeTexture(textureProperties, texture, slot) {
    if (texture.image.length !== 6) return;
    const forceUpload = initTexture(textureProperties, texture);
    const source = texture.source;
    state.bindTexture(_gl.TEXTURE_CUBE_MAP, textureProperties.__webglTexture, _gl.TEXTURE0 + slot);
    const sourceProperties = properties.get(source);
    if (source.version !== sourceProperties.__version || forceUpload === true) {
      state.activeTexture(_gl.TEXTURE0 + slot);
      _gl.pixelStorei(_gl.UNPACK_FLIP_Y_WEBGL, texture.flipY);
      _gl.pixelStorei(_gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, texture.premultiplyAlpha);
      _gl.pixelStorei(_gl.UNPACK_ALIGNMENT, texture.unpackAlignment);
      _gl.pixelStorei(_gl.UNPACK_COLORSPACE_CONVERSION_WEBGL, _gl.NONE);
      const isCompressed = texture.isCompressedTexture || texture.image[0].isCompressedTexture;
      const isDataTexture = texture.image[0] && texture.image[0].isDataTexture;
      const cubeImage = [];
      for (let i2 = 0; i2 < 6; i2++) {
        if (!isCompressed && !isDataTexture) {
          cubeImage[i2] = resizeImage(texture.image[i2], false, true, maxCubemapSize);
        } else {
          cubeImage[i2] = isDataTexture ? texture.image[i2].image : texture.image[i2];
        }
        cubeImage[i2] = verifyColorSpace(texture, cubeImage[i2]);
      }
      const image = cubeImage[0], supportsMips = isPowerOfTwo$1(image) || isWebGL2, glFormat = utils2.convert(texture.format, texture.colorSpace), glType = utils2.convert(texture.type), glInternalFormat = getInternalFormat(texture.internalFormat, glFormat, glType, texture.colorSpace);
      const useTexStorage = isWebGL2 && texture.isVideoTexture !== true;
      const allocateMemory = sourceProperties.__version === void 0 || forceUpload === true;
      let levels = getMipLevels(texture, image, supportsMips);
      setTextureParameters(_gl.TEXTURE_CUBE_MAP, texture, supportsMips);
      let mipmaps;
      if (isCompressed) {
        if (useTexStorage && allocateMemory) {
          state.texStorage2D(_gl.TEXTURE_CUBE_MAP, levels, glInternalFormat, image.width, image.height);
        }
        for (let i2 = 0; i2 < 6; i2++) {
          mipmaps = cubeImage[i2].mipmaps;
          for (let j = 0; j < mipmaps.length; j++) {
            const mipmap = mipmaps[j];
            if (texture.format !== RGBAFormat) {
              if (glFormat !== null) {
                if (useTexStorage) {
                  state.compressedTexSubImage2D(_gl.TEXTURE_CUBE_MAP_POSITIVE_X + i2, j, 0, 0, mipmap.width, mipmap.height, glFormat, mipmap.data);
                } else {
                  state.compressedTexImage2D(_gl.TEXTURE_CUBE_MAP_POSITIVE_X + i2, j, glInternalFormat, mipmap.width, mipmap.height, 0, mipmap.data);
                }
              } else {
                console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()");
              }
            } else {
              if (useTexStorage) {
                state.texSubImage2D(_gl.TEXTURE_CUBE_MAP_POSITIVE_X + i2, j, 0, 0, mipmap.width, mipmap.height, glFormat, glType, mipmap.data);
              } else {
                state.texImage2D(_gl.TEXTURE_CUBE_MAP_POSITIVE_X + i2, j, glInternalFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data);
              }
            }
          }
        }
      } else {
        mipmaps = texture.mipmaps;
        if (useTexStorage && allocateMemory) {
          if (mipmaps.length > 0) levels++;
          state.texStorage2D(_gl.TEXTURE_CUBE_MAP, levels, glInternalFormat, cubeImage[0].width, cubeImage[0].height);
        }
        for (let i2 = 0; i2 < 6; i2++) {
          if (isDataTexture) {
            if (useTexStorage) {
              state.texSubImage2D(_gl.TEXTURE_CUBE_MAP_POSITIVE_X + i2, 0, 0, 0, cubeImage[i2].width, cubeImage[i2].height, glFormat, glType, cubeImage[i2].data);
            } else {
              state.texImage2D(_gl.TEXTURE_CUBE_MAP_POSITIVE_X + i2, 0, glInternalFormat, cubeImage[i2].width, cubeImage[i2].height, 0, glFormat, glType, cubeImage[i2].data);
            }
            for (let j = 0; j < mipmaps.length; j++) {
              const mipmap = mipmaps[j];
              const mipmapImage = mipmap.image[i2].image;
              if (useTexStorage) {
                state.texSubImage2D(_gl.TEXTURE_CUBE_MAP_POSITIVE_X + i2, j + 1, 0, 0, mipmapImage.width, mipmapImage.height, glFormat, glType, mipmapImage.data);
              } else {
                state.texImage2D(_gl.TEXTURE_CUBE_MAP_POSITIVE_X + i2, j + 1, glInternalFormat, mipmapImage.width, mipmapImage.height, 0, glFormat, glType, mipmapImage.data);
              }
            }
          } else {
            if (useTexStorage) {
              state.texSubImage2D(_gl.TEXTURE_CUBE_MAP_POSITIVE_X + i2, 0, 0, 0, glFormat, glType, cubeImage[i2]);
            } else {
              state.texImage2D(_gl.TEXTURE_CUBE_MAP_POSITIVE_X + i2, 0, glInternalFormat, glFormat, glType, cubeImage[i2]);
            }
            for (let j = 0; j < mipmaps.length; j++) {
              const mipmap = mipmaps[j];
              if (useTexStorage) {
                state.texSubImage2D(_gl.TEXTURE_CUBE_MAP_POSITIVE_X + i2, j + 1, 0, 0, glFormat, glType, mipmap.image[i2]);
              } else {
                state.texImage2D(_gl.TEXTURE_CUBE_MAP_POSITIVE_X + i2, j + 1, glInternalFormat, glFormat, glType, mipmap.image[i2]);
              }
            }
          }
        }
      }
      if (textureNeedsGenerateMipmaps(texture, supportsMips)) {
        generateMipmap(_gl.TEXTURE_CUBE_MAP);
      }
      sourceProperties.__version = source.version;
      if (texture.onUpdate) texture.onUpdate(texture);
    }
    textureProperties.__version = texture.version;
  }
  function setupFrameBufferTexture(framebuffer, renderTarget, texture, attachment, textureTarget) {
    const glFormat = utils2.convert(texture.format, texture.colorSpace);
    const glType = utils2.convert(texture.type);
    const glInternalFormat = getInternalFormat(texture.internalFormat, glFormat, glType, texture.colorSpace);
    const renderTargetProperties = properties.get(renderTarget);
    if (!renderTargetProperties.__hasExternalTextures) {
      if (textureTarget === _gl.TEXTURE_3D || textureTarget === _gl.TEXTURE_2D_ARRAY) {
        state.texImage3D(textureTarget, 0, glInternalFormat, renderTarget.width, renderTarget.height, renderTarget.depth, 0, glFormat, glType, null);
      } else {
        state.texImage2D(textureTarget, 0, glInternalFormat, renderTarget.width, renderTarget.height, 0, glFormat, glType, null);
      }
    }
    state.bindFramebuffer(_gl.FRAMEBUFFER, framebuffer);
    if (useMultisampledRTT(renderTarget)) {
      multisampledRTTExt.framebufferTexture2DMultisampleEXT(_gl.FRAMEBUFFER, attachment, textureTarget, properties.get(texture).__webglTexture, 0, getRenderTargetSamples(renderTarget));
    } else if (textureTarget === _gl.TEXTURE_2D || textureTarget >= _gl.TEXTURE_CUBE_MAP_POSITIVE_X && textureTarget <= _gl.TEXTURE_CUBE_MAP_NEGATIVE_Z) {
      _gl.framebufferTexture2D(_gl.FRAMEBUFFER, attachment, textureTarget, properties.get(texture).__webglTexture, 0);
    }
    state.bindFramebuffer(_gl.FRAMEBUFFER, null);
  }
  function setupRenderBufferStorage(renderbuffer, renderTarget, isMultisample) {
    _gl.bindRenderbuffer(_gl.RENDERBUFFER, renderbuffer);
    if (renderTarget.depthBuffer && !renderTarget.stencilBuffer) {
      let glInternalFormat = _gl.DEPTH_COMPONENT16;
      if (isMultisample || useMultisampledRTT(renderTarget)) {
        const depthTexture = renderTarget.depthTexture;
        if (depthTexture && depthTexture.isDepthTexture) {
          if (depthTexture.type === FloatType) {
            glInternalFormat = _gl.DEPTH_COMPONENT32F;
          } else if (depthTexture.type === UnsignedIntType) {
            glInternalFormat = _gl.DEPTH_COMPONENT24;
          }
        }
        const samples = getRenderTargetSamples(renderTarget);
        if (useMultisampledRTT(renderTarget)) {
          multisampledRTTExt.renderbufferStorageMultisampleEXT(_gl.RENDERBUFFER, samples, glInternalFormat, renderTarget.width, renderTarget.height);
        } else {
          _gl.renderbufferStorageMultisample(_gl.RENDERBUFFER, samples, glInternalFormat, renderTarget.width, renderTarget.height);
        }
      } else {
        _gl.renderbufferStorage(_gl.RENDERBUFFER, glInternalFormat, renderTarget.width, renderTarget.height);
      }
      _gl.framebufferRenderbuffer(_gl.FRAMEBUFFER, _gl.DEPTH_ATTACHMENT, _gl.RENDERBUFFER, renderbuffer);
    } else if (renderTarget.depthBuffer && renderTarget.stencilBuffer) {
      const samples = getRenderTargetSamples(renderTarget);
      if (isMultisample && useMultisampledRTT(renderTarget) === false) {
        _gl.renderbufferStorageMultisample(_gl.RENDERBUFFER, samples, _gl.DEPTH24_STENCIL8, renderTarget.width, renderTarget.height);
      } else if (useMultisampledRTT(renderTarget)) {
        multisampledRTTExt.renderbufferStorageMultisampleEXT(_gl.RENDERBUFFER, samples, _gl.DEPTH24_STENCIL8, renderTarget.width, renderTarget.height);
      } else {
        _gl.renderbufferStorage(_gl.RENDERBUFFER, _gl.DEPTH_STENCIL, renderTarget.width, renderTarget.height);
      }
      _gl.framebufferRenderbuffer(_gl.FRAMEBUFFER, _gl.DEPTH_STENCIL_ATTACHMENT, _gl.RENDERBUFFER, renderbuffer);
    } else {
      const textures = renderTarget.isWebGLMultipleRenderTargets === true ? renderTarget.texture : [renderTarget.texture];
      for (let i2 = 0; i2 < textures.length; i2++) {
        const texture = textures[i2];
        const glFormat = utils2.convert(texture.format, texture.colorSpace);
        const glType = utils2.convert(texture.type);
        const glInternalFormat = getInternalFormat(texture.internalFormat, glFormat, glType, texture.colorSpace);
        const samples = getRenderTargetSamples(renderTarget);
        if (isMultisample && useMultisampledRTT(renderTarget) === false) {
          _gl.renderbufferStorageMultisample(_gl.RENDERBUFFER, samples, glInternalFormat, renderTarget.width, renderTarget.height);
        } else if (useMultisampledRTT(renderTarget)) {
          multisampledRTTExt.renderbufferStorageMultisampleEXT(_gl.RENDERBUFFER, samples, glInternalFormat, renderTarget.width, renderTarget.height);
        } else {
          _gl.renderbufferStorage(_gl.RENDERBUFFER, glInternalFormat, renderTarget.width, renderTarget.height);
        }
      }
    }
    _gl.bindRenderbuffer(_gl.RENDERBUFFER, null);
  }
  function setupDepthTexture(framebuffer, renderTarget) {
    const isCube = renderTarget && renderTarget.isWebGLCubeRenderTarget;
    if (isCube) throw new Error("Depth Texture with cube render targets is not supported");
    state.bindFramebuffer(_gl.FRAMEBUFFER, framebuffer);
    if (!(renderTarget.depthTexture && renderTarget.depthTexture.isDepthTexture)) {
      throw new Error("renderTarget.depthTexture must be an instance of THREE.DepthTexture");
    }
    if (!properties.get(renderTarget.depthTexture).__webglTexture || renderTarget.depthTexture.image.width !== renderTarget.width || renderTarget.depthTexture.image.height !== renderTarget.height) {
      renderTarget.depthTexture.image.width = renderTarget.width;
      renderTarget.depthTexture.image.height = renderTarget.height;
      renderTarget.depthTexture.needsUpdate = true;
    }
    setTexture2D(renderTarget.depthTexture, 0);
    const webglDepthTexture = properties.get(renderTarget.depthTexture).__webglTexture;
    const samples = getRenderTargetSamples(renderTarget);
    if (renderTarget.depthTexture.format === DepthFormat) {
      if (useMultisampledRTT(renderTarget)) {
        multisampledRTTExt.framebufferTexture2DMultisampleEXT(_gl.FRAMEBUFFER, _gl.DEPTH_ATTACHMENT, _gl.TEXTURE_2D, webglDepthTexture, 0, samples);
      } else {
        _gl.framebufferTexture2D(_gl.FRAMEBUFFER, _gl.DEPTH_ATTACHMENT, _gl.TEXTURE_2D, webglDepthTexture, 0);
      }
    } else if (renderTarget.depthTexture.format === DepthStencilFormat) {
      if (useMultisampledRTT(renderTarget)) {
        multisampledRTTExt.framebufferTexture2DMultisampleEXT(_gl.FRAMEBUFFER, _gl.DEPTH_STENCIL_ATTACHMENT, _gl.TEXTURE_2D, webglDepthTexture, 0, samples);
      } else {
        _gl.framebufferTexture2D(_gl.FRAMEBUFFER, _gl.DEPTH_STENCIL_ATTACHMENT, _gl.TEXTURE_2D, webglDepthTexture, 0);
      }
    } else {
      throw new Error("Unknown depthTexture format");
    }
  }
  function setupDepthRenderbuffer(renderTarget) {
    const renderTargetProperties = properties.get(renderTarget);
    const isCube = renderTarget.isWebGLCubeRenderTarget === true;
    if (renderTarget.depthTexture && !renderTargetProperties.__autoAllocateDepthBuffer) {
      if (isCube) throw new Error("target.depthTexture not supported in Cube render targets");
      setupDepthTexture(renderTargetProperties.__webglFramebuffer, renderTarget);
    } else {
      if (isCube) {
        renderTargetProperties.__webglDepthbuffer = [];
        for (let i2 = 0; i2 < 6; i2++) {
          state.bindFramebuffer(_gl.FRAMEBUFFER, renderTargetProperties.__webglFramebuffer[i2]);
          renderTargetProperties.__webglDepthbuffer[i2] = _gl.createRenderbuffer();
          setupRenderBufferStorage(renderTargetProperties.__webglDepthbuffer[i2], renderTarget, false);
        }
      } else {
        state.bindFramebuffer(_gl.FRAMEBUFFER, renderTargetProperties.__webglFramebuffer);
        renderTargetProperties.__webglDepthbuffer = _gl.createRenderbuffer();
        setupRenderBufferStorage(renderTargetProperties.__webglDepthbuffer, renderTarget, false);
      }
    }
    state.bindFramebuffer(_gl.FRAMEBUFFER, null);
  }
  function rebindTextures(renderTarget, colorTexture, depthTexture) {
    const renderTargetProperties = properties.get(renderTarget);
    if (colorTexture !== void 0) {
      setupFrameBufferTexture(renderTargetProperties.__webglFramebuffer, renderTarget, renderTarget.texture, _gl.COLOR_ATTACHMENT0, _gl.TEXTURE_2D);
    }
    if (depthTexture !== void 0) {
      setupDepthRenderbuffer(renderTarget);
    }
  }
  function setupRenderTarget(renderTarget) {
    const texture = renderTarget.texture;
    const renderTargetProperties = properties.get(renderTarget);
    const textureProperties = properties.get(texture);
    renderTarget.addEventListener("dispose", onRenderTargetDispose);
    if (renderTarget.isWebGLMultipleRenderTargets !== true) {
      if (textureProperties.__webglTexture === void 0) {
        textureProperties.__webglTexture = _gl.createTexture();
      }
      textureProperties.__version = texture.version;
      info.memory.textures++;
    }
    const isCube = renderTarget.isWebGLCubeRenderTarget === true;
    const isMultipleRenderTargets = renderTarget.isWebGLMultipleRenderTargets === true;
    const supportsMips = isPowerOfTwo$1(renderTarget) || isWebGL2;
    if (isCube) {
      renderTargetProperties.__webglFramebuffer = [];
      for (let i2 = 0; i2 < 6; i2++) {
        renderTargetProperties.__webglFramebuffer[i2] = _gl.createFramebuffer();
      }
    } else {
      renderTargetProperties.__webglFramebuffer = _gl.createFramebuffer();
      if (isMultipleRenderTargets) {
        if (capabilities2.drawBuffers) {
          const textures = renderTarget.texture;
          for (let i2 = 0, il = textures.length; i2 < il; i2++) {
            const attachmentProperties = properties.get(textures[i2]);
            if (attachmentProperties.__webglTexture === void 0) {
              attachmentProperties.__webglTexture = _gl.createTexture();
              info.memory.textures++;
            }
          }
        } else {
          console.warn("THREE.WebGLRenderer: WebGLMultipleRenderTargets can only be used with WebGL2 or WEBGL_draw_buffers extension.");
        }
      }
      if (isWebGL2 && renderTarget.samples > 0 && useMultisampledRTT(renderTarget) === false) {
        const textures = isMultipleRenderTargets ? texture : [texture];
        renderTargetProperties.__webglMultisampledFramebuffer = _gl.createFramebuffer();
        renderTargetProperties.__webglColorRenderbuffer = [];
        state.bindFramebuffer(_gl.FRAMEBUFFER, renderTargetProperties.__webglMultisampledFramebuffer);
        for (let i2 = 0; i2 < textures.length; i2++) {
          const texture2 = textures[i2];
          renderTargetProperties.__webglColorRenderbuffer[i2] = _gl.createRenderbuffer();
          _gl.bindRenderbuffer(_gl.RENDERBUFFER, renderTargetProperties.__webglColorRenderbuffer[i2]);
          const glFormat = utils2.convert(texture2.format, texture2.colorSpace);
          const glType = utils2.convert(texture2.type);
          const glInternalFormat = getInternalFormat(texture2.internalFormat, glFormat, glType, texture2.colorSpace, renderTarget.isXRRenderTarget === true);
          const samples = getRenderTargetSamples(renderTarget);
          _gl.renderbufferStorageMultisample(_gl.RENDERBUFFER, samples, glInternalFormat, renderTarget.width, renderTarget.height);
          _gl.framebufferRenderbuffer(_gl.FRAMEBUFFER, _gl.COLOR_ATTACHMENT0 + i2, _gl.RENDERBUFFER, renderTargetProperties.__webglColorRenderbuffer[i2]);
        }
        _gl.bindRenderbuffer(_gl.RENDERBUFFER, null);
        if (renderTarget.depthBuffer) {
          renderTargetProperties.__webglDepthRenderbuffer = _gl.createRenderbuffer();
          setupRenderBufferStorage(renderTargetProperties.__webglDepthRenderbuffer, renderTarget, true);
        }
        state.bindFramebuffer(_gl.FRAMEBUFFER, null);
      }
    }
    if (isCube) {
      state.bindTexture(_gl.TEXTURE_CUBE_MAP, textureProperties.__webglTexture);
      setTextureParameters(_gl.TEXTURE_CUBE_MAP, texture, supportsMips);
      for (let i2 = 0; i2 < 6; i2++) {
        setupFrameBufferTexture(renderTargetProperties.__webglFramebuffer[i2], renderTarget, texture, _gl.COLOR_ATTACHMENT0, _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i2);
      }
      if (textureNeedsGenerateMipmaps(texture, supportsMips)) {
        generateMipmap(_gl.TEXTURE_CUBE_MAP);
      }
      state.unbindTexture();
    } else if (isMultipleRenderTargets) {
      const textures = renderTarget.texture;
      for (let i2 = 0, il = textures.length; i2 < il; i2++) {
        const attachment = textures[i2];
        const attachmentProperties = properties.get(attachment);
        state.bindTexture(_gl.TEXTURE_2D, attachmentProperties.__webglTexture);
        setTextureParameters(_gl.TEXTURE_2D, attachment, supportsMips);
        setupFrameBufferTexture(renderTargetProperties.__webglFramebuffer, renderTarget, attachment, _gl.COLOR_ATTACHMENT0 + i2, _gl.TEXTURE_2D);
        if (textureNeedsGenerateMipmaps(attachment, supportsMips)) {
          generateMipmap(_gl.TEXTURE_2D);
        }
      }
      state.unbindTexture();
    } else {
      let glTextureType = _gl.TEXTURE_2D;
      if (renderTarget.isWebGL3DRenderTarget || renderTarget.isWebGLArrayRenderTarget) {
        if (isWebGL2) {
          glTextureType = renderTarget.isWebGL3DRenderTarget ? _gl.TEXTURE_3D : _gl.TEXTURE_2D_ARRAY;
        } else {
          console.error("THREE.WebGLTextures: THREE.Data3DTexture and THREE.DataArrayTexture only supported with WebGL2.");
        }
      }
      state.bindTexture(glTextureType, textureProperties.__webglTexture);
      setTextureParameters(glTextureType, texture, supportsMips);
      setupFrameBufferTexture(renderTargetProperties.__webglFramebuffer, renderTarget, texture, _gl.COLOR_ATTACHMENT0, glTextureType);
      if (textureNeedsGenerateMipmaps(texture, supportsMips)) {
        generateMipmap(glTextureType);
      }
      state.unbindTexture();
    }
    if (renderTarget.depthBuffer) {
      setupDepthRenderbuffer(renderTarget);
    }
  }
  function updateRenderTargetMipmap(renderTarget) {
    const supportsMips = isPowerOfTwo$1(renderTarget) || isWebGL2;
    const textures = renderTarget.isWebGLMultipleRenderTargets === true ? renderTarget.texture : [renderTarget.texture];
    for (let i2 = 0, il = textures.length; i2 < il; i2++) {
      const texture = textures[i2];
      if (textureNeedsGenerateMipmaps(texture, supportsMips)) {
        const target = renderTarget.isWebGLCubeRenderTarget ? _gl.TEXTURE_CUBE_MAP : _gl.TEXTURE_2D;
        const webglTexture = properties.get(texture).__webglTexture;
        state.bindTexture(target, webglTexture);
        generateMipmap(target);
        state.unbindTexture();
      }
    }
  }
  function updateMultisampleRenderTarget(renderTarget) {
    if (isWebGL2 && renderTarget.samples > 0 && useMultisampledRTT(renderTarget) === false) {
      const textures = renderTarget.isWebGLMultipleRenderTargets ? renderTarget.texture : [renderTarget.texture];
      const width = renderTarget.width;
      const height = renderTarget.height;
      let mask = _gl.COLOR_BUFFER_BIT;
      const invalidationArray = [];
      const depthStyle = renderTarget.stencilBuffer ? _gl.DEPTH_STENCIL_ATTACHMENT : _gl.DEPTH_ATTACHMENT;
      const renderTargetProperties = properties.get(renderTarget);
      const isMultipleRenderTargets = renderTarget.isWebGLMultipleRenderTargets === true;
      if (isMultipleRenderTargets) {
        for (let i2 = 0; i2 < textures.length; i2++) {
          state.bindFramebuffer(_gl.FRAMEBUFFER, renderTargetProperties.__webglMultisampledFramebuffer);
          _gl.framebufferRenderbuffer(_gl.FRAMEBUFFER, _gl.COLOR_ATTACHMENT0 + i2, _gl.RENDERBUFFER, null);
          state.bindFramebuffer(_gl.FRAMEBUFFER, renderTargetProperties.__webglFramebuffer);
          _gl.framebufferTexture2D(_gl.DRAW_FRAMEBUFFER, _gl.COLOR_ATTACHMENT0 + i2, _gl.TEXTURE_2D, null, 0);
        }
      }
      state.bindFramebuffer(_gl.READ_FRAMEBUFFER, renderTargetProperties.__webglMultisampledFramebuffer);
      state.bindFramebuffer(_gl.DRAW_FRAMEBUFFER, renderTargetProperties.__webglFramebuffer);
      for (let i2 = 0; i2 < textures.length; i2++) {
        invalidationArray.push(_gl.COLOR_ATTACHMENT0 + i2);
        if (renderTarget.depthBuffer) {
          invalidationArray.push(depthStyle);
        }
        const ignoreDepthValues = renderTargetProperties.__ignoreDepthValues !== void 0 ? renderTargetProperties.__ignoreDepthValues : false;
        if (ignoreDepthValues === false) {
          if (renderTarget.depthBuffer) mask |= _gl.DEPTH_BUFFER_BIT;
          if (renderTarget.stencilBuffer) mask |= _gl.STENCIL_BUFFER_BIT;
        }
        if (isMultipleRenderTargets) {
          _gl.framebufferRenderbuffer(_gl.READ_FRAMEBUFFER, _gl.COLOR_ATTACHMENT0, _gl.RENDERBUFFER, renderTargetProperties.__webglColorRenderbuffer[i2]);
        }
        if (ignoreDepthValues === true) {
          _gl.invalidateFramebuffer(_gl.READ_FRAMEBUFFER, [depthStyle]);
          _gl.invalidateFramebuffer(_gl.DRAW_FRAMEBUFFER, [depthStyle]);
        }
        if (isMultipleRenderTargets) {
          const webglTexture = properties.get(textures[i2]).__webglTexture;
          _gl.framebufferTexture2D(_gl.DRAW_FRAMEBUFFER, _gl.COLOR_ATTACHMENT0, _gl.TEXTURE_2D, webglTexture, 0);
        }
        _gl.blitFramebuffer(0, 0, width, height, 0, 0, width, height, mask, _gl.NEAREST);
        if (supportsInvalidateFramebuffer) {
          _gl.invalidateFramebuffer(_gl.READ_FRAMEBUFFER, invalidationArray);
        }
      }
      state.bindFramebuffer(_gl.READ_FRAMEBUFFER, null);
      state.bindFramebuffer(_gl.DRAW_FRAMEBUFFER, null);
      if (isMultipleRenderTargets) {
        for (let i2 = 0; i2 < textures.length; i2++) {
          state.bindFramebuffer(_gl.FRAMEBUFFER, renderTargetProperties.__webglMultisampledFramebuffer);
          _gl.framebufferRenderbuffer(_gl.FRAMEBUFFER, _gl.COLOR_ATTACHMENT0 + i2, _gl.RENDERBUFFER, renderTargetProperties.__webglColorRenderbuffer[i2]);
          const webglTexture = properties.get(textures[i2]).__webglTexture;
          state.bindFramebuffer(_gl.FRAMEBUFFER, renderTargetProperties.__webglFramebuffer);
          _gl.framebufferTexture2D(_gl.DRAW_FRAMEBUFFER, _gl.COLOR_ATTACHMENT0 + i2, _gl.TEXTURE_2D, webglTexture, 0);
        }
      }
      state.bindFramebuffer(_gl.DRAW_FRAMEBUFFER, renderTargetProperties.__webglMultisampledFramebuffer);
    }
  }
  function getRenderTargetSamples(renderTarget) {
    return Math.min(maxSamples, renderTarget.samples);
  }
  function useMultisampledRTT(renderTarget) {
    const renderTargetProperties = properties.get(renderTarget);
    return isWebGL2 && renderTarget.samples > 0 && extensions.has("WEBGL_multisampled_render_to_texture") === true && renderTargetProperties.__useRenderToTexture !== false;
  }
  function updateVideoTexture(texture) {
    const frame = info.render.frame;
    if (_videoTextures.get(texture) !== frame) {
      _videoTextures.set(texture, frame);
      texture.update();
    }
  }
  function verifyColorSpace(texture, image) {
    const colorSpace = texture.colorSpace;
    const format = texture.format;
    const type = texture.type;
    if (texture.isCompressedTexture === true || texture.format === _SRGBAFormat) return image;
    if (colorSpace !== LinearSRGBColorSpace && colorSpace !== NoColorSpace) {
      if (colorSpace === SRGBColorSpace) {
        if (isWebGL2 === false) {
          if (extensions.has("EXT_sRGB") === true && format === RGBAFormat) {
            texture.format = _SRGBAFormat;
            texture.minFilter = LinearFilter;
            texture.generateMipmaps = false;
          } else {
            image = ImageUtils.sRGBToLinear(image);
          }
        } else {
          if (format !== RGBAFormat || type !== UnsignedByteType) {
            console.warn("THREE.WebGLTextures: sRGB encoded textures have to use RGBAFormat and UnsignedByteType.");
          }
        }
      } else {
        console.error("THREE.WebGLTextures: Unsupported texture color space:", colorSpace);
      }
    }
    return image;
  }
  this.allocateTextureUnit = allocateTextureUnit;
  this.resetTextureUnits = resetTextureUnits;
  this.setTexture2D = setTexture2D;
  this.setTexture2DArray = setTexture2DArray;
  this.setTexture3D = setTexture3D;
  this.setTextureCube = setTextureCube;
  this.rebindTextures = rebindTextures;
  this.setupRenderTarget = setupRenderTarget;
  this.updateRenderTargetMipmap = updateRenderTargetMipmap;
  this.updateMultisampleRenderTarget = updateMultisampleRenderTarget;
  this.setupDepthRenderbuffer = setupDepthRenderbuffer;
  this.setupFrameBufferTexture = setupFrameBufferTexture;
  this.useMultisampledRTT = useMultisampledRTT;
}
function WebGLUtils(gl, extensions, capabilities2) {
  const isWebGL2 = capabilities2.isWebGL2;
  function convert(p2, colorSpace = NoColorSpace) {
    let extension;
    if (p2 === UnsignedByteType) return gl.UNSIGNED_BYTE;
    if (p2 === UnsignedShort4444Type) return gl.UNSIGNED_SHORT_4_4_4_4;
    if (p2 === UnsignedShort5551Type) return gl.UNSIGNED_SHORT_5_5_5_1;
    if (p2 === ByteType) return gl.BYTE;
    if (p2 === ShortType) return gl.SHORT;
    if (p2 === UnsignedShortType) return gl.UNSIGNED_SHORT;
    if (p2 === IntType) return gl.INT;
    if (p2 === UnsignedIntType) return gl.UNSIGNED_INT;
    if (p2 === FloatType) return gl.FLOAT;
    if (p2 === HalfFloatType) {
      if (isWebGL2) return gl.HALF_FLOAT;
      extension = extensions.get("OES_texture_half_float");
      if (extension !== null) {
        return extension.HALF_FLOAT_OES;
      } else {
        return null;
      }
    }
    if (p2 === AlphaFormat) return gl.ALPHA;
    if (p2 === RGBAFormat) return gl.RGBA;
    if (p2 === LuminanceFormat) return gl.LUMINANCE;
    if (p2 === LuminanceAlphaFormat) return gl.LUMINANCE_ALPHA;
    if (p2 === DepthFormat) return gl.DEPTH_COMPONENT;
    if (p2 === DepthStencilFormat) return gl.DEPTH_STENCIL;
    if (p2 === _SRGBAFormat) {
      extension = extensions.get("EXT_sRGB");
      if (extension !== null) {
        return extension.SRGB_ALPHA_EXT;
      } else {
        return null;
      }
    }
    if (p2 === RedFormat) return gl.RED;
    if (p2 === RedIntegerFormat) return gl.RED_INTEGER;
    if (p2 === RGFormat) return gl.RG;
    if (p2 === RGIntegerFormat) return gl.RG_INTEGER;
    if (p2 === RGBAIntegerFormat) return gl.RGBA_INTEGER;
    if (p2 === RGB_S3TC_DXT1_Format || p2 === RGBA_S3TC_DXT1_Format || p2 === RGBA_S3TC_DXT3_Format || p2 === RGBA_S3TC_DXT5_Format) {
      if (colorSpace === SRGBColorSpace) {
        extension = extensions.get("WEBGL_compressed_texture_s3tc_srgb");
        if (extension !== null) {
          if (p2 === RGB_S3TC_DXT1_Format) return extension.COMPRESSED_SRGB_S3TC_DXT1_EXT;
          if (p2 === RGBA_S3TC_DXT1_Format) return extension.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT;
          if (p2 === RGBA_S3TC_DXT3_Format) return extension.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT;
          if (p2 === RGBA_S3TC_DXT5_Format) return extension.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT;
        } else {
          return null;
        }
      } else {
        extension = extensions.get("WEBGL_compressed_texture_s3tc");
        if (extension !== null) {
          if (p2 === RGB_S3TC_DXT1_Format) return extension.COMPRESSED_RGB_S3TC_DXT1_EXT;
          if (p2 === RGBA_S3TC_DXT1_Format) return extension.COMPRESSED_RGBA_S3TC_DXT1_EXT;
          if (p2 === RGBA_S3TC_DXT3_Format) return extension.COMPRESSED_RGBA_S3TC_DXT3_EXT;
          if (p2 === RGBA_S3TC_DXT5_Format) return extension.COMPRESSED_RGBA_S3TC_DXT5_EXT;
        } else {
          return null;
        }
      }
    }
    if (p2 === RGB_PVRTC_4BPPV1_Format || p2 === RGB_PVRTC_2BPPV1_Format || p2 === RGBA_PVRTC_4BPPV1_Format || p2 === RGBA_PVRTC_2BPPV1_Format) {
      extension = extensions.get("WEBGL_compressed_texture_pvrtc");
      if (extension !== null) {
        if (p2 === RGB_PVRTC_4BPPV1_Format) return extension.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
        if (p2 === RGB_PVRTC_2BPPV1_Format) return extension.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
        if (p2 === RGBA_PVRTC_4BPPV1_Format) return extension.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
        if (p2 === RGBA_PVRTC_2BPPV1_Format) return extension.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG;
      } else {
        return null;
      }
    }
    if (p2 === RGB_ETC1_Format) {
      extension = extensions.get("WEBGL_compressed_texture_etc1");
      if (extension !== null) {
        return extension.COMPRESSED_RGB_ETC1_WEBGL;
      } else {
        return null;
      }
    }
    if (p2 === RGB_ETC2_Format || p2 === RGBA_ETC2_EAC_Format) {
      extension = extensions.get("WEBGL_compressed_texture_etc");
      if (extension !== null) {
        if (p2 === RGB_ETC2_Format) return colorSpace === SRGBColorSpace ? extension.COMPRESSED_SRGB8_ETC2 : extension.COMPRESSED_RGB8_ETC2;
        if (p2 === RGBA_ETC2_EAC_Format) return colorSpace === SRGBColorSpace ? extension.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC : extension.COMPRESSED_RGBA8_ETC2_EAC;
      } else {
        return null;
      }
    }
    if (p2 === RGBA_ASTC_4x4_Format || p2 === RGBA_ASTC_5x4_Format || p2 === RGBA_ASTC_5x5_Format || p2 === RGBA_ASTC_6x5_Format || p2 === RGBA_ASTC_6x6_Format || p2 === RGBA_ASTC_8x5_Format || p2 === RGBA_ASTC_8x6_Format || p2 === RGBA_ASTC_8x8_Format || p2 === RGBA_ASTC_10x5_Format || p2 === RGBA_ASTC_10x6_Format || p2 === RGBA_ASTC_10x8_Format || p2 === RGBA_ASTC_10x10_Format || p2 === RGBA_ASTC_12x10_Format || p2 === RGBA_ASTC_12x12_Format) {
      extension = extensions.get("WEBGL_compressed_texture_astc");
      if (extension !== null) {
        if (p2 === RGBA_ASTC_4x4_Format) return colorSpace === SRGBColorSpace ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR : extension.COMPRESSED_RGBA_ASTC_4x4_KHR;
        if (p2 === RGBA_ASTC_5x4_Format) return colorSpace === SRGBColorSpace ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR : extension.COMPRESSED_RGBA_ASTC_5x4_KHR;
        if (p2 === RGBA_ASTC_5x5_Format) return colorSpace === SRGBColorSpace ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR : extension.COMPRESSED_RGBA_ASTC_5x5_KHR;
        if (p2 === RGBA_ASTC_6x5_Format) return colorSpace === SRGBColorSpace ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR : extension.COMPRESSED_RGBA_ASTC_6x5_KHR;
        if (p2 === RGBA_ASTC_6x6_Format) return colorSpace === SRGBColorSpace ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR : extension.COMPRESSED_RGBA_ASTC_6x6_KHR;
        if (p2 === RGBA_ASTC_8x5_Format) return colorSpace === SRGBColorSpace ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR : extension.COMPRESSED_RGBA_ASTC_8x5_KHR;
        if (p2 === RGBA_ASTC_8x6_Format) return colorSpace === SRGBColorSpace ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR : extension.COMPRESSED_RGBA_ASTC_8x6_KHR;
        if (p2 === RGBA_ASTC_8x8_Format) return colorSpace === SRGBColorSpace ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR : extension.COMPRESSED_RGBA_ASTC_8x8_KHR;
        if (p2 === RGBA_ASTC_10x5_Format) return colorSpace === SRGBColorSpace ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR : extension.COMPRESSED_RGBA_ASTC_10x5_KHR;
        if (p2 === RGBA_ASTC_10x6_Format) return colorSpace === SRGBColorSpace ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR : extension.COMPRESSED_RGBA_ASTC_10x6_KHR;
        if (p2 === RGBA_ASTC_10x8_Format) return colorSpace === SRGBColorSpace ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR : extension.COMPRESSED_RGBA_ASTC_10x8_KHR;
        if (p2 === RGBA_ASTC_10x10_Format) return colorSpace === SRGBColorSpace ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR : extension.COMPRESSED_RGBA_ASTC_10x10_KHR;
        if (p2 === RGBA_ASTC_12x10_Format) return colorSpace === SRGBColorSpace ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR : extension.COMPRESSED_RGBA_ASTC_12x10_KHR;
        if (p2 === RGBA_ASTC_12x12_Format) return colorSpace === SRGBColorSpace ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR : extension.COMPRESSED_RGBA_ASTC_12x12_KHR;
      } else {
        return null;
      }
    }
    if (p2 === RGBA_BPTC_Format) {
      extension = extensions.get("EXT_texture_compression_bptc");
      if (extension !== null) {
        if (p2 === RGBA_BPTC_Format) return colorSpace === SRGBColorSpace ? extension.COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT : extension.COMPRESSED_RGBA_BPTC_UNORM_EXT;
      } else {
        return null;
      }
    }
    if (p2 === RED_RGTC1_Format || p2 === SIGNED_RED_RGTC1_Format || p2 === RED_GREEN_RGTC2_Format || p2 === SIGNED_RED_GREEN_RGTC2_Format) {
      extension = extensions.get("EXT_texture_compression_rgtc");
      if (extension !== null) {
        if (p2 === RGBA_BPTC_Format) return extension.COMPRESSED_RED_RGTC1_EXT;
        if (p2 === SIGNED_RED_RGTC1_Format) return extension.COMPRESSED_SIGNED_RED_RGTC1_EXT;
        if (p2 === RED_GREEN_RGTC2_Format) return extension.COMPRESSED_RED_GREEN_RGTC2_EXT;
        if (p2 === SIGNED_RED_GREEN_RGTC2_Format) return extension.COMPRESSED_SIGNED_RED_GREEN_RGTC2_EXT;
      } else {
        return null;
      }
    }
    if (p2 === UnsignedInt248Type) {
      if (isWebGL2) return gl.UNSIGNED_INT_24_8;
      extension = extensions.get("WEBGL_depth_texture");
      if (extension !== null) {
        return extension.UNSIGNED_INT_24_8_WEBGL;
      } else {
        return null;
      }
    }
    return gl[p2] !== void 0 ? gl[p2] : null;
  }
  return { convert };
}
var ArrayCamera = class extends PerspectiveCamera {
  constructor(array = []) {
    super();
    this.isArrayCamera = true;
    this.cameras = array;
  }
};
var Group = class extends Object3D {
  constructor() {
    super();
    this.isGroup = true;
    this.type = "Group";
  }
};
var _moveEvent = { type: "move" };
var WebXRController = class {
  constructor() {
    this._targetRay = null;
    this._grip = null;
    this._hand = null;
  }
  getHandSpace() {
    if (this._hand === null) {
      this._hand = new Group();
      this._hand.matrixAutoUpdate = false;
      this._hand.visible = false;
      this._hand.joints = {};
      this._hand.inputState = { pinching: false };
    }
    return this._hand;
  }
  getTargetRaySpace() {
    if (this._targetRay === null) {
      this._targetRay = new Group();
      this._targetRay.matrixAutoUpdate = false;
      this._targetRay.visible = false;
      this._targetRay.hasLinearVelocity = false;
      this._targetRay.linearVelocity = new Vector3();
      this._targetRay.hasAngularVelocity = false;
      this._targetRay.angularVelocity = new Vector3();
    }
    return this._targetRay;
  }
  getGripSpace() {
    if (this._grip === null) {
      this._grip = new Group();
      this._grip.matrixAutoUpdate = false;
      this._grip.visible = false;
      this._grip.hasLinearVelocity = false;
      this._grip.linearVelocity = new Vector3();
      this._grip.hasAngularVelocity = false;
      this._grip.angularVelocity = new Vector3();
    }
    return this._grip;
  }
  dispatchEvent(event) {
    if (this._targetRay !== null) {
      this._targetRay.dispatchEvent(event);
    }
    if (this._grip !== null) {
      this._grip.dispatchEvent(event);
    }
    if (this._hand !== null) {
      this._hand.dispatchEvent(event);
    }
    return this;
  }
  connect(inputSource) {
    if (inputSource && inputSource.hand) {
      const hand = this._hand;
      if (hand) {
        for (const inputjoint of inputSource.hand.values()) {
          this._getHandJoint(hand, inputjoint);
        }
      }
    }
    this.dispatchEvent({ type: "connected", data: inputSource });
    return this;
  }
  disconnect(inputSource) {
    this.dispatchEvent({ type: "disconnected", data: inputSource });
    if (this._targetRay !== null) {
      this._targetRay.visible = false;
    }
    if (this._grip !== null) {
      this._grip.visible = false;
    }
    if (this._hand !== null) {
      this._hand.visible = false;
    }
    return this;
  }
  update(inputSource, frame, referenceSpace) {
    let inputPose = null;
    let gripPose = null;
    let handPose = null;
    const targetRay = this._targetRay;
    const grip = this._grip;
    const hand = this._hand;
    if (inputSource && frame.session.visibilityState !== "visible-blurred") {
      if (hand && inputSource.hand) {
        handPose = true;
        for (const inputjoint of inputSource.hand.values()) {
          const jointPose = frame.getJointPose(inputjoint, referenceSpace);
          const joint = this._getHandJoint(hand, inputjoint);
          if (jointPose !== null) {
            joint.matrix.fromArray(jointPose.transform.matrix);
            joint.matrix.decompose(joint.position, joint.rotation, joint.scale);
            joint.matrixWorldNeedsUpdate = true;
            joint.jointRadius = jointPose.radius;
          }
          joint.visible = jointPose !== null;
        }
        const indexTip = hand.joints["index-finger-tip"];
        const thumbTip = hand.joints["thumb-tip"];
        const distance = indexTip.position.distanceTo(thumbTip.position);
        const distanceToPinch = 0.02;
        const threshold = 5e-3;
        if (hand.inputState.pinching && distance > distanceToPinch + threshold) {
          hand.inputState.pinching = false;
          this.dispatchEvent({
            type: "pinchend",
            handedness: inputSource.handedness,
            target: this
          });
        } else if (!hand.inputState.pinching && distance <= distanceToPinch - threshold) {
          hand.inputState.pinching = true;
          this.dispatchEvent({
            type: "pinchstart",
            handedness: inputSource.handedness,
            target: this
          });
        }
      } else {
        if (grip !== null && inputSource.gripSpace) {
          gripPose = frame.getPose(inputSource.gripSpace, referenceSpace);
          if (gripPose !== null) {
            grip.matrix.fromArray(gripPose.transform.matrix);
            grip.matrix.decompose(grip.position, grip.rotation, grip.scale);
            grip.matrixWorldNeedsUpdate = true;
            if (gripPose.linearVelocity) {
              grip.hasLinearVelocity = true;
              grip.linearVelocity.copy(gripPose.linearVelocity);
            } else {
              grip.hasLinearVelocity = false;
            }
            if (gripPose.angularVelocity) {
              grip.hasAngularVelocity = true;
              grip.angularVelocity.copy(gripPose.angularVelocity);
            } else {
              grip.hasAngularVelocity = false;
            }
          }
        }
      }
      if (targetRay !== null) {
        inputPose = frame.getPose(inputSource.targetRaySpace, referenceSpace);
        if (inputPose === null && gripPose !== null) {
          inputPose = gripPose;
        }
        if (inputPose !== null) {
          targetRay.matrix.fromArray(inputPose.transform.matrix);
          targetRay.matrix.decompose(targetRay.position, targetRay.rotation, targetRay.scale);
          targetRay.matrixWorldNeedsUpdate = true;
          if (inputPose.linearVelocity) {
            targetRay.hasLinearVelocity = true;
            targetRay.linearVelocity.copy(inputPose.linearVelocity);
          } else {
            targetRay.hasLinearVelocity = false;
          }
          if (inputPose.angularVelocity) {
            targetRay.hasAngularVelocity = true;
            targetRay.angularVelocity.copy(inputPose.angularVelocity);
          } else {
            targetRay.hasAngularVelocity = false;
          }
          this.dispatchEvent(_moveEvent);
        }
      }
    }
    if (targetRay !== null) {
      targetRay.visible = inputPose !== null;
    }
    if (grip !== null) {
      grip.visible = gripPose !== null;
    }
    if (hand !== null) {
      hand.visible = handPose !== null;
    }
    return this;
  }
  // private method
  _getHandJoint(hand, inputjoint) {
    if (hand.joints[inputjoint.jointName] === void 0) {
      const joint = new Group();
      joint.matrixAutoUpdate = false;
      joint.visible = false;
      hand.joints[inputjoint.jointName] = joint;
      hand.add(joint);
    }
    return hand.joints[inputjoint.jointName];
  }
};
var DepthTexture = class extends Texture {
  constructor(width, height, type, mapping, wrapS, wrapT, magFilter, minFilter, anisotropy, format) {
    format = format !== void 0 ? format : DepthFormat;
    if (format !== DepthFormat && format !== DepthStencilFormat) {
      throw new Error("DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat");
    }
    if (type === void 0 && format === DepthFormat) type = UnsignedIntType;
    if (type === void 0 && format === DepthStencilFormat) type = UnsignedInt248Type;
    super(null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy);
    this.isDepthTexture = true;
    this.image = { width, height };
    this.magFilter = magFilter !== void 0 ? magFilter : NearestFilter;
    this.minFilter = minFilter !== void 0 ? minFilter : NearestFilter;
    this.flipY = false;
    this.generateMipmaps = false;
    this.compareFunction = null;
  }
  copy(source) {
    super.copy(source);
    this.compareFunction = source.compareFunction;
    return this;
  }
  toJSON(meta) {
    const data = super.toJSON(meta);
    if (this.compareFunction !== null) data.compareFunction = this.compareFunction;
    return data;
  }
};
var WebXRManager = class extends EventDispatcher {
  constructor(renderer, gl) {
    super();
    const scope = this;
    let session = null;
    let framebufferScaleFactor = 1;
    let referenceSpace = null;
    let referenceSpaceType = "local-floor";
    let foveation = 1;
    let customReferenceSpace = null;
    let pose = null;
    let glBinding = null;
    let glProjLayer = null;
    let glBaseLayer = null;
    let xrFrame = null;
    const attributes = gl.getContextAttributes();
    let initialRenderTarget = null;
    let newRenderTarget = null;
    const controllers = [];
    const controllerInputSources = [];
    let userCamera = null;
    const cameraL = new PerspectiveCamera();
    cameraL.layers.enable(1);
    cameraL.viewport = new Vector4();
    const cameraR = new PerspectiveCamera();
    cameraR.layers.enable(2);
    cameraR.viewport = new Vector4();
    const cameras = [cameraL, cameraR];
    const cameraXR = new ArrayCamera();
    cameraXR.layers.enable(1);
    cameraXR.layers.enable(2);
    let _currentDepthNear = null;
    let _currentDepthFar = null;
    this.cameraAutoUpdate = true;
    this.enabled = false;
    this.isPresenting = false;
    this.getCamera = function() {
    };
    this.setUserCamera = function(value) {
      userCamera = value;
    };
    this.getController = function(index) {
      let controller = controllers[index];
      if (controller === void 0) {
        controller = new WebXRController();
        controllers[index] = controller;
      }
      return controller.getTargetRaySpace();
    };
    this.getControllerGrip = function(index) {
      let controller = controllers[index];
      if (controller === void 0) {
        controller = new WebXRController();
        controllers[index] = controller;
      }
      return controller.getGripSpace();
    };
    this.getHand = function(index) {
      let controller = controllers[index];
      if (controller === void 0) {
        controller = new WebXRController();
        controllers[index] = controller;
      }
      return controller.getHandSpace();
    };
    function onSessionEvent(event) {
      const controllerIndex = controllerInputSources.indexOf(event.inputSource);
      if (controllerIndex === -1) {
        return;
      }
      const controller = controllers[controllerIndex];
      if (controller !== void 0) {
        controller.update(event.inputSource, event.frame, customReferenceSpace || referenceSpace);
        controller.dispatchEvent({ type: event.type, data: event.inputSource });
      }
    }
    function onSessionEnd() {
      session.removeEventListener("select", onSessionEvent);
      session.removeEventListener("selectstart", onSessionEvent);
      session.removeEventListener("selectend", onSessionEvent);
      session.removeEventListener("squeeze", onSessionEvent);
      session.removeEventListener("squeezestart", onSessionEvent);
      session.removeEventListener("squeezeend", onSessionEvent);
      session.removeEventListener("end", onSessionEnd);
      session.removeEventListener("inputsourceschange", onInputSourcesChange);
      for (let i2 = 0; i2 < controllers.length; i2++) {
        const inputSource = controllerInputSources[i2];
        if (inputSource === null) continue;
        controllerInputSources[i2] = null;
        controllers[i2].disconnect(inputSource);
      }
      _currentDepthNear = null;
      _currentDepthFar = null;
      renderer.setRenderTarget(initialRenderTarget);
      glBaseLayer = null;
      glProjLayer = null;
      glBinding = null;
      session = null;
      newRenderTarget = null;
      animation.stop();
      scope.isPresenting = false;
      scope.dispatchEvent({ type: "sessionend" });
    }
    this.setFramebufferScaleFactor = function(value) {
      framebufferScaleFactor = value;
      if (scope.isPresenting === true) {
        console.warn("THREE.WebXRManager: Cannot change framebuffer scale while presenting.");
      }
    };
    this.setReferenceSpaceType = function(value) {
      referenceSpaceType = value;
      if (scope.isPresenting === true) {
        console.warn("THREE.WebXRManager: Cannot change reference space type while presenting.");
      }
    };
    this.getReferenceSpace = function() {
      return customReferenceSpace || referenceSpace;
    };
    this.setReferenceSpace = function(space) {
      customReferenceSpace = space;
    };
    this.getBaseLayer = function() {
      return glProjLayer !== null ? glProjLayer : glBaseLayer;
    };
    this.getBinding = function() {
      return glBinding;
    };
    this.getFrame = function() {
      return xrFrame;
    };
    this.getSession = function() {
      return session;
    };
    this.setSession = async function(value) {
      session = value;
      if (session !== null) {
        initialRenderTarget = renderer.getRenderTarget();
        session.addEventListener("select", onSessionEvent);
        session.addEventListener("selectstart", onSessionEvent);
        session.addEventListener("selectend", onSessionEvent);
        session.addEventListener("squeeze", onSessionEvent);
        session.addEventListener("squeezestart", onSessionEvent);
        session.addEventListener("squeezeend", onSessionEvent);
        session.addEventListener("end", onSessionEnd);
        session.addEventListener("inputsourceschange", onInputSourcesChange);
        if (attributes.xrCompatible !== true) {
          await gl.makeXRCompatible();
        }
        if (session.renderState.layers === void 0 || renderer.capabilities.isWebGL2 === false) {
          const layerInit = {
            antialias: session.renderState.layers === void 0 ? attributes.antialias : true,
            alpha: true,
            depth: attributes.depth,
            stencil: attributes.stencil,
            framebufferScaleFactor
          };
          glBaseLayer = new XRWebGLLayer(session, gl, layerInit);
          session.updateRenderState({ baseLayer: glBaseLayer });
          newRenderTarget = new WebGLRenderTarget(
            glBaseLayer.framebufferWidth,
            glBaseLayer.framebufferHeight,
            {
              format: RGBAFormat,
              type: UnsignedByteType,
              colorSpace: renderer.outputColorSpace,
              stencilBuffer: attributes.stencil
            }
          );
        } else {
          let depthFormat = null;
          let depthType = null;
          let glDepthFormat = null;
          if (attributes.depth) {
            glDepthFormat = attributes.stencil ? gl.DEPTH24_STENCIL8 : gl.DEPTH_COMPONENT24;
            depthFormat = attributes.stencil ? DepthStencilFormat : DepthFormat;
            depthType = attributes.stencil ? UnsignedInt248Type : UnsignedIntType;
          }
          const projectionlayerInit = {
            colorFormat: gl.RGBA8,
            depthFormat: glDepthFormat,
            scaleFactor: framebufferScaleFactor
          };
          glBinding = new XRWebGLBinding(session, gl);
          glProjLayer = glBinding.createProjectionLayer(projectionlayerInit);
          session.updateRenderState({ layers: [glProjLayer] });
          newRenderTarget = new WebGLRenderTarget(
            glProjLayer.textureWidth,
            glProjLayer.textureHeight,
            {
              format: RGBAFormat,
              type: UnsignedByteType,
              depthTexture: new DepthTexture(glProjLayer.textureWidth, glProjLayer.textureHeight, depthType, void 0, void 0, void 0, void 0, void 0, void 0, depthFormat),
              stencilBuffer: attributes.stencil,
              colorSpace: renderer.outputColorSpace,
              samples: attributes.antialias ? 4 : 0
            }
          );
          const renderTargetProperties = renderer.properties.get(newRenderTarget);
          renderTargetProperties.__ignoreDepthValues = glProjLayer.ignoreDepthValues;
        }
        newRenderTarget.isXRRenderTarget = true;
        this.setFoveation(foveation);
        customReferenceSpace = null;
        referenceSpace = await session.requestReferenceSpace(referenceSpaceType);
        animation.setContext(session);
        animation.start();
        scope.isPresenting = true;
        scope.dispatchEvent({ type: "sessionstart" });
      }
    };
    this.getEnvironmentBlendMode = function() {
      if (session !== null) {
        return session.environmentBlendMode;
      }
    };
    function onInputSourcesChange(event) {
      for (let i2 = 0; i2 < event.removed.length; i2++) {
        const inputSource = event.removed[i2];
        const index = controllerInputSources.indexOf(inputSource);
        if (index >= 0) {
          controllerInputSources[index] = null;
          controllers[index].disconnect(inputSource);
        }
      }
      for (let i2 = 0; i2 < event.added.length; i2++) {
        const inputSource = event.added[i2];
        let controllerIndex = controllerInputSources.indexOf(inputSource);
        if (controllerIndex === -1) {
          for (let i3 = 0; i3 < controllers.length; i3++) {
            if (i3 >= controllerInputSources.length) {
              controllerInputSources.push(inputSource);
              controllerIndex = i3;
              break;
            } else if (controllerInputSources[i3] === null) {
              controllerInputSources[i3] = inputSource;
              controllerIndex = i3;
              break;
            }
          }
          if (controllerIndex === -1) break;
        }
        const controller = controllers[controllerIndex];
        if (controller) {
          controller.connect(inputSource);
        }
      }
    }
    const cameraLPos = new Vector3();
    const cameraRPos = new Vector3();
    function setProjectionFromUnion(camera, cameraL2, cameraR2) {
      cameraLPos.setFromMatrixPosition(cameraL2.matrixWorld);
      cameraRPos.setFromMatrixPosition(cameraR2.matrixWorld);
      const ipd = cameraLPos.distanceTo(cameraRPos);
      const projL = cameraL2.projectionMatrix.elements;
      const projR = cameraR2.projectionMatrix.elements;
      const near = projL[14] / (projL[10] - 1);
      const far = projL[14] / (projL[10] + 1);
      const topFov = (projL[9] + 1) / projL[5];
      const bottomFov = (projL[9] - 1) / projL[5];
      const leftFov = (projL[8] - 1) / projL[0];
      const rightFov = (projR[8] + 1) / projR[0];
      const left = near * leftFov;
      const right = near * rightFov;
      const zOffset = ipd / (-leftFov + rightFov);
      const xOffset = zOffset * -leftFov;
      cameraL2.matrixWorld.decompose(camera.position, camera.quaternion, camera.scale);
      camera.translateX(xOffset);
      camera.translateZ(zOffset);
      camera.matrixWorld.compose(camera.position, camera.quaternion, camera.scale);
      camera.matrixWorldInverse.copy(camera.matrixWorld).invert();
      const near2 = near + zOffset;
      const far2 = far + zOffset;
      const left2 = left - xOffset;
      const right2 = right + (ipd - xOffset);
      const top2 = topFov * far / far2 * near2;
      const bottom2 = bottomFov * far / far2 * near2;
      camera.projectionMatrix.makePerspective(left2, right2, top2, bottom2, near2, far2);
      camera.projectionMatrixInverse.copy(camera.projectionMatrix).invert();
    }
    function updateCamera(camera, parent) {
      if (parent === null) {
        camera.matrixWorld.copy(camera.matrix);
      } else {
        camera.matrixWorld.multiplyMatrices(parent.matrixWorld, camera.matrix);
      }
      camera.matrixWorldInverse.copy(camera.matrixWorld).invert();
    }
    this.updateCameraXR = function(camera) {
      if (session === null) return camera;
      if (userCamera) {
        camera = userCamera;
      }
      cameraXR.near = cameraR.near = cameraL.near = camera.near;
      cameraXR.far = cameraR.far = cameraL.far = camera.far;
      if (_currentDepthNear !== cameraXR.near || _currentDepthFar !== cameraXR.far) {
        session.updateRenderState({
          depthNear: cameraXR.near,
          depthFar: cameraXR.far
        });
        _currentDepthNear = cameraXR.near;
        _currentDepthFar = cameraXR.far;
      }
      const parent = camera.parent;
      const cameras2 = cameraXR.cameras;
      updateCamera(cameraXR, parent);
      for (let i2 = 0; i2 < cameras2.length; i2++) {
        updateCamera(cameras2[i2], parent);
      }
      if (cameras2.length === 2) {
        setProjectionFromUnion(cameraXR, cameraL, cameraR);
      } else {
        cameraXR.projectionMatrix.copy(cameraL.projectionMatrix);
      }
      if (userCamera) {
        updateUserCamera(cameraXR, parent);
      }
      return cameraXR;
    };
    function updateUserCamera(cameraXR2, parent) {
      const camera = userCamera;
      if (parent === null) {
        camera.matrix.copy(cameraXR2.matrixWorld);
      } else {
        camera.matrix.copy(parent.matrixWorld);
        camera.matrix.invert();
        camera.matrix.multiply(cameraXR2.matrixWorld);
      }
      camera.matrix.decompose(camera.position, camera.quaternion, camera.scale);
      camera.updateMatrixWorld(true);
      const children = camera.children;
      for (let i2 = 0, l2 = children.length; i2 < l2; i2++) {
        children[i2].updateMatrixWorld(true);
      }
      camera.projectionMatrix.copy(cameraXR2.projectionMatrix);
      camera.projectionMatrixInverse.copy(cameraXR2.projectionMatrixInverse);
      if (camera.isPerspectiveCamera) {
        camera.fov = RAD2DEG * 2 * Math.atan(1 / camera.projectionMatrix.elements[5]);
        camera.zoom = 1;
      }
    }
    this.getFoveation = function() {
      if (glProjLayer === null && glBaseLayer === null) {
        return void 0;
      }
      return foveation;
    };
    this.setFoveation = function(value) {
      foveation = value;
      if (glProjLayer !== null) {
        glProjLayer.fixedFoveation = value;
      }
      if (glBaseLayer !== null && glBaseLayer.fixedFoveation !== void 0) {
        glBaseLayer.fixedFoveation = value;
      }
    };
    let onAnimationFrameCallback = null;
    function onAnimationFrame(time, frame) {
      pose = frame.getViewerPose(customReferenceSpace || referenceSpace);
      xrFrame = frame;
      if (pose !== null) {
        const views = pose.views;
        if (glBaseLayer !== null) {
          renderer.setRenderTargetFramebuffer(newRenderTarget, glBaseLayer.framebuffer);
          renderer.setRenderTarget(newRenderTarget);
        }
        let cameraXRNeedsUpdate = false;
        if (views.length !== cameraXR.cameras.length) {
          cameraXR.cameras.length = 0;
          cameraXRNeedsUpdate = true;
        }
        for (let i2 = 0; i2 < views.length; i2++) {
          const view = views[i2];
          let viewport = null;
          if (glBaseLayer !== null) {
            viewport = glBaseLayer.getViewport(view);
          } else {
            const glSubImage = glBinding.getViewSubImage(glProjLayer, view);
            viewport = glSubImage.viewport;
            if (i2 === 0) {
              renderer.setRenderTargetTextures(
                newRenderTarget,
                glSubImage.colorTexture,
                glProjLayer.ignoreDepthValues ? void 0 : glSubImage.depthStencilTexture
              );
              renderer.setRenderTarget(newRenderTarget);
            }
          }
          let camera = cameras[i2];
          if (camera === void 0) {
            camera = new PerspectiveCamera();
            camera.layers.enable(i2);
            camera.viewport = new Vector4();
            cameras[i2] = camera;
          }
          camera.matrix.fromArray(view.transform.matrix);
          camera.matrix.decompose(camera.position, camera.quaternion, camera.scale);
          camera.projectionMatrix.fromArray(view.projectionMatrix);
          camera.projectionMatrixInverse.copy(camera.projectionMatrix).invert();
          camera.viewport.set(viewport.x, viewport.y, viewport.width, viewport.height);
          if (i2 === 0) {
            cameraXR.matrix.copy(camera.matrix);
            cameraXR.matrix.decompose(cameraXR.position, cameraXR.quaternion, cameraXR.scale);
          }
          if (cameraXRNeedsUpdate === true) {
            cameraXR.cameras.push(camera);
          }
        }
      }
      for (let i2 = 0; i2 < controllers.length; i2++) {
        const inputSource = controllerInputSources[i2];
        const controller = controllers[i2];
        if (inputSource !== null && controller !== void 0) {
          controller.update(inputSource, frame, customReferenceSpace || referenceSpace);
        }
      }
      if (onAnimationFrameCallback) onAnimationFrameCallback(time, frame);
      if (frame.detectedPlanes) {
        scope.dispatchEvent({ type: "planesdetected", data: frame });
      }
      xrFrame = null;
    }
    const animation = new WebGLAnimation();
    animation.setAnimationLoop(onAnimationFrame);
    this.setAnimationLoop = function(callback) {
      onAnimationFrameCallback = callback;
    };
    this.dispose = function() {
    };
  }
};
function WebGLMaterials(renderer, properties) {
  function refreshTransformUniform(map, uniform) {
    if (map.matrixAutoUpdate === true) {
      map.updateMatrix();
    }
    uniform.value.copy(map.matrix);
  }
  function refreshFogUniforms(uniforms, fog) {
    fog.color.getRGB(uniforms.fogColor.value, getUnlitUniformColorSpace(renderer));
    if (fog.isFog) {
      uniforms.fogNear.value = fog.near;
      uniforms.fogFar.value = fog.far;
    } else if (fog.isFogExp2) {
      uniforms.fogDensity.value = fog.density;
    }
  }
  function refreshMaterialUniforms(uniforms, material, pixelRatio, height, transmissionRenderTarget) {
    if (material.isMeshBasicMaterial) {
      refreshUniformsCommon(uniforms, material);
    } else if (material.isMeshLambertMaterial) {
      refreshUniformsCommon(uniforms, material);
    } else if (material.isMeshToonMaterial) {
      refreshUniformsCommon(uniforms, material);
      refreshUniformsToon(uniforms, material);
    } else if (material.isMeshPhongMaterial) {
      refreshUniformsCommon(uniforms, material);
      refreshUniformsPhong(uniforms, material);
    } else if (material.isMeshStandardMaterial) {
      refreshUniformsCommon(uniforms, material);
      refreshUniformsStandard(uniforms, material);
      if (material.isMeshPhysicalMaterial) {
        refreshUniformsPhysical(uniforms, material, transmissionRenderTarget);
      }
    } else if (material.isMeshMatcapMaterial) {
      refreshUniformsCommon(uniforms, material);
      refreshUniformsMatcap(uniforms, material);
    } else if (material.isMeshDepthMaterial) {
      refreshUniformsCommon(uniforms, material);
    } else if (material.isMeshDistanceMaterial) {
      refreshUniformsCommon(uniforms, material);
      refreshUniformsDistance(uniforms, material);
    } else if (material.isMeshNormalMaterial) {
      refreshUniformsCommon(uniforms, material);
    } else if (material.isLineBasicMaterial) {
      refreshUniformsLine(uniforms, material);
      if (material.isLineDashedMaterial) {
        refreshUniformsDash(uniforms, material);
      }
    } else if (material.isPointsMaterial) {
      refreshUniformsPoints(uniforms, material, pixelRatio, height);
    } else if (material.isSpriteMaterial) {
      refreshUniformsSprites(uniforms, material);
    } else if (material.isShadowMaterial) {
      uniforms.color.value.copy(material.color);
      uniforms.opacity.value = material.opacity;
    } else if (material.isShaderMaterial) {
      material.uniformsNeedUpdate = false;
    }
  }
  function refreshUniformsCommon(uniforms, material) {
    uniforms.opacity.value = material.opacity;
    if (material.color) {
      uniforms.diffuse.value.copy(material.color);
    }
    if (material.emissive) {
      uniforms.emissive.value.copy(material.emissive).multiplyScalar(material.emissiveIntensity);
    }
    if (material.map) {
      uniforms.map.value = material.map;
      refreshTransformUniform(material.map, uniforms.mapTransform);
    }
    if (material.alphaMap) {
      uniforms.alphaMap.value = material.alphaMap;
      refreshTransformUniform(material.alphaMap, uniforms.alphaMapTransform);
    }
    if (material.bumpMap) {
      uniforms.bumpMap.value = material.bumpMap;
      refreshTransformUniform(material.bumpMap, uniforms.bumpMapTransform);
      uniforms.bumpScale.value = material.bumpScale;
      if (material.side === BackSide) {
        uniforms.bumpScale.value *= -1;
      }
    }
    if (material.normalMap) {
      uniforms.normalMap.value = material.normalMap;
      refreshTransformUniform(material.normalMap, uniforms.normalMapTransform);
      uniforms.normalScale.value.copy(material.normalScale);
      if (material.side === BackSide) {
        uniforms.normalScale.value.negate();
      }
    }
    if (material.displacementMap) {
      uniforms.displacementMap.value = material.displacementMap;
      refreshTransformUniform(material.displacementMap, uniforms.displacementMapTransform);
      uniforms.displacementScale.value = material.displacementScale;
      uniforms.displacementBias.value = material.displacementBias;
    }
    if (material.emissiveMap) {
      uniforms.emissiveMap.value = material.emissiveMap;
      refreshTransformUniform(material.emissiveMap, uniforms.emissiveMapTransform);
    }
    if (material.specularMap) {
      uniforms.specularMap.value = material.specularMap;
      refreshTransformUniform(material.specularMap, uniforms.specularMapTransform);
    }
    if (material.alphaTest > 0) {
      uniforms.alphaTest.value = material.alphaTest;
    }
    const envMap = properties.get(material).envMap;
    if (envMap) {
      uniforms.envMap.value = envMap;
      uniforms.flipEnvMap.value = envMap.isCubeTexture && envMap.isRenderTargetTexture === false ? -1 : 1;
      uniforms.reflectivity.value = material.reflectivity;
      uniforms.ior.value = material.ior;
      uniforms.refractionRatio.value = material.refractionRatio;
    }
    if (material.lightMap) {
      uniforms.lightMap.value = material.lightMap;
      const scaleFactor = renderer.useLegacyLights === true ? Math.PI : 1;
      uniforms.lightMapIntensity.value = material.lightMapIntensity * scaleFactor;
      refreshTransformUniform(material.lightMap, uniforms.lightMapTransform);
    }
    if (material.aoMap) {
      uniforms.aoMap.value = material.aoMap;
      uniforms.aoMapIntensity.value = material.aoMapIntensity;
      refreshTransformUniform(material.aoMap, uniforms.aoMapTransform);
    }
  }
  function refreshUniformsLine(uniforms, material) {
    uniforms.diffuse.value.copy(material.color);
    uniforms.opacity.value = material.opacity;
    if (material.map) {
      uniforms.map.value = material.map;
      refreshTransformUniform(material.map, uniforms.mapTransform);
    }
  }
  function refreshUniformsDash(uniforms, material) {
    uniforms.dashSize.value = material.dashSize;
    uniforms.totalSize.value = material.dashSize + material.gapSize;
    uniforms.scale.value = material.scale;
  }
  function refreshUniformsPoints(uniforms, material, pixelRatio, height) {
    uniforms.diffuse.value.copy(material.color);
    uniforms.opacity.value = material.opacity;
    uniforms.size.value = material.size * pixelRatio;
    uniforms.scale.value = height * 0.5;
    if (material.map) {
      uniforms.map.value = material.map;
      refreshTransformUniform(material.map, uniforms.uvTransform);
    }
    if (material.alphaMap) {
      uniforms.alphaMap.value = material.alphaMap;
      refreshTransformUniform(material.alphaMap, uniforms.alphaMapTransform);
    }
    if (material.alphaTest > 0) {
      uniforms.alphaTest.value = material.alphaTest;
    }
  }
  function refreshUniformsSprites(uniforms, material) {
    uniforms.diffuse.value.copy(material.color);
    uniforms.opacity.value = material.opacity;
    uniforms.rotation.value = material.rotation;
    if (material.map) {
      uniforms.map.value = material.map;
      refreshTransformUniform(material.map, uniforms.mapTransform);
    }
    if (material.alphaMap) {
      uniforms.alphaMap.value = material.alphaMap;
      refreshTransformUniform(material.alphaMap, uniforms.alphaMapTransform);
    }
    if (material.alphaTest > 0) {
      uniforms.alphaTest.value = material.alphaTest;
    }
  }
  function refreshUniformsPhong(uniforms, material) {
    uniforms.specular.value.copy(material.specular);
    uniforms.shininess.value = Math.max(material.shininess, 1e-4);
  }
  function refreshUniformsToon(uniforms, material) {
    if (material.gradientMap) {
      uniforms.gradientMap.value = material.gradientMap;
    }
  }
  function refreshUniformsStandard(uniforms, material) {
    uniforms.metalness.value = material.metalness;
    if (material.metalnessMap) {
      uniforms.metalnessMap.value = material.metalnessMap;
      refreshTransformUniform(material.metalnessMap, uniforms.metalnessMapTransform);
    }
    uniforms.roughness.value = material.roughness;
    if (material.roughnessMap) {
      uniforms.roughnessMap.value = material.roughnessMap;
      refreshTransformUniform(material.roughnessMap, uniforms.roughnessMapTransform);
    }
    const envMap = properties.get(material).envMap;
    if (envMap) {
      uniforms.envMapIntensity.value = material.envMapIntensity;
    }
  }
  function refreshUniformsPhysical(uniforms, material, transmissionRenderTarget) {
    uniforms.ior.value = material.ior;
    if (material.sheen > 0) {
      uniforms.sheenColor.value.copy(material.sheenColor).multiplyScalar(material.sheen);
      uniforms.sheenRoughness.value = material.sheenRoughness;
      if (material.sheenColorMap) {
        uniforms.sheenColorMap.value = material.sheenColorMap;
        refreshTransformUniform(material.sheenColorMap, uniforms.sheenColorMapTransform);
      }
      if (material.sheenRoughnessMap) {
        uniforms.sheenRoughnessMap.value = material.sheenRoughnessMap;
        refreshTransformUniform(material.sheenRoughnessMap, uniforms.sheenRoughnessMapTransform);
      }
    }
    if (material.clearcoat > 0) {
      uniforms.clearcoat.value = material.clearcoat;
      uniforms.clearcoatRoughness.value = material.clearcoatRoughness;
      if (material.clearcoatMap) {
        uniforms.clearcoatMap.value = material.clearcoatMap;
        refreshTransformUniform(material.clearcoatMap, uniforms.clearcoatMapTransform);
      }
      if (material.clearcoatRoughnessMap) {
        uniforms.clearcoatRoughnessMap.value = material.clearcoatRoughnessMap;
        refreshTransformUniform(material.clearcoatRoughnessMap, uniforms.clearcoatRoughnessMapTransform);
      }
      if (material.clearcoatNormalMap) {
        uniforms.clearcoatNormalMap.value = material.clearcoatNormalMap;
        refreshTransformUniform(material.clearcoatNormalMap, uniforms.clearcoatNormalMapTransform);
        uniforms.clearcoatNormalScale.value.copy(material.clearcoatNormalScale);
        if (material.side === BackSide) {
          uniforms.clearcoatNormalScale.value.negate();
        }
      }
    }
    if (material.iridescence > 0) {
      uniforms.iridescence.value = material.iridescence;
      uniforms.iridescenceIOR.value = material.iridescenceIOR;
      uniforms.iridescenceThicknessMinimum.value = material.iridescenceThicknessRange[0];
      uniforms.iridescenceThicknessMaximum.value = material.iridescenceThicknessRange[1];
      if (material.iridescenceMap) {
        uniforms.iridescenceMap.value = material.iridescenceMap;
        refreshTransformUniform(material.iridescenceMap, uniforms.iridescenceMapTransform);
      }
      if (material.iridescenceThicknessMap) {
        uniforms.iridescenceThicknessMap.value = material.iridescenceThicknessMap;
        refreshTransformUniform(material.iridescenceThicknessMap, uniforms.iridescenceThicknessMapTransform);
      }
    }
    if (material.transmission > 0) {
      uniforms.transmission.value = material.transmission;
      uniforms.transmissionSamplerMap.value = transmissionRenderTarget.texture;
      uniforms.transmissionSamplerSize.value.set(transmissionRenderTarget.width, transmissionRenderTarget.height);
      if (material.transmissionMap) {
        uniforms.transmissionMap.value = material.transmissionMap;
        refreshTransformUniform(material.transmissionMap, uniforms.transmissionMapTransform);
      }
      uniforms.thickness.value = material.thickness;
      if (material.thicknessMap) {
        uniforms.thicknessMap.value = material.thicknessMap;
        refreshTransformUniform(material.thicknessMap, uniforms.thicknessMapTransform);
      }
      uniforms.attenuationDistance.value = material.attenuationDistance;
      uniforms.attenuationColor.value.copy(material.attenuationColor);
    }
    if (material.anisotropy > 0) {
      uniforms.anisotropyVector.value.set(material.anisotropy * Math.cos(material.anisotropyRotation), material.anisotropy * Math.sin(material.anisotropyRotation));
      if (material.anisotropyMap) {
        uniforms.anisotropyMap.value = material.anisotropyMap;
        refreshTransformUniform(material.anisotropyMap, uniforms.anisotropyMapTransform);
      }
    }
    uniforms.specularIntensity.value = material.specularIntensity;
    uniforms.specularColor.value.copy(material.specularColor);
    if (material.specularColorMap) {
      uniforms.specularColorMap.value = material.specularColorMap;
      refreshTransformUniform(material.specularColorMap, uniforms.specularColorMapTransform);
    }
    if (material.specularIntensityMap) {
      uniforms.specularIntensityMap.value = material.specularIntensityMap;
      refreshTransformUniform(material.specularIntensityMap, uniforms.specularIntensityMapTransform);
    }
  }
  function refreshUniformsMatcap(uniforms, material) {
    if (material.matcap) {
      uniforms.matcap.value = material.matcap;
    }
  }
  function refreshUniformsDistance(uniforms, material) {
    const light = properties.get(material).light;
    uniforms.referencePosition.value.setFromMatrixPosition(light.matrixWorld);
    uniforms.nearDistance.value = light.shadow.camera.near;
    uniforms.farDistance.value = light.shadow.camera.far;
  }
  return {
    refreshFogUniforms,
    refreshMaterialUniforms
  };
}
function WebGLUniformsGroups(gl, info, capabilities2, state) {
  let buffers = {};
  let updateList = {};
  let allocatedBindingPoints = [];
  const maxBindingPoints = capabilities2.isWebGL2 ? gl.getParameter(gl.MAX_UNIFORM_BUFFER_BINDINGS) : 0;
  function bind(uniformsGroup, program) {
    const webglProgram = program.program;
    state.uniformBlockBinding(uniformsGroup, webglProgram);
  }
  function update(uniformsGroup, program) {
    let buffer = buffers[uniformsGroup.id];
    if (buffer === void 0) {
      prepareUniformsGroup(uniformsGroup);
      buffer = createBuffer(uniformsGroup);
      buffers[uniformsGroup.id] = buffer;
      uniformsGroup.addEventListener("dispose", onUniformsGroupsDispose);
    }
    const webglProgram = program.program;
    state.updateUBOMapping(uniformsGroup, webglProgram);
    const frame = info.render.frame;
    if (updateList[uniformsGroup.id] !== frame) {
      updateBufferData(uniformsGroup);
      updateList[uniformsGroup.id] = frame;
    }
  }
  function createBuffer(uniformsGroup) {
    const bindingPointIndex = allocateBindingPointIndex();
    uniformsGroup.__bindingPointIndex = bindingPointIndex;
    const buffer = gl.createBuffer();
    const size = uniformsGroup.__size;
    const usage = uniformsGroup.usage;
    gl.bindBuffer(gl.UNIFORM_BUFFER, buffer);
    gl.bufferData(gl.UNIFORM_BUFFER, size, usage);
    gl.bindBuffer(gl.UNIFORM_BUFFER, null);
    gl.bindBufferBase(gl.UNIFORM_BUFFER, bindingPointIndex, buffer);
    return buffer;
  }
  function allocateBindingPointIndex() {
    for (let i2 = 0; i2 < maxBindingPoints; i2++) {
      if (allocatedBindingPoints.indexOf(i2) === -1) {
        allocatedBindingPoints.push(i2);
        return i2;
      }
    }
    console.error("THREE.WebGLRenderer: Maximum number of simultaneously usable uniforms groups reached.");
    return 0;
  }
  function updateBufferData(uniformsGroup) {
    const buffer = buffers[uniformsGroup.id];
    const uniforms = uniformsGroup.uniforms;
    const cache = uniformsGroup.__cache;
    gl.bindBuffer(gl.UNIFORM_BUFFER, buffer);
    for (let i2 = 0, il = uniforms.length; i2 < il; i2++) {
      const uniform = uniforms[i2];
      if (hasUniformChanged(uniform, i2, cache) === true) {
        const offset = uniform.__offset;
        const values = Array.isArray(uniform.value) ? uniform.value : [uniform.value];
        let arrayOffset = 0;
        for (let i3 = 0; i3 < values.length; i3++) {
          const value = values[i3];
          const info2 = getUniformSize(value);
          if (typeof value === "number") {
            uniform.__data[0] = value;
            gl.bufferSubData(gl.UNIFORM_BUFFER, offset + arrayOffset, uniform.__data);
          } else if (value.isMatrix3) {
            uniform.__data[0] = value.elements[0];
            uniform.__data[1] = value.elements[1];
            uniform.__data[2] = value.elements[2];
            uniform.__data[3] = value.elements[0];
            uniform.__data[4] = value.elements[3];
            uniform.__data[5] = value.elements[4];
            uniform.__data[6] = value.elements[5];
            uniform.__data[7] = value.elements[0];
            uniform.__data[8] = value.elements[6];
            uniform.__data[9] = value.elements[7];
            uniform.__data[10] = value.elements[8];
            uniform.__data[11] = value.elements[0];
          } else {
            value.toArray(uniform.__data, arrayOffset);
            arrayOffset += info2.storage / Float32Array.BYTES_PER_ELEMENT;
          }
        }
        gl.bufferSubData(gl.UNIFORM_BUFFER, offset, uniform.__data);
      }
    }
    gl.bindBuffer(gl.UNIFORM_BUFFER, null);
  }
  function hasUniformChanged(uniform, index, cache) {
    const value = uniform.value;
    if (cache[index] === void 0) {
      if (typeof value === "number") {
        cache[index] = value;
      } else {
        const values = Array.isArray(value) ? value : [value];
        const tempValues = [];
        for (let i2 = 0; i2 < values.length; i2++) {
          tempValues.push(values[i2].clone());
        }
        cache[index] = tempValues;
      }
      return true;
    } else {
      if (typeof value === "number") {
        if (cache[index] !== value) {
          cache[index] = value;
          return true;
        }
      } else {
        const cachedObjects = Array.isArray(cache[index]) ? cache[index] : [cache[index]];
        const values = Array.isArray(value) ? value : [value];
        for (let i2 = 0; i2 < cachedObjects.length; i2++) {
          const cachedObject = cachedObjects[i2];
          if (cachedObject.equals(values[i2]) === false) {
            cachedObject.copy(values[i2]);
            return true;
          }
        }
      }
    }
    return false;
  }
  function prepareUniformsGroup(uniformsGroup) {
    const uniforms = uniformsGroup.uniforms;
    let offset = 0;
    const chunkSize = 16;
    let chunkOffset = 0;
    for (let i2 = 0, l2 = uniforms.length; i2 < l2; i2++) {
      const uniform = uniforms[i2];
      const infos = {
        boundary: 0,
        // bytes
        storage: 0
        // bytes
      };
      const values = Array.isArray(uniform.value) ? uniform.value : [uniform.value];
      for (let j = 0, jl = values.length; j < jl; j++) {
        const value = values[j];
        const info2 = getUniformSize(value);
        infos.boundary += info2.boundary;
        infos.storage += info2.storage;
      }
      uniform.__data = new Float32Array(infos.storage / Float32Array.BYTES_PER_ELEMENT);
      uniform.__offset = offset;
      if (i2 > 0) {
        chunkOffset = offset % chunkSize;
        const remainingSizeInChunk = chunkSize - chunkOffset;
        if (chunkOffset !== 0 && remainingSizeInChunk - infos.boundary < 0) {
          offset += chunkSize - chunkOffset;
          uniform.__offset = offset;
        }
      }
      offset += infos.storage;
    }
    chunkOffset = offset % chunkSize;
    if (chunkOffset > 0) offset += chunkSize - chunkOffset;
    uniformsGroup.__size = offset;
    uniformsGroup.__cache = {};
    return this;
  }
  function getUniformSize(value) {
    const info2 = {
      boundary: 0,
      // bytes
      storage: 0
      // bytes
    };
    if (typeof value === "number") {
      info2.boundary = 4;
      info2.storage = 4;
    } else if (value.isVector2) {
      info2.boundary = 8;
      info2.storage = 8;
    } else if (value.isVector3 || value.isColor) {
      info2.boundary = 16;
      info2.storage = 12;
    } else if (value.isVector4) {
      info2.boundary = 16;
      info2.storage = 16;
    } else if (value.isMatrix3) {
      info2.boundary = 48;
      info2.storage = 48;
    } else if (value.isMatrix4) {
      info2.boundary = 64;
      info2.storage = 64;
    } else if (value.isTexture) {
      console.warn("THREE.WebGLRenderer: Texture samplers can not be part of an uniforms group.");
    } else {
      console.warn("THREE.WebGLRenderer: Unsupported uniform value type.", value);
    }
    return info2;
  }
  function onUniformsGroupsDispose(event) {
    const uniformsGroup = event.target;
    uniformsGroup.removeEventListener("dispose", onUniformsGroupsDispose);
    const index = allocatedBindingPoints.indexOf(uniformsGroup.__bindingPointIndex);
    allocatedBindingPoints.splice(index, 1);
    gl.deleteBuffer(buffers[uniformsGroup.id]);
    delete buffers[uniformsGroup.id];
    delete updateList[uniformsGroup.id];
  }
  function dispose() {
    for (const id2 in buffers) {
      gl.deleteBuffer(buffers[id2]);
    }
    allocatedBindingPoints = [];
    buffers = {};
    updateList = {};
  }
  return {
    bind,
    update,
    dispose
  };
}
function createCanvasElement() {
  const canvas = createElementNS("canvas");
  canvas.style.display = "block";
  return canvas;
}
var WebGLRenderer = class {
  constructor(parameters = {}) {
    const {
      canvas = createCanvasElement(),
      context = null,
      depth = true,
      stencil = true,
      alpha = false,
      antialias = false,
      premultipliedAlpha = true,
      preserveDrawingBuffer = false,
      powerPreference = "default",
      failIfMajorPerformanceCaveat = false
    } = parameters;
    this.isWebGLRenderer = true;
    let _alpha;
    if (context !== null) {
      _alpha = context.getContextAttributes().alpha;
    } else {
      _alpha = alpha;
    }
    const uintClearColor = new Uint32Array(4);
    const intClearColor = new Int32Array(4);
    let currentRenderList = null;
    let currentRenderState = null;
    const renderListStack = [];
    const renderStateStack = [];
    this.domElement = canvas;
    this.debug = {
      /**
       * Enables error checking and reporting when shader programs are being compiled
       * @type {boolean}
       */
      checkShaderErrors: true,
      /**
       * Callback for custom error reporting.
       * @type {?Function}
       */
      onShaderError: null
    };
    this.autoClear = true;
    this.autoClearColor = true;
    this.autoClearDepth = true;
    this.autoClearStencil = true;
    this.sortObjects = true;
    this.clippingPlanes = [];
    this.localClippingEnabled = false;
    this.outputColorSpace = SRGBColorSpace;
    this.useLegacyLights = true;
    this.toneMapping = NoToneMapping;
    this.toneMappingExposure = 1;
    const _this = this;
    let _isContextLost = false;
    let _currentActiveCubeFace = 0;
    let _currentActiveMipmapLevel = 0;
    let _currentRenderTarget = null;
    let _currentMaterialId = -1;
    let _currentCamera = null;
    const _currentViewport = new Vector4();
    const _currentScissor = new Vector4();
    let _currentScissorTest = null;
    const _currentClearColor = new Color(0);
    let _currentClearAlpha = 0;
    let _width = canvas.width;
    let _height = canvas.height;
    let _pixelRatio = 1;
    let _opaqueSort = null;
    let _transparentSort = null;
    const _viewport2 = new Vector4(0, 0, _width, _height);
    const _scissor = new Vector4(0, 0, _width, _height);
    let _scissorTest = false;
    const _frustum = new Frustum();
    let _clippingEnabled = false;
    let _localClippingEnabled = false;
    let _transmissionRenderTarget = null;
    const _projScreenMatrix2 = new Matrix4();
    const _vector22 = new Vector2();
    const _vector32 = new Vector3();
    const _emptyScene = { background: null, fog: null, environment: null, overrideMaterial: null, isScene: true };
    function getTargetPixelRatio() {
      return _currentRenderTarget === null ? _pixelRatio : 1;
    }
    let _gl = context;
    function getContext(contextNames, contextAttributes) {
      for (let i2 = 0; i2 < contextNames.length; i2++) {
        const contextName = contextNames[i2];
        const context2 = canvas.getContext(contextName, contextAttributes);
        if (context2 !== null) return context2;
      }
      return null;
    }
    try {
      const contextAttributes = {
        alpha: true,
        depth,
        stencil,
        antialias,
        premultipliedAlpha,
        preserveDrawingBuffer,
        powerPreference,
        failIfMajorPerformanceCaveat
      };
      if ("setAttribute" in canvas) canvas.setAttribute("data-engine", `three.js r${REVISION}`);
      canvas.addEventListener("webglcontextlost", onContextLost, false);
      canvas.addEventListener("webglcontextrestored", onContextRestore, false);
      canvas.addEventListener("webglcontextcreationerror", onContextCreationError, false);
      if (_gl === null) {
        const contextNames = ["webgl2", "webgl", "experimental-webgl"];
        if (_this.isWebGL1Renderer === true) {
          contextNames.shift();
        }
        _gl = getContext(contextNames, contextAttributes);
        if (_gl === null) {
          if (getContext(contextNames)) {
            throw new Error("Error creating WebGL context with your selected attributes.");
          } else {
            throw new Error("Error creating WebGL context.");
          }
        }
      }
      if (_gl instanceof WebGLRenderingContext) {
        console.warn("THREE.WebGLRenderer: WebGL 1 support was deprecated in r153 and will be removed in r163.");
      }
      if (_gl.getShaderPrecisionFormat === void 0) {
        _gl.getShaderPrecisionFormat = function() {
          return { "rangeMin": 1, "rangeMax": 1, "precision": 1 };
        };
      }
    } catch (error) {
      console.error("THREE.WebGLRenderer: " + error.message);
      throw error;
    }
    let extensions, capabilities2, state, info;
    let properties, textures, cubemaps, cubeuvmaps, attributes, geometries2, objects;
    let programCache, materials2, renderLists, renderStates, clipping, shadowMap;
    let background, morphtargets, bufferRenderer, indexedBufferRenderer;
    let utils2, bindingStates, uniformsGroups;
    function initGLContext() {
      extensions = new WebGLExtensions(_gl);
      capabilities2 = new WebGLCapabilities(_gl, extensions, parameters);
      extensions.init(capabilities2);
      utils2 = new WebGLUtils(_gl, extensions, capabilities2);
      state = new WebGLState(_gl, extensions, capabilities2);
      info = new WebGLInfo(_gl);
      properties = new WebGLProperties();
      textures = new WebGLTextures(_gl, extensions, state, properties, capabilities2, utils2, info);
      cubemaps = new WebGLCubeMaps(_this);
      cubeuvmaps = new WebGLCubeUVMaps(_this);
      attributes = new WebGLAttributes(_gl, capabilities2);
      bindingStates = new WebGLBindingStates(_gl, extensions, attributes, capabilities2);
      geometries2 = new WebGLGeometries(_gl, attributes, info, bindingStates);
      objects = new WebGLObjects(_gl, geometries2, attributes, info);
      morphtargets = new WebGLMorphtargets(_gl, capabilities2, textures);
      clipping = new WebGLClipping(properties);
      programCache = new WebGLPrograms(_this, cubemaps, cubeuvmaps, extensions, capabilities2, bindingStates, clipping);
      materials2 = new WebGLMaterials(_this, properties);
      renderLists = new WebGLRenderLists();
      renderStates = new WebGLRenderStates(extensions, capabilities2);
      background = new WebGLBackground(_this, cubemaps, cubeuvmaps, state, objects, _alpha, premultipliedAlpha);
      shadowMap = new WebGLShadowMap(_this, objects, capabilities2);
      uniformsGroups = new WebGLUniformsGroups(_gl, info, capabilities2, state);
      bufferRenderer = new WebGLBufferRenderer(_gl, extensions, info, capabilities2);
      indexedBufferRenderer = new WebGLIndexedBufferRenderer(_gl, extensions, info, capabilities2);
      info.programs = programCache.programs;
      _this.capabilities = capabilities2;
      _this.extensions = extensions;
      _this.properties = properties;
      _this.renderLists = renderLists;
      _this.shadowMap = shadowMap;
      _this.state = state;
      _this.info = info;
    }
    initGLContext();
    const xr = new WebXRManager(_this, _gl);
    this.xr = xr;
    this.getContext = function() {
      return _gl;
    };
    this.getContextAttributes = function() {
      return _gl.getContextAttributes();
    };
    this.forceContextLoss = function() {
      const extension = extensions.get("WEBGL_lose_context");
      if (extension) extension.loseContext();
    };
    this.forceContextRestore = function() {
      const extension = extensions.get("WEBGL_lose_context");
      if (extension) extension.restoreContext();
    };
    this.getPixelRatio = function() {
      return _pixelRatio;
    };
    this.setPixelRatio = function(value) {
      if (value === void 0) return;
      _pixelRatio = value;
      this.setSize(_width, _height, false);
    };
    this.getSize = function(target) {
      return target.set(_width, _height);
    };
    this.setSize = function(width, height, updateStyle = true) {
      if (xr.isPresenting) {
        console.warn("THREE.WebGLRenderer: Can't change size while VR device is presenting.");
        return;
      }
      _width = width;
      _height = height;
      canvas.width = Math.floor(width * _pixelRatio);
      canvas.height = Math.floor(height * _pixelRatio);
      if (updateStyle === true) {
        canvas.style.width = width + "px";
        canvas.style.height = height + "px";
      }
      this.setViewport(0, 0, width, height);
    };
    this.getDrawingBufferSize = function(target) {
      return target.set(_width * _pixelRatio, _height * _pixelRatio).floor();
    };
    this.setDrawingBufferSize = function(width, height, pixelRatio) {
      _width = width;
      _height = height;
      _pixelRatio = pixelRatio;
      canvas.width = Math.floor(width * pixelRatio);
      canvas.height = Math.floor(height * pixelRatio);
      this.setViewport(0, 0, width, height);
    };
    this.getCurrentViewport = function(target) {
      return target.copy(_currentViewport);
    };
    this.getViewport = function(target) {
      return target.copy(_viewport2);
    };
    this.setViewport = function(x3, y2, width, height) {
      if (x3.isVector4) {
        _viewport2.set(x3.x, x3.y, x3.z, x3.w);
      } else {
        _viewport2.set(x3, y2, width, height);
      }
      state.viewport(_currentViewport.copy(_viewport2).multiplyScalar(_pixelRatio).floor());
    };
    this.getScissor = function(target) {
      return target.copy(_scissor);
    };
    this.setScissor = function(x3, y2, width, height) {
      if (x3.isVector4) {
        _scissor.set(x3.x, x3.y, x3.z, x3.w);
      } else {
        _scissor.set(x3, y2, width, height);
      }
      state.scissor(_currentScissor.copy(_scissor).multiplyScalar(_pixelRatio).floor());
    };
    this.getScissorTest = function() {
      return _scissorTest;
    };
    this.setScissorTest = function(boolean) {
      state.setScissorTest(_scissorTest = boolean);
    };
    this.setOpaqueSort = function(method) {
      _opaqueSort = method;
    };
    this.setTransparentSort = function(method) {
      _transparentSort = method;
    };
    this.getClearColor = function(target) {
      return target.copy(background.getClearColor());
    };
    this.setClearColor = function() {
      background.setClearColor.apply(background, arguments);
    };
    this.getClearAlpha = function() {
      return background.getClearAlpha();
    };
    this.setClearAlpha = function() {
      background.setClearAlpha.apply(background, arguments);
    };
    this.clear = function(color = true, depth2 = true, stencil2 = true) {
      let bits = 0;
      if (color) {
        let isIntegerFormat = false;
        if (_currentRenderTarget !== null) {
          const targetFormat = _currentRenderTarget.texture.format;
          isIntegerFormat = targetFormat === RGBAIntegerFormat || targetFormat === RGIntegerFormat || targetFormat === RedIntegerFormat;
        }
        if (isIntegerFormat) {
          const targetType = _currentRenderTarget.texture.type;
          const isUnsignedType = targetType === UnsignedByteType || targetType === UnsignedIntType || targetType === UnsignedShortType || targetType === UnsignedInt248Type || targetType === UnsignedShort4444Type || targetType === UnsignedShort5551Type;
          const clearColor = background.getClearColor();
          const a2 = background.getClearAlpha();
          const r2 = clearColor.r;
          const g2 = clearColor.g;
          const b2 = clearColor.b;
          const __webglFramebuffer = properties.get(_currentRenderTarget).__webglFramebuffer;
          if (isUnsignedType) {
            uintClearColor[0] = r2;
            uintClearColor[1] = g2;
            uintClearColor[2] = b2;
            uintClearColor[3] = a2;
            _gl.clearBufferuiv(_gl.COLOR, __webglFramebuffer, uintClearColor);
          } else {
            intClearColor[0] = r2;
            intClearColor[1] = g2;
            intClearColor[2] = b2;
            intClearColor[3] = a2;
            _gl.clearBufferiv(_gl.COLOR, __webglFramebuffer, intClearColor);
          }
        } else {
          bits |= _gl.COLOR_BUFFER_BIT;
        }
      }
      if (depth2) bits |= _gl.DEPTH_BUFFER_BIT;
      if (stencil2) bits |= _gl.STENCIL_BUFFER_BIT;
      _gl.clear(bits);
    };
    this.clearColor = function() {
      this.clear(true, false, false);
    };
    this.clearDepth = function() {
      this.clear(false, true, false);
    };
    this.clearStencil = function() {
      this.clear(false, false, true);
    };
    this.dispose = function() {
      canvas.removeEventListener("webglcontextlost", onContextLost, false);
      canvas.removeEventListener("webglcontextrestored", onContextRestore, false);
      canvas.removeEventListener("webglcontextcreationerror", onContextCreationError, false);
      renderLists.dispose();
      renderStates.dispose();
      properties.dispose();
      cubemaps.dispose();
      cubeuvmaps.dispose();
      objects.dispose();
      bindingStates.dispose();
      uniformsGroups.dispose();
      programCache.dispose();
      xr.dispose();
      xr.removeEventListener("sessionstart", onXRSessionStart);
      xr.removeEventListener("sessionend", onXRSessionEnd);
      if (_transmissionRenderTarget) {
        _transmissionRenderTarget.dispose();
        _transmissionRenderTarget = null;
      }
      animation.stop();
    };
    function onContextLost(event) {
      event.preventDefault();
      console.log("THREE.WebGLRenderer: Context Lost.");
      _isContextLost = true;
    }
    function onContextRestore() {
      console.log("THREE.WebGLRenderer: Context Restored.");
      _isContextLost = false;
      const infoAutoReset = info.autoReset;
      const shadowMapEnabled = shadowMap.enabled;
      const shadowMapAutoUpdate = shadowMap.autoUpdate;
      const shadowMapNeedsUpdate = shadowMap.needsUpdate;
      const shadowMapType = shadowMap.type;
      initGLContext();
      info.autoReset = infoAutoReset;
      shadowMap.enabled = shadowMapEnabled;
      shadowMap.autoUpdate = shadowMapAutoUpdate;
      shadowMap.needsUpdate = shadowMapNeedsUpdate;
      shadowMap.type = shadowMapType;
    }
    function onContextCreationError(event) {
      console.error("THREE.WebGLRenderer: A WebGL context could not be created. Reason: ", event.statusMessage);
    }
    function onMaterialDispose(event) {
      const material = event.target;
      material.removeEventListener("dispose", onMaterialDispose);
      deallocateMaterial(material);
    }
    function deallocateMaterial(material) {
      releaseMaterialProgramReferences(material);
      properties.remove(material);
    }
    function releaseMaterialProgramReferences(material) {
      const programs = properties.get(material).programs;
      if (programs !== void 0) {
        programs.forEach(function(program) {
          programCache.releaseProgram(program);
        });
        if (material.isShaderMaterial) {
          programCache.releaseShaderCache(material);
        }
      }
    }
    this.renderBufferDirect = function(camera, scene, geometry, material, object, group) {
      if (scene === null) scene = _emptyScene;
      const frontFaceCW = object.isMesh && object.matrixWorld.determinant() < 0;
      const program = setProgram(camera, scene, geometry, material, object);
      state.setMaterial(material, frontFaceCW);
      let index = geometry.index;
      let rangeFactor = 1;
      if (material.wireframe === true) {
        index = geometries2.getWireframeAttribute(geometry);
        rangeFactor = 2;
      }
      const drawRange = geometry.drawRange;
      const position = geometry.attributes.position;
      let drawStart = drawRange.start * rangeFactor;
      let drawEnd = (drawRange.start + drawRange.count) * rangeFactor;
      if (group !== null) {
        drawStart = Math.max(drawStart, group.start * rangeFactor);
        drawEnd = Math.min(drawEnd, (group.start + group.count) * rangeFactor);
      }
      if (index !== null) {
        drawStart = Math.max(drawStart, 0);
        drawEnd = Math.min(drawEnd, index.count);
      } else if (position !== void 0 && position !== null) {
        drawStart = Math.max(drawStart, 0);
        drawEnd = Math.min(drawEnd, position.count);
      }
      const drawCount = drawEnd - drawStart;
      if (drawCount < 0 || drawCount === Infinity) return;
      bindingStates.setup(object, material, program, geometry, index);
      let attribute;
      let renderer = bufferRenderer;
      if (index !== null) {
        attribute = attributes.get(index);
        renderer = indexedBufferRenderer;
        renderer.setIndex(attribute);
      }
      if (object.isMesh) {
        if (material.wireframe === true) {
          state.setLineWidth(material.wireframeLinewidth * getTargetPixelRatio());
          renderer.setMode(_gl.LINES);
        } else {
          renderer.setMode(_gl.TRIANGLES);
        }
      } else if (object.isLine) {
        let lineWidth = material.linewidth;
        if (lineWidth === void 0) lineWidth = 1;
        state.setLineWidth(lineWidth * getTargetPixelRatio());
        if (object.isLineSegments) {
          renderer.setMode(_gl.LINES);
        } else if (object.isLineLoop) {
          renderer.setMode(_gl.LINE_LOOP);
        } else {
          renderer.setMode(_gl.LINE_STRIP);
        }
      } else if (object.isPoints) {
        renderer.setMode(_gl.POINTS);
      } else if (object.isSprite) {
        renderer.setMode(_gl.TRIANGLES);
      }
      if (object.isInstancedMesh) {
        renderer.renderInstances(drawStart, drawCount, object.count);
      } else if (geometry.isInstancedBufferGeometry) {
        const maxInstanceCount = geometry._maxInstanceCount !== void 0 ? geometry._maxInstanceCount : Infinity;
        const instanceCount = Math.min(geometry.instanceCount, maxInstanceCount);
        renderer.renderInstances(drawStart, drawCount, instanceCount);
      } else {
        renderer.render(drawStart, drawCount);
      }
    };
    this.compile = function(scene, camera) {
      function prepare(material, scene2, object) {
        if (material.transparent === true && material.side === DoubleSide && material.forceSinglePass === false) {
          material.side = BackSide;
          material.needsUpdate = true;
          getProgram(material, scene2, object);
          material.side = FrontSide;
          material.needsUpdate = true;
          getProgram(material, scene2, object);
          material.side = DoubleSide;
        } else {
          getProgram(material, scene2, object);
        }
      }
      currentRenderState = renderStates.get(scene);
      currentRenderState.init();
      renderStateStack.push(currentRenderState);
      scene.traverseVisible(function(object) {
        if (object.isLight && object.layers.test(camera.layers)) {
          currentRenderState.pushLight(object);
          if (object.castShadow) {
            currentRenderState.pushShadow(object);
          }
        }
      });
      currentRenderState.setupLights(_this.useLegacyLights);
      scene.traverse(function(object) {
        const material = object.material;
        if (material) {
          if (Array.isArray(material)) {
            for (let i2 = 0; i2 < material.length; i2++) {
              const material2 = material[i2];
              prepare(material2, scene, object);
            }
          } else {
            prepare(material, scene, object);
          }
        }
      });
      renderStateStack.pop();
      currentRenderState = null;
    };
    let onAnimationFrameCallback = null;
    function onAnimationFrame(time) {
      if (onAnimationFrameCallback) onAnimationFrameCallback(time);
    }
    function onXRSessionStart() {
      animation.stop();
    }
    function onXRSessionEnd() {
      animation.start();
    }
    const animation = new WebGLAnimation();
    animation.setAnimationLoop(onAnimationFrame);
    if (typeof self !== "undefined") animation.setContext(self);
    this.setAnimationLoop = function(callback) {
      onAnimationFrameCallback = callback;
      xr.setAnimationLoop(callback);
      callback === null ? animation.stop() : animation.start();
    };
    xr.addEventListener("sessionstart", onXRSessionStart);
    xr.addEventListener("sessionend", onXRSessionEnd);
    this.render = function(scene, camera) {
      if (camera !== void 0 && camera.isCamera !== true) {
        console.error("THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.");
        return;
      }
      if (_isContextLost === true) return;
      if (scene.matrixWorldAutoUpdate === true) scene.updateMatrixWorld();
      if (camera.parent === null && camera.matrixWorldAutoUpdate === true) camera.updateMatrixWorld();
      if (xr.enabled === true && xr.isPresenting === true) {
        camera = xr.updateCameraXR(camera);
      }
      if (scene.isScene === true) scene.onBeforeRender(_this, scene, camera, _currentRenderTarget);
      currentRenderState = renderStates.get(scene, renderStateStack.length);
      currentRenderState.init();
      renderStateStack.push(currentRenderState);
      _projScreenMatrix2.multiplyMatrices(camera.projectionMatrix, camera.matrixWorldInverse);
      _frustum.setFromProjectionMatrix(_projScreenMatrix2);
      _localClippingEnabled = this.localClippingEnabled;
      _clippingEnabled = clipping.init(this.clippingPlanes, _localClippingEnabled);
      currentRenderList = renderLists.get(scene, renderListStack.length);
      currentRenderList.init();
      renderListStack.push(currentRenderList);
      projectObject(scene, camera, 0, _this.sortObjects);
      currentRenderList.finish();
      if (_this.sortObjects === true) {
        currentRenderList.sort(_opaqueSort, _transparentSort);
      }
      if (_clippingEnabled === true) clipping.beginShadows();
      const shadowsArray = currentRenderState.state.shadowsArray;
      shadowMap.render(shadowsArray, scene, camera);
      if (_clippingEnabled === true) clipping.endShadows();
      if (this.info.autoReset === true) this.info.reset();
      this.info.render.frame++;
      background.render(currentRenderList, scene);
      currentRenderState.setupLights(_this.useLegacyLights);
      if (camera.isArrayCamera) {
        const cameras = camera.cameras;
        for (let i2 = 0, l2 = cameras.length; i2 < l2; i2++) {
          const camera2 = cameras[i2];
          renderScene(currentRenderList, scene, camera2, camera2.viewport);
        }
      } else {
        renderScene(currentRenderList, scene, camera);
      }
      if (_currentRenderTarget !== null) {
        textures.updateMultisampleRenderTarget(_currentRenderTarget);
        textures.updateRenderTargetMipmap(_currentRenderTarget);
      }
      if (scene.isScene === true) scene.onAfterRender(_this, scene, camera);
      bindingStates.resetDefaultState();
      _currentMaterialId = -1;
      _currentCamera = null;
      renderStateStack.pop();
      if (renderStateStack.length > 0) {
        currentRenderState = renderStateStack[renderStateStack.length - 1];
      } else {
        currentRenderState = null;
      }
      renderListStack.pop();
      if (renderListStack.length > 0) {
        currentRenderList = renderListStack[renderListStack.length - 1];
      } else {
        currentRenderList = null;
      }
    };
    function projectObject(object, camera, groupOrder, sortObjects) {
      if (object.visible === false) return;
      const visible = object.layers.test(camera.layers);
      if (visible) {
        if (object.isGroup) {
          groupOrder = object.renderOrder;
        } else if (object.isLOD) {
          if (object.autoUpdate === true) object.update(camera);
        } else if (object.isLight) {
          currentRenderState.pushLight(object);
          if (object.castShadow) {
            currentRenderState.pushShadow(object);
          }
        } else if (object.isSprite) {
          if (!object.frustumCulled || _frustum.intersectsSprite(object)) {
            if (sortObjects) {
              _vector32.setFromMatrixPosition(object.matrixWorld).applyMatrix4(_projScreenMatrix2);
            }
            const geometry = objects.update(object);
            const material = object.material;
            if (material.visible) {
              currentRenderList.push(object, geometry, material, groupOrder, _vector32.z, null);
            }
          }
        } else if (object.isMesh || object.isLine || object.isPoints) {
          if (!object.frustumCulled || _frustum.intersectsObject(object)) {
            if (object.isSkinnedMesh) {
              if (object.skeleton.frame !== info.render.frame) {
                object.skeleton.update();
                object.skeleton.frame = info.render.frame;
              }
            }
            const geometry = objects.update(object);
            const material = object.material;
            if (sortObjects) {
              if (object.boundingSphere !== void 0) {
                if (object.boundingSphere === null) object.computeBoundingSphere();
                _vector32.copy(object.boundingSphere.center);
              } else {
                if (geometry.boundingSphere === null) geometry.computeBoundingSphere();
                _vector32.copy(geometry.boundingSphere.center);
              }
              _vector32.applyMatrix4(object.matrixWorld).applyMatrix4(_projScreenMatrix2);
            }
            if (Array.isArray(material)) {
              const groups2 = geometry.groups;
              for (let i2 = 0, l2 = groups2.length; i2 < l2; i2++) {
                const group = groups2[i2];
                const groupMaterial = material[group.materialIndex];
                if (groupMaterial && groupMaterial.visible) {
                  currentRenderList.push(object, geometry, groupMaterial, groupOrder, _vector32.z, group);
                }
              }
            } else if (material.visible) {
              currentRenderList.push(object, geometry, material, groupOrder, _vector32.z, null);
            }
          }
        }
      }
      const children = object.children;
      for (let i2 = 0, l2 = children.length; i2 < l2; i2++) {
        projectObject(children[i2], camera, groupOrder, sortObjects);
      }
    }
    function renderScene(currentRenderList2, scene, camera, viewport) {
      const opaqueObjects = currentRenderList2.opaque;
      const transmissiveObjects = currentRenderList2.transmissive;
      const transparentObjects = currentRenderList2.transparent;
      currentRenderState.setupLightsView(camera);
      if (_clippingEnabled === true) clipping.setGlobalState(_this.clippingPlanes, camera);
      if (transmissiveObjects.length > 0) renderTransmissionPass(opaqueObjects, transmissiveObjects, scene, camera);
      if (viewport) state.viewport(_currentViewport.copy(viewport));
      if (opaqueObjects.length > 0) renderObjects(opaqueObjects, scene, camera);
      if (transmissiveObjects.length > 0) renderObjects(transmissiveObjects, scene, camera);
      if (transparentObjects.length > 0) renderObjects(transparentObjects, scene, camera);
      state.buffers.depth.setTest(true);
      state.buffers.depth.setMask(true);
      state.buffers.color.setMask(true);
      state.setPolygonOffset(false);
    }
    function renderTransmissionPass(opaqueObjects, transmissiveObjects, scene, camera) {
      const isWebGL2 = capabilities2.isWebGL2;
      if (_transmissionRenderTarget === null) {
        _transmissionRenderTarget = new WebGLRenderTarget(1, 1, {
          generateMipmaps: true,
          type: extensions.has("EXT_color_buffer_half_float") ? HalfFloatType : UnsignedByteType,
          minFilter: LinearMipmapLinearFilter,
          samples: isWebGL2 && antialias === true ? 4 : 0
        });
      }
      _this.getDrawingBufferSize(_vector22);
      if (isWebGL2) {
        _transmissionRenderTarget.setSize(_vector22.x, _vector22.y);
      } else {
        _transmissionRenderTarget.setSize(floorPowerOfTwo(_vector22.x), floorPowerOfTwo(_vector22.y));
      }
      const currentRenderTarget = _this.getRenderTarget();
      _this.setRenderTarget(_transmissionRenderTarget);
      _this.getClearColor(_currentClearColor);
      _currentClearAlpha = _this.getClearAlpha();
      if (_currentClearAlpha < 1) _this.setClearColor(16777215, 0.5);
      _this.clear();
      const currentToneMapping = _this.toneMapping;
      _this.toneMapping = NoToneMapping;
      renderObjects(opaqueObjects, scene, camera);
      textures.updateMultisampleRenderTarget(_transmissionRenderTarget);
      textures.updateRenderTargetMipmap(_transmissionRenderTarget);
      let renderTargetNeedsUpdate = false;
      for (let i2 = 0, l2 = transmissiveObjects.length; i2 < l2; i2++) {
        const renderItem = transmissiveObjects[i2];
        const object = renderItem.object;
        const geometry = renderItem.geometry;
        const material = renderItem.material;
        const group = renderItem.group;
        if (material.side === DoubleSide && object.layers.test(camera.layers)) {
          const currentSide = material.side;
          material.side = BackSide;
          material.needsUpdate = true;
          renderObject(object, scene, camera, geometry, material, group);
          material.side = currentSide;
          material.needsUpdate = true;
          renderTargetNeedsUpdate = true;
        }
      }
      if (renderTargetNeedsUpdate === true) {
        textures.updateMultisampleRenderTarget(_transmissionRenderTarget);
        textures.updateRenderTargetMipmap(_transmissionRenderTarget);
      }
      _this.setRenderTarget(currentRenderTarget);
      _this.setClearColor(_currentClearColor, _currentClearAlpha);
      _this.toneMapping = currentToneMapping;
    }
    function renderObjects(renderList, scene, camera) {
      const overrideMaterial = scene.isScene === true ? scene.overrideMaterial : null;
      for (let i2 = 0, l2 = renderList.length; i2 < l2; i2++) {
        const renderItem = renderList[i2];
        const object = renderItem.object;
        const geometry = renderItem.geometry;
        const material = overrideMaterial === null ? renderItem.material : overrideMaterial;
        const group = renderItem.group;
        if (object.layers.test(camera.layers)) {
          renderObject(object, scene, camera, geometry, material, group);
        }
      }
    }
    function renderObject(object, scene, camera, geometry, material, group) {
      object.onBeforeRender(_this, scene, camera, geometry, material, group);
      object.modelViewMatrix.multiplyMatrices(camera.matrixWorldInverse, object.matrixWorld);
      object.normalMatrix.getNormalMatrix(object.modelViewMatrix);
      material.onBeforeRender(_this, scene, camera, geometry, object, group);
      if (material.transparent === true && material.side === DoubleSide && material.forceSinglePass === false) {
        material.side = BackSide;
        material.needsUpdate = true;
        _this.renderBufferDirect(camera, scene, geometry, material, object, group);
        material.side = FrontSide;
        material.needsUpdate = true;
        _this.renderBufferDirect(camera, scene, geometry, material, object, group);
        material.side = DoubleSide;
      } else {
        _this.renderBufferDirect(camera, scene, geometry, material, object, group);
      }
      object.onAfterRender(_this, scene, camera, geometry, material, group);
    }
    function getProgram(material, scene, object) {
      if (scene.isScene !== true) scene = _emptyScene;
      const materialProperties = properties.get(material);
      const lights = currentRenderState.state.lights;
      const shadowsArray = currentRenderState.state.shadowsArray;
      const lightsStateVersion = lights.state.version;
      const parameters2 = programCache.getParameters(material, lights.state, shadowsArray, scene, object);
      const programCacheKey = programCache.getProgramCacheKey(parameters2);
      let programs = materialProperties.programs;
      materialProperties.environment = material.isMeshStandardMaterial ? scene.environment : null;
      materialProperties.fog = scene.fog;
      materialProperties.envMap = (material.isMeshStandardMaterial ? cubeuvmaps : cubemaps).get(material.envMap || materialProperties.environment);
      if (programs === void 0) {
        material.addEventListener("dispose", onMaterialDispose);
        programs = /* @__PURE__ */ new Map();
        materialProperties.programs = programs;
      }
      let program = programs.get(programCacheKey);
      if (program !== void 0) {
        if (materialProperties.currentProgram === program && materialProperties.lightsStateVersion === lightsStateVersion) {
          updateCommonMaterialProperties(material, parameters2);
          return program;
        }
      } else {
        parameters2.uniforms = programCache.getUniforms(material);
        material.onBuild(object, parameters2, _this);
        material.onBeforeCompile(parameters2, _this);
        program = programCache.acquireProgram(parameters2, programCacheKey);
        programs.set(programCacheKey, program);
        materialProperties.uniforms = parameters2.uniforms;
      }
      const uniforms = materialProperties.uniforms;
      if (!material.isShaderMaterial && !material.isRawShaderMaterial || material.clipping === true) {
        uniforms.clippingPlanes = clipping.uniform;
      }
      updateCommonMaterialProperties(material, parameters2);
      materialProperties.needsLights = materialNeedsLights(material);
      materialProperties.lightsStateVersion = lightsStateVersion;
      if (materialProperties.needsLights) {
        uniforms.ambientLightColor.value = lights.state.ambient;
        uniforms.lightProbe.value = lights.state.probe;
        uniforms.directionalLights.value = lights.state.directional;
        uniforms.directionalLightShadows.value = lights.state.directionalShadow;
        uniforms.spotLights.value = lights.state.spot;
        uniforms.spotLightShadows.value = lights.state.spotShadow;
        uniforms.rectAreaLights.value = lights.state.rectArea;
        uniforms.ltc_1.value = lights.state.rectAreaLTC1;
        uniforms.ltc_2.value = lights.state.rectAreaLTC2;
        uniforms.pointLights.value = lights.state.point;
        uniforms.pointLightShadows.value = lights.state.pointShadow;
        uniforms.hemisphereLights.value = lights.state.hemi;
        uniforms.directionalShadowMap.value = lights.state.directionalShadowMap;
        uniforms.directionalShadowMatrix.value = lights.state.directionalShadowMatrix;
        uniforms.spotShadowMap.value = lights.state.spotShadowMap;
        uniforms.spotLightMatrix.value = lights.state.spotLightMatrix;
        uniforms.spotLightMap.value = lights.state.spotLightMap;
        uniforms.pointShadowMap.value = lights.state.pointShadowMap;
        uniforms.pointShadowMatrix.value = lights.state.pointShadowMatrix;
      }
      const progUniforms = program.getUniforms();
      const uniformsList = WebGLUniforms.seqWithValue(progUniforms.seq, uniforms);
      materialProperties.currentProgram = program;
      materialProperties.uniformsList = uniformsList;
      return program;
    }
    function updateCommonMaterialProperties(material, parameters2) {
      const materialProperties = properties.get(material);
      materialProperties.outputColorSpace = parameters2.outputColorSpace;
      materialProperties.instancing = parameters2.instancing;
      materialProperties.skinning = parameters2.skinning;
      materialProperties.morphTargets = parameters2.morphTargets;
      materialProperties.morphNormals = parameters2.morphNormals;
      materialProperties.morphColors = parameters2.morphColors;
      materialProperties.morphTargetsCount = parameters2.morphTargetsCount;
      materialProperties.numClippingPlanes = parameters2.numClippingPlanes;
      materialProperties.numIntersection = parameters2.numClipIntersection;
      materialProperties.vertexAlphas = parameters2.vertexAlphas;
      materialProperties.vertexTangents = parameters2.vertexTangents;
      materialProperties.toneMapping = parameters2.toneMapping;
    }
    function setProgram(camera, scene, geometry, material, object) {
      if (scene.isScene !== true) scene = _emptyScene;
      textures.resetTextureUnits();
      const fog = scene.fog;
      const environment = material.isMeshStandardMaterial ? scene.environment : null;
      const colorSpace = _currentRenderTarget === null ? _this.outputColorSpace : _currentRenderTarget.isXRRenderTarget === true ? _currentRenderTarget.texture.colorSpace : LinearSRGBColorSpace;
      const envMap = (material.isMeshStandardMaterial ? cubeuvmaps : cubemaps).get(material.envMap || environment);
      const vertexAlphas = material.vertexColors === true && !!geometry.attributes.color && geometry.attributes.color.itemSize === 4;
      const vertexTangents = !!geometry.attributes.tangent && (!!material.normalMap || material.anisotropy > 0);
      const morphTargets = !!geometry.morphAttributes.position;
      const morphNormals = !!geometry.morphAttributes.normal;
      const morphColors = !!geometry.morphAttributes.color;
      const toneMapping = material.toneMapped ? _this.toneMapping : NoToneMapping;
      const morphAttribute = geometry.morphAttributes.position || geometry.morphAttributes.normal || geometry.morphAttributes.color;
      const morphTargetsCount = morphAttribute !== void 0 ? morphAttribute.length : 0;
      const materialProperties = properties.get(material);
      const lights = currentRenderState.state.lights;
      if (_clippingEnabled === true) {
        if (_localClippingEnabled === true || camera !== _currentCamera) {
          const useCache = camera === _currentCamera && material.id === _currentMaterialId;
          clipping.setState(material, camera, useCache);
        }
      }
      let needsProgramChange = false;
      if (material.version === materialProperties.__version) {
        if (materialProperties.needsLights && materialProperties.lightsStateVersion !== lights.state.version) {
          needsProgramChange = true;
        } else if (materialProperties.outputColorSpace !== colorSpace) {
          needsProgramChange = true;
        } else if (object.isInstancedMesh && materialProperties.instancing === false) {
          needsProgramChange = true;
        } else if (!object.isInstancedMesh && materialProperties.instancing === true) {
          needsProgramChange = true;
        } else if (object.isSkinnedMesh && materialProperties.skinning === false) {
          needsProgramChange = true;
        } else if (!object.isSkinnedMesh && materialProperties.skinning === true) {
          needsProgramChange = true;
        } else if (materialProperties.envMap !== envMap) {
          needsProgramChange = true;
        } else if (material.fog === true && materialProperties.fog !== fog) {
          needsProgramChange = true;
        } else if (materialProperties.numClippingPlanes !== void 0 && (materialProperties.numClippingPlanes !== clipping.numPlanes || materialProperties.numIntersection !== clipping.numIntersection)) {
          needsProgramChange = true;
        } else if (materialProperties.vertexAlphas !== vertexAlphas) {
          needsProgramChange = true;
        } else if (materialProperties.vertexTangents !== vertexTangents) {
          needsProgramChange = true;
        } else if (materialProperties.morphTargets !== morphTargets) {
          needsProgramChange = true;
        } else if (materialProperties.morphNormals !== morphNormals) {
          needsProgramChange = true;
        } else if (materialProperties.morphColors !== morphColors) {
          needsProgramChange = true;
        } else if (materialProperties.toneMapping !== toneMapping) {
          needsProgramChange = true;
        } else if (capabilities2.isWebGL2 === true && materialProperties.morphTargetsCount !== morphTargetsCount) {
          needsProgramChange = true;
        }
      } else {
        needsProgramChange = true;
        materialProperties.__version = material.version;
      }
      let program = materialProperties.currentProgram;
      if (needsProgramChange === true) {
        program = getProgram(material, scene, object);
      }
      let refreshProgram = false;
      let refreshMaterial = false;
      let refreshLights = false;
      const p_uniforms = program.getUniforms(), m_uniforms = materialProperties.uniforms;
      if (state.useProgram(program.program)) {
        refreshProgram = true;
        refreshMaterial = true;
        refreshLights = true;
      }
      if (material.id !== _currentMaterialId) {
        _currentMaterialId = material.id;
        refreshMaterial = true;
      }
      if (refreshProgram || _currentCamera !== camera) {
        p_uniforms.setValue(_gl, "projectionMatrix", camera.projectionMatrix);
        if (capabilities2.logarithmicDepthBuffer) {
          p_uniforms.setValue(
            _gl,
            "logDepthBufFC",
            2 / (Math.log(camera.far + 1) / Math.LN2)
          );
        }
        if (_currentCamera !== camera) {
          _currentCamera = camera;
          refreshMaterial = true;
          refreshLights = true;
        }
        if (material.isShaderMaterial || material.isMeshPhongMaterial || material.isMeshToonMaterial || material.isMeshStandardMaterial || material.envMap) {
          const uCamPos = p_uniforms.map.cameraPosition;
          if (uCamPos !== void 0) {
            uCamPos.setValue(
              _gl,
              _vector32.setFromMatrixPosition(camera.matrixWorld)
            );
          }
        }
        if (material.isMeshPhongMaterial || material.isMeshToonMaterial || material.isMeshLambertMaterial || material.isMeshBasicMaterial || material.isMeshStandardMaterial || material.isShaderMaterial) {
          p_uniforms.setValue(_gl, "isOrthographic", camera.isOrthographicCamera === true);
        }
        if (material.isMeshPhongMaterial || material.isMeshToonMaterial || material.isMeshLambertMaterial || material.isMeshBasicMaterial || material.isMeshStandardMaterial || material.isShaderMaterial || material.isShadowMaterial || object.isSkinnedMesh) {
          p_uniforms.setValue(_gl, "viewMatrix", camera.matrixWorldInverse);
        }
      }
      if (object.isSkinnedMesh) {
        p_uniforms.setOptional(_gl, object, "bindMatrix");
        p_uniforms.setOptional(_gl, object, "bindMatrixInverse");
        const skeleton = object.skeleton;
        if (skeleton) {
          if (capabilities2.floatVertexTextures) {
            if (skeleton.boneTexture === null) skeleton.computeBoneTexture();
            p_uniforms.setValue(_gl, "boneTexture", skeleton.boneTexture, textures);
            p_uniforms.setValue(_gl, "boneTextureSize", skeleton.boneTextureSize);
          } else {
            console.warn("THREE.WebGLRenderer: SkinnedMesh can only be used with WebGL 2. With WebGL 1 OES_texture_float and vertex textures support is required.");
          }
        }
      }
      const morphAttributes = geometry.morphAttributes;
      if (morphAttributes.position !== void 0 || morphAttributes.normal !== void 0 || morphAttributes.color !== void 0 && capabilities2.isWebGL2 === true) {
        morphtargets.update(object, geometry, program);
      }
      if (refreshMaterial || materialProperties.receiveShadow !== object.receiveShadow) {
        materialProperties.receiveShadow = object.receiveShadow;
        p_uniforms.setValue(_gl, "receiveShadow", object.receiveShadow);
      }
      if (material.isMeshGouraudMaterial && material.envMap !== null) {
        m_uniforms.envMap.value = envMap;
        m_uniforms.flipEnvMap.value = envMap.isCubeTexture && envMap.isRenderTargetTexture === false ? -1 : 1;
      }
      if (refreshMaterial) {
        p_uniforms.setValue(_gl, "toneMappingExposure", _this.toneMappingExposure);
        if (materialProperties.needsLights) {
          markUniformsLightsNeedsUpdate(m_uniforms, refreshLights);
        }
        if (fog && material.fog === true) {
          materials2.refreshFogUniforms(m_uniforms, fog);
        }
        materials2.refreshMaterialUniforms(m_uniforms, material, _pixelRatio, _height, _transmissionRenderTarget);
        WebGLUniforms.upload(_gl, materialProperties.uniformsList, m_uniforms, textures);
      }
      if (material.isShaderMaterial && material.uniformsNeedUpdate === true) {
        WebGLUniforms.upload(_gl, materialProperties.uniformsList, m_uniforms, textures);
        material.uniformsNeedUpdate = false;
      }
      if (material.isSpriteMaterial) {
        p_uniforms.setValue(_gl, "center", object.center);
      }
      p_uniforms.setValue(_gl, "modelViewMatrix", object.modelViewMatrix);
      p_uniforms.setValue(_gl, "normalMatrix", object.normalMatrix);
      p_uniforms.setValue(_gl, "modelMatrix", object.matrixWorld);
      if (material.isShaderMaterial || material.isRawShaderMaterial) {
        const groups2 = material.uniformsGroups;
        for (let i2 = 0, l2 = groups2.length; i2 < l2; i2++) {
          if (capabilities2.isWebGL2) {
            const group = groups2[i2];
            uniformsGroups.update(group, program);
            uniformsGroups.bind(group, program);
          } else {
            console.warn("THREE.WebGLRenderer: Uniform Buffer Objects can only be used with WebGL 2.");
          }
        }
      }
      return program;
    }
    function markUniformsLightsNeedsUpdate(uniforms, value) {
      uniforms.ambientLightColor.needsUpdate = value;
      uniforms.lightProbe.needsUpdate = value;
      uniforms.directionalLights.needsUpdate = value;
      uniforms.directionalLightShadows.needsUpdate = value;
      uniforms.pointLights.needsUpdate = value;
      uniforms.pointLightShadows.needsUpdate = value;
      uniforms.spotLights.needsUpdate = value;
      uniforms.spotLightShadows.needsUpdate = value;
      uniforms.rectAreaLights.needsUpdate = value;
      uniforms.hemisphereLights.needsUpdate = value;
    }
    function materialNeedsLights(material) {
      return material.isMeshLambertMaterial || material.isMeshToonMaterial || material.isMeshPhongMaterial || material.isMeshStandardMaterial || material.isShadowMaterial || material.isShaderMaterial && material.lights === true;
    }
    this.getActiveCubeFace = function() {
      return _currentActiveCubeFace;
    };
    this.getActiveMipmapLevel = function() {
      return _currentActiveMipmapLevel;
    };
    this.getRenderTarget = function() {
      return _currentRenderTarget;
    };
    this.setRenderTargetTextures = function(renderTarget, colorTexture, depthTexture) {
      properties.get(renderTarget.texture).__webglTexture = colorTexture;
      properties.get(renderTarget.depthTexture).__webglTexture = depthTexture;
      const renderTargetProperties = properties.get(renderTarget);
      renderTargetProperties.__hasExternalTextures = true;
      if (renderTargetProperties.__hasExternalTextures) {
        renderTargetProperties.__autoAllocateDepthBuffer = depthTexture === void 0;
        if (!renderTargetProperties.__autoAllocateDepthBuffer) {
          if (extensions.has("WEBGL_multisampled_render_to_texture") === true) {
            console.warn("THREE.WebGLRenderer: Render-to-texture extension was disabled because an external texture was provided");
            renderTargetProperties.__useRenderToTexture = false;
          }
        }
      }
    };
    this.setRenderTargetFramebuffer = function(renderTarget, defaultFramebuffer) {
      const renderTargetProperties = properties.get(renderTarget);
      renderTargetProperties.__webglFramebuffer = defaultFramebuffer;
      renderTargetProperties.__useDefaultFramebuffer = defaultFramebuffer === void 0;
    };
    this.setRenderTarget = function(renderTarget, activeCubeFace = 0, activeMipmapLevel = 0) {
      _currentRenderTarget = renderTarget;
      _currentActiveCubeFace = activeCubeFace;
      _currentActiveMipmapLevel = activeMipmapLevel;
      let useDefaultFramebuffer = true;
      let framebuffer = null;
      let isCube = false;
      let isRenderTarget3D = false;
      if (renderTarget) {
        const renderTargetProperties = properties.get(renderTarget);
        if (renderTargetProperties.__useDefaultFramebuffer !== void 0) {
          state.bindFramebuffer(_gl.FRAMEBUFFER, null);
          useDefaultFramebuffer = false;
        } else if (renderTargetProperties.__webglFramebuffer === void 0) {
          textures.setupRenderTarget(renderTarget);
        } else if (renderTargetProperties.__hasExternalTextures) {
          textures.rebindTextures(renderTarget, properties.get(renderTarget.texture).__webglTexture, properties.get(renderTarget.depthTexture).__webglTexture);
        }
        const texture = renderTarget.texture;
        if (texture.isData3DTexture || texture.isDataArrayTexture || texture.isCompressedArrayTexture) {
          isRenderTarget3D = true;
        }
        const __webglFramebuffer = properties.get(renderTarget).__webglFramebuffer;
        if (renderTarget.isWebGLCubeRenderTarget) {
          framebuffer = __webglFramebuffer[activeCubeFace];
          isCube = true;
        } else if (capabilities2.isWebGL2 && renderTarget.samples > 0 && textures.useMultisampledRTT(renderTarget) === false) {
          framebuffer = properties.get(renderTarget).__webglMultisampledFramebuffer;
        } else {
          framebuffer = __webglFramebuffer;
        }
        _currentViewport.copy(renderTarget.viewport);
        _currentScissor.copy(renderTarget.scissor);
        _currentScissorTest = renderTarget.scissorTest;
      } else {
        _currentViewport.copy(_viewport2).multiplyScalar(_pixelRatio).floor();
        _currentScissor.copy(_scissor).multiplyScalar(_pixelRatio).floor();
        _currentScissorTest = _scissorTest;
      }
      const framebufferBound = state.bindFramebuffer(_gl.FRAMEBUFFER, framebuffer);
      if (framebufferBound && capabilities2.drawBuffers && useDefaultFramebuffer) {
        state.drawBuffers(renderTarget, framebuffer);
      }
      state.viewport(_currentViewport);
      state.scissor(_currentScissor);
      state.setScissorTest(_currentScissorTest);
      if (isCube) {
        const textureProperties = properties.get(renderTarget.texture);
        _gl.framebufferTexture2D(_gl.FRAMEBUFFER, _gl.COLOR_ATTACHMENT0, _gl.TEXTURE_CUBE_MAP_POSITIVE_X + activeCubeFace, textureProperties.__webglTexture, activeMipmapLevel);
      } else if (isRenderTarget3D) {
        const textureProperties = properties.get(renderTarget.texture);
        const layer = activeCubeFace || 0;
        _gl.framebufferTextureLayer(_gl.FRAMEBUFFER, _gl.COLOR_ATTACHMENT0, textureProperties.__webglTexture, activeMipmapLevel || 0, layer);
      }
      _currentMaterialId = -1;
    };
    this.readRenderTargetPixels = function(renderTarget, x3, y2, width, height, buffer, activeCubeFaceIndex) {
      if (!(renderTarget && renderTarget.isWebGLRenderTarget)) {
        console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.");
        return;
      }
      let framebuffer = properties.get(renderTarget).__webglFramebuffer;
      if (renderTarget.isWebGLCubeRenderTarget && activeCubeFaceIndex !== void 0) {
        framebuffer = framebuffer[activeCubeFaceIndex];
      }
      if (framebuffer) {
        state.bindFramebuffer(_gl.FRAMEBUFFER, framebuffer);
        try {
          const texture = renderTarget.texture;
          const textureFormat = texture.format;
          const textureType = texture.type;
          if (textureFormat !== RGBAFormat && utils2.convert(textureFormat) !== _gl.getParameter(_gl.IMPLEMENTATION_COLOR_READ_FORMAT)) {
            console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.");
            return;
          }
          const halfFloatSupportedByExt = textureType === HalfFloatType && (extensions.has("EXT_color_buffer_half_float") || capabilities2.isWebGL2 && extensions.has("EXT_color_buffer_float"));
          if (textureType !== UnsignedByteType && utils2.convert(textureType) !== _gl.getParameter(_gl.IMPLEMENTATION_COLOR_READ_TYPE) && // Edge and Chrome Mac < 52 (#9513)
          !(textureType === FloatType && (capabilities2.isWebGL2 || extensions.has("OES_texture_float") || extensions.has("WEBGL_color_buffer_float"))) && // Chrome Mac >= 52 and Firefox
          !halfFloatSupportedByExt) {
            console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.");
            return;
          }
          if (x3 >= 0 && x3 <= renderTarget.width - width && (y2 >= 0 && y2 <= renderTarget.height - height)) {
            _gl.readPixels(x3, y2, width, height, utils2.convert(textureFormat), utils2.convert(textureType), buffer);
          }
        } finally {
          const framebuffer2 = _currentRenderTarget !== null ? properties.get(_currentRenderTarget).__webglFramebuffer : null;
          state.bindFramebuffer(_gl.FRAMEBUFFER, framebuffer2);
        }
      }
    };
    this.copyFramebufferToTexture = function(position, texture, level = 0) {
      const levelScale = Math.pow(2, -level);
      const width = Math.floor(texture.image.width * levelScale);
      const height = Math.floor(texture.image.height * levelScale);
      textures.setTexture2D(texture, 0);
      _gl.copyTexSubImage2D(_gl.TEXTURE_2D, level, 0, 0, position.x, position.y, width, height);
      state.unbindTexture();
    };
    this.copyTextureToTexture = function(position, srcTexture, dstTexture, level = 0) {
      const width = srcTexture.image.width;
      const height = srcTexture.image.height;
      const glFormat = utils2.convert(dstTexture.format);
      const glType = utils2.convert(dstTexture.type);
      textures.setTexture2D(dstTexture, 0);
      _gl.pixelStorei(_gl.UNPACK_FLIP_Y_WEBGL, dstTexture.flipY);
      _gl.pixelStorei(_gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, dstTexture.premultiplyAlpha);
      _gl.pixelStorei(_gl.UNPACK_ALIGNMENT, dstTexture.unpackAlignment);
      if (srcTexture.isDataTexture) {
        _gl.texSubImage2D(_gl.TEXTURE_2D, level, position.x, position.y, width, height, glFormat, glType, srcTexture.image.data);
      } else {
        if (srcTexture.isCompressedTexture) {
          _gl.compressedTexSubImage2D(_gl.TEXTURE_2D, level, position.x, position.y, srcTexture.mipmaps[0].width, srcTexture.mipmaps[0].height, glFormat, srcTexture.mipmaps[0].data);
        } else {
          _gl.texSubImage2D(_gl.TEXTURE_2D, level, position.x, position.y, glFormat, glType, srcTexture.image);
        }
      }
      if (level === 0 && dstTexture.generateMipmaps) _gl.generateMipmap(_gl.TEXTURE_2D);
      state.unbindTexture();
    };
    this.copyTextureToTexture3D = function(sourceBox, position, srcTexture, dstTexture, level = 0) {
      if (_this.isWebGL1Renderer) {
        console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: can only be used with WebGL2.");
        return;
      }
      const width = sourceBox.max.x - sourceBox.min.x + 1;
      const height = sourceBox.max.y - sourceBox.min.y + 1;
      const depth2 = sourceBox.max.z - sourceBox.min.z + 1;
      const glFormat = utils2.convert(dstTexture.format);
      const glType = utils2.convert(dstTexture.type);
      let glTarget;
      if (dstTexture.isData3DTexture) {
        textures.setTexture3D(dstTexture, 0);
        glTarget = _gl.TEXTURE_3D;
      } else if (dstTexture.isDataArrayTexture) {
        textures.setTexture2DArray(dstTexture, 0);
        glTarget = _gl.TEXTURE_2D_ARRAY;
      } else {
        console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: only supports THREE.DataTexture3D and THREE.DataTexture2DArray.");
        return;
      }
      _gl.pixelStorei(_gl.UNPACK_FLIP_Y_WEBGL, dstTexture.flipY);
      _gl.pixelStorei(_gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, dstTexture.premultiplyAlpha);
      _gl.pixelStorei(_gl.UNPACK_ALIGNMENT, dstTexture.unpackAlignment);
      const unpackRowLen = _gl.getParameter(_gl.UNPACK_ROW_LENGTH);
      const unpackImageHeight = _gl.getParameter(_gl.UNPACK_IMAGE_HEIGHT);
      const unpackSkipPixels = _gl.getParameter(_gl.UNPACK_SKIP_PIXELS);
      const unpackSkipRows = _gl.getParameter(_gl.UNPACK_SKIP_ROWS);
      const unpackSkipImages = _gl.getParameter(_gl.UNPACK_SKIP_IMAGES);
      const image = srcTexture.isCompressedTexture ? srcTexture.mipmaps[0] : srcTexture.image;
      _gl.pixelStorei(_gl.UNPACK_ROW_LENGTH, image.width);
      _gl.pixelStorei(_gl.UNPACK_IMAGE_HEIGHT, image.height);
      _gl.pixelStorei(_gl.UNPACK_SKIP_PIXELS, sourceBox.min.x);
      _gl.pixelStorei(_gl.UNPACK_SKIP_ROWS, sourceBox.min.y);
      _gl.pixelStorei(_gl.UNPACK_SKIP_IMAGES, sourceBox.min.z);
      if (srcTexture.isDataTexture || srcTexture.isData3DTexture) {
        _gl.texSubImage3D(glTarget, level, position.x, position.y, position.z, width, height, depth2, glFormat, glType, image.data);
      } else {
        if (srcTexture.isCompressedArrayTexture) {
          console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: untested support for compressed srcTexture.");
          _gl.compressedTexSubImage3D(glTarget, level, position.x, position.y, position.z, width, height, depth2, glFormat, image.data);
        } else {
          _gl.texSubImage3D(glTarget, level, position.x, position.y, position.z, width, height, depth2, glFormat, glType, image);
        }
      }
      _gl.pixelStorei(_gl.UNPACK_ROW_LENGTH, unpackRowLen);
      _gl.pixelStorei(_gl.UNPACK_IMAGE_HEIGHT, unpackImageHeight);
      _gl.pixelStorei(_gl.UNPACK_SKIP_PIXELS, unpackSkipPixels);
      _gl.pixelStorei(_gl.UNPACK_SKIP_ROWS, unpackSkipRows);
      _gl.pixelStorei(_gl.UNPACK_SKIP_IMAGES, unpackSkipImages);
      if (level === 0 && dstTexture.generateMipmaps) _gl.generateMipmap(glTarget);
      state.unbindTexture();
    };
    this.initTexture = function(texture) {
      if (texture.isCubeTexture) {
        textures.setTextureCube(texture, 0);
      } else if (texture.isData3DTexture) {
        textures.setTexture3D(texture, 0);
      } else if (texture.isDataArrayTexture || texture.isCompressedArrayTexture) {
        textures.setTexture2DArray(texture, 0);
      } else {
        textures.setTexture2D(texture, 0);
      }
      state.unbindTexture();
    };
    this.resetState = function() {
      _currentActiveCubeFace = 0;
      _currentActiveMipmapLevel = 0;
      _currentRenderTarget = null;
      state.reset();
      bindingStates.reset();
    };
    if (typeof __THREE_DEVTOOLS__ !== "undefined") {
      __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe", { detail: this }));
    }
  }
  get coordinateSystem() {
    return WebGLCoordinateSystem;
  }
  get physicallyCorrectLights() {
    console.warn("THREE.WebGLRenderer: the property .physicallyCorrectLights has been removed. Set renderer.useLegacyLights instead.");
    return !this.useLegacyLights;
  }
  set physicallyCorrectLights(value) {
    console.warn("THREE.WebGLRenderer: the property .physicallyCorrectLights has been removed. Set renderer.useLegacyLights instead.");
    this.useLegacyLights = !value;
  }
  get outputEncoding() {
    console.warn("THREE.WebGLRenderer: Property .outputEncoding has been removed. Use .outputColorSpace instead.");
    return this.outputColorSpace === SRGBColorSpace ? sRGBEncoding : LinearEncoding;
  }
  set outputEncoding(encoding) {
    console.warn("THREE.WebGLRenderer: Property .outputEncoding has been removed. Use .outputColorSpace instead.");
    this.outputColorSpace = encoding === sRGBEncoding ? SRGBColorSpace : LinearSRGBColorSpace;
  }
};
var WebGL1Renderer = class extends WebGLRenderer {
};
WebGL1Renderer.prototype.isWebGL1Renderer = true;
var FogExp2 = class _FogExp2 {
  constructor(color, density = 25e-5) {
    this.isFogExp2 = true;
    this.name = "";
    this.color = new Color(color);
    this.density = density;
  }
  clone() {
    return new _FogExp2(this.color, this.density);
  }
  toJSON() {
    return {
      type: "FogExp2",
      color: this.color.getHex(),
      density: this.density
    };
  }
};
var Fog = class _Fog {
  constructor(color, near = 1, far = 1e3) {
    this.isFog = true;
    this.name = "";
    this.color = new Color(color);
    this.near = near;
    this.far = far;
  }
  clone() {
    return new _Fog(this.color, this.near, this.far);
  }
  toJSON() {
    return {
      type: "Fog",
      color: this.color.getHex(),
      near: this.near,
      far: this.far
    };
  }
};
var Scene = class extends Object3D {
  constructor() {
    super();
    this.isScene = true;
    this.type = "Scene";
    this.background = null;
    this.environment = null;
    this.fog = null;
    this.backgroundBlurriness = 0;
    this.backgroundIntensity = 1;
    this.overrideMaterial = null;
    if (typeof __THREE_DEVTOOLS__ !== "undefined") {
      __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe", { detail: this }));
    }
  }
  copy(source, recursive) {
    super.copy(source, recursive);
    if (source.background !== null) this.background = source.background.clone();
    if (source.environment !== null) this.environment = source.environment.clone();
    if (source.fog !== null) this.fog = source.fog.clone();
    this.backgroundBlurriness = source.backgroundBlurriness;
    this.backgroundIntensity = source.backgroundIntensity;
    if (source.overrideMaterial !== null) this.overrideMaterial = source.overrideMaterial.clone();
    this.matrixAutoUpdate = source.matrixAutoUpdate;
    return this;
  }
  toJSON(meta) {
    const data = super.toJSON(meta);
    if (this.fog !== null) data.object.fog = this.fog.toJSON();
    if (this.backgroundBlurriness > 0) data.object.backgroundBlurriness = this.backgroundBlurriness;
    if (this.backgroundIntensity !== 1) data.object.backgroundIntensity = this.backgroundIntensity;
    return data;
  }
  get autoUpdate() {
    console.warn("THREE.Scene: autoUpdate was renamed to matrixWorldAutoUpdate in r144.");
    return this.matrixWorldAutoUpdate;
  }
  set autoUpdate(value) {
    console.warn("THREE.Scene: autoUpdate was renamed to matrixWorldAutoUpdate in r144.");
    this.matrixWorldAutoUpdate = value;
  }
};
var InterleavedBuffer = class {
  constructor(array, stride) {
    this.isInterleavedBuffer = true;
    this.array = array;
    this.stride = stride;
    this.count = array !== void 0 ? array.length / stride : 0;
    this.usage = StaticDrawUsage;
    this.updateRange = { offset: 0, count: -1 };
    this.version = 0;
    this.uuid = generateUUID();
  }
  onUploadCallback() {
  }
  set needsUpdate(value) {
    if (value === true) this.version++;
  }
  setUsage(value) {
    this.usage = value;
    return this;
  }
  copy(source) {
    this.array = new source.array.constructor(source.array);
    this.count = source.count;
    this.stride = source.stride;
    this.usage = source.usage;
    return this;
  }
  copyAt(index1, attribute, index2) {
    index1 *= this.stride;
    index2 *= attribute.stride;
    for (let i2 = 0, l2 = this.stride; i2 < l2; i2++) {
      this.array[index1 + i2] = attribute.array[index2 + i2];
    }
    return this;
  }
  set(value, offset = 0) {
    this.array.set(value, offset);
    return this;
  }
  clone(data) {
    if (data.arrayBuffers === void 0) {
      data.arrayBuffers = {};
    }
    if (this.array.buffer._uuid === void 0) {
      this.array.buffer._uuid = generateUUID();
    }
    if (data.arrayBuffers[this.array.buffer._uuid] === void 0) {
      data.arrayBuffers[this.array.buffer._uuid] = this.array.slice(0).buffer;
    }
    const array = new this.array.constructor(data.arrayBuffers[this.array.buffer._uuid]);
    const ib = new this.constructor(array, this.stride);
    ib.setUsage(this.usage);
    return ib;
  }
  onUpload(callback) {
    this.onUploadCallback = callback;
    return this;
  }
  toJSON(data) {
    if (data.arrayBuffers === void 0) {
      data.arrayBuffers = {};
    }
    if (this.array.buffer._uuid === void 0) {
      this.array.buffer._uuid = generateUUID();
    }
    if (data.arrayBuffers[this.array.buffer._uuid] === void 0) {
      data.arrayBuffers[this.array.buffer._uuid] = Array.from(new Uint32Array(this.array.buffer));
    }
    return {
      uuid: this.uuid,
      buffer: this.array.buffer._uuid,
      type: this.array.constructor.name,
      stride: this.stride
    };
  }
};
var _vector$5 = new Vector3();
var InterleavedBufferAttribute = class _InterleavedBufferAttribute {
  constructor(interleavedBuffer, itemSize, offset, normalized = false) {
    this.isInterleavedBufferAttribute = true;
    this.name = "";
    this.data = interleavedBuffer;
    this.itemSize = itemSize;
    this.offset = offset;
    this.normalized = normalized;
  }
  get count() {
    return this.data.count;
  }
  get array() {
    return this.data.array;
  }
  set needsUpdate(value) {
    this.data.needsUpdate = value;
  }
  applyMatrix4(m2) {
    for (let i2 = 0, l2 = this.data.count; i2 < l2; i2++) {
      _vector$5.fromBufferAttribute(this, i2);
      _vector$5.applyMatrix4(m2);
      this.setXYZ(i2, _vector$5.x, _vector$5.y, _vector$5.z);
    }
    return this;
  }
  applyNormalMatrix(m2) {
    for (let i2 = 0, l2 = this.count; i2 < l2; i2++) {
      _vector$5.fromBufferAttribute(this, i2);
      _vector$5.applyNormalMatrix(m2);
      this.setXYZ(i2, _vector$5.x, _vector$5.y, _vector$5.z);
    }
    return this;
  }
  transformDirection(m2) {
    for (let i2 = 0, l2 = this.count; i2 < l2; i2++) {
      _vector$5.fromBufferAttribute(this, i2);
      _vector$5.transformDirection(m2);
      this.setXYZ(i2, _vector$5.x, _vector$5.y, _vector$5.z);
    }
    return this;
  }
  setX(index, x3) {
    if (this.normalized) x3 = normalize(x3, this.array);
    this.data.array[index * this.data.stride + this.offset] = x3;
    return this;
  }
  setY(index, y2) {
    if (this.normalized) y2 = normalize(y2, this.array);
    this.data.array[index * this.data.stride + this.offset + 1] = y2;
    return this;
  }
  setZ(index, z) {
    if (this.normalized) z = normalize(z, this.array);
    this.data.array[index * this.data.stride + this.offset + 2] = z;
    return this;
  }
  setW(index, w2) {
    if (this.normalized) w2 = normalize(w2, this.array);
    this.data.array[index * this.data.stride + this.offset + 3] = w2;
    return this;
  }
  getX(index) {
    let x3 = this.data.array[index * this.data.stride + this.offset];
    if (this.normalized) x3 = denormalize(x3, this.array);
    return x3;
  }
  getY(index) {
    let y2 = this.data.array[index * this.data.stride + this.offset + 1];
    if (this.normalized) y2 = denormalize(y2, this.array);
    return y2;
  }
  getZ(index) {
    let z = this.data.array[index * this.data.stride + this.offset + 2];
    if (this.normalized) z = denormalize(z, this.array);
    return z;
  }
  getW(index) {
    let w2 = this.data.array[index * this.data.stride + this.offset + 3];
    if (this.normalized) w2 = denormalize(w2, this.array);
    return w2;
  }
  setXY(index, x3, y2) {
    index = index * this.data.stride + this.offset;
    if (this.normalized) {
      x3 = normalize(x3, this.array);
      y2 = normalize(y2, this.array);
    }
    this.data.array[index + 0] = x3;
    this.data.array[index + 1] = y2;
    return this;
  }
  setXYZ(index, x3, y2, z) {
    index = index * this.data.stride + this.offset;
    if (this.normalized) {
      x3 = normalize(x3, this.array);
      y2 = normalize(y2, this.array);
      z = normalize(z, this.array);
    }
    this.data.array[index + 0] = x3;
    this.data.array[index + 1] = y2;
    this.data.array[index + 2] = z;
    return this;
  }
  setXYZW(index, x3, y2, z, w2) {
    index = index * this.data.stride + this.offset;
    if (this.normalized) {
      x3 = normalize(x3, this.array);
      y2 = normalize(y2, this.array);
      z = normalize(z, this.array);
      w2 = normalize(w2, this.array);
    }
    this.data.array[index + 0] = x3;
    this.data.array[index + 1] = y2;
    this.data.array[index + 2] = z;
    this.data.array[index + 3] = w2;
    return this;
  }
  clone(data) {
    if (data === void 0) {
      console.log("THREE.InterleavedBufferAttribute.clone(): Cloning an interleaved buffer attribute will de-interleave buffer data.");
      const array = [];
      for (let i2 = 0; i2 < this.count; i2++) {
        const index = i2 * this.data.stride + this.offset;
        for (let j = 0; j < this.itemSize; j++) {
          array.push(this.data.array[index + j]);
        }
      }
      return new BufferAttribute(new this.array.constructor(array), this.itemSize, this.normalized);
    } else {
      if (data.interleavedBuffers === void 0) {
        data.interleavedBuffers = {};
      }
      if (data.interleavedBuffers[this.data.uuid] === void 0) {
        data.interleavedBuffers[this.data.uuid] = this.data.clone(data);
      }
      return new _InterleavedBufferAttribute(data.interleavedBuffers[this.data.uuid], this.itemSize, this.offset, this.normalized);
    }
  }
  toJSON(data) {
    if (data === void 0) {
      console.log("THREE.InterleavedBufferAttribute.toJSON(): Serializing an interleaved buffer attribute will de-interleave buffer data.");
      const array = [];
      for (let i2 = 0; i2 < this.count; i2++) {
        const index = i2 * this.data.stride + this.offset;
        for (let j = 0; j < this.itemSize; j++) {
          array.push(this.data.array[index + j]);
        }
      }
      return {
        itemSize: this.itemSize,
        type: this.array.constructor.name,
        array,
        normalized: this.normalized
      };
    } else {
      if (data.interleavedBuffers === void 0) {
        data.interleavedBuffers = {};
      }
      if (data.interleavedBuffers[this.data.uuid] === void 0) {
        data.interleavedBuffers[this.data.uuid] = this.data.toJSON(data);
      }
      return {
        isInterleavedBufferAttribute: true,
        itemSize: this.itemSize,
        data: this.data.uuid,
        offset: this.offset,
        normalized: this.normalized
      };
    }
  }
};
var SpriteMaterial = class extends Material {
  constructor(parameters) {
    super();
    this.isSpriteMaterial = true;
    this.type = "SpriteMaterial";
    this.color = new Color(16777215);
    this.map = null;
    this.alphaMap = null;
    this.rotation = 0;
    this.sizeAttenuation = true;
    this.transparent = true;
    this.fog = true;
    this.setValues(parameters);
  }
  copy(source) {
    super.copy(source);
    this.color.copy(source.color);
    this.map = source.map;
    this.alphaMap = source.alphaMap;
    this.rotation = source.rotation;
    this.sizeAttenuation = source.sizeAttenuation;
    this.fog = source.fog;
    return this;
  }
};
var _geometry;
var _intersectPoint = new Vector3();
var _worldScale = new Vector3();
var _mvPosition = new Vector3();
var _alignedPosition = new Vector2();
var _rotatedPosition = new Vector2();
var _viewWorldMatrix = new Matrix4();
var _vA = new Vector3();
var _vB = new Vector3();
var _vC = new Vector3();
var _uvA = new Vector2();
var _uvB = new Vector2();
var _uvC = new Vector2();
var Sprite = class extends Object3D {
  constructor(material) {
    super();
    this.isSprite = true;
    this.type = "Sprite";
    if (_geometry === void 0) {
      _geometry = new BufferGeometry();
      const float32Array = new Float32Array([
        -0.5,
        -0.5,
        0,
        0,
        0,
        0.5,
        -0.5,
        0,
        1,
        0,
        0.5,
        0.5,
        0,
        1,
        1,
        -0.5,
        0.5,
        0,
        0,
        1
      ]);
      const interleavedBuffer = new InterleavedBuffer(float32Array, 5);
      _geometry.setIndex([0, 1, 2, 0, 2, 3]);
      _geometry.setAttribute("position", new InterleavedBufferAttribute(interleavedBuffer, 3, 0, false));
      _geometry.setAttribute("uv", new InterleavedBufferAttribute(interleavedBuffer, 2, 3, false));
    }
    this.geometry = _geometry;
    this.material = material !== void 0 ? material : new SpriteMaterial();
    this.center = new Vector2(0.5, 0.5);
  }
  raycast(raycaster, intersects2) {
    if (raycaster.camera === null) {
      console.error('THREE.Sprite: "Raycaster.camera" needs to be set in order to raycast against sprites.');
    }
    _worldScale.setFromMatrixScale(this.matrixWorld);
    _viewWorldMatrix.copy(raycaster.camera.matrixWorld);
    this.modelViewMatrix.multiplyMatrices(raycaster.camera.matrixWorldInverse, this.matrixWorld);
    _mvPosition.setFromMatrixPosition(this.modelViewMatrix);
    if (raycaster.camera.isPerspectiveCamera && this.material.sizeAttenuation === false) {
      _worldScale.multiplyScalar(-_mvPosition.z);
    }
    const rotation = this.material.rotation;
    let sin, cos;
    if (rotation !== 0) {
      cos = Math.cos(rotation);
      sin = Math.sin(rotation);
    }
    const center = this.center;
    transformVertex(_vA.set(-0.5, -0.5, 0), _mvPosition, center, _worldScale, sin, cos);
    transformVertex(_vB.set(0.5, -0.5, 0), _mvPosition, center, _worldScale, sin, cos);
    transformVertex(_vC.set(0.5, 0.5, 0), _mvPosition, center, _worldScale, sin, cos);
    _uvA.set(0, 0);
    _uvB.set(1, 0);
    _uvC.set(1, 1);
    let intersect = raycaster.ray.intersectTriangle(_vA, _vB, _vC, false, _intersectPoint);
    if (intersect === null) {
      transformVertex(_vB.set(-0.5, 0.5, 0), _mvPosition, center, _worldScale, sin, cos);
      _uvB.set(0, 1);
      intersect = raycaster.ray.intersectTriangle(_vA, _vC, _vB, false, _intersectPoint);
      if (intersect === null) {
        return;
      }
    }
    const distance = raycaster.ray.origin.distanceTo(_intersectPoint);
    if (distance < raycaster.near || distance > raycaster.far) return;
    intersects2.push({
      distance,
      point: _intersectPoint.clone(),
      uv: Triangle.getInterpolation(_intersectPoint, _vA, _vB, _vC, _uvA, _uvB, _uvC, new Vector2()),
      face: null,
      object: this
    });
  }
  copy(source, recursive) {
    super.copy(source, recursive);
    if (source.center !== void 0) this.center.copy(source.center);
    this.material = source.material;
    return this;
  }
};
function transformVertex(vertexPosition, mvPosition, center, scale, sin, cos) {
  _alignedPosition.subVectors(vertexPosition, center).addScalar(0.5).multiply(scale);
  if (sin !== void 0) {
    _rotatedPosition.x = cos * _alignedPosition.x - sin * _alignedPosition.y;
    _rotatedPosition.y = sin * _alignedPosition.x + cos * _alignedPosition.y;
  } else {
    _rotatedPosition.copy(_alignedPosition);
  }
  vertexPosition.copy(mvPosition);
  vertexPosition.x += _rotatedPosition.x;
  vertexPosition.y += _rotatedPosition.y;
  vertexPosition.applyMatrix4(_viewWorldMatrix);
}
var _v1$2 = new Vector3();
var _v2$1 = new Vector3();
var LOD = class extends Object3D {
  constructor() {
    super();
    this._currentLevel = 0;
    this.type = "LOD";
    Object.defineProperties(this, {
      levels: {
        enumerable: true,
        value: []
      },
      isLOD: {
        value: true
      }
    });
    this.autoUpdate = true;
  }
  copy(source) {
    super.copy(source, false);
    const levels = source.levels;
    for (let i2 = 0, l2 = levels.length; i2 < l2; i2++) {
      const level = levels[i2];
      this.addLevel(level.object.clone(), level.distance, level.hysteresis);
    }
    this.autoUpdate = source.autoUpdate;
    return this;
  }
  addLevel(object, distance = 0, hysteresis = 0) {
    distance = Math.abs(distance);
    const levels = this.levels;
    let l2;
    for (l2 = 0; l2 < levels.length; l2++) {
      if (distance < levels[l2].distance) {
        break;
      }
    }
    levels.splice(l2, 0, { distance, hysteresis, object });
    this.add(object);
    return this;
  }
  getCurrentLevel() {
    return this._currentLevel;
  }
  getObjectForDistance(distance) {
    const levels = this.levels;
    if (levels.length > 0) {
      let i2, l2;
      for (i2 = 1, l2 = levels.length; i2 < l2; i2++) {
        let levelDistance = levels[i2].distance;
        if (levels[i2].object.visible) {
          levelDistance -= levelDistance * levels[i2].hysteresis;
        }
        if (distance < levelDistance) {
          break;
        }
      }
      return levels[i2 - 1].object;
    }
    return null;
  }
  raycast(raycaster, intersects2) {
    const levels = this.levels;
    if (levels.length > 0) {
      _v1$2.setFromMatrixPosition(this.matrixWorld);
      const distance = raycaster.ray.origin.distanceTo(_v1$2);
      this.getObjectForDistance(distance).raycast(raycaster, intersects2);
    }
  }
  update(camera) {
    const levels = this.levels;
    if (levels.length > 1) {
      _v1$2.setFromMatrixPosition(camera.matrixWorld);
      _v2$1.setFromMatrixPosition(this.matrixWorld);
      const distance = _v1$2.distanceTo(_v2$1) / camera.zoom;
      levels[0].object.visible = true;
      let i2, l2;
      for (i2 = 1, l2 = levels.length; i2 < l2; i2++) {
        let levelDistance = levels[i2].distance;
        if (levels[i2].object.visible) {
          levelDistance -= levelDistance * levels[i2].hysteresis;
        }
        if (distance >= levelDistance) {
          levels[i2 - 1].object.visible = false;
          levels[i2].object.visible = true;
        } else {
          break;
        }
      }
      this._currentLevel = i2 - 1;
      for (; i2 < l2; i2++) {
        levels[i2].object.visible = false;
      }
    }
  }
  toJSON(meta) {
    const data = super.toJSON(meta);
    if (this.autoUpdate === false) data.object.autoUpdate = false;
    data.object.levels = [];
    const levels = this.levels;
    for (let i2 = 0, l2 = levels.length; i2 < l2; i2++) {
      const level = levels[i2];
      data.object.levels.push({
        object: level.object.uuid,
        distance: level.distance,
        hysteresis: level.hysteresis
      });
    }
    return data;
  }
};
var _basePosition = new Vector3();
var _skinIndex = new Vector4();
var _skinWeight = new Vector4();
var _vector3 = new Vector3();
var _matrix4 = new Matrix4();
var _vertex = new Vector3();
var _sphere$3 = new Sphere();
var _inverseMatrix$2 = new Matrix4();
var _ray$2 = new Ray();
var SkinnedMesh = class extends Mesh {
  constructor(geometry, material) {
    super(geometry, material);
    this.isSkinnedMesh = true;
    this.type = "SkinnedMesh";
    this.bindMode = "attached";
    this.bindMatrix = new Matrix4();
    this.bindMatrixInverse = new Matrix4();
    this.boundingBox = null;
    this.boundingSphere = null;
  }
  computeBoundingBox() {
    const geometry = this.geometry;
    if (this.boundingBox === null) {
      this.boundingBox = new Box3();
    }
    this.boundingBox.makeEmpty();
    const positionAttribute = geometry.getAttribute("position");
    for (let i2 = 0; i2 < positionAttribute.count; i2++) {
      _vertex.fromBufferAttribute(positionAttribute, i2);
      this.applyBoneTransform(i2, _vertex);
      this.boundingBox.expandByPoint(_vertex);
    }
  }
  computeBoundingSphere() {
    const geometry = this.geometry;
    if (this.boundingSphere === null) {
      this.boundingSphere = new Sphere();
    }
    this.boundingSphere.makeEmpty();
    const positionAttribute = geometry.getAttribute("position");
    for (let i2 = 0; i2 < positionAttribute.count; i2++) {
      _vertex.fromBufferAttribute(positionAttribute, i2);
      this.applyBoneTransform(i2, _vertex);
      this.boundingSphere.expandByPoint(_vertex);
    }
  }
  copy(source, recursive) {
    super.copy(source, recursive);
    this.bindMode = source.bindMode;
    this.bindMatrix.copy(source.bindMatrix);
    this.bindMatrixInverse.copy(source.bindMatrixInverse);
    this.skeleton = source.skeleton;
    if (source.boundingBox !== null) this.boundingBox = source.boundingBox.clone();
    if (source.boundingSphere !== null) this.boundingSphere = source.boundingSphere.clone();
    return this;
  }
  raycast(raycaster, intersects2) {
    const material = this.material;
    const matrixWorld = this.matrixWorld;
    if (material === void 0) return;
    if (this.boundingSphere === null) this.computeBoundingSphere();
    _sphere$3.copy(this.boundingSphere);
    _sphere$3.applyMatrix4(matrixWorld);
    if (raycaster.ray.intersectsSphere(_sphere$3) === false) return;
    _inverseMatrix$2.copy(matrixWorld).invert();
    _ray$2.copy(raycaster.ray).applyMatrix4(_inverseMatrix$2);
    if (this.boundingBox !== null) {
      if (_ray$2.intersectsBox(this.boundingBox) === false) return;
    }
    this._computeIntersections(raycaster, intersects2, _ray$2);
  }
  getVertexPosition(index, target) {
    super.getVertexPosition(index, target);
    this.applyBoneTransform(index, target);
    return target;
  }
  bind(skeleton, bindMatrix) {
    this.skeleton = skeleton;
    if (bindMatrix === void 0) {
      this.updateMatrixWorld(true);
      this.skeleton.calculateInverses();
      bindMatrix = this.matrixWorld;
    }
    this.bindMatrix.copy(bindMatrix);
    this.bindMatrixInverse.copy(bindMatrix).invert();
  }
  pose() {
    this.skeleton.pose();
  }
  normalizeSkinWeights() {
    const vector = new Vector4();
    const skinWeight = this.geometry.attributes.skinWeight;
    for (let i2 = 0, l2 = skinWeight.count; i2 < l2; i2++) {
      vector.fromBufferAttribute(skinWeight, i2);
      const scale = 1 / vector.manhattanLength();
      if (scale !== Infinity) {
        vector.multiplyScalar(scale);
      } else {
        vector.set(1, 0, 0, 0);
      }
      skinWeight.setXYZW(i2, vector.x, vector.y, vector.z, vector.w);
    }
  }
  updateMatrixWorld(force) {
    super.updateMatrixWorld(force);
    if (this.bindMode === "attached") {
      this.bindMatrixInverse.copy(this.matrixWorld).invert();
    } else if (this.bindMode === "detached") {
      this.bindMatrixInverse.copy(this.bindMatrix).invert();
    } else {
      console.warn("THREE.SkinnedMesh: Unrecognized bindMode: " + this.bindMode);
    }
  }
  applyBoneTransform(index, vector) {
    const skeleton = this.skeleton;
    const geometry = this.geometry;
    _skinIndex.fromBufferAttribute(geometry.attributes.skinIndex, index);
    _skinWeight.fromBufferAttribute(geometry.attributes.skinWeight, index);
    _basePosition.copy(vector).applyMatrix4(this.bindMatrix);
    vector.set(0, 0, 0);
    for (let i2 = 0; i2 < 4; i2++) {
      const weight = _skinWeight.getComponent(i2);
      if (weight !== 0) {
        const boneIndex = _skinIndex.getComponent(i2);
        _matrix4.multiplyMatrices(skeleton.bones[boneIndex].matrixWorld, skeleton.boneInverses[boneIndex]);
        vector.addScaledVector(_vector3.copy(_basePosition).applyMatrix4(_matrix4), weight);
      }
    }
    return vector.applyMatrix4(this.bindMatrixInverse);
  }
  boneTransform(index, vector) {
    console.warn("THREE.SkinnedMesh: .boneTransform() was renamed to .applyBoneTransform() in r151.");
    return this.applyBoneTransform(index, vector);
  }
};
var Bone = class extends Object3D {
  constructor() {
    super();
    this.isBone = true;
    this.type = "Bone";
  }
};
var DataTexture = class extends Texture {
  constructor(data = null, width = 1, height = 1, format, type, mapping, wrapS, wrapT, magFilter = NearestFilter, minFilter = NearestFilter, anisotropy, colorSpace) {
    super(null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, colorSpace);
    this.isDataTexture = true;
    this.image = { data, width, height };
    this.generateMipmaps = false;
    this.flipY = false;
    this.unpackAlignment = 1;
  }
};
var _offsetMatrix = new Matrix4();
var _identityMatrix = new Matrix4();
var Skeleton = class _Skeleton {
  constructor(bones = [], boneInverses = []) {
    this.uuid = generateUUID();
    this.bones = bones.slice(0);
    this.boneInverses = boneInverses;
    this.boneMatrices = null;
    this.boneTexture = null;
    this.boneTextureSize = 0;
    this.frame = -1;
    this.init();
  }
  init() {
    const bones = this.bones;
    const boneInverses = this.boneInverses;
    this.boneMatrices = new Float32Array(bones.length * 16);
    if (boneInverses.length === 0) {
      this.calculateInverses();
    } else {
      if (bones.length !== boneInverses.length) {
        console.warn("THREE.Skeleton: Number of inverse bone matrices does not match amount of bones.");
        this.boneInverses = [];
        for (let i2 = 0, il = this.bones.length; i2 < il; i2++) {
          this.boneInverses.push(new Matrix4());
        }
      }
    }
  }
  calculateInverses() {
    this.boneInverses.length = 0;
    for (let i2 = 0, il = this.bones.length; i2 < il; i2++) {
      const inverse = new Matrix4();
      if (this.bones[i2]) {
        inverse.copy(this.bones[i2].matrixWorld).invert();
      }
      this.boneInverses.push(inverse);
    }
  }
  pose() {
    for (let i2 = 0, il = this.bones.length; i2 < il; i2++) {
      const bone = this.bones[i2];
      if (bone) {
        bone.matrixWorld.copy(this.boneInverses[i2]).invert();
      }
    }
    for (let i2 = 0, il = this.bones.length; i2 < il; i2++) {
      const bone = this.bones[i2];
      if (bone) {
        if (bone.parent && bone.parent.isBone) {
          bone.matrix.copy(bone.parent.matrixWorld).invert();
          bone.matrix.multiply(bone.matrixWorld);
        } else {
          bone.matrix.copy(bone.matrixWorld);
        }
        bone.matrix.decompose(bone.position, bone.quaternion, bone.scale);
      }
    }
  }
  update() {
    const bones = this.bones;
    const boneInverses = this.boneInverses;
    const boneMatrices = this.boneMatrices;
    const boneTexture = this.boneTexture;
    for (let i2 = 0, il = bones.length; i2 < il; i2++) {
      const matrix = bones[i2] ? bones[i2].matrixWorld : _identityMatrix;
      _offsetMatrix.multiplyMatrices(matrix, boneInverses[i2]);
      _offsetMatrix.toArray(boneMatrices, i2 * 16);
    }
    if (boneTexture !== null) {
      boneTexture.needsUpdate = true;
    }
  }
  clone() {
    return new _Skeleton(this.bones, this.boneInverses);
  }
  computeBoneTexture() {
    let size = Math.sqrt(this.bones.length * 4);
    size = ceilPowerOfTwo(size);
    size = Math.max(size, 4);
    const boneMatrices = new Float32Array(size * size * 4);
    boneMatrices.set(this.boneMatrices);
    const boneTexture = new DataTexture(boneMatrices, size, size, RGBAFormat, FloatType);
    boneTexture.needsUpdate = true;
    this.boneMatrices = boneMatrices;
    this.boneTexture = boneTexture;
    this.boneTextureSize = size;
    return this;
  }
  getBoneByName(name) {
    for (let i2 = 0, il = this.bones.length; i2 < il; i2++) {
      const bone = this.bones[i2];
      if (bone.name === name) {
        return bone;
      }
    }
    return void 0;
  }
  dispose() {
    if (this.boneTexture !== null) {
      this.boneTexture.dispose();
      this.boneTexture = null;
    }
  }
  fromJSON(json, bones) {
    this.uuid = json.uuid;
    for (let i2 = 0, l2 = json.bones.length; i2 < l2; i2++) {
      const uuid = json.bones[i2];
      let bone = bones[uuid];
      if (bone === void 0) {
        console.warn("THREE.Skeleton: No bone found with UUID:", uuid);
        bone = new Bone();
      }
      this.bones.push(bone);
      this.boneInverses.push(new Matrix4().fromArray(json.boneInverses[i2]));
    }
    this.init();
    return this;
  }
  toJSON() {
    const data = {
      metadata: {
        version: 4.6,
        type: "Skeleton",
        generator: "Skeleton.toJSON"
      },
      bones: [],
      boneInverses: []
    };
    data.uuid = this.uuid;
    const bones = this.bones;
    const boneInverses = this.boneInverses;
    for (let i2 = 0, l2 = bones.length; i2 < l2; i2++) {
      const bone = bones[i2];
      data.bones.push(bone.uuid);
      const boneInverse = boneInverses[i2];
      data.boneInverses.push(boneInverse.toArray());
    }
    return data;
  }
};
var InstancedBufferAttribute = class extends BufferAttribute {
  constructor(array, itemSize, normalized, meshPerAttribute = 1) {
    super(array, itemSize, normalized);
    this.isInstancedBufferAttribute = true;
    this.meshPerAttribute = meshPerAttribute;
  }
  copy(source) {
    super.copy(source);
    this.meshPerAttribute = source.meshPerAttribute;
    return this;
  }
  toJSON() {
    const data = super.toJSON();
    data.meshPerAttribute = this.meshPerAttribute;
    data.isInstancedBufferAttribute = true;
    return data;
  }
};
var _instanceLocalMatrix = new Matrix4();
var _instanceWorldMatrix = new Matrix4();
var _instanceIntersects = [];
var _box3 = new Box3();
var _identity = new Matrix4();
var _mesh = new Mesh();
var _sphere$2 = new Sphere();
var InstancedMesh = class extends Mesh {
  constructor(geometry, material, count) {
    super(geometry, material);
    this.isInstancedMesh = true;
    this.instanceMatrix = new InstancedBufferAttribute(new Float32Array(count * 16), 16);
    this.instanceColor = null;
    this.count = count;
    this.boundingBox = null;
    this.boundingSphere = null;
    for (let i2 = 0; i2 < count; i2++) {
      this.setMatrixAt(i2, _identity);
    }
  }
  computeBoundingBox() {
    const geometry = this.geometry;
    const count = this.count;
    if (this.boundingBox === null) {
      this.boundingBox = new Box3();
    }
    if (geometry.boundingBox === null) {
      geometry.computeBoundingBox();
    }
    this.boundingBox.makeEmpty();
    for (let i2 = 0; i2 < count; i2++) {
      this.getMatrixAt(i2, _instanceLocalMatrix);
      _box3.copy(geometry.boundingBox).applyMatrix4(_instanceLocalMatrix);
      this.boundingBox.union(_box3);
    }
  }
  computeBoundingSphere() {
    const geometry = this.geometry;
    const count = this.count;
    if (this.boundingSphere === null) {
      this.boundingSphere = new Sphere();
    }
    if (geometry.boundingSphere === null) {
      geometry.computeBoundingSphere();
    }
    this.boundingSphere.makeEmpty();
    for (let i2 = 0; i2 < count; i2++) {
      this.getMatrixAt(i2, _instanceLocalMatrix);
      _sphere$2.copy(geometry.boundingSphere).applyMatrix4(_instanceLocalMatrix);
      this.boundingSphere.union(_sphere$2);
    }
  }
  copy(source, recursive) {
    super.copy(source, recursive);
    this.instanceMatrix.copy(source.instanceMatrix);
    if (source.instanceColor !== null) this.instanceColor = source.instanceColor.clone();
    this.count = source.count;
    if (source.boundingBox !== null) this.boundingBox = source.boundingBox.clone();
    if (source.boundingSphere !== null) this.boundingSphere = source.boundingSphere.clone();
    return this;
  }
  getColorAt(index, color) {
    color.fromArray(this.instanceColor.array, index * 3);
  }
  getMatrixAt(index, matrix) {
    matrix.fromArray(this.instanceMatrix.array, index * 16);
  }
  raycast(raycaster, intersects2) {
    const matrixWorld = this.matrixWorld;
    const raycastTimes = this.count;
    _mesh.geometry = this.geometry;
    _mesh.material = this.material;
    if (_mesh.material === void 0) return;
    if (this.boundingSphere === null) this.computeBoundingSphere();
    _sphere$2.copy(this.boundingSphere);
    _sphere$2.applyMatrix4(matrixWorld);
    if (raycaster.ray.intersectsSphere(_sphere$2) === false) return;
    for (let instanceId = 0; instanceId < raycastTimes; instanceId++) {
      this.getMatrixAt(instanceId, _instanceLocalMatrix);
      _instanceWorldMatrix.multiplyMatrices(matrixWorld, _instanceLocalMatrix);
      _mesh.matrixWorld = _instanceWorldMatrix;
      _mesh.raycast(raycaster, _instanceIntersects);
      for (let i2 = 0, l2 = _instanceIntersects.length; i2 < l2; i2++) {
        const intersect = _instanceIntersects[i2];
        intersect.instanceId = instanceId;
        intersect.object = this;
        intersects2.push(intersect);
      }
      _instanceIntersects.length = 0;
    }
  }
  setColorAt(index, color) {
    if (this.instanceColor === null) {
      this.instanceColor = new InstancedBufferAttribute(new Float32Array(this.instanceMatrix.count * 3), 3);
    }
    color.toArray(this.instanceColor.array, index * 3);
  }
  setMatrixAt(index, matrix) {
    matrix.toArray(this.instanceMatrix.array, index * 16);
  }
  updateMorphTargets() {
  }
  dispose() {
    this.dispatchEvent({ type: "dispose" });
  }
};
var LineBasicMaterial = class extends Material {
  constructor(parameters) {
    super();
    this.isLineBasicMaterial = true;
    this.type = "LineBasicMaterial";
    this.color = new Color(16777215);
    this.map = null;
    this.linewidth = 1;
    this.linecap = "round";
    this.linejoin = "round";
    this.fog = true;
    this.setValues(parameters);
  }
  copy(source) {
    super.copy(source);
    this.color.copy(source.color);
    this.map = source.map;
    this.linewidth = source.linewidth;
    this.linecap = source.linecap;
    this.linejoin = source.linejoin;
    this.fog = source.fog;
    return this;
  }
};
var _start$1 = new Vector3();
var _end$1 = new Vector3();
var _inverseMatrix$1 = new Matrix4();
var _ray$1 = new Ray();
var _sphere$1 = new Sphere();
var Line = class extends Object3D {
  constructor(geometry = new BufferGeometry(), material = new LineBasicMaterial()) {
    super();
    this.isLine = true;
    this.type = "Line";
    this.geometry = geometry;
    this.material = material;
    this.updateMorphTargets();
  }
  copy(source, recursive) {
    super.copy(source, recursive);
    this.material = source.material;
    this.geometry = source.geometry;
    return this;
  }
  computeLineDistances() {
    const geometry = this.geometry;
    if (geometry.index === null) {
      const positionAttribute = geometry.attributes.position;
      const lineDistances = [0];
      for (let i2 = 1, l2 = positionAttribute.count; i2 < l2; i2++) {
        _start$1.fromBufferAttribute(positionAttribute, i2 - 1);
        _end$1.fromBufferAttribute(positionAttribute, i2);
        lineDistances[i2] = lineDistances[i2 - 1];
        lineDistances[i2] += _start$1.distanceTo(_end$1);
      }
      geometry.setAttribute("lineDistance", new Float32BufferAttribute(lineDistances, 1));
    } else {
      console.warn("THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");
    }
    return this;
  }
  raycast(raycaster, intersects2) {
    const geometry = this.geometry;
    const matrixWorld = this.matrixWorld;
    const threshold = raycaster.params.Line.threshold;
    const drawRange = geometry.drawRange;
    if (geometry.boundingSphere === null) geometry.computeBoundingSphere();
    _sphere$1.copy(geometry.boundingSphere);
    _sphere$1.applyMatrix4(matrixWorld);
    _sphere$1.radius += threshold;
    if (raycaster.ray.intersectsSphere(_sphere$1) === false) return;
    _inverseMatrix$1.copy(matrixWorld).invert();
    _ray$1.copy(raycaster.ray).applyMatrix4(_inverseMatrix$1);
    const localThreshold = threshold / ((this.scale.x + this.scale.y + this.scale.z) / 3);
    const localThresholdSq = localThreshold * localThreshold;
    const vStart = new Vector3();
    const vEnd = new Vector3();
    const interSegment = new Vector3();
    const interRay = new Vector3();
    const step = this.isLineSegments ? 2 : 1;
    const index = geometry.index;
    const attributes = geometry.attributes;
    const positionAttribute = attributes.position;
    if (index !== null) {
      const start = Math.max(0, drawRange.start);
      const end = Math.min(index.count, drawRange.start + drawRange.count);
      for (let i2 = start, l2 = end - 1; i2 < l2; i2 += step) {
        const a2 = index.getX(i2);
        const b2 = index.getX(i2 + 1);
        vStart.fromBufferAttribute(positionAttribute, a2);
        vEnd.fromBufferAttribute(positionAttribute, b2);
        const distSq = _ray$1.distanceSqToSegment(vStart, vEnd, interRay, interSegment);
        if (distSq > localThresholdSq) continue;
        interRay.applyMatrix4(this.matrixWorld);
        const distance = raycaster.ray.origin.distanceTo(interRay);
        if (distance < raycaster.near || distance > raycaster.far) continue;
        intersects2.push({
          distance,
          // What do we want? intersection point on the ray or on the segment??
          // point: raycaster.ray.at( distance ),
          point: interSegment.clone().applyMatrix4(this.matrixWorld),
          index: i2,
          face: null,
          faceIndex: null,
          object: this
        });
      }
    } else {
      const start = Math.max(0, drawRange.start);
      const end = Math.min(positionAttribute.count, drawRange.start + drawRange.count);
      for (let i2 = start, l2 = end - 1; i2 < l2; i2 += step) {
        vStart.fromBufferAttribute(positionAttribute, i2);
        vEnd.fromBufferAttribute(positionAttribute, i2 + 1);
        const distSq = _ray$1.distanceSqToSegment(vStart, vEnd, interRay, interSegment);
        if (distSq > localThresholdSq) continue;
        interRay.applyMatrix4(this.matrixWorld);
        const distance = raycaster.ray.origin.distanceTo(interRay);
        if (distance < raycaster.near || distance > raycaster.far) continue;
        intersects2.push({
          distance,
          // What do we want? intersection point on the ray or on the segment??
          // point: raycaster.ray.at( distance ),
          point: interSegment.clone().applyMatrix4(this.matrixWorld),
          index: i2,
          face: null,
          faceIndex: null,
          object: this
        });
      }
    }
  }
  updateMorphTargets() {
    const geometry = this.geometry;
    const morphAttributes = geometry.morphAttributes;
    const keys = Object.keys(morphAttributes);
    if (keys.length > 0) {
      const morphAttribute = morphAttributes[keys[0]];
      if (morphAttribute !== void 0) {
        this.morphTargetInfluences = [];
        this.morphTargetDictionary = {};
        for (let m2 = 0, ml = morphAttribute.length; m2 < ml; m2++) {
          const name = morphAttribute[m2].name || String(m2);
          this.morphTargetInfluences.push(0);
          this.morphTargetDictionary[name] = m2;
        }
      }
    }
  }
};
var _start = new Vector3();
var _end = new Vector3();
var LineSegments = class extends Line {
  constructor(geometry, material) {
    super(geometry, material);
    this.isLineSegments = true;
    this.type = "LineSegments";
  }
  computeLineDistances() {
    const geometry = this.geometry;
    if (geometry.index === null) {
      const positionAttribute = geometry.attributes.position;
      const lineDistances = [];
      for (let i2 = 0, l2 = positionAttribute.count; i2 < l2; i2 += 2) {
        _start.fromBufferAttribute(positionAttribute, i2);
        _end.fromBufferAttribute(positionAttribute, i2 + 1);
        lineDistances[i2] = i2 === 0 ? 0 : lineDistances[i2 - 1];
        lineDistances[i2 + 1] = lineDistances[i2] + _start.distanceTo(_end);
      }
      geometry.setAttribute("lineDistance", new Float32BufferAttribute(lineDistances, 1));
    } else {
      console.warn("THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");
    }
    return this;
  }
};
var LineLoop = class extends Line {
  constructor(geometry, material) {
    super(geometry, material);
    this.isLineLoop = true;
    this.type = "LineLoop";
  }
};
var PointsMaterial = class extends Material {
  constructor(parameters) {
    super();
    this.isPointsMaterial = true;
    this.type = "PointsMaterial";
    this.color = new Color(16777215);
    this.map = null;
    this.alphaMap = null;
    this.size = 1;
    this.sizeAttenuation = true;
    this.fog = true;
    this.setValues(parameters);
  }
  copy(source) {
    super.copy(source);
    this.color.copy(source.color);
    this.map = source.map;
    this.alphaMap = source.alphaMap;
    this.size = source.size;
    this.sizeAttenuation = source.sizeAttenuation;
    this.fog = source.fog;
    return this;
  }
};
var _inverseMatrix = new Matrix4();
var _ray = new Ray();
var _sphere = new Sphere();
var _position$2 = new Vector3();
var Points = class extends Object3D {
  constructor(geometry = new BufferGeometry(), material = new PointsMaterial()) {
    super();
    this.isPoints = true;
    this.type = "Points";
    this.geometry = geometry;
    this.material = material;
    this.updateMorphTargets();
  }
  copy(source, recursive) {
    super.copy(source, recursive);
    this.material = source.material;
    this.geometry = source.geometry;
    return this;
  }
  raycast(raycaster, intersects2) {
    const geometry = this.geometry;
    const matrixWorld = this.matrixWorld;
    const threshold = raycaster.params.Points.threshold;
    const drawRange = geometry.drawRange;
    if (geometry.boundingSphere === null) geometry.computeBoundingSphere();
    _sphere.copy(geometry.boundingSphere);
    _sphere.applyMatrix4(matrixWorld);
    _sphere.radius += threshold;
    if (raycaster.ray.intersectsSphere(_sphere) === false) return;
    _inverseMatrix.copy(matrixWorld).invert();
    _ray.copy(raycaster.ray).applyMatrix4(_inverseMatrix);
    const localThreshold = threshold / ((this.scale.x + this.scale.y + this.scale.z) / 3);
    const localThresholdSq = localThreshold * localThreshold;
    const index = geometry.index;
    const attributes = geometry.attributes;
    const positionAttribute = attributes.position;
    if (index !== null) {
      const start = Math.max(0, drawRange.start);
      const end = Math.min(index.count, drawRange.start + drawRange.count);
      for (let i2 = start, il = end; i2 < il; i2++) {
        const a2 = index.getX(i2);
        _position$2.fromBufferAttribute(positionAttribute, a2);
        testPoint(_position$2, a2, localThresholdSq, matrixWorld, raycaster, intersects2, this);
      }
    } else {
      const start = Math.max(0, drawRange.start);
      const end = Math.min(positionAttribute.count, drawRange.start + drawRange.count);
      for (let i2 = start, l2 = end; i2 < l2; i2++) {
        _position$2.fromBufferAttribute(positionAttribute, i2);
        testPoint(_position$2, i2, localThresholdSq, matrixWorld, raycaster, intersects2, this);
      }
    }
  }
  updateMorphTargets() {
    const geometry = this.geometry;
    const morphAttributes = geometry.morphAttributes;
    const keys = Object.keys(morphAttributes);
    if (keys.length > 0) {
      const morphAttribute = morphAttributes[keys[0]];
      if (morphAttribute !== void 0) {
        this.morphTargetInfluences = [];
        this.morphTargetDictionary = {};
        for (let m2 = 0, ml = morphAttribute.length; m2 < ml; m2++) {
          const name = morphAttribute[m2].name || String(m2);
          this.morphTargetInfluences.push(0);
          this.morphTargetDictionary[name] = m2;
        }
      }
    }
  }
};
function testPoint(point, index, localThresholdSq, matrixWorld, raycaster, intersects2, object) {
  const rayPointDistanceSq = _ray.distanceSqToPoint(point);
  if (rayPointDistanceSq < localThresholdSq) {
    const intersectPoint = new Vector3();
    _ray.closestPointToPoint(point, intersectPoint);
    intersectPoint.applyMatrix4(matrixWorld);
    const distance = raycaster.ray.origin.distanceTo(intersectPoint);
    if (distance < raycaster.near || distance > raycaster.far) return;
    intersects2.push({
      distance,
      distanceToRay: Math.sqrt(rayPointDistanceSq),
      point: intersectPoint,
      index,
      face: null,
      object
    });
  }
}
var VideoTexture = class extends Texture {
  constructor(video, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy) {
    super(video, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy);
    this.isVideoTexture = true;
    this.minFilter = minFilter !== void 0 ? minFilter : LinearFilter;
    this.magFilter = magFilter !== void 0 ? magFilter : LinearFilter;
    this.generateMipmaps = false;
    const scope = this;
    function updateVideo() {
      scope.needsUpdate = true;
      video.requestVideoFrameCallback(updateVideo);
    }
    if ("requestVideoFrameCallback" in video) {
      video.requestVideoFrameCallback(updateVideo);
    }
  }
  clone() {
    return new this.constructor(this.image).copy(this);
  }
  update() {
    const video = this.image;
    const hasVideoFrameCallback = "requestVideoFrameCallback" in video;
    if (hasVideoFrameCallback === false && video.readyState >= video.HAVE_CURRENT_DATA) {
      this.needsUpdate = true;
    }
  }
};
var FramebufferTexture = class extends Texture {
  constructor(width, height) {
    super({ width, height });
    this.isFramebufferTexture = true;
    this.magFilter = NearestFilter;
    this.minFilter = NearestFilter;
    this.generateMipmaps = false;
    this.needsUpdate = true;
  }
};
var CompressedTexture = class extends Texture {
  constructor(mipmaps, width, height, format, type, mapping, wrapS, wrapT, magFilter, minFilter, anisotropy, colorSpace) {
    super(null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, colorSpace);
    this.isCompressedTexture = true;
    this.image = { width, height };
    this.mipmaps = mipmaps;
    this.flipY = false;
    this.generateMipmaps = false;
  }
};
var CompressedArrayTexture = class extends CompressedTexture {
  constructor(mipmaps, width, height, depth, format, type) {
    super(mipmaps, width, height, format, type);
    this.isCompressedArrayTexture = true;
    this.image.depth = depth;
    this.wrapR = ClampToEdgeWrapping;
  }
};
var CanvasTexture = class extends Texture {
  constructor(canvas, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy) {
    super(canvas, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy);
    this.isCanvasTexture = true;
    this.needsUpdate = true;
  }
};
var Curve = class {
  constructor() {
    this.type = "Curve";
    this.arcLengthDivisions = 200;
  }
  // Virtual base class method to overwrite and implement in subclasses
  //	- t [0 .. 1]
  getPoint() {
    console.warn("THREE.Curve: .getPoint() not implemented.");
    return null;
  }
  // Get point at relative position in curve according to arc length
  // - u [0 .. 1]
  getPointAt(u2, optionalTarget) {
    const t2 = this.getUtoTmapping(u2);
    return this.getPoint(t2, optionalTarget);
  }
  // Get sequence of points using getPoint( t )
  getPoints(divisions = 5) {
    const points = [];
    for (let d2 = 0; d2 <= divisions; d2++) {
      points.push(this.getPoint(d2 / divisions));
    }
    return points;
  }
  // Get sequence of points using getPointAt( u )
  getSpacedPoints(divisions = 5) {
    const points = [];
    for (let d2 = 0; d2 <= divisions; d2++) {
      points.push(this.getPointAt(d2 / divisions));
    }
    return points;
  }
  // Get total curve arc length
  getLength() {
    const lengths = this.getLengths();
    return lengths[lengths.length - 1];
  }
  // Get list of cumulative segment lengths
  getLengths(divisions = this.arcLengthDivisions) {
    if (this.cacheArcLengths && this.cacheArcLengths.length === divisions + 1 && !this.needsUpdate) {
      return this.cacheArcLengths;
    }
    this.needsUpdate = false;
    const cache = [];
    let current, last = this.getPoint(0);
    let sum = 0;
    cache.push(0);
    for (let p2 = 1; p2 <= divisions; p2++) {
      current = this.getPoint(p2 / divisions);
      sum += current.distanceTo(last);
      cache.push(sum);
      last = current;
    }
    this.cacheArcLengths = cache;
    return cache;
  }
  updateArcLengths() {
    this.needsUpdate = true;
    this.getLengths();
  }
  // Given u ( 0 .. 1 ), get a t to find p. This gives you points which are equidistant
  getUtoTmapping(u2, distance) {
    const arcLengths = this.getLengths();
    let i2 = 0;
    const il = arcLengths.length;
    let targetArcLength;
    if (distance) {
      targetArcLength = distance;
    } else {
      targetArcLength = u2 * arcLengths[il - 1];
    }
    let low = 0, high = il - 1, comparison;
    while (low <= high) {
      i2 = Math.floor(low + (high - low) / 2);
      comparison = arcLengths[i2] - targetArcLength;
      if (comparison < 0) {
        low = i2 + 1;
      } else if (comparison > 0) {
        high = i2 - 1;
      } else {
        high = i2;
        break;
      }
    }
    i2 = high;
    if (arcLengths[i2] === targetArcLength) {
      return i2 / (il - 1);
    }
    const lengthBefore = arcLengths[i2];
    const lengthAfter = arcLengths[i2 + 1];
    const segmentLength = lengthAfter - lengthBefore;
    const segmentFraction = (targetArcLength - lengthBefore) / segmentLength;
    const t2 = (i2 + segmentFraction) / (il - 1);
    return t2;
  }
  // Returns a unit vector tangent at t
  // In case any sub curve does not implement its tangent derivation,
  // 2 points a small delta apart will be used to find its gradient
  // which seems to give a reasonable approximation
  getTangent(t2, optionalTarget) {
    const delta = 1e-4;
    let t1 = t2 - delta;
    let t22 = t2 + delta;
    if (t1 < 0) t1 = 0;
    if (t22 > 1) t22 = 1;
    const pt1 = this.getPoint(t1);
    const pt2 = this.getPoint(t22);
    const tangent = optionalTarget || (pt1.isVector2 ? new Vector2() : new Vector3());
    tangent.copy(pt2).sub(pt1).normalize();
    return tangent;
  }
  getTangentAt(u2, optionalTarget) {
    const t2 = this.getUtoTmapping(u2);
    return this.getTangent(t2, optionalTarget);
  }
  computeFrenetFrames(segments, closed) {
    const normal = new Vector3();
    const tangents = [];
    const normals = [];
    const binormals = [];
    const vec = new Vector3();
    const mat = new Matrix4();
    for (let i2 = 0; i2 <= segments; i2++) {
      const u2 = i2 / segments;
      tangents[i2] = this.getTangentAt(u2, new Vector3());
    }
    normals[0] = new Vector3();
    binormals[0] = new Vector3();
    let min = Number.MAX_VALUE;
    const tx = Math.abs(tangents[0].x);
    const ty = Math.abs(tangents[0].y);
    const tz = Math.abs(tangents[0].z);
    if (tx <= min) {
      min = tx;
      normal.set(1, 0, 0);
    }
    if (ty <= min) {
      min = ty;
      normal.set(0, 1, 0);
    }
    if (tz <= min) {
      normal.set(0, 0, 1);
    }
    vec.crossVectors(tangents[0], normal).normalize();
    normals[0].crossVectors(tangents[0], vec);
    binormals[0].crossVectors(tangents[0], normals[0]);
    for (let i2 = 1; i2 <= segments; i2++) {
      normals[i2] = normals[i2 - 1].clone();
      binormals[i2] = binormals[i2 - 1].clone();
      vec.crossVectors(tangents[i2 - 1], tangents[i2]);
      if (vec.length() > Number.EPSILON) {
        vec.normalize();
        const theta = Math.acos(clamp(tangents[i2 - 1].dot(tangents[i2]), -1, 1));
        normals[i2].applyMatrix4(mat.makeRotationAxis(vec, theta));
      }
      binormals[i2].crossVectors(tangents[i2], normals[i2]);
    }
    if (closed === true) {
      let theta = Math.acos(clamp(normals[0].dot(normals[segments]), -1, 1));
      theta /= segments;
      if (tangents[0].dot(vec.crossVectors(normals[0], normals[segments])) > 0) {
        theta = -theta;
      }
      for (let i2 = 1; i2 <= segments; i2++) {
        normals[i2].applyMatrix4(mat.makeRotationAxis(tangents[i2], theta * i2));
        binormals[i2].crossVectors(tangents[i2], normals[i2]);
      }
    }
    return {
      tangents,
      normals,
      binormals
    };
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(source) {
    this.arcLengthDivisions = source.arcLengthDivisions;
    return this;
  }
  toJSON() {
    const data = {
      metadata: {
        version: 4.6,
        type: "Curve",
        generator: "Curve.toJSON"
      }
    };
    data.arcLengthDivisions = this.arcLengthDivisions;
    data.type = this.type;
    return data;
  }
  fromJSON(json) {
    this.arcLengthDivisions = json.arcLengthDivisions;
    return this;
  }
};
var EllipseCurve = class extends Curve {
  constructor(aX = 0, aY = 0, xRadius = 1, yRadius = 1, aStartAngle = 0, aEndAngle = Math.PI * 2, aClockwise = false, aRotation = 0) {
    super();
    this.isEllipseCurve = true;
    this.type = "EllipseCurve";
    this.aX = aX;
    this.aY = aY;
    this.xRadius = xRadius;
    this.yRadius = yRadius;
    this.aStartAngle = aStartAngle;
    this.aEndAngle = aEndAngle;
    this.aClockwise = aClockwise;
    this.aRotation = aRotation;
  }
  getPoint(t2, optionalTarget) {
    const point = optionalTarget || new Vector2();
    const twoPi = Math.PI * 2;
    let deltaAngle = this.aEndAngle - this.aStartAngle;
    const samePoints = Math.abs(deltaAngle) < Number.EPSILON;
    while (deltaAngle < 0) deltaAngle += twoPi;
    while (deltaAngle > twoPi) deltaAngle -= twoPi;
    if (deltaAngle < Number.EPSILON) {
      if (samePoints) {
        deltaAngle = 0;
      } else {
        deltaAngle = twoPi;
      }
    }
    if (this.aClockwise === true && !samePoints) {
      if (deltaAngle === twoPi) {
        deltaAngle = -twoPi;
      } else {
        deltaAngle = deltaAngle - twoPi;
      }
    }
    const angle = this.aStartAngle + t2 * deltaAngle;
    let x3 = this.aX + this.xRadius * Math.cos(angle);
    let y2 = this.aY + this.yRadius * Math.sin(angle);
    if (this.aRotation !== 0) {
      const cos = Math.cos(this.aRotation);
      const sin = Math.sin(this.aRotation);
      const tx = x3 - this.aX;
      const ty = y2 - this.aY;
      x3 = tx * cos - ty * sin + this.aX;
      y2 = tx * sin + ty * cos + this.aY;
    }
    return point.set(x3, y2);
  }
  copy(source) {
    super.copy(source);
    this.aX = source.aX;
    this.aY = source.aY;
    this.xRadius = source.xRadius;
    this.yRadius = source.yRadius;
    this.aStartAngle = source.aStartAngle;
    this.aEndAngle = source.aEndAngle;
    this.aClockwise = source.aClockwise;
    this.aRotation = source.aRotation;
    return this;
  }
  toJSON() {
    const data = super.toJSON();
    data.aX = this.aX;
    data.aY = this.aY;
    data.xRadius = this.xRadius;
    data.yRadius = this.yRadius;
    data.aStartAngle = this.aStartAngle;
    data.aEndAngle = this.aEndAngle;
    data.aClockwise = this.aClockwise;
    data.aRotation = this.aRotation;
    return data;
  }
  fromJSON(json) {
    super.fromJSON(json);
    this.aX = json.aX;
    this.aY = json.aY;
    this.xRadius = json.xRadius;
    this.yRadius = json.yRadius;
    this.aStartAngle = json.aStartAngle;
    this.aEndAngle = json.aEndAngle;
    this.aClockwise = json.aClockwise;
    this.aRotation = json.aRotation;
    return this;
  }
};
var ArcCurve = class extends EllipseCurve {
  constructor(aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise) {
    super(aX, aY, aRadius, aRadius, aStartAngle, aEndAngle, aClockwise);
    this.isArcCurve = true;
    this.type = "ArcCurve";
  }
};
function CubicPoly() {
  let c0 = 0, c1 = 0, c2 = 0, c3 = 0;
  function init(x0, x1, t0, t1) {
    c0 = x0;
    c1 = t0;
    c2 = -3 * x0 + 3 * x1 - 2 * t0 - t1;
    c3 = 2 * x0 - 2 * x1 + t0 + t1;
  }
  return {
    initCatmullRom: function(x0, x1, x22, x3, tension) {
      init(x1, x22, tension * (x22 - x0), tension * (x3 - x1));
    },
    initNonuniformCatmullRom: function(x0, x1, x22, x3, dt0, dt1, dt2) {
      let t1 = (x1 - x0) / dt0 - (x22 - x0) / (dt0 + dt1) + (x22 - x1) / dt1;
      let t2 = (x22 - x1) / dt1 - (x3 - x1) / (dt1 + dt2) + (x3 - x22) / dt2;
      t1 *= dt1;
      t2 *= dt1;
      init(x1, x22, t1, t2);
    },
    calc: function(t2) {
      const t22 = t2 * t2;
      const t3 = t22 * t2;
      return c0 + c1 * t2 + c2 * t22 + c3 * t3;
    }
  };
}
var tmp = new Vector3();
var px = new CubicPoly();
var py = new CubicPoly();
var pz = new CubicPoly();
var CatmullRomCurve3 = class extends Curve {
  constructor(points = [], closed = false, curveType = "centripetal", tension = 0.5) {
    super();
    this.isCatmullRomCurve3 = true;
    this.type = "CatmullRomCurve3";
    this.points = points;
    this.closed = closed;
    this.curveType = curveType;
    this.tension = tension;
  }
  getPoint(t2, optionalTarget = new Vector3()) {
    const point = optionalTarget;
    const points = this.points;
    const l2 = points.length;
    const p2 = (l2 - (this.closed ? 0 : 1)) * t2;
    let intPoint = Math.floor(p2);
    let weight = p2 - intPoint;
    if (this.closed) {
      intPoint += intPoint > 0 ? 0 : (Math.floor(Math.abs(intPoint) / l2) + 1) * l2;
    } else if (weight === 0 && intPoint === l2 - 1) {
      intPoint = l2 - 2;
      weight = 1;
    }
    let p0, p3;
    if (this.closed || intPoint > 0) {
      p0 = points[(intPoint - 1) % l2];
    } else {
      tmp.subVectors(points[0], points[1]).add(points[0]);
      p0 = tmp;
    }
    const p1 = points[intPoint % l2];
    const p22 = points[(intPoint + 1) % l2];
    if (this.closed || intPoint + 2 < l2) {
      p3 = points[(intPoint + 2) % l2];
    } else {
      tmp.subVectors(points[l2 - 1], points[l2 - 2]).add(points[l2 - 1]);
      p3 = tmp;
    }
    if (this.curveType === "centripetal" || this.curveType === "chordal") {
      const pow = this.curveType === "chordal" ? 0.5 : 0.25;
      let dt0 = Math.pow(p0.distanceToSquared(p1), pow);
      let dt1 = Math.pow(p1.distanceToSquared(p22), pow);
      let dt2 = Math.pow(p22.distanceToSquared(p3), pow);
      if (dt1 < 1e-4) dt1 = 1;
      if (dt0 < 1e-4) dt0 = dt1;
      if (dt2 < 1e-4) dt2 = dt1;
      px.initNonuniformCatmullRom(p0.x, p1.x, p22.x, p3.x, dt0, dt1, dt2);
      py.initNonuniformCatmullRom(p0.y, p1.y, p22.y, p3.y, dt0, dt1, dt2);
      pz.initNonuniformCatmullRom(p0.z, p1.z, p22.z, p3.z, dt0, dt1, dt2);
    } else if (this.curveType === "catmullrom") {
      px.initCatmullRom(p0.x, p1.x, p22.x, p3.x, this.tension);
      py.initCatmullRom(p0.y, p1.y, p22.y, p3.y, this.tension);
      pz.initCatmullRom(p0.z, p1.z, p22.z, p3.z, this.tension);
    }
    point.set(
      px.calc(weight),
      py.calc(weight),
      pz.calc(weight)
    );
    return point;
  }
  copy(source) {
    super.copy(source);
    this.points = [];
    for (let i2 = 0, l2 = source.points.length; i2 < l2; i2++) {
      const point = source.points[i2];
      this.points.push(point.clone());
    }
    this.closed = source.closed;
    this.curveType = source.curveType;
    this.tension = source.tension;
    return this;
  }
  toJSON() {
    const data = super.toJSON();
    data.points = [];
    for (let i2 = 0, l2 = this.points.length; i2 < l2; i2++) {
      const point = this.points[i2];
      data.points.push(point.toArray());
    }
    data.closed = this.closed;
    data.curveType = this.curveType;
    data.tension = this.tension;
    return data;
  }
  fromJSON(json) {
    super.fromJSON(json);
    this.points = [];
    for (let i2 = 0, l2 = json.points.length; i2 < l2; i2++) {
      const point = json.points[i2];
      this.points.push(new Vector3().fromArray(point));
    }
    this.closed = json.closed;
    this.curveType = json.curveType;
    this.tension = json.tension;
    return this;
  }
};
function CatmullRom(t2, p0, p1, p2, p3) {
  const v0 = (p2 - p0) * 0.5;
  const v1 = (p3 - p1) * 0.5;
  const t22 = t2 * t2;
  const t3 = t2 * t22;
  return (2 * p1 - 2 * p2 + v0 + v1) * t3 + (-3 * p1 + 3 * p2 - 2 * v0 - v1) * t22 + v0 * t2 + p1;
}
function QuadraticBezierP0(t2, p2) {
  const k2 = 1 - t2;
  return k2 * k2 * p2;
}
function QuadraticBezierP1(t2, p2) {
  return 2 * (1 - t2) * t2 * p2;
}
function QuadraticBezierP2(t2, p2) {
  return t2 * t2 * p2;
}
function QuadraticBezier(t2, p0, p1, p2) {
  return QuadraticBezierP0(t2, p0) + QuadraticBezierP1(t2, p1) + QuadraticBezierP2(t2, p2);
}
function CubicBezierP0(t2, p2) {
  const k2 = 1 - t2;
  return k2 * k2 * k2 * p2;
}
function CubicBezierP1(t2, p2) {
  const k2 = 1 - t2;
  return 3 * k2 * k2 * t2 * p2;
}
function CubicBezierP2(t2, p2) {
  return 3 * (1 - t2) * t2 * t2 * p2;
}
function CubicBezierP3(t2, p2) {
  return t2 * t2 * t2 * p2;
}
function CubicBezier(t2, p0, p1, p2, p3) {
  return CubicBezierP0(t2, p0) + CubicBezierP1(t2, p1) + CubicBezierP2(t2, p2) + CubicBezierP3(t2, p3);
}
var CubicBezierCurve = class extends Curve {
  constructor(v0 = new Vector2(), v1 = new Vector2(), v2 = new Vector2(), v3 = new Vector2()) {
    super();
    this.isCubicBezierCurve = true;
    this.type = "CubicBezierCurve";
    this.v0 = v0;
    this.v1 = v1;
    this.v2 = v2;
    this.v3 = v3;
  }
  getPoint(t2, optionalTarget = new Vector2()) {
    const point = optionalTarget;
    const v0 = this.v0, v1 = this.v1, v2 = this.v2, v3 = this.v3;
    point.set(
      CubicBezier(t2, v0.x, v1.x, v2.x, v3.x),
      CubicBezier(t2, v0.y, v1.y, v2.y, v3.y)
    );
    return point;
  }
  copy(source) {
    super.copy(source);
    this.v0.copy(source.v0);
    this.v1.copy(source.v1);
    this.v2.copy(source.v2);
    this.v3.copy(source.v3);
    return this;
  }
  toJSON() {
    const data = super.toJSON();
    data.v0 = this.v0.toArray();
    data.v1 = this.v1.toArray();
    data.v2 = this.v2.toArray();
    data.v3 = this.v3.toArray();
    return data;
  }
  fromJSON(json) {
    super.fromJSON(json);
    this.v0.fromArray(json.v0);
    this.v1.fromArray(json.v1);
    this.v2.fromArray(json.v2);
    this.v3.fromArray(json.v3);
    return this;
  }
};
var CubicBezierCurve3 = class extends Curve {
  constructor(v0 = new Vector3(), v1 = new Vector3(), v2 = new Vector3(), v3 = new Vector3()) {
    super();
    this.isCubicBezierCurve3 = true;
    this.type = "CubicBezierCurve3";
    this.v0 = v0;
    this.v1 = v1;
    this.v2 = v2;
    this.v3 = v3;
  }
  getPoint(t2, optionalTarget = new Vector3()) {
    const point = optionalTarget;
    const v0 = this.v0, v1 = this.v1, v2 = this.v2, v3 = this.v3;
    point.set(
      CubicBezier(t2, v0.x, v1.x, v2.x, v3.x),
      CubicBezier(t2, v0.y, v1.y, v2.y, v3.y),
      CubicBezier(t2, v0.z, v1.z, v2.z, v3.z)
    );
    return point;
  }
  copy(source) {
    super.copy(source);
    this.v0.copy(source.v0);
    this.v1.copy(source.v1);
    this.v2.copy(source.v2);
    this.v3.copy(source.v3);
    return this;
  }
  toJSON() {
    const data = super.toJSON();
    data.v0 = this.v0.toArray();
    data.v1 = this.v1.toArray();
    data.v2 = this.v2.toArray();
    data.v3 = this.v3.toArray();
    return data;
  }
  fromJSON(json) {
    super.fromJSON(json);
    this.v0.fromArray(json.v0);
    this.v1.fromArray(json.v1);
    this.v2.fromArray(json.v2);
    this.v3.fromArray(json.v3);
    return this;
  }
};
var LineCurve = class extends Curve {
  constructor(v1 = new Vector2(), v2 = new Vector2()) {
    super();
    this.isLineCurve = true;
    this.type = "LineCurve";
    this.v1 = v1;
    this.v2 = v2;
  }
  getPoint(t2, optionalTarget = new Vector2()) {
    const point = optionalTarget;
    if (t2 === 1) {
      point.copy(this.v2);
    } else {
      point.copy(this.v2).sub(this.v1);
      point.multiplyScalar(t2).add(this.v1);
    }
    return point;
  }
  // Line curve is linear, so we can overwrite default getPointAt
  getPointAt(u2, optionalTarget) {
    return this.getPoint(u2, optionalTarget);
  }
  getTangent(t2, optionalTarget = new Vector2()) {
    return optionalTarget.subVectors(this.v2, this.v1).normalize();
  }
  getTangentAt(u2, optionalTarget) {
    return this.getTangent(u2, optionalTarget);
  }
  copy(source) {
    super.copy(source);
    this.v1.copy(source.v1);
    this.v2.copy(source.v2);
    return this;
  }
  toJSON() {
    const data = super.toJSON();
    data.v1 = this.v1.toArray();
    data.v2 = this.v2.toArray();
    return data;
  }
  fromJSON(json) {
    super.fromJSON(json);
    this.v1.fromArray(json.v1);
    this.v2.fromArray(json.v2);
    return this;
  }
};
var LineCurve3 = class extends Curve {
  constructor(v1 = new Vector3(), v2 = new Vector3()) {
    super();
    this.isLineCurve3 = true;
    this.type = "LineCurve3";
    this.v1 = v1;
    this.v2 = v2;
  }
  getPoint(t2, optionalTarget = new Vector3()) {
    const point = optionalTarget;
    if (t2 === 1) {
      point.copy(this.v2);
    } else {
      point.copy(this.v2).sub(this.v1);
      point.multiplyScalar(t2).add(this.v1);
    }
    return point;
  }
  // Line curve is linear, so we can overwrite default getPointAt
  getPointAt(u2, optionalTarget) {
    return this.getPoint(u2, optionalTarget);
  }
  getTangent(t2, optionalTarget = new Vector3()) {
    return optionalTarget.subVectors(this.v2, this.v1).normalize();
  }
  getTangentAt(u2, optionalTarget) {
    return this.getTangent(u2, optionalTarget);
  }
  copy(source) {
    super.copy(source);
    this.v1.copy(source.v1);
    this.v2.copy(source.v2);
    return this;
  }
  toJSON() {
    const data = super.toJSON();
    data.v1 = this.v1.toArray();
    data.v2 = this.v2.toArray();
    return data;
  }
  fromJSON(json) {
    super.fromJSON(json);
    this.v1.fromArray(json.v1);
    this.v2.fromArray(json.v2);
    return this;
  }
};
var QuadraticBezierCurve = class extends Curve {
  constructor(v0 = new Vector2(), v1 = new Vector2(), v2 = new Vector2()) {
    super();
    this.isQuadraticBezierCurve = true;
    this.type = "QuadraticBezierCurve";
    this.v0 = v0;
    this.v1 = v1;
    this.v2 = v2;
  }
  getPoint(t2, optionalTarget = new Vector2()) {
    const point = optionalTarget;
    const v0 = this.v0, v1 = this.v1, v2 = this.v2;
    point.set(
      QuadraticBezier(t2, v0.x, v1.x, v2.x),
      QuadraticBezier(t2, v0.y, v1.y, v2.y)
    );
    return point;
  }
  copy(source) {
    super.copy(source);
    this.v0.copy(source.v0);
    this.v1.copy(source.v1);
    this.v2.copy(source.v2);
    return this;
  }
  toJSON() {
    const data = super.toJSON();
    data.v0 = this.v0.toArray();
    data.v1 = this.v1.toArray();
    data.v2 = this.v2.toArray();
    return data;
  }
  fromJSON(json) {
    super.fromJSON(json);
    this.v0.fromArray(json.v0);
    this.v1.fromArray(json.v1);
    this.v2.fromArray(json.v2);
    return this;
  }
};
var QuadraticBezierCurve3 = class extends Curve {
  constructor(v0 = new Vector3(), v1 = new Vector3(), v2 = new Vector3()) {
    super();
    this.isQuadraticBezierCurve3 = true;
    this.type = "QuadraticBezierCurve3";
    this.v0 = v0;
    this.v1 = v1;
    this.v2 = v2;
  }
  getPoint(t2, optionalTarget = new Vector3()) {
    const point = optionalTarget;
    const v0 = this.v0, v1 = this.v1, v2 = this.v2;
    point.set(
      QuadraticBezier(t2, v0.x, v1.x, v2.x),
      QuadraticBezier(t2, v0.y, v1.y, v2.y),
      QuadraticBezier(t2, v0.z, v1.z, v2.z)
    );
    return point;
  }
  copy(source) {
    super.copy(source);
    this.v0.copy(source.v0);
    this.v1.copy(source.v1);
    this.v2.copy(source.v2);
    return this;
  }
  toJSON() {
    const data = super.toJSON();
    data.v0 = this.v0.toArray();
    data.v1 = this.v1.toArray();
    data.v2 = this.v2.toArray();
    return data;
  }
  fromJSON(json) {
    super.fromJSON(json);
    this.v0.fromArray(json.v0);
    this.v1.fromArray(json.v1);
    this.v2.fromArray(json.v2);
    return this;
  }
};
var SplineCurve = class extends Curve {
  constructor(points = []) {
    super();
    this.isSplineCurve = true;
    this.type = "SplineCurve";
    this.points = points;
  }
  getPoint(t2, optionalTarget = new Vector2()) {
    const point = optionalTarget;
    const points = this.points;
    const p2 = (points.length - 1) * t2;
    const intPoint = Math.floor(p2);
    const weight = p2 - intPoint;
    const p0 = points[intPoint === 0 ? intPoint : intPoint - 1];
    const p1 = points[intPoint];
    const p22 = points[intPoint > points.length - 2 ? points.length - 1 : intPoint + 1];
    const p3 = points[intPoint > points.length - 3 ? points.length - 1 : intPoint + 2];
    point.set(
      CatmullRom(weight, p0.x, p1.x, p22.x, p3.x),
      CatmullRom(weight, p0.y, p1.y, p22.y, p3.y)
    );
    return point;
  }
  copy(source) {
    super.copy(source);
    this.points = [];
    for (let i2 = 0, l2 = source.points.length; i2 < l2; i2++) {
      const point = source.points[i2];
      this.points.push(point.clone());
    }
    return this;
  }
  toJSON() {
    const data = super.toJSON();
    data.points = [];
    for (let i2 = 0, l2 = this.points.length; i2 < l2; i2++) {
      const point = this.points[i2];
      data.points.push(point.toArray());
    }
    return data;
  }
  fromJSON(json) {
    super.fromJSON(json);
    this.points = [];
    for (let i2 = 0, l2 = json.points.length; i2 < l2; i2++) {
      const point = json.points[i2];
      this.points.push(new Vector2().fromArray(point));
    }
    return this;
  }
};
var Curves = Object.freeze({
  __proto__: null,
  ArcCurve,
  CatmullRomCurve3,
  CubicBezierCurve,
  CubicBezierCurve3,
  EllipseCurve,
  LineCurve,
  LineCurve3,
  QuadraticBezierCurve,
  QuadraticBezierCurve3,
  SplineCurve
});
var CurvePath = class extends Curve {
  constructor() {
    super();
    this.type = "CurvePath";
    this.curves = [];
    this.autoClose = false;
  }
  add(curve) {
    this.curves.push(curve);
  }
  closePath() {
    const startPoint = this.curves[0].getPoint(0);
    const endPoint = this.curves[this.curves.length - 1].getPoint(1);
    if (!startPoint.equals(endPoint)) {
      this.curves.push(new LineCurve(endPoint, startPoint));
    }
  }
  // To get accurate point with reference to
  // entire path distance at time t,
  // following has to be done:
  // 1. Length of each sub path have to be known
  // 2. Locate and identify type of curve
  // 3. Get t for the curve
  // 4. Return curve.getPointAt(t')
  getPoint(t2, optionalTarget) {
    const d2 = t2 * this.getLength();
    const curveLengths = this.getCurveLengths();
    let i2 = 0;
    while (i2 < curveLengths.length) {
      if (curveLengths[i2] >= d2) {
        const diff = curveLengths[i2] - d2;
        const curve = this.curves[i2];
        const segmentLength = curve.getLength();
        const u2 = segmentLength === 0 ? 0 : 1 - diff / segmentLength;
        return curve.getPointAt(u2, optionalTarget);
      }
      i2++;
    }
    return null;
  }
  // We cannot use the default THREE.Curve getPoint() with getLength() because in
  // THREE.Curve, getLength() depends on getPoint() but in THREE.CurvePath
  // getPoint() depends on getLength
  getLength() {
    const lens = this.getCurveLengths();
    return lens[lens.length - 1];
  }
  // cacheLengths must be recalculated.
  updateArcLengths() {
    this.needsUpdate = true;
    this.cacheLengths = null;
    this.getCurveLengths();
  }
  // Compute lengths and cache them
  // We cannot overwrite getLengths() because UtoT mapping uses it.
  getCurveLengths() {
    if (this.cacheLengths && this.cacheLengths.length === this.curves.length) {
      return this.cacheLengths;
    }
    const lengths = [];
    let sums = 0;
    for (let i2 = 0, l2 = this.curves.length; i2 < l2; i2++) {
      sums += this.curves[i2].getLength();
      lengths.push(sums);
    }
    this.cacheLengths = lengths;
    return lengths;
  }
  getSpacedPoints(divisions = 40) {
    const points = [];
    for (let i2 = 0; i2 <= divisions; i2++) {
      points.push(this.getPoint(i2 / divisions));
    }
    if (this.autoClose) {
      points.push(points[0]);
    }
    return points;
  }
  getPoints(divisions = 12) {
    const points = [];
    let last;
    for (let i2 = 0, curves = this.curves; i2 < curves.length; i2++) {
      const curve = curves[i2];
      const resolution = curve.isEllipseCurve ? divisions * 2 : curve.isLineCurve || curve.isLineCurve3 ? 1 : curve.isSplineCurve ? divisions * curve.points.length : divisions;
      const pts = curve.getPoints(resolution);
      for (let j = 0; j < pts.length; j++) {
        const point = pts[j];
        if (last && last.equals(point)) continue;
        points.push(point);
        last = point;
      }
    }
    if (this.autoClose && points.length > 1 && !points[points.length - 1].equals(points[0])) {
      points.push(points[0]);
    }
    return points;
  }
  copy(source) {
    super.copy(source);
    this.curves = [];
    for (let i2 = 0, l2 = source.curves.length; i2 < l2; i2++) {
      const curve = source.curves[i2];
      this.curves.push(curve.clone());
    }
    this.autoClose = source.autoClose;
    return this;
  }
  toJSON() {
    const data = super.toJSON();
    data.autoClose = this.autoClose;
    data.curves = [];
    for (let i2 = 0, l2 = this.curves.length; i2 < l2; i2++) {
      const curve = this.curves[i2];
      data.curves.push(curve.toJSON());
    }
    return data;
  }
  fromJSON(json) {
    super.fromJSON(json);
    this.autoClose = json.autoClose;
    this.curves = [];
    for (let i2 = 0, l2 = json.curves.length; i2 < l2; i2++) {
      const curve = json.curves[i2];
      this.curves.push(new Curves[curve.type]().fromJSON(curve));
    }
    return this;
  }
};
var Path = class extends CurvePath {
  constructor(points) {
    super();
    this.type = "Path";
    this.currentPoint = new Vector2();
    if (points) {
      this.setFromPoints(points);
    }
  }
  setFromPoints(points) {
    this.moveTo(points[0].x, points[0].y);
    for (let i2 = 1, l2 = points.length; i2 < l2; i2++) {
      this.lineTo(points[i2].x, points[i2].y);
    }
    return this;
  }
  moveTo(x3, y2) {
    this.currentPoint.set(x3, y2);
    return this;
  }
  lineTo(x3, y2) {
    const curve = new LineCurve(this.currentPoint.clone(), new Vector2(x3, y2));
    this.curves.push(curve);
    this.currentPoint.set(x3, y2);
    return this;
  }
  quadraticCurveTo(aCPx, aCPy, aX, aY) {
    const curve = new QuadraticBezierCurve(
      this.currentPoint.clone(),
      new Vector2(aCPx, aCPy),
      new Vector2(aX, aY)
    );
    this.curves.push(curve);
    this.currentPoint.set(aX, aY);
    return this;
  }
  bezierCurveTo(aCP1x, aCP1y, aCP2x, aCP2y, aX, aY) {
    const curve = new CubicBezierCurve(
      this.currentPoint.clone(),
      new Vector2(aCP1x, aCP1y),
      new Vector2(aCP2x, aCP2y),
      new Vector2(aX, aY)
    );
    this.curves.push(curve);
    this.currentPoint.set(aX, aY);
    return this;
  }
  splineThru(pts) {
    const npts = [this.currentPoint.clone()].concat(pts);
    const curve = new SplineCurve(npts);
    this.curves.push(curve);
    this.currentPoint.copy(pts[pts.length - 1]);
    return this;
  }
  arc(aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise) {
    const x0 = this.currentPoint.x;
    const y0 = this.currentPoint.y;
    this.absarc(
      aX + x0,
      aY + y0,
      aRadius,
      aStartAngle,
      aEndAngle,
      aClockwise
    );
    return this;
  }
  absarc(aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise) {
    this.absellipse(aX, aY, aRadius, aRadius, aStartAngle, aEndAngle, aClockwise);
    return this;
  }
  ellipse(aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation) {
    const x0 = this.currentPoint.x;
    const y0 = this.currentPoint.y;
    this.absellipse(aX + x0, aY + y0, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation);
    return this;
  }
  absellipse(aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation) {
    const curve = new EllipseCurve(aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation);
    if (this.curves.length > 0) {
      const firstPoint = curve.getPoint(0);
      if (!firstPoint.equals(this.currentPoint)) {
        this.lineTo(firstPoint.x, firstPoint.y);
      }
    }
    this.curves.push(curve);
    const lastPoint = curve.getPoint(1);
    this.currentPoint.copy(lastPoint);
    return this;
  }
  copy(source) {
    super.copy(source);
    this.currentPoint.copy(source.currentPoint);
    return this;
  }
  toJSON() {
    const data = super.toJSON();
    data.currentPoint = this.currentPoint.toArray();
    return data;
  }
  fromJSON(json) {
    super.fromJSON(json);
    this.currentPoint.fromArray(json.currentPoint);
    return this;
  }
};
var LatheGeometry = class _LatheGeometry extends BufferGeometry {
  constructor(points = [new Vector2(0, -0.5), new Vector2(0.5, 0), new Vector2(0, 0.5)], segments = 12, phiStart = 0, phiLength = Math.PI * 2) {
    super();
    this.type = "LatheGeometry";
    this.parameters = {
      points,
      segments,
      phiStart,
      phiLength
    };
    segments = Math.floor(segments);
    phiLength = clamp(phiLength, 0, Math.PI * 2);
    const indices = [];
    const vertices = [];
    const uvs = [];
    const initNormals = [];
    const normals = [];
    const inverseSegments = 1 / segments;
    const vertex2 = new Vector3();
    const uv = new Vector2();
    const normal = new Vector3();
    const curNormal = new Vector3();
    const prevNormal = new Vector3();
    let dx = 0;
    let dy = 0;
    for (let j = 0; j <= points.length - 1; j++) {
      switch (j) {
        case 0:
          dx = points[j + 1].x - points[j].x;
          dy = points[j + 1].y - points[j].y;
          normal.x = dy * 1;
          normal.y = -dx;
          normal.z = dy * 0;
          prevNormal.copy(normal);
          normal.normalize();
          initNormals.push(normal.x, normal.y, normal.z);
          break;
        case points.length - 1:
          initNormals.push(prevNormal.x, prevNormal.y, prevNormal.z);
          break;
        default:
          dx = points[j + 1].x - points[j].x;
          dy = points[j + 1].y - points[j].y;
          normal.x = dy * 1;
          normal.y = -dx;
          normal.z = dy * 0;
          curNormal.copy(normal);
          normal.x += prevNormal.x;
          normal.y += prevNormal.y;
          normal.z += prevNormal.z;
          normal.normalize();
          initNormals.push(normal.x, normal.y, normal.z);
          prevNormal.copy(curNormal);
      }
    }
    for (let i2 = 0; i2 <= segments; i2++) {
      const phi = phiStart + i2 * inverseSegments * phiLength;
      const sin = Math.sin(phi);
      const cos = Math.cos(phi);
      for (let j = 0; j <= points.length - 1; j++) {
        vertex2.x = points[j].x * sin;
        vertex2.y = points[j].y;
        vertex2.z = points[j].x * cos;
        vertices.push(vertex2.x, vertex2.y, vertex2.z);
        uv.x = i2 / segments;
        uv.y = j / (points.length - 1);
        uvs.push(uv.x, uv.y);
        const x3 = initNormals[3 * j + 0] * sin;
        const y2 = initNormals[3 * j + 1];
        const z = initNormals[3 * j + 0] * cos;
        normals.push(x3, y2, z);
      }
    }
    for (let i2 = 0; i2 < segments; i2++) {
      for (let j = 0; j < points.length - 1; j++) {
        const base = j + i2 * points.length;
        const a2 = base;
        const b2 = base + points.length;
        const c2 = base + points.length + 1;
        const d2 = base + 1;
        indices.push(a2, b2, d2);
        indices.push(c2, d2, b2);
      }
    }
    this.setIndex(indices);
    this.setAttribute("position", new Float32BufferAttribute(vertices, 3));
    this.setAttribute("uv", new Float32BufferAttribute(uvs, 2));
    this.setAttribute("normal", new Float32BufferAttribute(normals, 3));
  }
  copy(source) {
    super.copy(source);
    this.parameters = Object.assign({}, source.parameters);
    return this;
  }
  static fromJSON(data) {
    return new _LatheGeometry(data.points, data.segments, data.phiStart, data.phiLength);
  }
};
var CapsuleGeometry = class _CapsuleGeometry extends LatheGeometry {
  constructor(radius = 1, length = 1, capSegments = 4, radialSegments = 8) {
    const path = new Path();
    path.absarc(0, -length / 2, radius, Math.PI * 1.5, 0);
    path.absarc(0, length / 2, radius, 0, Math.PI * 0.5);
    super(path.getPoints(capSegments), radialSegments);
    this.type = "CapsuleGeometry";
    this.parameters = {
      radius,
      height: length,
      capSegments,
      radialSegments
    };
  }
  static fromJSON(data) {
    return new _CapsuleGeometry(data.radius, data.length, data.capSegments, data.radialSegments);
  }
};
var CircleGeometry = class _CircleGeometry extends BufferGeometry {
  constructor(radius = 1, segments = 32, thetaStart = 0, thetaLength = Math.PI * 2) {
    super();
    this.type = "CircleGeometry";
    this.parameters = {
      radius,
      segments,
      thetaStart,
      thetaLength
    };
    segments = Math.max(3, segments);
    const indices = [];
    const vertices = [];
    const normals = [];
    const uvs = [];
    const vertex2 = new Vector3();
    const uv = new Vector2();
    vertices.push(0, 0, 0);
    normals.push(0, 0, 1);
    uvs.push(0.5, 0.5);
    for (let s2 = 0, i2 = 3; s2 <= segments; s2++, i2 += 3) {
      const segment = thetaStart + s2 / segments * thetaLength;
      vertex2.x = radius * Math.cos(segment);
      vertex2.y = radius * Math.sin(segment);
      vertices.push(vertex2.x, vertex2.y, vertex2.z);
      normals.push(0, 0, 1);
      uv.x = (vertices[i2] / radius + 1) / 2;
      uv.y = (vertices[i2 + 1] / radius + 1) / 2;
      uvs.push(uv.x, uv.y);
    }
    for (let i2 = 1; i2 <= segments; i2++) {
      indices.push(i2, i2 + 1, 0);
    }
    this.setIndex(indices);
    this.setAttribute("position", new Float32BufferAttribute(vertices, 3));
    this.setAttribute("normal", new Float32BufferAttribute(normals, 3));
    this.setAttribute("uv", new Float32BufferAttribute(uvs, 2));
  }
  copy(source) {
    super.copy(source);
    this.parameters = Object.assign({}, source.parameters);
    return this;
  }
  static fromJSON(data) {
    return new _CircleGeometry(data.radius, data.segments, data.thetaStart, data.thetaLength);
  }
};
var CylinderGeometry = class _CylinderGeometry extends BufferGeometry {
  constructor(radiusTop = 1, radiusBottom = 1, height = 1, radialSegments = 32, heightSegments = 1, openEnded = false, thetaStart = 0, thetaLength = Math.PI * 2) {
    super();
    this.type = "CylinderGeometry";
    this.parameters = {
      radiusTop,
      radiusBottom,
      height,
      radialSegments,
      heightSegments,
      openEnded,
      thetaStart,
      thetaLength
    };
    const scope = this;
    radialSegments = Math.floor(radialSegments);
    heightSegments = Math.floor(heightSegments);
    const indices = [];
    const vertices = [];
    const normals = [];
    const uvs = [];
    let index = 0;
    const indexArray = [];
    const halfHeight = height / 2;
    let groupStart = 0;
    generateTorso();
    if (openEnded === false) {
      if (radiusTop > 0) generateCap(true);
      if (radiusBottom > 0) generateCap(false);
    }
    this.setIndex(indices);
    this.setAttribute("position", new Float32BufferAttribute(vertices, 3));
    this.setAttribute("normal", new Float32BufferAttribute(normals, 3));
    this.setAttribute("uv", new Float32BufferAttribute(uvs, 2));
    function generateTorso() {
      const normal = new Vector3();
      const vertex2 = new Vector3();
      let groupCount = 0;
      const slope = (radiusBottom - radiusTop) / height;
      for (let y2 = 0; y2 <= heightSegments; y2++) {
        const indexRow = [];
        const v2 = y2 / heightSegments;
        const radius = v2 * (radiusBottom - radiusTop) + radiusTop;
        for (let x3 = 0; x3 <= radialSegments; x3++) {
          const u2 = x3 / radialSegments;
          const theta = u2 * thetaLength + thetaStart;
          const sinTheta = Math.sin(theta);
          const cosTheta = Math.cos(theta);
          vertex2.x = radius * sinTheta;
          vertex2.y = -v2 * height + halfHeight;
          vertex2.z = radius * cosTheta;
          vertices.push(vertex2.x, vertex2.y, vertex2.z);
          normal.set(sinTheta, slope, cosTheta).normalize();
          normals.push(normal.x, normal.y, normal.z);
          uvs.push(u2, 1 - v2);
          indexRow.push(index++);
        }
        indexArray.push(indexRow);
      }
      for (let x3 = 0; x3 < radialSegments; x3++) {
        for (let y2 = 0; y2 < heightSegments; y2++) {
          const a2 = indexArray[y2][x3];
          const b2 = indexArray[y2 + 1][x3];
          const c2 = indexArray[y2 + 1][x3 + 1];
          const d2 = indexArray[y2][x3 + 1];
          indices.push(a2, b2, d2);
          indices.push(b2, c2, d2);
          groupCount += 6;
        }
      }
      scope.addGroup(groupStart, groupCount, 0);
      groupStart += groupCount;
    }
    function generateCap(top) {
      const centerIndexStart = index;
      const uv = new Vector2();
      const vertex2 = new Vector3();
      let groupCount = 0;
      const radius = top === true ? radiusTop : radiusBottom;
      const sign2 = top === true ? 1 : -1;
      for (let x3 = 1; x3 <= radialSegments; x3++) {
        vertices.push(0, halfHeight * sign2, 0);
        normals.push(0, sign2, 0);
        uvs.push(0.5, 0.5);
        index++;
      }
      const centerIndexEnd = index;
      for (let x3 = 0; x3 <= radialSegments; x3++) {
        const u2 = x3 / radialSegments;
        const theta = u2 * thetaLength + thetaStart;
        const cosTheta = Math.cos(theta);
        const sinTheta = Math.sin(theta);
        vertex2.x = radius * sinTheta;
        vertex2.y = halfHeight * sign2;
        vertex2.z = radius * cosTheta;
        vertices.push(vertex2.x, vertex2.y, vertex2.z);
        normals.push(0, sign2, 0);
        uv.x = cosTheta * 0.5 + 0.5;
        uv.y = sinTheta * 0.5 * sign2 + 0.5;
        uvs.push(uv.x, uv.y);
        index++;
      }
      for (let x3 = 0; x3 < radialSegments; x3++) {
        const c2 = centerIndexStart + x3;
        const i2 = centerIndexEnd + x3;
        if (top === true) {
          indices.push(i2, i2 + 1, c2);
        } else {
          indices.push(i2 + 1, i2, c2);
        }
        groupCount += 3;
      }
      scope.addGroup(groupStart, groupCount, top === true ? 1 : 2);
      groupStart += groupCount;
    }
  }
  copy(source) {
    super.copy(source);
    this.parameters = Object.assign({}, source.parameters);
    return this;
  }
  static fromJSON(data) {
    return new _CylinderGeometry(data.radiusTop, data.radiusBottom, data.height, data.radialSegments, data.heightSegments, data.openEnded, data.thetaStart, data.thetaLength);
  }
};
var ConeGeometry = class _ConeGeometry extends CylinderGeometry {
  constructor(radius = 1, height = 1, radialSegments = 32, heightSegments = 1, openEnded = false, thetaStart = 0, thetaLength = Math.PI * 2) {
    super(0, radius, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength);
    this.type = "ConeGeometry";
    this.parameters = {
      radius,
      height,
      radialSegments,
      heightSegments,
      openEnded,
      thetaStart,
      thetaLength
    };
  }
  static fromJSON(data) {
    return new _ConeGeometry(data.radius, data.height, data.radialSegments, data.heightSegments, data.openEnded, data.thetaStart, data.thetaLength);
  }
};
var PolyhedronGeometry = class _PolyhedronGeometry extends BufferGeometry {
  constructor(vertices = [], indices = [], radius = 1, detail = 0) {
    super();
    this.type = "PolyhedronGeometry";
    this.parameters = {
      vertices,
      indices,
      radius,
      detail
    };
    const vertexBuffer = [];
    const uvBuffer = [];
    subdivide(detail);
    applyRadius(radius);
    generateUVs();
    this.setAttribute("position", new Float32BufferAttribute(vertexBuffer, 3));
    this.setAttribute("normal", new Float32BufferAttribute(vertexBuffer.slice(), 3));
    this.setAttribute("uv", new Float32BufferAttribute(uvBuffer, 2));
    if (detail === 0) {
      this.computeVertexNormals();
    } else {
      this.normalizeNormals();
    }
    function subdivide(detail2) {
      const a2 = new Vector3();
      const b2 = new Vector3();
      const c2 = new Vector3();
      for (let i2 = 0; i2 < indices.length; i2 += 3) {
        getVertexByIndex(indices[i2 + 0], a2);
        getVertexByIndex(indices[i2 + 1], b2);
        getVertexByIndex(indices[i2 + 2], c2);
        subdivideFace(a2, b2, c2, detail2);
      }
    }
    function subdivideFace(a2, b2, c2, detail2) {
      const cols = detail2 + 1;
      const v2 = [];
      for (let i2 = 0; i2 <= cols; i2++) {
        v2[i2] = [];
        const aj = a2.clone().lerp(c2, i2 / cols);
        const bj = b2.clone().lerp(c2, i2 / cols);
        const rows = cols - i2;
        for (let j = 0; j <= rows; j++) {
          if (j === 0 && i2 === cols) {
            v2[i2][j] = aj;
          } else {
            v2[i2][j] = aj.clone().lerp(bj, j / rows);
          }
        }
      }
      for (let i2 = 0; i2 < cols; i2++) {
        for (let j = 0; j < 2 * (cols - i2) - 1; j++) {
          const k2 = Math.floor(j / 2);
          if (j % 2 === 0) {
            pushVertex(v2[i2][k2 + 1]);
            pushVertex(v2[i2 + 1][k2]);
            pushVertex(v2[i2][k2]);
          } else {
            pushVertex(v2[i2][k2 + 1]);
            pushVertex(v2[i2 + 1][k2 + 1]);
            pushVertex(v2[i2 + 1][k2]);
          }
        }
      }
    }
    function applyRadius(radius2) {
      const vertex2 = new Vector3();
      for (let i2 = 0; i2 < vertexBuffer.length; i2 += 3) {
        vertex2.x = vertexBuffer[i2 + 0];
        vertex2.y = vertexBuffer[i2 + 1];
        vertex2.z = vertexBuffer[i2 + 2];
        vertex2.normalize().multiplyScalar(radius2);
        vertexBuffer[i2 + 0] = vertex2.x;
        vertexBuffer[i2 + 1] = vertex2.y;
        vertexBuffer[i2 + 2] = vertex2.z;
      }
    }
    function generateUVs() {
      const vertex2 = new Vector3();
      for (let i2 = 0; i2 < vertexBuffer.length; i2 += 3) {
        vertex2.x = vertexBuffer[i2 + 0];
        vertex2.y = vertexBuffer[i2 + 1];
        vertex2.z = vertexBuffer[i2 + 2];
        const u2 = azimuth(vertex2) / 2 / Math.PI + 0.5;
        const v2 = inclination(vertex2) / Math.PI + 0.5;
        uvBuffer.push(u2, 1 - v2);
      }
      correctUVs();
      correctSeam();
    }
    function correctSeam() {
      for (let i2 = 0; i2 < uvBuffer.length; i2 += 6) {
        const x0 = uvBuffer[i2 + 0];
        const x1 = uvBuffer[i2 + 2];
        const x22 = uvBuffer[i2 + 4];
        const max = Math.max(x0, x1, x22);
        const min = Math.min(x0, x1, x22);
        if (max > 0.9 && min < 0.1) {
          if (x0 < 0.2) uvBuffer[i2 + 0] += 1;
          if (x1 < 0.2) uvBuffer[i2 + 2] += 1;
          if (x22 < 0.2) uvBuffer[i2 + 4] += 1;
        }
      }
    }
    function pushVertex(vertex2) {
      vertexBuffer.push(vertex2.x, vertex2.y, vertex2.z);
    }
    function getVertexByIndex(index, vertex2) {
      const stride = index * 3;
      vertex2.x = vertices[stride + 0];
      vertex2.y = vertices[stride + 1];
      vertex2.z = vertices[stride + 2];
    }
    function correctUVs() {
      const a2 = new Vector3();
      const b2 = new Vector3();
      const c2 = new Vector3();
      const centroid = new Vector3();
      const uvA = new Vector2();
      const uvB = new Vector2();
      const uvC = new Vector2();
      for (let i2 = 0, j = 0; i2 < vertexBuffer.length; i2 += 9, j += 6) {
        a2.set(vertexBuffer[i2 + 0], vertexBuffer[i2 + 1], vertexBuffer[i2 + 2]);
        b2.set(vertexBuffer[i2 + 3], vertexBuffer[i2 + 4], vertexBuffer[i2 + 5]);
        c2.set(vertexBuffer[i2 + 6], vertexBuffer[i2 + 7], vertexBuffer[i2 + 8]);
        uvA.set(uvBuffer[j + 0], uvBuffer[j + 1]);
        uvB.set(uvBuffer[j + 2], uvBuffer[j + 3]);
        uvC.set(uvBuffer[j + 4], uvBuffer[j + 5]);
        centroid.copy(a2).add(b2).add(c2).divideScalar(3);
        const azi = azimuth(centroid);
        correctUV(uvA, j + 0, a2, azi);
        correctUV(uvB, j + 2, b2, azi);
        correctUV(uvC, j + 4, c2, azi);
      }
    }
    function correctUV(uv, stride, vector, azimuth2) {
      if (azimuth2 < 0 && uv.x === 1) {
        uvBuffer[stride] = uv.x - 1;
      }
      if (vector.x === 0 && vector.z === 0) {
        uvBuffer[stride] = azimuth2 / 2 / Math.PI + 0.5;
      }
    }
    function azimuth(vector) {
      return Math.atan2(vector.z, -vector.x);
    }
    function inclination(vector) {
      return Math.atan2(-vector.y, Math.sqrt(vector.x * vector.x + vector.z * vector.z));
    }
  }
  copy(source) {
    super.copy(source);
    this.parameters = Object.assign({}, source.parameters);
    return this;
  }
  static fromJSON(data) {
    return new _PolyhedronGeometry(data.vertices, data.indices, data.radius, data.details);
  }
};
var DodecahedronGeometry = class _DodecahedronGeometry extends PolyhedronGeometry {
  constructor(radius = 1, detail = 0) {
    const t2 = (1 + Math.sqrt(5)) / 2;
    const r2 = 1 / t2;
    const vertices = [
      // (±1, ±1, ±1)
      -1,
      -1,
      -1,
      -1,
      -1,
      1,
      -1,
      1,
      -1,
      -1,
      1,
      1,
      1,
      -1,
      -1,
      1,
      -1,
      1,
      1,
      1,
      -1,
      1,
      1,
      1,
      // (0, ±1/φ, ±φ)
      0,
      -r2,
      -t2,
      0,
      -r2,
      t2,
      0,
      r2,
      -t2,
      0,
      r2,
      t2,
      // (±1/φ, ±φ, 0)
      -r2,
      -t2,
      0,
      -r2,
      t2,
      0,
      r2,
      -t2,
      0,
      r2,
      t2,
      0,
      // (±φ, 0, ±1/φ)
      -t2,
      0,
      -r2,
      t2,
      0,
      -r2,
      -t2,
      0,
      r2,
      t2,
      0,
      r2
    ];
    const indices = [
      3,
      11,
      7,
      3,
      7,
      15,
      3,
      15,
      13,
      7,
      19,
      17,
      7,
      17,
      6,
      7,
      6,
      15,
      17,
      4,
      8,
      17,
      8,
      10,
      17,
      10,
      6,
      8,
      0,
      16,
      8,
      16,
      2,
      8,
      2,
      10,
      0,
      12,
      1,
      0,
      1,
      18,
      0,
      18,
      16,
      6,
      10,
      2,
      6,
      2,
      13,
      6,
      13,
      15,
      2,
      16,
      18,
      2,
      18,
      3,
      2,
      3,
      13,
      18,
      1,
      9,
      18,
      9,
      11,
      18,
      11,
      3,
      4,
      14,
      12,
      4,
      12,
      0,
      4,
      0,
      8,
      11,
      9,
      5,
      11,
      5,
      19,
      11,
      19,
      7,
      19,
      5,
      14,
      19,
      14,
      4,
      19,
      4,
      17,
      1,
      12,
      14,
      1,
      14,
      5,
      1,
      5,
      9
    ];
    super(vertices, indices, radius, detail);
    this.type = "DodecahedronGeometry";
    this.parameters = {
      radius,
      detail
    };
  }
  static fromJSON(data) {
    return new _DodecahedronGeometry(data.radius, data.detail);
  }
};
var _v0 = new Vector3();
var _v1$1 = new Vector3();
var _normal = new Vector3();
var _triangle = new Triangle();
var EdgesGeometry = class extends BufferGeometry {
  constructor(geometry = null, thresholdAngle = 1) {
    super();
    this.type = "EdgesGeometry";
    this.parameters = {
      geometry,
      thresholdAngle
    };
    if (geometry !== null) {
      const precisionPoints = 4;
      const precision = Math.pow(10, precisionPoints);
      const thresholdDot = Math.cos(DEG2RAD * thresholdAngle);
      const indexAttr = geometry.getIndex();
      const positionAttr = geometry.getAttribute("position");
      const indexCount = indexAttr ? indexAttr.count : positionAttr.count;
      const indexArr = [0, 0, 0];
      const vertKeys = ["a", "b", "c"];
      const hashes = new Array(3);
      const edgeData = {};
      const vertices = [];
      for (let i2 = 0; i2 < indexCount; i2 += 3) {
        if (indexAttr) {
          indexArr[0] = indexAttr.getX(i2);
          indexArr[1] = indexAttr.getX(i2 + 1);
          indexArr[2] = indexAttr.getX(i2 + 2);
        } else {
          indexArr[0] = i2;
          indexArr[1] = i2 + 1;
          indexArr[2] = i2 + 2;
        }
        const { a: a2, b: b2, c: c2 } = _triangle;
        a2.fromBufferAttribute(positionAttr, indexArr[0]);
        b2.fromBufferAttribute(positionAttr, indexArr[1]);
        c2.fromBufferAttribute(positionAttr, indexArr[2]);
        _triangle.getNormal(_normal);
        hashes[0] = `${Math.round(a2.x * precision)},${Math.round(a2.y * precision)},${Math.round(a2.z * precision)}`;
        hashes[1] = `${Math.round(b2.x * precision)},${Math.round(b2.y * precision)},${Math.round(b2.z * precision)}`;
        hashes[2] = `${Math.round(c2.x * precision)},${Math.round(c2.y * precision)},${Math.round(c2.z * precision)}`;
        if (hashes[0] === hashes[1] || hashes[1] === hashes[2] || hashes[2] === hashes[0]) {
          continue;
        }
        for (let j = 0; j < 3; j++) {
          const jNext = (j + 1) % 3;
          const vecHash0 = hashes[j];
          const vecHash1 = hashes[jNext];
          const v0 = _triangle[vertKeys[j]];
          const v1 = _triangle[vertKeys[jNext]];
          const hash = `${vecHash0}_${vecHash1}`;
          const reverseHash = `${vecHash1}_${vecHash0}`;
          if (reverseHash in edgeData && edgeData[reverseHash]) {
            if (_normal.dot(edgeData[reverseHash].normal) <= thresholdDot) {
              vertices.push(v0.x, v0.y, v0.z);
              vertices.push(v1.x, v1.y, v1.z);
            }
            edgeData[reverseHash] = null;
          } else if (!(hash in edgeData)) {
            edgeData[hash] = {
              index0: indexArr[j],
              index1: indexArr[jNext],
              normal: _normal.clone()
            };
          }
        }
      }
      for (const key in edgeData) {
        if (edgeData[key]) {
          const { index0, index1 } = edgeData[key];
          _v0.fromBufferAttribute(positionAttr, index0);
          _v1$1.fromBufferAttribute(positionAttr, index1);
          vertices.push(_v0.x, _v0.y, _v0.z);
          vertices.push(_v1$1.x, _v1$1.y, _v1$1.z);
        }
      }
      this.setAttribute("position", new Float32BufferAttribute(vertices, 3));
    }
  }
  copy(source) {
    super.copy(source);
    this.parameters = Object.assign({}, source.parameters);
    return this;
  }
};
var Shape = class extends Path {
  constructor(points) {
    super(points);
    this.uuid = generateUUID();
    this.type = "Shape";
    this.holes = [];
  }
  getPointsHoles(divisions) {
    const holesPts = [];
    for (let i2 = 0, l2 = this.holes.length; i2 < l2; i2++) {
      holesPts[i2] = this.holes[i2].getPoints(divisions);
    }
    return holesPts;
  }
  // get points of shape and holes (keypoints based on segments parameter)
  extractPoints(divisions) {
    return {
      shape: this.getPoints(divisions),
      holes: this.getPointsHoles(divisions)
    };
  }
  copy(source) {
    super.copy(source);
    this.holes = [];
    for (let i2 = 0, l2 = source.holes.length; i2 < l2; i2++) {
      const hole = source.holes[i2];
      this.holes.push(hole.clone());
    }
    return this;
  }
  toJSON() {
    const data = super.toJSON();
    data.uuid = this.uuid;
    data.holes = [];
    for (let i2 = 0, l2 = this.holes.length; i2 < l2; i2++) {
      const hole = this.holes[i2];
      data.holes.push(hole.toJSON());
    }
    return data;
  }
  fromJSON(json) {
    super.fromJSON(json);
    this.uuid = json.uuid;
    this.holes = [];
    for (let i2 = 0, l2 = json.holes.length; i2 < l2; i2++) {
      const hole = json.holes[i2];
      this.holes.push(new Path().fromJSON(hole));
    }
    return this;
  }
};
var Earcut = {
  triangulate: function(data, holeIndices, dim = 2) {
    const hasHoles = holeIndices && holeIndices.length;
    const outerLen = hasHoles ? holeIndices[0] * dim : data.length;
    let outerNode = linkedList(data, 0, outerLen, dim, true);
    const triangles = [];
    if (!outerNode || outerNode.next === outerNode.prev) return triangles;
    let minX, minY, maxX, maxY, x3, y2, invSize;
    if (hasHoles) outerNode = eliminateHoles(data, holeIndices, outerNode, dim);
    if (data.length > 80 * dim) {
      minX = maxX = data[0];
      minY = maxY = data[1];
      for (let i2 = dim; i2 < outerLen; i2 += dim) {
        x3 = data[i2];
        y2 = data[i2 + 1];
        if (x3 < minX) minX = x3;
        if (y2 < minY) minY = y2;
        if (x3 > maxX) maxX = x3;
        if (y2 > maxY) maxY = y2;
      }
      invSize = Math.max(maxX - minX, maxY - minY);
      invSize = invSize !== 0 ? 32767 / invSize : 0;
    }
    earcutLinked(outerNode, triangles, dim, minX, minY, invSize, 0);
    return triangles;
  }
};
function linkedList(data, start, end, dim, clockwise) {
  let i2, last;
  if (clockwise === signedArea(data, start, end, dim) > 0) {
    for (i2 = start; i2 < end; i2 += dim) last = insertNode(i2, data[i2], data[i2 + 1], last);
  } else {
    for (i2 = end - dim; i2 >= start; i2 -= dim) last = insertNode(i2, data[i2], data[i2 + 1], last);
  }
  if (last && equals(last, last.next)) {
    removeNode(last);
    last = last.next;
  }
  return last;
}
function filterPoints(start, end) {
  if (!start) return start;
  if (!end) end = start;
  let p2 = start, again;
  do {
    again = false;
    if (!p2.steiner && (equals(p2, p2.next) || area(p2.prev, p2, p2.next) === 0)) {
      removeNode(p2);
      p2 = end = p2.prev;
      if (p2 === p2.next) break;
      again = true;
    } else {
      p2 = p2.next;
    }
  } while (again || p2 !== end);
  return end;
}
function earcutLinked(ear, triangles, dim, minX, minY, invSize, pass) {
  if (!ear) return;
  if (!pass && invSize) indexCurve(ear, minX, minY, invSize);
  let stop = ear, prev, next;
  while (ear.prev !== ear.next) {
    prev = ear.prev;
    next = ear.next;
    if (invSize ? isEarHashed(ear, minX, minY, invSize) : isEar(ear)) {
      triangles.push(prev.i / dim | 0);
      triangles.push(ear.i / dim | 0);
      triangles.push(next.i / dim | 0);
      removeNode(ear);
      ear = next.next;
      stop = next.next;
      continue;
    }
    ear = next;
    if (ear === stop) {
      if (!pass) {
        earcutLinked(filterPoints(ear), triangles, dim, minX, minY, invSize, 1);
      } else if (pass === 1) {
        ear = cureLocalIntersections(filterPoints(ear), triangles, dim);
        earcutLinked(ear, triangles, dim, minX, minY, invSize, 2);
      } else if (pass === 2) {
        splitEarcut(ear, triangles, dim, minX, minY, invSize);
      }
      break;
    }
  }
}
function isEar(ear) {
  const a2 = ear.prev, b2 = ear, c2 = ear.next;
  if (area(a2, b2, c2) >= 0) return false;
  const ax = a2.x, bx = b2.x, cx = c2.x, ay = a2.y, by = b2.y, cy = c2.y;
  const x0 = ax < bx ? ax < cx ? ax : cx : bx < cx ? bx : cx, y0 = ay < by ? ay < cy ? ay : cy : by < cy ? by : cy, x1 = ax > bx ? ax > cx ? ax : cx : bx > cx ? bx : cx, y1 = ay > by ? ay > cy ? ay : cy : by > cy ? by : cy;
  let p2 = c2.next;
  while (p2 !== a2) {
    if (p2.x >= x0 && p2.x <= x1 && p2.y >= y0 && p2.y <= y1 && pointInTriangle(ax, ay, bx, by, cx, cy, p2.x, p2.y) && area(p2.prev, p2, p2.next) >= 0) return false;
    p2 = p2.next;
  }
  return true;
}
function isEarHashed(ear, minX, minY, invSize) {
  const a2 = ear.prev, b2 = ear, c2 = ear.next;
  if (area(a2, b2, c2) >= 0) return false;
  const ax = a2.x, bx = b2.x, cx = c2.x, ay = a2.y, by = b2.y, cy = c2.y;
  const x0 = ax < bx ? ax < cx ? ax : cx : bx < cx ? bx : cx, y0 = ay < by ? ay < cy ? ay : cy : by < cy ? by : cy, x1 = ax > bx ? ax > cx ? ax : cx : bx > cx ? bx : cx, y1 = ay > by ? ay > cy ? ay : cy : by > cy ? by : cy;
  const minZ = zOrder(x0, y0, minX, minY, invSize), maxZ = zOrder(x1, y1, minX, minY, invSize);
  let p2 = ear.prevZ, n = ear.nextZ;
  while (p2 && p2.z >= minZ && n && n.z <= maxZ) {
    if (p2.x >= x0 && p2.x <= x1 && p2.y >= y0 && p2.y <= y1 && p2 !== a2 && p2 !== c2 && pointInTriangle(ax, ay, bx, by, cx, cy, p2.x, p2.y) && area(p2.prev, p2, p2.next) >= 0) return false;
    p2 = p2.prevZ;
    if (n.x >= x0 && n.x <= x1 && n.y >= y0 && n.y <= y1 && n !== a2 && n !== c2 && pointInTriangle(ax, ay, bx, by, cx, cy, n.x, n.y) && area(n.prev, n, n.next) >= 0) return false;
    n = n.nextZ;
  }
  while (p2 && p2.z >= minZ) {
    if (p2.x >= x0 && p2.x <= x1 && p2.y >= y0 && p2.y <= y1 && p2 !== a2 && p2 !== c2 && pointInTriangle(ax, ay, bx, by, cx, cy, p2.x, p2.y) && area(p2.prev, p2, p2.next) >= 0) return false;
    p2 = p2.prevZ;
  }
  while (n && n.z <= maxZ) {
    if (n.x >= x0 && n.x <= x1 && n.y >= y0 && n.y <= y1 && n !== a2 && n !== c2 && pointInTriangle(ax, ay, bx, by, cx, cy, n.x, n.y) && area(n.prev, n, n.next) >= 0) return false;
    n = n.nextZ;
  }
  return true;
}
function cureLocalIntersections(start, triangles, dim) {
  let p2 = start;
  do {
    const a2 = p2.prev, b2 = p2.next.next;
    if (!equals(a2, b2) && intersects(a2, p2, p2.next, b2) && locallyInside(a2, b2) && locallyInside(b2, a2)) {
      triangles.push(a2.i / dim | 0);
      triangles.push(p2.i / dim | 0);
      triangles.push(b2.i / dim | 0);
      removeNode(p2);
      removeNode(p2.next);
      p2 = start = b2;
    }
    p2 = p2.next;
  } while (p2 !== start);
  return filterPoints(p2);
}
function splitEarcut(start, triangles, dim, minX, minY, invSize) {
  let a2 = start;
  do {
    let b2 = a2.next.next;
    while (b2 !== a2.prev) {
      if (a2.i !== b2.i && isValidDiagonal(a2, b2)) {
        let c2 = splitPolygon(a2, b2);
        a2 = filterPoints(a2, a2.next);
        c2 = filterPoints(c2, c2.next);
        earcutLinked(a2, triangles, dim, minX, minY, invSize, 0);
        earcutLinked(c2, triangles, dim, minX, minY, invSize, 0);
        return;
      }
      b2 = b2.next;
    }
    a2 = a2.next;
  } while (a2 !== start);
}
function eliminateHoles(data, holeIndices, outerNode, dim) {
  const queue = [];
  let i2, len, start, end, list;
  for (i2 = 0, len = holeIndices.length; i2 < len; i2++) {
    start = holeIndices[i2] * dim;
    end = i2 < len - 1 ? holeIndices[i2 + 1] * dim : data.length;
    list = linkedList(data, start, end, dim, false);
    if (list === list.next) list.steiner = true;
    queue.push(getLeftmost(list));
  }
  queue.sort(compareX);
  for (i2 = 0; i2 < queue.length; i2++) {
    outerNode = eliminateHole(queue[i2], outerNode);
  }
  return outerNode;
}
function compareX(a2, b2) {
  return a2.x - b2.x;
}
function eliminateHole(hole, outerNode) {
  const bridge = findHoleBridge(hole, outerNode);
  if (!bridge) {
    return outerNode;
  }
  const bridgeReverse = splitPolygon(bridge, hole);
  filterPoints(bridgeReverse, bridgeReverse.next);
  return filterPoints(bridge, bridge.next);
}
function findHoleBridge(hole, outerNode) {
  let p2 = outerNode, qx = -Infinity, m2;
  const hx = hole.x, hy = hole.y;
  do {
    if (hy <= p2.y && hy >= p2.next.y && p2.next.y !== p2.y) {
      const x3 = p2.x + (hy - p2.y) * (p2.next.x - p2.x) / (p2.next.y - p2.y);
      if (x3 <= hx && x3 > qx) {
        qx = x3;
        m2 = p2.x < p2.next.x ? p2 : p2.next;
        if (x3 === hx) return m2;
      }
    }
    p2 = p2.next;
  } while (p2 !== outerNode);
  if (!m2) return null;
  const stop = m2, mx = m2.x, my = m2.y;
  let tanMin = Infinity, tan;
  p2 = m2;
  do {
    if (hx >= p2.x && p2.x >= mx && hx !== p2.x && pointInTriangle(hy < my ? hx : qx, hy, mx, my, hy < my ? qx : hx, hy, p2.x, p2.y)) {
      tan = Math.abs(hy - p2.y) / (hx - p2.x);
      if (locallyInside(p2, hole) && (tan < tanMin || tan === tanMin && (p2.x > m2.x || p2.x === m2.x && sectorContainsSector(m2, p2)))) {
        m2 = p2;
        tanMin = tan;
      }
    }
    p2 = p2.next;
  } while (p2 !== stop);
  return m2;
}
function sectorContainsSector(m2, p2) {
  return area(m2.prev, m2, p2.prev) < 0 && area(p2.next, m2, m2.next) < 0;
}
function indexCurve(start, minX, minY, invSize) {
  let p2 = start;
  do {
    if (p2.z === 0) p2.z = zOrder(p2.x, p2.y, minX, minY, invSize);
    p2.prevZ = p2.prev;
    p2.nextZ = p2.next;
    p2 = p2.next;
  } while (p2 !== start);
  p2.prevZ.nextZ = null;
  p2.prevZ = null;
  sortLinked(p2);
}
function sortLinked(list) {
  let i2, p2, q, e2, tail, numMerges, pSize, qSize, inSize = 1;
  do {
    p2 = list;
    list = null;
    tail = null;
    numMerges = 0;
    while (p2) {
      numMerges++;
      q = p2;
      pSize = 0;
      for (i2 = 0; i2 < inSize; i2++) {
        pSize++;
        q = q.nextZ;
        if (!q) break;
      }
      qSize = inSize;
      while (pSize > 0 || qSize > 0 && q) {
        if (pSize !== 0 && (qSize === 0 || !q || p2.z <= q.z)) {
          e2 = p2;
          p2 = p2.nextZ;
          pSize--;
        } else {
          e2 = q;
          q = q.nextZ;
          qSize--;
        }
        if (tail) tail.nextZ = e2;
        else list = e2;
        e2.prevZ = tail;
        tail = e2;
      }
      p2 = q;
    }
    tail.nextZ = null;
    inSize *= 2;
  } while (numMerges > 1);
  return list;
}
function zOrder(x3, y2, minX, minY, invSize) {
  x3 = (x3 - minX) * invSize | 0;
  y2 = (y2 - minY) * invSize | 0;
  x3 = (x3 | x3 << 8) & 16711935;
  x3 = (x3 | x3 << 4) & 252645135;
  x3 = (x3 | x3 << 2) & 858993459;
  x3 = (x3 | x3 << 1) & 1431655765;
  y2 = (y2 | y2 << 8) & 16711935;
  y2 = (y2 | y2 << 4) & 252645135;
  y2 = (y2 | y2 << 2) & 858993459;
  y2 = (y2 | y2 << 1) & 1431655765;
  return x3 | y2 << 1;
}
function getLeftmost(start) {
  let p2 = start, leftmost = start;
  do {
    if (p2.x < leftmost.x || p2.x === leftmost.x && p2.y < leftmost.y) leftmost = p2;
    p2 = p2.next;
  } while (p2 !== start);
  return leftmost;
}
function pointInTriangle(ax, ay, bx, by, cx, cy, px2, py2) {
  return (cx - px2) * (ay - py2) >= (ax - px2) * (cy - py2) && (ax - px2) * (by - py2) >= (bx - px2) * (ay - py2) && (bx - px2) * (cy - py2) >= (cx - px2) * (by - py2);
}
function isValidDiagonal(a2, b2) {
  return a2.next.i !== b2.i && a2.prev.i !== b2.i && !intersectsPolygon(a2, b2) && // dones't intersect other edges
  (locallyInside(a2, b2) && locallyInside(b2, a2) && middleInside(a2, b2) && // locally visible
  (area(a2.prev, a2, b2.prev) || area(a2, b2.prev, b2)) || // does not create opposite-facing sectors
  equals(a2, b2) && area(a2.prev, a2, a2.next) > 0 && area(b2.prev, b2, b2.next) > 0);
}
function area(p2, q, r2) {
  return (q.y - p2.y) * (r2.x - q.x) - (q.x - p2.x) * (r2.y - q.y);
}
function equals(p1, p2) {
  return p1.x === p2.x && p1.y === p2.y;
}
function intersects(p1, q1, p2, q2) {
  const o1 = sign(area(p1, q1, p2));
  const o2 = sign(area(p1, q1, q2));
  const o3 = sign(area(p2, q2, p1));
  const o4 = sign(area(p2, q2, q1));
  if (o1 !== o2 && o3 !== o4) return true;
  if (o1 === 0 && onSegment(p1, p2, q1)) return true;
  if (o2 === 0 && onSegment(p1, q2, q1)) return true;
  if (o3 === 0 && onSegment(p2, p1, q2)) return true;
  if (o4 === 0 && onSegment(p2, q1, q2)) return true;
  return false;
}
function onSegment(p2, q, r2) {
  return q.x <= Math.max(p2.x, r2.x) && q.x >= Math.min(p2.x, r2.x) && q.y <= Math.max(p2.y, r2.y) && q.y >= Math.min(p2.y, r2.y);
}
function sign(num) {
  return num > 0 ? 1 : num < 0 ? -1 : 0;
}
function intersectsPolygon(a2, b2) {
  let p2 = a2;
  do {
    if (p2.i !== a2.i && p2.next.i !== a2.i && p2.i !== b2.i && p2.next.i !== b2.i && intersects(p2, p2.next, a2, b2)) return true;
    p2 = p2.next;
  } while (p2 !== a2);
  return false;
}
function locallyInside(a2, b2) {
  return area(a2.prev, a2, a2.next) < 0 ? area(a2, b2, a2.next) >= 0 && area(a2, a2.prev, b2) >= 0 : area(a2, b2, a2.prev) < 0 || area(a2, a2.next, b2) < 0;
}
function middleInside(a2, b2) {
  let p2 = a2, inside = false;
  const px2 = (a2.x + b2.x) / 2, py2 = (a2.y + b2.y) / 2;
  do {
    if (p2.y > py2 !== p2.next.y > py2 && p2.next.y !== p2.y && px2 < (p2.next.x - p2.x) * (py2 - p2.y) / (p2.next.y - p2.y) + p2.x)
      inside = !inside;
    p2 = p2.next;
  } while (p2 !== a2);
  return inside;
}
function splitPolygon(a2, b2) {
  const a22 = new Node(a2.i, a2.x, a2.y), b22 = new Node(b2.i, b2.x, b2.y), an = a2.next, bp = b2.prev;
  a2.next = b2;
  b2.prev = a2;
  a22.next = an;
  an.prev = a22;
  b22.next = a22;
  a22.prev = b22;
  bp.next = b22;
  b22.prev = bp;
  return b22;
}
function insertNode(i2, x3, y2, last) {
  const p2 = new Node(i2, x3, y2);
  if (!last) {
    p2.prev = p2;
    p2.next = p2;
  } else {
    p2.next = last.next;
    p2.prev = last;
    last.next.prev = p2;
    last.next = p2;
  }
  return p2;
}
function removeNode(p2) {
  p2.next.prev = p2.prev;
  p2.prev.next = p2.next;
  if (p2.prevZ) p2.prevZ.nextZ = p2.nextZ;
  if (p2.nextZ) p2.nextZ.prevZ = p2.prevZ;
}
function Node(i2, x3, y2) {
  this.i = i2;
  this.x = x3;
  this.y = y2;
  this.prev = null;
  this.next = null;
  this.z = 0;
  this.prevZ = null;
  this.nextZ = null;
  this.steiner = false;
}
function signedArea(data, start, end, dim) {
  let sum = 0;
  for (let i2 = start, j = end - dim; i2 < end; i2 += dim) {
    sum += (data[j] - data[i2]) * (data[i2 + 1] + data[j + 1]);
    j = i2;
  }
  return sum;
}
var ShapeUtils = class _ShapeUtils {
  // calculate area of the contour polygon
  static area(contour) {
    const n = contour.length;
    let a2 = 0;
    for (let p2 = n - 1, q = 0; q < n; p2 = q++) {
      a2 += contour[p2].x * contour[q].y - contour[q].x * contour[p2].y;
    }
    return a2 * 0.5;
  }
  static isClockWise(pts) {
    return _ShapeUtils.area(pts) < 0;
  }
  static triangulateShape(contour, holes) {
    const vertices = [];
    const holeIndices = [];
    const faces = [];
    removeDupEndPts(contour);
    addContour(vertices, contour);
    let holeIndex = contour.length;
    holes.forEach(removeDupEndPts);
    for (let i2 = 0; i2 < holes.length; i2++) {
      holeIndices.push(holeIndex);
      holeIndex += holes[i2].length;
      addContour(vertices, holes[i2]);
    }
    const triangles = Earcut.triangulate(vertices, holeIndices);
    for (let i2 = 0; i2 < triangles.length; i2 += 3) {
      faces.push(triangles.slice(i2, i2 + 3));
    }
    return faces;
  }
};
function removeDupEndPts(points) {
  const l2 = points.length;
  if (l2 > 2 && points[l2 - 1].equals(points[0])) {
    points.pop();
  }
}
function addContour(vertices, contour) {
  for (let i2 = 0; i2 < contour.length; i2++) {
    vertices.push(contour[i2].x);
    vertices.push(contour[i2].y);
  }
}
var ExtrudeGeometry = class _ExtrudeGeometry extends BufferGeometry {
  constructor(shapes = new Shape([new Vector2(0.5, 0.5), new Vector2(-0.5, 0.5), new Vector2(-0.5, -0.5), new Vector2(0.5, -0.5)]), options2 = {}) {
    super();
    this.type = "ExtrudeGeometry";
    this.parameters = {
      shapes,
      options: options2
    };
    shapes = Array.isArray(shapes) ? shapes : [shapes];
    const scope = this;
    const verticesArray = [];
    const uvArray = [];
    for (let i2 = 0, l2 = shapes.length; i2 < l2; i2++) {
      const shape = shapes[i2];
      addShape(shape);
    }
    this.setAttribute("position", new Float32BufferAttribute(verticesArray, 3));
    this.setAttribute("uv", new Float32BufferAttribute(uvArray, 2));
    this.computeVertexNormals();
    function addShape(shape) {
      const placeholder = [];
      const curveSegments = options2.curveSegments !== void 0 ? options2.curveSegments : 12;
      const steps = options2.steps !== void 0 ? options2.steps : 1;
      const depth = options2.depth !== void 0 ? options2.depth : 1;
      let bevelEnabled = options2.bevelEnabled !== void 0 ? options2.bevelEnabled : true;
      let bevelThickness = options2.bevelThickness !== void 0 ? options2.bevelThickness : 0.2;
      let bevelSize = options2.bevelSize !== void 0 ? options2.bevelSize : bevelThickness - 0.1;
      let bevelOffset = options2.bevelOffset !== void 0 ? options2.bevelOffset : 0;
      let bevelSegments = options2.bevelSegments !== void 0 ? options2.bevelSegments : 3;
      const extrudePath = options2.extrudePath;
      const uvgen = options2.UVGenerator !== void 0 ? options2.UVGenerator : WorldUVGenerator;
      let extrudePts, extrudeByPath = false;
      let splineTube, binormal, normal, position2;
      if (extrudePath) {
        extrudePts = extrudePath.getSpacedPoints(steps);
        extrudeByPath = true;
        bevelEnabled = false;
        splineTube = extrudePath.computeFrenetFrames(steps, false);
        binormal = new Vector3();
        normal = new Vector3();
        position2 = new Vector3();
      }
      if (!bevelEnabled) {
        bevelSegments = 0;
        bevelThickness = 0;
        bevelSize = 0;
        bevelOffset = 0;
      }
      const shapePoints = shape.extractPoints(curveSegments);
      let vertices = shapePoints.shape;
      const holes = shapePoints.holes;
      const reverse = !ShapeUtils.isClockWise(vertices);
      if (reverse) {
        vertices = vertices.reverse();
        for (let h2 = 0, hl = holes.length; h2 < hl; h2++) {
          const ahole = holes[h2];
          if (ShapeUtils.isClockWise(ahole)) {
            holes[h2] = ahole.reverse();
          }
        }
      }
      const faces = ShapeUtils.triangulateShape(vertices, holes);
      const contour = vertices;
      for (let h2 = 0, hl = holes.length; h2 < hl; h2++) {
        const ahole = holes[h2];
        vertices = vertices.concat(ahole);
      }
      function scalePt2(pt, vec, size) {
        if (!vec) console.error("THREE.ExtrudeGeometry: vec does not exist");
        return pt.clone().addScaledVector(vec, size);
      }
      const vlen = vertices.length, flen = faces.length;
      function getBevelVec(inPt, inPrev, inNext) {
        let v_trans_x, v_trans_y, shrink_by;
        const v_prev_x = inPt.x - inPrev.x, v_prev_y = inPt.y - inPrev.y;
        const v_next_x = inNext.x - inPt.x, v_next_y = inNext.y - inPt.y;
        const v_prev_lensq = v_prev_x * v_prev_x + v_prev_y * v_prev_y;
        const collinear0 = v_prev_x * v_next_y - v_prev_y * v_next_x;
        if (Math.abs(collinear0) > Number.EPSILON) {
          const v_prev_len = Math.sqrt(v_prev_lensq);
          const v_next_len = Math.sqrt(v_next_x * v_next_x + v_next_y * v_next_y);
          const ptPrevShift_x = inPrev.x - v_prev_y / v_prev_len;
          const ptPrevShift_y = inPrev.y + v_prev_x / v_prev_len;
          const ptNextShift_x = inNext.x - v_next_y / v_next_len;
          const ptNextShift_y = inNext.y + v_next_x / v_next_len;
          const sf = ((ptNextShift_x - ptPrevShift_x) * v_next_y - (ptNextShift_y - ptPrevShift_y) * v_next_x) / (v_prev_x * v_next_y - v_prev_y * v_next_x);
          v_trans_x = ptPrevShift_x + v_prev_x * sf - inPt.x;
          v_trans_y = ptPrevShift_y + v_prev_y * sf - inPt.y;
          const v_trans_lensq = v_trans_x * v_trans_x + v_trans_y * v_trans_y;
          if (v_trans_lensq <= 2) {
            return new Vector2(v_trans_x, v_trans_y);
          } else {
            shrink_by = Math.sqrt(v_trans_lensq / 2);
          }
        } else {
          let direction_eq = false;
          if (v_prev_x > Number.EPSILON) {
            if (v_next_x > Number.EPSILON) {
              direction_eq = true;
            }
          } else {
            if (v_prev_x < -Number.EPSILON) {
              if (v_next_x < -Number.EPSILON) {
                direction_eq = true;
              }
            } else {
              if (Math.sign(v_prev_y) === Math.sign(v_next_y)) {
                direction_eq = true;
              }
            }
          }
          if (direction_eq) {
            v_trans_x = -v_prev_y;
            v_trans_y = v_prev_x;
            shrink_by = Math.sqrt(v_prev_lensq);
          } else {
            v_trans_x = v_prev_x;
            v_trans_y = v_prev_y;
            shrink_by = Math.sqrt(v_prev_lensq / 2);
          }
        }
        return new Vector2(v_trans_x / shrink_by, v_trans_y / shrink_by);
      }
      const contourMovements = [];
      for (let i2 = 0, il = contour.length, j = il - 1, k2 = i2 + 1; i2 < il; i2++, j++, k2++) {
        if (j === il) j = 0;
        if (k2 === il) k2 = 0;
        contourMovements[i2] = getBevelVec(contour[i2], contour[j], contour[k2]);
      }
      const holesMovements = [];
      let oneHoleMovements, verticesMovements = contourMovements.concat();
      for (let h2 = 0, hl = holes.length; h2 < hl; h2++) {
        const ahole = holes[h2];
        oneHoleMovements = [];
        for (let i2 = 0, il = ahole.length, j = il - 1, k2 = i2 + 1; i2 < il; i2++, j++, k2++) {
          if (j === il) j = 0;
          if (k2 === il) k2 = 0;
          oneHoleMovements[i2] = getBevelVec(ahole[i2], ahole[j], ahole[k2]);
        }
        holesMovements.push(oneHoleMovements);
        verticesMovements = verticesMovements.concat(oneHoleMovements);
      }
      for (let b2 = 0; b2 < bevelSegments; b2++) {
        const t2 = b2 / bevelSegments;
        const z = bevelThickness * Math.cos(t2 * Math.PI / 2);
        const bs2 = bevelSize * Math.sin(t2 * Math.PI / 2) + bevelOffset;
        for (let i2 = 0, il = contour.length; i2 < il; i2++) {
          const vert = scalePt2(contour[i2], contourMovements[i2], bs2);
          v2(vert.x, vert.y, -z);
        }
        for (let h2 = 0, hl = holes.length; h2 < hl; h2++) {
          const ahole = holes[h2];
          oneHoleMovements = holesMovements[h2];
          for (let i2 = 0, il = ahole.length; i2 < il; i2++) {
            const vert = scalePt2(ahole[i2], oneHoleMovements[i2], bs2);
            v2(vert.x, vert.y, -z);
          }
        }
      }
      const bs = bevelSize + bevelOffset;
      for (let i2 = 0; i2 < vlen; i2++) {
        const vert = bevelEnabled ? scalePt2(vertices[i2], verticesMovements[i2], bs) : vertices[i2];
        if (!extrudeByPath) {
          v2(vert.x, vert.y, 0);
        } else {
          normal.copy(splineTube.normals[0]).multiplyScalar(vert.x);
          binormal.copy(splineTube.binormals[0]).multiplyScalar(vert.y);
          position2.copy(extrudePts[0]).add(normal).add(binormal);
          v2(position2.x, position2.y, position2.z);
        }
      }
      for (let s2 = 1; s2 <= steps; s2++) {
        for (let i2 = 0; i2 < vlen; i2++) {
          const vert = bevelEnabled ? scalePt2(vertices[i2], verticesMovements[i2], bs) : vertices[i2];
          if (!extrudeByPath) {
            v2(vert.x, vert.y, depth / steps * s2);
          } else {
            normal.copy(splineTube.normals[s2]).multiplyScalar(vert.x);
            binormal.copy(splineTube.binormals[s2]).multiplyScalar(vert.y);
            position2.copy(extrudePts[s2]).add(normal).add(binormal);
            v2(position2.x, position2.y, position2.z);
          }
        }
      }
      for (let b2 = bevelSegments - 1; b2 >= 0; b2--) {
        const t2 = b2 / bevelSegments;
        const z = bevelThickness * Math.cos(t2 * Math.PI / 2);
        const bs2 = bevelSize * Math.sin(t2 * Math.PI / 2) + bevelOffset;
        for (let i2 = 0, il = contour.length; i2 < il; i2++) {
          const vert = scalePt2(contour[i2], contourMovements[i2], bs2);
          v2(vert.x, vert.y, depth + z);
        }
        for (let h2 = 0, hl = holes.length; h2 < hl; h2++) {
          const ahole = holes[h2];
          oneHoleMovements = holesMovements[h2];
          for (let i2 = 0, il = ahole.length; i2 < il; i2++) {
            const vert = scalePt2(ahole[i2], oneHoleMovements[i2], bs2);
            if (!extrudeByPath) {
              v2(vert.x, vert.y, depth + z);
            } else {
              v2(vert.x, vert.y + extrudePts[steps - 1].y, extrudePts[steps - 1].x + z);
            }
          }
        }
      }
      buildLidFaces();
      buildSideFaces();
      function buildLidFaces() {
        const start = verticesArray.length / 3;
        if (bevelEnabled) {
          let layer = 0;
          let offset = vlen * layer;
          for (let i2 = 0; i2 < flen; i2++) {
            const face = faces[i2];
            f3(face[2] + offset, face[1] + offset, face[0] + offset);
          }
          layer = steps + bevelSegments * 2;
          offset = vlen * layer;
          for (let i2 = 0; i2 < flen; i2++) {
            const face = faces[i2];
            f3(face[0] + offset, face[1] + offset, face[2] + offset);
          }
        } else {
          for (let i2 = 0; i2 < flen; i2++) {
            const face = faces[i2];
            f3(face[2], face[1], face[0]);
          }
          for (let i2 = 0; i2 < flen; i2++) {
            const face = faces[i2];
            f3(face[0] + vlen * steps, face[1] + vlen * steps, face[2] + vlen * steps);
          }
        }
        scope.addGroup(start, verticesArray.length / 3 - start, 0);
      }
      function buildSideFaces() {
        const start = verticesArray.length / 3;
        let layeroffset = 0;
        sidewalls(contour, layeroffset);
        layeroffset += contour.length;
        for (let h2 = 0, hl = holes.length; h2 < hl; h2++) {
          const ahole = holes[h2];
          sidewalls(ahole, layeroffset);
          layeroffset += ahole.length;
        }
        scope.addGroup(start, verticesArray.length / 3 - start, 1);
      }
      function sidewalls(contour2, layeroffset) {
        let i2 = contour2.length;
        while (--i2 >= 0) {
          const j = i2;
          let k2 = i2 - 1;
          if (k2 < 0) k2 = contour2.length - 1;
          for (let s2 = 0, sl = steps + bevelSegments * 2; s2 < sl; s2++) {
            const slen1 = vlen * s2;
            const slen2 = vlen * (s2 + 1);
            const a2 = layeroffset + j + slen1, b2 = layeroffset + k2 + slen1, c2 = layeroffset + k2 + slen2, d2 = layeroffset + j + slen2;
            f4(a2, b2, c2, d2);
          }
        }
      }
      function v2(x3, y2, z) {
        placeholder.push(x3);
        placeholder.push(y2);
        placeholder.push(z);
      }
      function f3(a2, b2, c2) {
        addVertex(a2);
        addVertex(b2);
        addVertex(c2);
        const nextIndex = verticesArray.length / 3;
        const uvs = uvgen.generateTopUV(scope, verticesArray, nextIndex - 3, nextIndex - 2, nextIndex - 1);
        addUV(uvs[0]);
        addUV(uvs[1]);
        addUV(uvs[2]);
      }
      function f4(a2, b2, c2, d2) {
        addVertex(a2);
        addVertex(b2);
        addVertex(d2);
        addVertex(b2);
        addVertex(c2);
        addVertex(d2);
        const nextIndex = verticesArray.length / 3;
        const uvs = uvgen.generateSideWallUV(scope, verticesArray, nextIndex - 6, nextIndex - 3, nextIndex - 2, nextIndex - 1);
        addUV(uvs[0]);
        addUV(uvs[1]);
        addUV(uvs[3]);
        addUV(uvs[1]);
        addUV(uvs[2]);
        addUV(uvs[3]);
      }
      function addVertex(index) {
        verticesArray.push(placeholder[index * 3 + 0]);
        verticesArray.push(placeholder[index * 3 + 1]);
        verticesArray.push(placeholder[index * 3 + 2]);
      }
      function addUV(vector2) {
        uvArray.push(vector2.x);
        uvArray.push(vector2.y);
      }
    }
  }
  copy(source) {
    super.copy(source);
    this.parameters = Object.assign({}, source.parameters);
    return this;
  }
  toJSON() {
    const data = super.toJSON();
    const shapes = this.parameters.shapes;
    const options2 = this.parameters.options;
    return toJSON$1(shapes, options2, data);
  }
  static fromJSON(data, shapes) {
    const geometryShapes = [];
    for (let j = 0, jl = data.shapes.length; j < jl; j++) {
      const shape = shapes[data.shapes[j]];
      geometryShapes.push(shape);
    }
    const extrudePath = data.options.extrudePath;
    if (extrudePath !== void 0) {
      data.options.extrudePath = new Curves[extrudePath.type]().fromJSON(extrudePath);
    }
    return new _ExtrudeGeometry(geometryShapes, data.options);
  }
};
var WorldUVGenerator = {
  generateTopUV: function(geometry, vertices, indexA, indexB, indexC) {
    const a_x = vertices[indexA * 3];
    const a_y = vertices[indexA * 3 + 1];
    const b_x = vertices[indexB * 3];
    const b_y = vertices[indexB * 3 + 1];
    const c_x = vertices[indexC * 3];
    const c_y = vertices[indexC * 3 + 1];
    return [
      new Vector2(a_x, a_y),
      new Vector2(b_x, b_y),
      new Vector2(c_x, c_y)
    ];
  },
  generateSideWallUV: function(geometry, vertices, indexA, indexB, indexC, indexD) {
    const a_x = vertices[indexA * 3];
    const a_y = vertices[indexA * 3 + 1];
    const a_z = vertices[indexA * 3 + 2];
    const b_x = vertices[indexB * 3];
    const b_y = vertices[indexB * 3 + 1];
    const b_z = vertices[indexB * 3 + 2];
    const c_x = vertices[indexC * 3];
    const c_y = vertices[indexC * 3 + 1];
    const c_z = vertices[indexC * 3 + 2];
    const d_x = vertices[indexD * 3];
    const d_y = vertices[indexD * 3 + 1];
    const d_z = vertices[indexD * 3 + 2];
    if (Math.abs(a_y - b_y) < Math.abs(a_x - b_x)) {
      return [
        new Vector2(a_x, 1 - a_z),
        new Vector2(b_x, 1 - b_z),
        new Vector2(c_x, 1 - c_z),
        new Vector2(d_x, 1 - d_z)
      ];
    } else {
      return [
        new Vector2(a_y, 1 - a_z),
        new Vector2(b_y, 1 - b_z),
        new Vector2(c_y, 1 - c_z),
        new Vector2(d_y, 1 - d_z)
      ];
    }
  }
};
function toJSON$1(shapes, options2, data) {
  data.shapes = [];
  if (Array.isArray(shapes)) {
    for (let i2 = 0, l2 = shapes.length; i2 < l2; i2++) {
      const shape = shapes[i2];
      data.shapes.push(shape.uuid);
    }
  } else {
    data.shapes.push(shapes.uuid);
  }
  data.options = Object.assign({}, options2);
  if (options2.extrudePath !== void 0) data.options.extrudePath = options2.extrudePath.toJSON();
  return data;
}
var IcosahedronGeometry = class _IcosahedronGeometry extends PolyhedronGeometry {
  constructor(radius = 1, detail = 0) {
    const t2 = (1 + Math.sqrt(5)) / 2;
    const vertices = [
      -1,
      t2,
      0,
      1,
      t2,
      0,
      -1,
      -t2,
      0,
      1,
      -t2,
      0,
      0,
      -1,
      t2,
      0,
      1,
      t2,
      0,
      -1,
      -t2,
      0,
      1,
      -t2,
      t2,
      0,
      -1,
      t2,
      0,
      1,
      -t2,
      0,
      -1,
      -t2,
      0,
      1
    ];
    const indices = [
      0,
      11,
      5,
      0,
      5,
      1,
      0,
      1,
      7,
      0,
      7,
      10,
      0,
      10,
      11,
      1,
      5,
      9,
      5,
      11,
      4,
      11,
      10,
      2,
      10,
      7,
      6,
      7,
      1,
      8,
      3,
      9,
      4,
      3,
      4,
      2,
      3,
      2,
      6,
      3,
      6,
      8,
      3,
      8,
      9,
      4,
      9,
      5,
      2,
      4,
      11,
      6,
      2,
      10,
      8,
      6,
      7,
      9,
      8,
      1
    ];
    super(vertices, indices, radius, detail);
    this.type = "IcosahedronGeometry";
    this.parameters = {
      radius,
      detail
    };
  }
  static fromJSON(data) {
    return new _IcosahedronGeometry(data.radius, data.detail);
  }
};
var OctahedronGeometry = class _OctahedronGeometry extends PolyhedronGeometry {
  constructor(radius = 1, detail = 0) {
    const vertices = [
      1,
      0,
      0,
      -1,
      0,
      0,
      0,
      1,
      0,
      0,
      -1,
      0,
      0,
      0,
      1,
      0,
      0,
      -1
    ];
    const indices = [
      0,
      2,
      4,
      0,
      4,
      3,
      0,
      3,
      5,
      0,
      5,
      2,
      1,
      2,
      5,
      1,
      5,
      3,
      1,
      3,
      4,
      1,
      4,
      2
    ];
    super(vertices, indices, radius, detail);
    this.type = "OctahedronGeometry";
    this.parameters = {
      radius,
      detail
    };
  }
  static fromJSON(data) {
    return new _OctahedronGeometry(data.radius, data.detail);
  }
};
var RingGeometry = class _RingGeometry extends BufferGeometry {
  constructor(innerRadius = 0.5, outerRadius = 1, thetaSegments = 32, phiSegments = 1, thetaStart = 0, thetaLength = Math.PI * 2) {
    super();
    this.type = "RingGeometry";
    this.parameters = {
      innerRadius,
      outerRadius,
      thetaSegments,
      phiSegments,
      thetaStart,
      thetaLength
    };
    thetaSegments = Math.max(3, thetaSegments);
    phiSegments = Math.max(1, phiSegments);
    const indices = [];
    const vertices = [];
    const normals = [];
    const uvs = [];
    let radius = innerRadius;
    const radiusStep = (outerRadius - innerRadius) / phiSegments;
    const vertex2 = new Vector3();
    const uv = new Vector2();
    for (let j = 0; j <= phiSegments; j++) {
      for (let i2 = 0; i2 <= thetaSegments; i2++) {
        const segment = thetaStart + i2 / thetaSegments * thetaLength;
        vertex2.x = radius * Math.cos(segment);
        vertex2.y = radius * Math.sin(segment);
        vertices.push(vertex2.x, vertex2.y, vertex2.z);
        normals.push(0, 0, 1);
        uv.x = (vertex2.x / outerRadius + 1) / 2;
        uv.y = (vertex2.y / outerRadius + 1) / 2;
        uvs.push(uv.x, uv.y);
      }
      radius += radiusStep;
    }
    for (let j = 0; j < phiSegments; j++) {
      const thetaSegmentLevel = j * (thetaSegments + 1);
      for (let i2 = 0; i2 < thetaSegments; i2++) {
        const segment = i2 + thetaSegmentLevel;
        const a2 = segment;
        const b2 = segment + thetaSegments + 1;
        const c2 = segment + thetaSegments + 2;
        const d2 = segment + 1;
        indices.push(a2, b2, d2);
        indices.push(b2, c2, d2);
      }
    }
    this.setIndex(indices);
    this.setAttribute("position", new Float32BufferAttribute(vertices, 3));
    this.setAttribute("normal", new Float32BufferAttribute(normals, 3));
    this.setAttribute("uv", new Float32BufferAttribute(uvs, 2));
  }
  copy(source) {
    super.copy(source);
    this.parameters = Object.assign({}, source.parameters);
    return this;
  }
  static fromJSON(data) {
    return new _RingGeometry(data.innerRadius, data.outerRadius, data.thetaSegments, data.phiSegments, data.thetaStart, data.thetaLength);
  }
};
var ShapeGeometry = class _ShapeGeometry extends BufferGeometry {
  constructor(shapes = new Shape([new Vector2(0, 0.5), new Vector2(-0.5, -0.5), new Vector2(0.5, -0.5)]), curveSegments = 12) {
    super();
    this.type = "ShapeGeometry";
    this.parameters = {
      shapes,
      curveSegments
    };
    const indices = [];
    const vertices = [];
    const normals = [];
    const uvs = [];
    let groupStart = 0;
    let groupCount = 0;
    if (Array.isArray(shapes) === false) {
      addShape(shapes);
    } else {
      for (let i2 = 0; i2 < shapes.length; i2++) {
        addShape(shapes[i2]);
        this.addGroup(groupStart, groupCount, i2);
        groupStart += groupCount;
        groupCount = 0;
      }
    }
    this.setIndex(indices);
    this.setAttribute("position", new Float32BufferAttribute(vertices, 3));
    this.setAttribute("normal", new Float32BufferAttribute(normals, 3));
    this.setAttribute("uv", new Float32BufferAttribute(uvs, 2));
    function addShape(shape) {
      const indexOffset = vertices.length / 3;
      const points = shape.extractPoints(curveSegments);
      let shapeVertices = points.shape;
      const shapeHoles = points.holes;
      if (ShapeUtils.isClockWise(shapeVertices) === false) {
        shapeVertices = shapeVertices.reverse();
      }
      for (let i2 = 0, l2 = shapeHoles.length; i2 < l2; i2++) {
        const shapeHole = shapeHoles[i2];
        if (ShapeUtils.isClockWise(shapeHole) === true) {
          shapeHoles[i2] = shapeHole.reverse();
        }
      }
      const faces = ShapeUtils.triangulateShape(shapeVertices, shapeHoles);
      for (let i2 = 0, l2 = shapeHoles.length; i2 < l2; i2++) {
        const shapeHole = shapeHoles[i2];
        shapeVertices = shapeVertices.concat(shapeHole);
      }
      for (let i2 = 0, l2 = shapeVertices.length; i2 < l2; i2++) {
        const vertex2 = shapeVertices[i2];
        vertices.push(vertex2.x, vertex2.y, 0);
        normals.push(0, 0, 1);
        uvs.push(vertex2.x, vertex2.y);
      }
      for (let i2 = 0, l2 = faces.length; i2 < l2; i2++) {
        const face = faces[i2];
        const a2 = face[0] + indexOffset;
        const b2 = face[1] + indexOffset;
        const c2 = face[2] + indexOffset;
        indices.push(a2, b2, c2);
        groupCount += 3;
      }
    }
  }
  copy(source) {
    super.copy(source);
    this.parameters = Object.assign({}, source.parameters);
    return this;
  }
  toJSON() {
    const data = super.toJSON();
    const shapes = this.parameters.shapes;
    return toJSON(shapes, data);
  }
  static fromJSON(data, shapes) {
    const geometryShapes = [];
    for (let j = 0, jl = data.shapes.length; j < jl; j++) {
      const shape = shapes[data.shapes[j]];
      geometryShapes.push(shape);
    }
    return new _ShapeGeometry(geometryShapes, data.curveSegments);
  }
};
function toJSON(shapes, data) {
  data.shapes = [];
  if (Array.isArray(shapes)) {
    for (let i2 = 0, l2 = shapes.length; i2 < l2; i2++) {
      const shape = shapes[i2];
      data.shapes.push(shape.uuid);
    }
  } else {
    data.shapes.push(shapes.uuid);
  }
  return data;
}
var SphereGeometry = class _SphereGeometry extends BufferGeometry {
  constructor(radius = 1, widthSegments = 32, heightSegments = 16, phiStart = 0, phiLength = Math.PI * 2, thetaStart = 0, thetaLength = Math.PI) {
    super();
    this.type = "SphereGeometry";
    this.parameters = {
      radius,
      widthSegments,
      heightSegments,
      phiStart,
      phiLength,
      thetaStart,
      thetaLength
    };
    widthSegments = Math.max(3, Math.floor(widthSegments));
    heightSegments = Math.max(2, Math.floor(heightSegments));
    const thetaEnd = Math.min(thetaStart + thetaLength, Math.PI);
    let index = 0;
    const grid = [];
    const vertex2 = new Vector3();
    const normal = new Vector3();
    const indices = [];
    const vertices = [];
    const normals = [];
    const uvs = [];
    for (let iy = 0; iy <= heightSegments; iy++) {
      const verticesRow = [];
      const v2 = iy / heightSegments;
      let uOffset = 0;
      if (iy === 0 && thetaStart === 0) {
        uOffset = 0.5 / widthSegments;
      } else if (iy === heightSegments && thetaEnd === Math.PI) {
        uOffset = -0.5 / widthSegments;
      }
      for (let ix = 0; ix <= widthSegments; ix++) {
        const u2 = ix / widthSegments;
        vertex2.x = -radius * Math.cos(phiStart + u2 * phiLength) * Math.sin(thetaStart + v2 * thetaLength);
        vertex2.y = radius * Math.cos(thetaStart + v2 * thetaLength);
        vertex2.z = radius * Math.sin(phiStart + u2 * phiLength) * Math.sin(thetaStart + v2 * thetaLength);
        vertices.push(vertex2.x, vertex2.y, vertex2.z);
        normal.copy(vertex2).normalize();
        normals.push(normal.x, normal.y, normal.z);
        uvs.push(u2 + uOffset, 1 - v2);
        verticesRow.push(index++);
      }
      grid.push(verticesRow);
    }
    for (let iy = 0; iy < heightSegments; iy++) {
      for (let ix = 0; ix < widthSegments; ix++) {
        const a2 = grid[iy][ix + 1];
        const b2 = grid[iy][ix];
        const c2 = grid[iy + 1][ix];
        const d2 = grid[iy + 1][ix + 1];
        if (iy !== 0 || thetaStart > 0) indices.push(a2, b2, d2);
        if (iy !== heightSegments - 1 || thetaEnd < Math.PI) indices.push(b2, c2, d2);
      }
    }
    this.setIndex(indices);
    this.setAttribute("position", new Float32BufferAttribute(vertices, 3));
    this.setAttribute("normal", new Float32BufferAttribute(normals, 3));
    this.setAttribute("uv", new Float32BufferAttribute(uvs, 2));
  }
  copy(source) {
    super.copy(source);
    this.parameters = Object.assign({}, source.parameters);
    return this;
  }
  static fromJSON(data) {
    return new _SphereGeometry(data.radius, data.widthSegments, data.heightSegments, data.phiStart, data.phiLength, data.thetaStart, data.thetaLength);
  }
};
var TetrahedronGeometry = class _TetrahedronGeometry extends PolyhedronGeometry {
  constructor(radius = 1, detail = 0) {
    const vertices = [
      1,
      1,
      1,
      -1,
      -1,
      1,
      -1,
      1,
      -1,
      1,
      -1,
      -1
    ];
    const indices = [
      2,
      1,
      0,
      0,
      3,
      2,
      1,
      3,
      0,
      2,
      3,
      1
    ];
    super(vertices, indices, radius, detail);
    this.type = "TetrahedronGeometry";
    this.parameters = {
      radius,
      detail
    };
  }
  static fromJSON(data) {
    return new _TetrahedronGeometry(data.radius, data.detail);
  }
};
var TorusGeometry = class _TorusGeometry extends BufferGeometry {
  constructor(radius = 1, tube = 0.4, radialSegments = 12, tubularSegments = 48, arc = Math.PI * 2) {
    super();
    this.type = "TorusGeometry";
    this.parameters = {
      radius,
      tube,
      radialSegments,
      tubularSegments,
      arc
    };
    radialSegments = Math.floor(radialSegments);
    tubularSegments = Math.floor(tubularSegments);
    const indices = [];
    const vertices = [];
    const normals = [];
    const uvs = [];
    const center = new Vector3();
    const vertex2 = new Vector3();
    const normal = new Vector3();
    for (let j = 0; j <= radialSegments; j++) {
      for (let i2 = 0; i2 <= tubularSegments; i2++) {
        const u2 = i2 / tubularSegments * arc;
        const v2 = j / radialSegments * Math.PI * 2;
        vertex2.x = (radius + tube * Math.cos(v2)) * Math.cos(u2);
        vertex2.y = (radius + tube * Math.cos(v2)) * Math.sin(u2);
        vertex2.z = tube * Math.sin(v2);
        vertices.push(vertex2.x, vertex2.y, vertex2.z);
        center.x = radius * Math.cos(u2);
        center.y = radius * Math.sin(u2);
        normal.subVectors(vertex2, center).normalize();
        normals.push(normal.x, normal.y, normal.z);
        uvs.push(i2 / tubularSegments);
        uvs.push(j / radialSegments);
      }
    }
    for (let j = 1; j <= radialSegments; j++) {
      for (let i2 = 1; i2 <= tubularSegments; i2++) {
        const a2 = (tubularSegments + 1) * j + i2 - 1;
        const b2 = (tubularSegments + 1) * (j - 1) + i2 - 1;
        const c2 = (tubularSegments + 1) * (j - 1) + i2;
        const d2 = (tubularSegments + 1) * j + i2;
        indices.push(a2, b2, d2);
        indices.push(b2, c2, d2);
      }
    }
    this.setIndex(indices);
    this.setAttribute("position", new Float32BufferAttribute(vertices, 3));
    this.setAttribute("normal", new Float32BufferAttribute(normals, 3));
    this.setAttribute("uv", new Float32BufferAttribute(uvs, 2));
  }
  copy(source) {
    super.copy(source);
    this.parameters = Object.assign({}, source.parameters);
    return this;
  }
  static fromJSON(data) {
    return new _TorusGeometry(data.radius, data.tube, data.radialSegments, data.tubularSegments, data.arc);
  }
};
var TorusKnotGeometry = class _TorusKnotGeometry extends BufferGeometry {
  constructor(radius = 1, tube = 0.4, tubularSegments = 64, radialSegments = 8, p2 = 2, q = 3) {
    super();
    this.type = "TorusKnotGeometry";
    this.parameters = {
      radius,
      tube,
      tubularSegments,
      radialSegments,
      p: p2,
      q
    };
    tubularSegments = Math.floor(tubularSegments);
    radialSegments = Math.floor(radialSegments);
    const indices = [];
    const vertices = [];
    const normals = [];
    const uvs = [];
    const vertex2 = new Vector3();
    const normal = new Vector3();
    const P1 = new Vector3();
    const P2 = new Vector3();
    const B2 = new Vector3();
    const T = new Vector3();
    const N = new Vector3();
    for (let i2 = 0; i2 <= tubularSegments; ++i2) {
      const u2 = i2 / tubularSegments * p2 * Math.PI * 2;
      calculatePositionOnCurve(u2, p2, q, radius, P1);
      calculatePositionOnCurve(u2 + 0.01, p2, q, radius, P2);
      T.subVectors(P2, P1);
      N.addVectors(P2, P1);
      B2.crossVectors(T, N);
      N.crossVectors(B2, T);
      B2.normalize();
      N.normalize();
      for (let j = 0; j <= radialSegments; ++j) {
        const v2 = j / radialSegments * Math.PI * 2;
        const cx = -tube * Math.cos(v2);
        const cy = tube * Math.sin(v2);
        vertex2.x = P1.x + (cx * N.x + cy * B2.x);
        vertex2.y = P1.y + (cx * N.y + cy * B2.y);
        vertex2.z = P1.z + (cx * N.z + cy * B2.z);
        vertices.push(vertex2.x, vertex2.y, vertex2.z);
        normal.subVectors(vertex2, P1).normalize();
        normals.push(normal.x, normal.y, normal.z);
        uvs.push(i2 / tubularSegments);
        uvs.push(j / radialSegments);
      }
    }
    for (let j = 1; j <= tubularSegments; j++) {
      for (let i2 = 1; i2 <= radialSegments; i2++) {
        const a2 = (radialSegments + 1) * (j - 1) + (i2 - 1);
        const b2 = (radialSegments + 1) * j + (i2 - 1);
        const c2 = (radialSegments + 1) * j + i2;
        const d2 = (radialSegments + 1) * (j - 1) + i2;
        indices.push(a2, b2, d2);
        indices.push(b2, c2, d2);
      }
    }
    this.setIndex(indices);
    this.setAttribute("position", new Float32BufferAttribute(vertices, 3));
    this.setAttribute("normal", new Float32BufferAttribute(normals, 3));
    this.setAttribute("uv", new Float32BufferAttribute(uvs, 2));
    function calculatePositionOnCurve(u2, p3, q2, radius2, position) {
      const cu = Math.cos(u2);
      const su = Math.sin(u2);
      const quOverP = q2 / p3 * u2;
      const cs = Math.cos(quOverP);
      position.x = radius2 * (2 + cs) * 0.5 * cu;
      position.y = radius2 * (2 + cs) * su * 0.5;
      position.z = radius2 * Math.sin(quOverP) * 0.5;
    }
  }
  copy(source) {
    super.copy(source);
    this.parameters = Object.assign({}, source.parameters);
    return this;
  }
  static fromJSON(data) {
    return new _TorusKnotGeometry(data.radius, data.tube, data.tubularSegments, data.radialSegments, data.p, data.q);
  }
};
var TubeGeometry = class _TubeGeometry extends BufferGeometry {
  constructor(path = new QuadraticBezierCurve3(new Vector3(-1, -1, 0), new Vector3(-1, 1, 0), new Vector3(1, 1, 0)), tubularSegments = 64, radius = 1, radialSegments = 8, closed = false) {
    super();
    this.type = "TubeGeometry";
    this.parameters = {
      path,
      tubularSegments,
      radius,
      radialSegments,
      closed
    };
    const frames = path.computeFrenetFrames(tubularSegments, closed);
    this.tangents = frames.tangents;
    this.normals = frames.normals;
    this.binormals = frames.binormals;
    const vertex2 = new Vector3();
    const normal = new Vector3();
    const uv = new Vector2();
    let P = new Vector3();
    const vertices = [];
    const normals = [];
    const uvs = [];
    const indices = [];
    generateBufferData();
    this.setIndex(indices);
    this.setAttribute("position", new Float32BufferAttribute(vertices, 3));
    this.setAttribute("normal", new Float32BufferAttribute(normals, 3));
    this.setAttribute("uv", new Float32BufferAttribute(uvs, 2));
    function generateBufferData() {
      for (let i2 = 0; i2 < tubularSegments; i2++) {
        generateSegment(i2);
      }
      generateSegment(closed === false ? tubularSegments : 0);
      generateUVs();
      generateIndices();
    }
    function generateSegment(i2) {
      P = path.getPointAt(i2 / tubularSegments, P);
      const N = frames.normals[i2];
      const B2 = frames.binormals[i2];
      for (let j = 0; j <= radialSegments; j++) {
        const v2 = j / radialSegments * Math.PI * 2;
        const sin = Math.sin(v2);
        const cos = -Math.cos(v2);
        normal.x = cos * N.x + sin * B2.x;
        normal.y = cos * N.y + sin * B2.y;
        normal.z = cos * N.z + sin * B2.z;
        normal.normalize();
        normals.push(normal.x, normal.y, normal.z);
        vertex2.x = P.x + radius * normal.x;
        vertex2.y = P.y + radius * normal.y;
        vertex2.z = P.z + radius * normal.z;
        vertices.push(vertex2.x, vertex2.y, vertex2.z);
      }
    }
    function generateIndices() {
      for (let j = 1; j <= tubularSegments; j++) {
        for (let i2 = 1; i2 <= radialSegments; i2++) {
          const a2 = (radialSegments + 1) * (j - 1) + (i2 - 1);
          const b2 = (radialSegments + 1) * j + (i2 - 1);
          const c2 = (radialSegments + 1) * j + i2;
          const d2 = (radialSegments + 1) * (j - 1) + i2;
          indices.push(a2, b2, d2);
          indices.push(b2, c2, d2);
        }
      }
    }
    function generateUVs() {
      for (let i2 = 0; i2 <= tubularSegments; i2++) {
        for (let j = 0; j <= radialSegments; j++) {
          uv.x = i2 / tubularSegments;
          uv.y = j / radialSegments;
          uvs.push(uv.x, uv.y);
        }
      }
    }
  }
  copy(source) {
    super.copy(source);
    this.parameters = Object.assign({}, source.parameters);
    return this;
  }
  toJSON() {
    const data = super.toJSON();
    data.path = this.parameters.path.toJSON();
    return data;
  }
  static fromJSON(data) {
    return new _TubeGeometry(
      new Curves[data.path.type]().fromJSON(data.path),
      data.tubularSegments,
      data.radius,
      data.radialSegments,
      data.closed
    );
  }
};
var WireframeGeometry = class extends BufferGeometry {
  constructor(geometry = null) {
    super();
    this.type = "WireframeGeometry";
    this.parameters = {
      geometry
    };
    if (geometry !== null) {
      const vertices = [];
      const edges = /* @__PURE__ */ new Set();
      const start = new Vector3();
      const end = new Vector3();
      if (geometry.index !== null) {
        const position = geometry.attributes.position;
        const indices = geometry.index;
        let groups2 = geometry.groups;
        if (groups2.length === 0) {
          groups2 = [{ start: 0, count: indices.count, materialIndex: 0 }];
        }
        for (let o2 = 0, ol = groups2.length; o2 < ol; ++o2) {
          const group = groups2[o2];
          const groupStart = group.start;
          const groupCount = group.count;
          for (let i2 = groupStart, l2 = groupStart + groupCount; i2 < l2; i2 += 3) {
            for (let j = 0; j < 3; j++) {
              const index1 = indices.getX(i2 + j);
              const index2 = indices.getX(i2 + (j + 1) % 3);
              start.fromBufferAttribute(position, index1);
              end.fromBufferAttribute(position, index2);
              if (isUniqueEdge(start, end, edges) === true) {
                vertices.push(start.x, start.y, start.z);
                vertices.push(end.x, end.y, end.z);
              }
            }
          }
        }
      } else {
        const position = geometry.attributes.position;
        for (let i2 = 0, l2 = position.count / 3; i2 < l2; i2++) {
          for (let j = 0; j < 3; j++) {
            const index1 = 3 * i2 + j;
            const index2 = 3 * i2 + (j + 1) % 3;
            start.fromBufferAttribute(position, index1);
            end.fromBufferAttribute(position, index2);
            if (isUniqueEdge(start, end, edges) === true) {
              vertices.push(start.x, start.y, start.z);
              vertices.push(end.x, end.y, end.z);
            }
          }
        }
      }
      this.setAttribute("position", new Float32BufferAttribute(vertices, 3));
    }
  }
  copy(source) {
    super.copy(source);
    this.parameters = Object.assign({}, source.parameters);
    return this;
  }
};
function isUniqueEdge(start, end, edges) {
  const hash1 = `${start.x},${start.y},${start.z}-${end.x},${end.y},${end.z}`;
  const hash2 = `${end.x},${end.y},${end.z}-${start.x},${start.y},${start.z}`;
  if (edges.has(hash1) === true || edges.has(hash2) === true) {
    return false;
  } else {
    edges.add(hash1);
    edges.add(hash2);
    return true;
  }
}
var Geometries = Object.freeze({
  __proto__: null,
  BoxGeometry,
  CapsuleGeometry,
  CircleGeometry,
  ConeGeometry,
  CylinderGeometry,
  DodecahedronGeometry,
  EdgesGeometry,
  ExtrudeGeometry,
  IcosahedronGeometry,
  LatheGeometry,
  OctahedronGeometry,
  PlaneGeometry,
  PolyhedronGeometry,
  RingGeometry,
  ShapeGeometry,
  SphereGeometry,
  TetrahedronGeometry,
  TorusGeometry,
  TorusKnotGeometry,
  TubeGeometry,
  WireframeGeometry
});
var ShadowMaterial = class extends Material {
  constructor(parameters) {
    super();
    this.isShadowMaterial = true;
    this.type = "ShadowMaterial";
    this.color = new Color(0);
    this.transparent = true;
    this.fog = true;
    this.setValues(parameters);
  }
  copy(source) {
    super.copy(source);
    this.color.copy(source.color);
    this.fog = source.fog;
    return this;
  }
};
var RawShaderMaterial = class extends ShaderMaterial {
  constructor(parameters) {
    super(parameters);
    this.isRawShaderMaterial = true;
    this.type = "RawShaderMaterial";
  }
};
var MeshStandardMaterial = class extends Material {
  constructor(parameters) {
    super();
    this.isMeshStandardMaterial = true;
    this.defines = { "STANDARD": "" };
    this.type = "MeshStandardMaterial";
    this.color = new Color(16777215);
    this.roughness = 1;
    this.metalness = 0;
    this.map = null;
    this.lightMap = null;
    this.lightMapIntensity = 1;
    this.aoMap = null;
    this.aoMapIntensity = 1;
    this.emissive = new Color(0);
    this.emissiveIntensity = 1;
    this.emissiveMap = null;
    this.bumpMap = null;
    this.bumpScale = 1;
    this.normalMap = null;
    this.normalMapType = TangentSpaceNormalMap;
    this.normalScale = new Vector2(1, 1);
    this.displacementMap = null;
    this.displacementScale = 1;
    this.displacementBias = 0;
    this.roughnessMap = null;
    this.metalnessMap = null;
    this.alphaMap = null;
    this.envMap = null;
    this.envMapIntensity = 1;
    this.wireframe = false;
    this.wireframeLinewidth = 1;
    this.wireframeLinecap = "round";
    this.wireframeLinejoin = "round";
    this.flatShading = false;
    this.fog = true;
    this.setValues(parameters);
  }
  copy(source) {
    super.copy(source);
    this.defines = { "STANDARD": "" };
    this.color.copy(source.color);
    this.roughness = source.roughness;
    this.metalness = source.metalness;
    this.map = source.map;
    this.lightMap = source.lightMap;
    this.lightMapIntensity = source.lightMapIntensity;
    this.aoMap = source.aoMap;
    this.aoMapIntensity = source.aoMapIntensity;
    this.emissive.copy(source.emissive);
    this.emissiveMap = source.emissiveMap;
    this.emissiveIntensity = source.emissiveIntensity;
    this.bumpMap = source.bumpMap;
    this.bumpScale = source.bumpScale;
    this.normalMap = source.normalMap;
    this.normalMapType = source.normalMapType;
    this.normalScale.copy(source.normalScale);
    this.displacementMap = source.displacementMap;
    this.displacementScale = source.displacementScale;
    this.displacementBias = source.displacementBias;
    this.roughnessMap = source.roughnessMap;
    this.metalnessMap = source.metalnessMap;
    this.alphaMap = source.alphaMap;
    this.envMap = source.envMap;
    this.envMapIntensity = source.envMapIntensity;
    this.wireframe = source.wireframe;
    this.wireframeLinewidth = source.wireframeLinewidth;
    this.wireframeLinecap = source.wireframeLinecap;
    this.wireframeLinejoin = source.wireframeLinejoin;
    this.flatShading = source.flatShading;
    this.fog = source.fog;
    return this;
  }
};
var MeshPhysicalMaterial = class extends MeshStandardMaterial {
  constructor(parameters) {
    super();
    this.isMeshPhysicalMaterial = true;
    this.defines = {
      "STANDARD": "",
      "PHYSICAL": ""
    };
    this.type = "MeshPhysicalMaterial";
    this.anisotropyRotation = 0;
    this.anisotropyMap = null;
    this.clearcoatMap = null;
    this.clearcoatRoughness = 0;
    this.clearcoatRoughnessMap = null;
    this.clearcoatNormalScale = new Vector2(1, 1);
    this.clearcoatNormalMap = null;
    this.ior = 1.5;
    Object.defineProperty(this, "reflectivity", {
      get: function() {
        return clamp(2.5 * (this.ior - 1) / (this.ior + 1), 0, 1);
      },
      set: function(reflectivity) {
        this.ior = (1 + 0.4 * reflectivity) / (1 - 0.4 * reflectivity);
      }
    });
    this.iridescenceMap = null;
    this.iridescenceIOR = 1.3;
    this.iridescenceThicknessRange = [100, 400];
    this.iridescenceThicknessMap = null;
    this.sheenColor = new Color(0);
    this.sheenColorMap = null;
    this.sheenRoughness = 1;
    this.sheenRoughnessMap = null;
    this.transmissionMap = null;
    this.thickness = 0;
    this.thicknessMap = null;
    this.attenuationDistance = Infinity;
    this.attenuationColor = new Color(1, 1, 1);
    this.specularIntensity = 1;
    this.specularIntensityMap = null;
    this.specularColor = new Color(1, 1, 1);
    this.specularColorMap = null;
    this._anisotropy = 0;
    this._clearcoat = 0;
    this._iridescence = 0;
    this._sheen = 0;
    this._transmission = 0;
    this.setValues(parameters);
  }
  get anisotropy() {
    return this._anisotropy;
  }
  set anisotropy(value) {
    if (this._anisotropy > 0 !== value > 0) {
      this.version++;
    }
    this._anisotropy = value;
  }
  get clearcoat() {
    return this._clearcoat;
  }
  set clearcoat(value) {
    if (this._clearcoat > 0 !== value > 0) {
      this.version++;
    }
    this._clearcoat = value;
  }
  get iridescence() {
    return this._iridescence;
  }
  set iridescence(value) {
    if (this._iridescence > 0 !== value > 0) {
      this.version++;
    }
    this._iridescence = value;
  }
  get sheen() {
    return this._sheen;
  }
  set sheen(value) {
    if (this._sheen > 0 !== value > 0) {
      this.version++;
    }
    this._sheen = value;
  }
  get transmission() {
    return this._transmission;
  }
  set transmission(value) {
    if (this._transmission > 0 !== value > 0) {
      this.version++;
    }
    this._transmission = value;
  }
  copy(source) {
    super.copy(source);
    this.defines = {
      "STANDARD": "",
      "PHYSICAL": ""
    };
    this.anisotropy = source.anisotropy;
    this.anisotropyRotation = source.anisotropyRotation;
    this.anisotropyMap = source.anisotropyMap;
    this.clearcoat = source.clearcoat;
    this.clearcoatMap = source.clearcoatMap;
    this.clearcoatRoughness = source.clearcoatRoughness;
    this.clearcoatRoughnessMap = source.clearcoatRoughnessMap;
    this.clearcoatNormalMap = source.clearcoatNormalMap;
    this.clearcoatNormalScale.copy(source.clearcoatNormalScale);
    this.ior = source.ior;
    this.iridescence = source.iridescence;
    this.iridescenceMap = source.iridescenceMap;
    this.iridescenceIOR = source.iridescenceIOR;
    this.iridescenceThicknessRange = [...source.iridescenceThicknessRange];
    this.iridescenceThicknessMap = source.iridescenceThicknessMap;
    this.sheen = source.sheen;
    this.sheenColor.copy(source.sheenColor);
    this.sheenColorMap = source.sheenColorMap;
    this.sheenRoughness = source.sheenRoughness;
    this.sheenRoughnessMap = source.sheenRoughnessMap;
    this.transmission = source.transmission;
    this.transmissionMap = source.transmissionMap;
    this.thickness = source.thickness;
    this.thicknessMap = source.thicknessMap;
    this.attenuationDistance = source.attenuationDistance;
    this.attenuationColor.copy(source.attenuationColor);
    this.specularIntensity = source.specularIntensity;
    this.specularIntensityMap = source.specularIntensityMap;
    this.specularColor.copy(source.specularColor);
    this.specularColorMap = source.specularColorMap;
    return this;
  }
};
var MeshPhongMaterial = class extends Material {
  constructor(parameters) {
    super();
    this.isMeshPhongMaterial = true;
    this.type = "MeshPhongMaterial";
    this.color = new Color(16777215);
    this.specular = new Color(1118481);
    this.shininess = 30;
    this.map = null;
    this.lightMap = null;
    this.lightMapIntensity = 1;
    this.aoMap = null;
    this.aoMapIntensity = 1;
    this.emissive = new Color(0);
    this.emissiveIntensity = 1;
    this.emissiveMap = null;
    this.bumpMap = null;
    this.bumpScale = 1;
    this.normalMap = null;
    this.normalMapType = TangentSpaceNormalMap;
    this.normalScale = new Vector2(1, 1);
    this.displacementMap = null;
    this.displacementScale = 1;
    this.displacementBias = 0;
    this.specularMap = null;
    this.alphaMap = null;
    this.envMap = null;
    this.combine = MultiplyOperation;
    this.reflectivity = 1;
    this.refractionRatio = 0.98;
    this.wireframe = false;
    this.wireframeLinewidth = 1;
    this.wireframeLinecap = "round";
    this.wireframeLinejoin = "round";
    this.flatShading = false;
    this.fog = true;
    this.setValues(parameters);
  }
  copy(source) {
    super.copy(source);
    this.color.copy(source.color);
    this.specular.copy(source.specular);
    this.shininess = source.shininess;
    this.map = source.map;
    this.lightMap = source.lightMap;
    this.lightMapIntensity = source.lightMapIntensity;
    this.aoMap = source.aoMap;
    this.aoMapIntensity = source.aoMapIntensity;
    this.emissive.copy(source.emissive);
    this.emissiveMap = source.emissiveMap;
    this.emissiveIntensity = source.emissiveIntensity;
    this.bumpMap = source.bumpMap;
    this.bumpScale = source.bumpScale;
    this.normalMap = source.normalMap;
    this.normalMapType = source.normalMapType;
    this.normalScale.copy(source.normalScale);
    this.displacementMap = source.displacementMap;
    this.displacementScale = source.displacementScale;
    this.displacementBias = source.displacementBias;
    this.specularMap = source.specularMap;
    this.alphaMap = source.alphaMap;
    this.envMap = source.envMap;
    this.combine = source.combine;
    this.reflectivity = source.reflectivity;
    this.refractionRatio = source.refractionRatio;
    this.wireframe = source.wireframe;
    this.wireframeLinewidth = source.wireframeLinewidth;
    this.wireframeLinecap = source.wireframeLinecap;
    this.wireframeLinejoin = source.wireframeLinejoin;
    this.flatShading = source.flatShading;
    this.fog = source.fog;
    return this;
  }
};
var MeshToonMaterial = class extends Material {
  constructor(parameters) {
    super();
    this.isMeshToonMaterial = true;
    this.defines = { "TOON": "" };
    this.type = "MeshToonMaterial";
    this.color = new Color(16777215);
    this.map = null;
    this.gradientMap = null;
    this.lightMap = null;
    this.lightMapIntensity = 1;
    this.aoMap = null;
    this.aoMapIntensity = 1;
    this.emissive = new Color(0);
    this.emissiveIntensity = 1;
    this.emissiveMap = null;
    this.bumpMap = null;
    this.bumpScale = 1;
    this.normalMap = null;
    this.normalMapType = TangentSpaceNormalMap;
    this.normalScale = new Vector2(1, 1);
    this.displacementMap = null;
    this.displacementScale = 1;
    this.displacementBias = 0;
    this.alphaMap = null;
    this.wireframe = false;
    this.wireframeLinewidth = 1;
    this.wireframeLinecap = "round";
    this.wireframeLinejoin = "round";
    this.fog = true;
    this.setValues(parameters);
  }
  copy(source) {
    super.copy(source);
    this.color.copy(source.color);
    this.map = source.map;
    this.gradientMap = source.gradientMap;
    this.lightMap = source.lightMap;
    this.lightMapIntensity = source.lightMapIntensity;
    this.aoMap = source.aoMap;
    this.aoMapIntensity = source.aoMapIntensity;
    this.emissive.copy(source.emissive);
    this.emissiveMap = source.emissiveMap;
    this.emissiveIntensity = source.emissiveIntensity;
    this.bumpMap = source.bumpMap;
    this.bumpScale = source.bumpScale;
    this.normalMap = source.normalMap;
    this.normalMapType = source.normalMapType;
    this.normalScale.copy(source.normalScale);
    this.displacementMap = source.displacementMap;
    this.displacementScale = source.displacementScale;
    this.displacementBias = source.displacementBias;
    this.alphaMap = source.alphaMap;
    this.wireframe = source.wireframe;
    this.wireframeLinewidth = source.wireframeLinewidth;
    this.wireframeLinecap = source.wireframeLinecap;
    this.wireframeLinejoin = source.wireframeLinejoin;
    this.fog = source.fog;
    return this;
  }
};
var MeshNormalMaterial = class extends Material {
  constructor(parameters) {
    super();
    this.isMeshNormalMaterial = true;
    this.type = "MeshNormalMaterial";
    this.bumpMap = null;
    this.bumpScale = 1;
    this.normalMap = null;
    this.normalMapType = TangentSpaceNormalMap;
    this.normalScale = new Vector2(1, 1);
    this.displacementMap = null;
    this.displacementScale = 1;
    this.displacementBias = 0;
    this.wireframe = false;
    this.wireframeLinewidth = 1;
    this.flatShading = false;
    this.setValues(parameters);
  }
  copy(source) {
    super.copy(source);
    this.bumpMap = source.bumpMap;
    this.bumpScale = source.bumpScale;
    this.normalMap = source.normalMap;
    this.normalMapType = source.normalMapType;
    this.normalScale.copy(source.normalScale);
    this.displacementMap = source.displacementMap;
    this.displacementScale = source.displacementScale;
    this.displacementBias = source.displacementBias;
    this.wireframe = source.wireframe;
    this.wireframeLinewidth = source.wireframeLinewidth;
    this.flatShading = source.flatShading;
    return this;
  }
};
var MeshLambertMaterial = class extends Material {
  constructor(parameters) {
    super();
    this.isMeshLambertMaterial = true;
    this.type = "MeshLambertMaterial";
    this.color = new Color(16777215);
    this.map = null;
    this.lightMap = null;
    this.lightMapIntensity = 1;
    this.aoMap = null;
    this.aoMapIntensity = 1;
    this.emissive = new Color(0);
    this.emissiveIntensity = 1;
    this.emissiveMap = null;
    this.bumpMap = null;
    this.bumpScale = 1;
    this.normalMap = null;
    this.normalMapType = TangentSpaceNormalMap;
    this.normalScale = new Vector2(1, 1);
    this.displacementMap = null;
    this.displacementScale = 1;
    this.displacementBias = 0;
    this.specularMap = null;
    this.alphaMap = null;
    this.envMap = null;
    this.combine = MultiplyOperation;
    this.reflectivity = 1;
    this.refractionRatio = 0.98;
    this.wireframe = false;
    this.wireframeLinewidth = 1;
    this.wireframeLinecap = "round";
    this.wireframeLinejoin = "round";
    this.flatShading = false;
    this.fog = true;
    this.setValues(parameters);
  }
  copy(source) {
    super.copy(source);
    this.color.copy(source.color);
    this.map = source.map;
    this.lightMap = source.lightMap;
    this.lightMapIntensity = source.lightMapIntensity;
    this.aoMap = source.aoMap;
    this.aoMapIntensity = source.aoMapIntensity;
    this.emissive.copy(source.emissive);
    this.emissiveMap = source.emissiveMap;
    this.emissiveIntensity = source.emissiveIntensity;
    this.bumpMap = source.bumpMap;
    this.bumpScale = source.bumpScale;
    this.normalMap = source.normalMap;
    this.normalMapType = source.normalMapType;
    this.normalScale.copy(source.normalScale);
    this.displacementMap = source.displacementMap;
    this.displacementScale = source.displacementScale;
    this.displacementBias = source.displacementBias;
    this.specularMap = source.specularMap;
    this.alphaMap = source.alphaMap;
    this.envMap = source.envMap;
    this.combine = source.combine;
    this.reflectivity = source.reflectivity;
    this.refractionRatio = source.refractionRatio;
    this.wireframe = source.wireframe;
    this.wireframeLinewidth = source.wireframeLinewidth;
    this.wireframeLinecap = source.wireframeLinecap;
    this.wireframeLinejoin = source.wireframeLinejoin;
    this.flatShading = source.flatShading;
    this.fog = source.fog;
    return this;
  }
};
var MeshMatcapMaterial = class extends Material {
  constructor(parameters) {
    super();
    this.isMeshMatcapMaterial = true;
    this.defines = { "MATCAP": "" };
    this.type = "MeshMatcapMaterial";
    this.color = new Color(16777215);
    this.matcap = null;
    this.map = null;
    this.bumpMap = null;
    this.bumpScale = 1;
    this.normalMap = null;
    this.normalMapType = TangentSpaceNormalMap;
    this.normalScale = new Vector2(1, 1);
    this.displacementMap = null;
    this.displacementScale = 1;
    this.displacementBias = 0;
    this.alphaMap = null;
    this.flatShading = false;
    this.fog = true;
    this.setValues(parameters);
  }
  copy(source) {
    super.copy(source);
    this.defines = { "MATCAP": "" };
    this.color.copy(source.color);
    this.matcap = source.matcap;
    this.map = source.map;
    this.bumpMap = source.bumpMap;
    this.bumpScale = source.bumpScale;
    this.normalMap = source.normalMap;
    this.normalMapType = source.normalMapType;
    this.normalScale.copy(source.normalScale);
    this.displacementMap = source.displacementMap;
    this.displacementScale = source.displacementScale;
    this.displacementBias = source.displacementBias;
    this.alphaMap = source.alphaMap;
    this.flatShading = source.flatShading;
    this.fog = source.fog;
    return this;
  }
};
var LineDashedMaterial = class extends LineBasicMaterial {
  constructor(parameters) {
    super();
    this.isLineDashedMaterial = true;
    this.type = "LineDashedMaterial";
    this.scale = 1;
    this.dashSize = 3;
    this.gapSize = 1;
    this.setValues(parameters);
  }
  copy(source) {
    super.copy(source);
    this.scale = source.scale;
    this.dashSize = source.dashSize;
    this.gapSize = source.gapSize;
    return this;
  }
};
function arraySlice(array, from, to) {
  if (isTypedArray(array)) {
    return new array.constructor(array.subarray(from, to !== void 0 ? to : array.length));
  }
  return array.slice(from, to);
}
function convertArray(array, type, forceClone) {
  if (!array || // let 'undefined' and 'null' pass
  !forceClone && array.constructor === type) return array;
  if (typeof type.BYTES_PER_ELEMENT === "number") {
    return new type(array);
  }
  return Array.prototype.slice.call(array);
}
function isTypedArray(object) {
  return ArrayBuffer.isView(object) && !(object instanceof DataView);
}
function getKeyframeOrder(times) {
  function compareTime(i2, j) {
    return times[i2] - times[j];
  }
  const n = times.length;
  const result = new Array(n);
  for (let i2 = 0; i2 !== n; ++i2) result[i2] = i2;
  result.sort(compareTime);
  return result;
}
function sortedArray(values, stride, order) {
  const nValues = values.length;
  const result = new values.constructor(nValues);
  for (let i2 = 0, dstOffset = 0; dstOffset !== nValues; ++i2) {
    const srcOffset = order[i2] * stride;
    for (let j = 0; j !== stride; ++j) {
      result[dstOffset++] = values[srcOffset + j];
    }
  }
  return result;
}
function flattenJSON(jsonKeys, times, values, valuePropertyName) {
  let i2 = 1, key = jsonKeys[0];
  while (key !== void 0 && key[valuePropertyName] === void 0) {
    key = jsonKeys[i2++];
  }
  if (key === void 0) return;
  let value = key[valuePropertyName];
  if (value === void 0) return;
  if (Array.isArray(value)) {
    do {
      value = key[valuePropertyName];
      if (value !== void 0) {
        times.push(key.time);
        values.push.apply(values, value);
      }
      key = jsonKeys[i2++];
    } while (key !== void 0);
  } else if (value.toArray !== void 0) {
    do {
      value = key[valuePropertyName];
      if (value !== void 0) {
        times.push(key.time);
        value.toArray(values, values.length);
      }
      key = jsonKeys[i2++];
    } while (key !== void 0);
  } else {
    do {
      value = key[valuePropertyName];
      if (value !== void 0) {
        times.push(key.time);
        values.push(value);
      }
      key = jsonKeys[i2++];
    } while (key !== void 0);
  }
}
function subclip(sourceClip, name, startFrame, endFrame, fps = 30) {
  const clip = sourceClip.clone();
  clip.name = name;
  const tracks = [];
  for (let i2 = 0; i2 < clip.tracks.length; ++i2) {
    const track = clip.tracks[i2];
    const valueSize = track.getValueSize();
    const times = [];
    const values = [];
    for (let j = 0; j < track.times.length; ++j) {
      const frame = track.times[j] * fps;
      if (frame < startFrame || frame >= endFrame) continue;
      times.push(track.times[j]);
      for (let k2 = 0; k2 < valueSize; ++k2) {
        values.push(track.values[j * valueSize + k2]);
      }
    }
    if (times.length === 0) continue;
    track.times = convertArray(times, track.times.constructor);
    track.values = convertArray(values, track.values.constructor);
    tracks.push(track);
  }
  clip.tracks = tracks;
  let minStartTime = Infinity;
  for (let i2 = 0; i2 < clip.tracks.length; ++i2) {
    if (minStartTime > clip.tracks[i2].times[0]) {
      minStartTime = clip.tracks[i2].times[0];
    }
  }
  for (let i2 = 0; i2 < clip.tracks.length; ++i2) {
    clip.tracks[i2].shift(-1 * minStartTime);
  }
  clip.resetDuration();
  return clip;
}
function makeClipAdditive(targetClip, referenceFrame = 0, referenceClip = targetClip, fps = 30) {
  if (fps <= 0) fps = 30;
  const numTracks = referenceClip.tracks.length;
  const referenceTime = referenceFrame / fps;
  for (let i2 = 0; i2 < numTracks; ++i2) {
    const referenceTrack = referenceClip.tracks[i2];
    const referenceTrackType = referenceTrack.ValueTypeName;
    if (referenceTrackType === "bool" || referenceTrackType === "string") continue;
    const targetTrack = targetClip.tracks.find(function(track) {
      return track.name === referenceTrack.name && track.ValueTypeName === referenceTrackType;
    });
    if (targetTrack === void 0) continue;
    let referenceOffset = 0;
    const referenceValueSize = referenceTrack.getValueSize();
    if (referenceTrack.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline) {
      referenceOffset = referenceValueSize / 3;
    }
    let targetOffset = 0;
    const targetValueSize = targetTrack.getValueSize();
    if (targetTrack.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline) {
      targetOffset = targetValueSize / 3;
    }
    const lastIndex = referenceTrack.times.length - 1;
    let referenceValue;
    if (referenceTime <= referenceTrack.times[0]) {
      const startIndex = referenceOffset;
      const endIndex = referenceValueSize - referenceOffset;
      referenceValue = arraySlice(referenceTrack.values, startIndex, endIndex);
    } else if (referenceTime >= referenceTrack.times[lastIndex]) {
      const startIndex = lastIndex * referenceValueSize + referenceOffset;
      const endIndex = startIndex + referenceValueSize - referenceOffset;
      referenceValue = arraySlice(referenceTrack.values, startIndex, endIndex);
    } else {
      const interpolant = referenceTrack.createInterpolant();
      const startIndex = referenceOffset;
      const endIndex = referenceValueSize - referenceOffset;
      interpolant.evaluate(referenceTime);
      referenceValue = arraySlice(interpolant.resultBuffer, startIndex, endIndex);
    }
    if (referenceTrackType === "quaternion") {
      const referenceQuat = new Quaternion().fromArray(referenceValue).normalize().conjugate();
      referenceQuat.toArray(referenceValue);
    }
    const numTimes = targetTrack.times.length;
    for (let j = 0; j < numTimes; ++j) {
      const valueStart = j * targetValueSize + targetOffset;
      if (referenceTrackType === "quaternion") {
        Quaternion.multiplyQuaternionsFlat(
          targetTrack.values,
          valueStart,
          referenceValue,
          0,
          targetTrack.values,
          valueStart
        );
      } else {
        const valueEnd = targetValueSize - targetOffset * 2;
        for (let k2 = 0; k2 < valueEnd; ++k2) {
          targetTrack.values[valueStart + k2] -= referenceValue[k2];
        }
      }
    }
  }
  targetClip.blendMode = AdditiveAnimationBlendMode;
  return targetClip;
}
var AnimationUtils = {
  arraySlice,
  convertArray,
  isTypedArray,
  getKeyframeOrder,
  sortedArray,
  flattenJSON,
  subclip,
  makeClipAdditive
};
var Interpolant = class {
  constructor(parameterPositions, sampleValues, sampleSize, resultBuffer) {
    this.parameterPositions = parameterPositions;
    this._cachedIndex = 0;
    this.resultBuffer = resultBuffer !== void 0 ? resultBuffer : new sampleValues.constructor(sampleSize);
    this.sampleValues = sampleValues;
    this.valueSize = sampleSize;
    this.settings = null;
    this.DefaultSettings_ = {};
  }
  evaluate(t2) {
    const pp = this.parameterPositions;
    let i1 = this._cachedIndex, t1 = pp[i1], t0 = pp[i1 - 1];
    validate_interval: {
      seek: {
        let right;
        linear_scan: {
          forward_scan: if (!(t2 < t1)) {
            for (let giveUpAt = i1 + 2; ; ) {
              if (t1 === void 0) {
                if (t2 < t0) break forward_scan;
                i1 = pp.length;
                this._cachedIndex = i1;
                return this.copySampleValue_(i1 - 1);
              }
              if (i1 === giveUpAt) break;
              t0 = t1;
              t1 = pp[++i1];
              if (t2 < t1) {
                break seek;
              }
            }
            right = pp.length;
            break linear_scan;
          }
          if (!(t2 >= t0)) {
            const t1global = pp[1];
            if (t2 < t1global) {
              i1 = 2;
              t0 = t1global;
            }
            for (let giveUpAt = i1 - 2; ; ) {
              if (t0 === void 0) {
                this._cachedIndex = 0;
                return this.copySampleValue_(0);
              }
              if (i1 === giveUpAt) break;
              t1 = t0;
              t0 = pp[--i1 - 1];
              if (t2 >= t0) {
                break seek;
              }
            }
            right = i1;
            i1 = 0;
            break linear_scan;
          }
          break validate_interval;
        }
        while (i1 < right) {
          const mid = i1 + right >>> 1;
          if (t2 < pp[mid]) {
            right = mid;
          } else {
            i1 = mid + 1;
          }
        }
        t1 = pp[i1];
        t0 = pp[i1 - 1];
        if (t0 === void 0) {
          this._cachedIndex = 0;
          return this.copySampleValue_(0);
        }
        if (t1 === void 0) {
          i1 = pp.length;
          this._cachedIndex = i1;
          return this.copySampleValue_(i1 - 1);
        }
      }
      this._cachedIndex = i1;
      this.intervalChanged_(i1, t0, t1);
    }
    return this.interpolate_(i1, t0, t2, t1);
  }
  getSettings_() {
    return this.settings || this.DefaultSettings_;
  }
  copySampleValue_(index) {
    const result = this.resultBuffer, values = this.sampleValues, stride = this.valueSize, offset = index * stride;
    for (let i2 = 0; i2 !== stride; ++i2) {
      result[i2] = values[offset + i2];
    }
    return result;
  }
  // Template methods for derived classes:
  interpolate_() {
    throw new Error("call to abstract method");
  }
  intervalChanged_() {
  }
};
var CubicInterpolant = class extends Interpolant {
  constructor(parameterPositions, sampleValues, sampleSize, resultBuffer) {
    super(parameterPositions, sampleValues, sampleSize, resultBuffer);
    this._weightPrev = -0;
    this._offsetPrev = -0;
    this._weightNext = -0;
    this._offsetNext = -0;
    this.DefaultSettings_ = {
      endingStart: ZeroCurvatureEnding,
      endingEnd: ZeroCurvatureEnding
    };
  }
  intervalChanged_(i1, t0, t1) {
    const pp = this.parameterPositions;
    let iPrev = i1 - 2, iNext = i1 + 1, tPrev = pp[iPrev], tNext = pp[iNext];
    if (tPrev === void 0) {
      switch (this.getSettings_().endingStart) {
        case ZeroSlopeEnding:
          iPrev = i1;
          tPrev = 2 * t0 - t1;
          break;
        case WrapAroundEnding:
          iPrev = pp.length - 2;
          tPrev = t0 + pp[iPrev] - pp[iPrev + 1];
          break;
        default:
          iPrev = i1;
          tPrev = t1;
      }
    }
    if (tNext === void 0) {
      switch (this.getSettings_().endingEnd) {
        case ZeroSlopeEnding:
          iNext = i1;
          tNext = 2 * t1 - t0;
          break;
        case WrapAroundEnding:
          iNext = 1;
          tNext = t1 + pp[1] - pp[0];
          break;
        default:
          iNext = i1 - 1;
          tNext = t0;
      }
    }
    const halfDt = (t1 - t0) * 0.5, stride = this.valueSize;
    this._weightPrev = halfDt / (t0 - tPrev);
    this._weightNext = halfDt / (tNext - t1);
    this._offsetPrev = iPrev * stride;
    this._offsetNext = iNext * stride;
  }
  interpolate_(i1, t0, t2, t1) {
    const result = this.resultBuffer, values = this.sampleValues, stride = this.valueSize, o1 = i1 * stride, o0 = o1 - stride, oP = this._offsetPrev, oN = this._offsetNext, wP = this._weightPrev, wN = this._weightNext, p2 = (t2 - t0) / (t1 - t0), pp = p2 * p2, ppp = pp * p2;
    const sP = -wP * ppp + 2 * wP * pp - wP * p2;
    const s0 = (1 + wP) * ppp + (-1.5 - 2 * wP) * pp + (-0.5 + wP) * p2 + 1;
    const s1 = (-1 - wN) * ppp + (1.5 + wN) * pp + 0.5 * p2;
    const sN = wN * ppp - wN * pp;
    for (let i2 = 0; i2 !== stride; ++i2) {
      result[i2] = sP * values[oP + i2] + s0 * values[o0 + i2] + s1 * values[o1 + i2] + sN * values[oN + i2];
    }
    return result;
  }
};
var LinearInterpolant = class extends Interpolant {
  constructor(parameterPositions, sampleValues, sampleSize, resultBuffer) {
    super(parameterPositions, sampleValues, sampleSize, resultBuffer);
  }
  interpolate_(i1, t0, t2, t1) {
    const result = this.resultBuffer, values = this.sampleValues, stride = this.valueSize, offset1 = i1 * stride, offset0 = offset1 - stride, weight1 = (t2 - t0) / (t1 - t0), weight0 = 1 - weight1;
    for (let i2 = 0; i2 !== stride; ++i2) {
      result[i2] = values[offset0 + i2] * weight0 + values[offset1 + i2] * weight1;
    }
    return result;
  }
};
var DiscreteInterpolant = class extends Interpolant {
  constructor(parameterPositions, sampleValues, sampleSize, resultBuffer) {
    super(parameterPositions, sampleValues, sampleSize, resultBuffer);
  }
  interpolate_(i1) {
    return this.copySampleValue_(i1 - 1);
  }
};
var KeyframeTrack = class {
  constructor(name, times, values, interpolation) {
    if (name === void 0) throw new Error("THREE.KeyframeTrack: track name is undefined");
    if (times === void 0 || times.length === 0) throw new Error("THREE.KeyframeTrack: no keyframes in track named " + name);
    this.name = name;
    this.times = convertArray(times, this.TimeBufferType);
    this.values = convertArray(values, this.ValueBufferType);
    this.setInterpolation(interpolation || this.DefaultInterpolation);
  }
  // Serialization (in static context, because of constructor invocation
  // and automatic invocation of .toJSON):
  static toJSON(track) {
    const trackType = track.constructor;
    let json;
    if (trackType.toJSON !== this.toJSON) {
      json = trackType.toJSON(track);
    } else {
      json = {
        "name": track.name,
        "times": convertArray(track.times, Array),
        "values": convertArray(track.values, Array)
      };
      const interpolation = track.getInterpolation();
      if (interpolation !== track.DefaultInterpolation) {
        json.interpolation = interpolation;
      }
    }
    json.type = track.ValueTypeName;
    return json;
  }
  InterpolantFactoryMethodDiscrete(result) {
    return new DiscreteInterpolant(this.times, this.values, this.getValueSize(), result);
  }
  InterpolantFactoryMethodLinear(result) {
    return new LinearInterpolant(this.times, this.values, this.getValueSize(), result);
  }
  InterpolantFactoryMethodSmooth(result) {
    return new CubicInterpolant(this.times, this.values, this.getValueSize(), result);
  }
  setInterpolation(interpolation) {
    let factoryMethod;
    switch (interpolation) {
      case InterpolateDiscrete:
        factoryMethod = this.InterpolantFactoryMethodDiscrete;
        break;
      case InterpolateLinear:
        factoryMethod = this.InterpolantFactoryMethodLinear;
        break;
      case InterpolateSmooth:
        factoryMethod = this.InterpolantFactoryMethodSmooth;
        break;
    }
    if (factoryMethod === void 0) {
      const message = "unsupported interpolation for " + this.ValueTypeName + " keyframe track named " + this.name;
      if (this.createInterpolant === void 0) {
        if (interpolation !== this.DefaultInterpolation) {
          this.setInterpolation(this.DefaultInterpolation);
        } else {
          throw new Error(message);
        }
      }
      console.warn("THREE.KeyframeTrack:", message);
      return this;
    }
    this.createInterpolant = factoryMethod;
    return this;
  }
  getInterpolation() {
    switch (this.createInterpolant) {
      case this.InterpolantFactoryMethodDiscrete:
        return InterpolateDiscrete;
      case this.InterpolantFactoryMethodLinear:
        return InterpolateLinear;
      case this.InterpolantFactoryMethodSmooth:
        return InterpolateSmooth;
    }
  }
  getValueSize() {
    return this.values.length / this.times.length;
  }
  // move all keyframes either forwards or backwards in time
  shift(timeOffset) {
    if (timeOffset !== 0) {
      const times = this.times;
      for (let i2 = 0, n = times.length; i2 !== n; ++i2) {
        times[i2] += timeOffset;
      }
    }
    return this;
  }
  // scale all keyframe times by a factor (useful for frame <-> seconds conversions)
  scale(timeScale) {
    if (timeScale !== 1) {
      const times = this.times;
      for (let i2 = 0, n = times.length; i2 !== n; ++i2) {
        times[i2] *= timeScale;
      }
    }
    return this;
  }
  // removes keyframes before and after animation without changing any values within the range [startTime, endTime].
  // IMPORTANT: We do not shift around keys to the start of the track time, because for interpolated keys this will change their values
  trim(startTime, endTime) {
    const times = this.times, nKeys = times.length;
    let from = 0, to = nKeys - 1;
    while (from !== nKeys && times[from] < startTime) {
      ++from;
    }
    while (to !== -1 && times[to] > endTime) {
      --to;
    }
    ++to;
    if (from !== 0 || to !== nKeys) {
      if (from >= to) {
        to = Math.max(to, 1);
        from = to - 1;
      }
      const stride = this.getValueSize();
      this.times = arraySlice(times, from, to);
      this.values = arraySlice(this.values, from * stride, to * stride);
    }
    return this;
  }
  // ensure we do not get a GarbageInGarbageOut situation, make sure tracks are at least minimally viable
  validate() {
    let valid = true;
    const valueSize = this.getValueSize();
    if (valueSize - Math.floor(valueSize) !== 0) {
      console.error("THREE.KeyframeTrack: Invalid value size in track.", this);
      valid = false;
    }
    const times = this.times, values = this.values, nKeys = times.length;
    if (nKeys === 0) {
      console.error("THREE.KeyframeTrack: Track is empty.", this);
      valid = false;
    }
    let prevTime = null;
    for (let i2 = 0; i2 !== nKeys; i2++) {
      const currTime = times[i2];
      if (typeof currTime === "number" && isNaN(currTime)) {
        console.error("THREE.KeyframeTrack: Time is not a valid number.", this, i2, currTime);
        valid = false;
        break;
      }
      if (prevTime !== null && prevTime > currTime) {
        console.error("THREE.KeyframeTrack: Out of order keys.", this, i2, currTime, prevTime);
        valid = false;
        break;
      }
      prevTime = currTime;
    }
    if (values !== void 0) {
      if (isTypedArray(values)) {
        for (let i2 = 0, n = values.length; i2 !== n; ++i2) {
          const value = values[i2];
          if (isNaN(value)) {
            console.error("THREE.KeyframeTrack: Value is not a valid number.", this, i2, value);
            valid = false;
            break;
          }
        }
      }
    }
    return valid;
  }
  // removes equivalent sequential keys as common in morph target sequences
  // (0,0,0,0,1,1,1,0,0,0,0,0,0,0) --> (0,0,1,1,0,0)
  optimize() {
    const times = arraySlice(this.times), values = arraySlice(this.values), stride = this.getValueSize(), smoothInterpolation = this.getInterpolation() === InterpolateSmooth, lastIndex = times.length - 1;
    let writeIndex = 1;
    for (let i2 = 1; i2 < lastIndex; ++i2) {
      let keep = false;
      const time = times[i2];
      const timeNext = times[i2 + 1];
      if (time !== timeNext && (i2 !== 1 || time !== times[0])) {
        if (!smoothInterpolation) {
          const offset = i2 * stride, offsetP = offset - stride, offsetN = offset + stride;
          for (let j = 0; j !== stride; ++j) {
            const value = values[offset + j];
            if (value !== values[offsetP + j] || value !== values[offsetN + j]) {
              keep = true;
              break;
            }
          }
        } else {
          keep = true;
        }
      }
      if (keep) {
        if (i2 !== writeIndex) {
          times[writeIndex] = times[i2];
          const readOffset = i2 * stride, writeOffset = writeIndex * stride;
          for (let j = 0; j !== stride; ++j) {
            values[writeOffset + j] = values[readOffset + j];
          }
        }
        ++writeIndex;
      }
    }
    if (lastIndex > 0) {
      times[writeIndex] = times[lastIndex];
      for (let readOffset = lastIndex * stride, writeOffset = writeIndex * stride, j = 0; j !== stride; ++j) {
        values[writeOffset + j] = values[readOffset + j];
      }
      ++writeIndex;
    }
    if (writeIndex !== times.length) {
      this.times = arraySlice(times, 0, writeIndex);
      this.values = arraySlice(values, 0, writeIndex * stride);
    } else {
      this.times = times;
      this.values = values;
    }
    return this;
  }
  clone() {
    const times = arraySlice(this.times, 0);
    const values = arraySlice(this.values, 0);
    const TypedKeyframeTrack = this.constructor;
    const track = new TypedKeyframeTrack(this.name, times, values);
    track.createInterpolant = this.createInterpolant;
    return track;
  }
};
KeyframeTrack.prototype.TimeBufferType = Float32Array;
KeyframeTrack.prototype.ValueBufferType = Float32Array;
KeyframeTrack.prototype.DefaultInterpolation = InterpolateLinear;
var BooleanKeyframeTrack = class extends KeyframeTrack {
};
BooleanKeyframeTrack.prototype.ValueTypeName = "bool";
BooleanKeyframeTrack.prototype.ValueBufferType = Array;
BooleanKeyframeTrack.prototype.DefaultInterpolation = InterpolateDiscrete;
BooleanKeyframeTrack.prototype.InterpolantFactoryMethodLinear = void 0;
BooleanKeyframeTrack.prototype.InterpolantFactoryMethodSmooth = void 0;
var ColorKeyframeTrack = class extends KeyframeTrack {
};
ColorKeyframeTrack.prototype.ValueTypeName = "color";
var NumberKeyframeTrack = class extends KeyframeTrack {
};
NumberKeyframeTrack.prototype.ValueTypeName = "number";
var QuaternionLinearInterpolant = class extends Interpolant {
  constructor(parameterPositions, sampleValues, sampleSize, resultBuffer) {
    super(parameterPositions, sampleValues, sampleSize, resultBuffer);
  }
  interpolate_(i1, t0, t2, t1) {
    const result = this.resultBuffer, values = this.sampleValues, stride = this.valueSize, alpha = (t2 - t0) / (t1 - t0);
    let offset = i1 * stride;
    for (let end = offset + stride; offset !== end; offset += 4) {
      Quaternion.slerpFlat(result, 0, values, offset - stride, values, offset, alpha);
    }
    return result;
  }
};
var QuaternionKeyframeTrack = class extends KeyframeTrack {
  InterpolantFactoryMethodLinear(result) {
    return new QuaternionLinearInterpolant(this.times, this.values, this.getValueSize(), result);
  }
};
QuaternionKeyframeTrack.prototype.ValueTypeName = "quaternion";
QuaternionKeyframeTrack.prototype.DefaultInterpolation = InterpolateLinear;
QuaternionKeyframeTrack.prototype.InterpolantFactoryMethodSmooth = void 0;
var StringKeyframeTrack = class extends KeyframeTrack {
};
StringKeyframeTrack.prototype.ValueTypeName = "string";
StringKeyframeTrack.prototype.ValueBufferType = Array;
StringKeyframeTrack.prototype.DefaultInterpolation = InterpolateDiscrete;
StringKeyframeTrack.prototype.InterpolantFactoryMethodLinear = void 0;
StringKeyframeTrack.prototype.InterpolantFactoryMethodSmooth = void 0;
var VectorKeyframeTrack = class extends KeyframeTrack {
};
VectorKeyframeTrack.prototype.ValueTypeName = "vector";
var AnimationClip = class {
  constructor(name, duration = -1, tracks, blendMode = NormalAnimationBlendMode) {
    this.name = name;
    this.tracks = tracks;
    this.duration = duration;
    this.blendMode = blendMode;
    this.uuid = generateUUID();
    if (this.duration < 0) {
      this.resetDuration();
    }
  }
  static parse(json) {
    const tracks = [], jsonTracks = json.tracks, frameTime = 1 / (json.fps || 1);
    for (let i2 = 0, n = jsonTracks.length; i2 !== n; ++i2) {
      tracks.push(parseKeyframeTrack(jsonTracks[i2]).scale(frameTime));
    }
    const clip = new this(json.name, json.duration, tracks, json.blendMode);
    clip.uuid = json.uuid;
    return clip;
  }
  static toJSON(clip) {
    const tracks = [], clipTracks = clip.tracks;
    const json = {
      "name": clip.name,
      "duration": clip.duration,
      "tracks": tracks,
      "uuid": clip.uuid,
      "blendMode": clip.blendMode
    };
    for (let i2 = 0, n = clipTracks.length; i2 !== n; ++i2) {
      tracks.push(KeyframeTrack.toJSON(clipTracks[i2]));
    }
    return json;
  }
  static CreateFromMorphTargetSequence(name, morphTargetSequence, fps, noLoop) {
    const numMorphTargets = morphTargetSequence.length;
    const tracks = [];
    for (let i2 = 0; i2 < numMorphTargets; i2++) {
      let times = [];
      let values = [];
      times.push(
        (i2 + numMorphTargets - 1) % numMorphTargets,
        i2,
        (i2 + 1) % numMorphTargets
      );
      values.push(0, 1, 0);
      const order = getKeyframeOrder(times);
      times = sortedArray(times, 1, order);
      values = sortedArray(values, 1, order);
      if (!noLoop && times[0] === 0) {
        times.push(numMorphTargets);
        values.push(values[0]);
      }
      tracks.push(
        new NumberKeyframeTrack(
          ".morphTargetInfluences[" + morphTargetSequence[i2].name + "]",
          times,
          values
        ).scale(1 / fps)
      );
    }
    return new this(name, -1, tracks);
  }
  static findByName(objectOrClipArray, name) {
    let clipArray = objectOrClipArray;
    if (!Array.isArray(objectOrClipArray)) {
      const o2 = objectOrClipArray;
      clipArray = o2.geometry && o2.geometry.animations || o2.animations;
    }
    for (let i2 = 0; i2 < clipArray.length; i2++) {
      if (clipArray[i2].name === name) {
        return clipArray[i2];
      }
    }
    return null;
  }
  static CreateClipsFromMorphTargetSequences(morphTargets, fps, noLoop) {
    const animationToMorphTargets = {};
    const pattern = /^([\w-]*?)([\d]+)$/;
    for (let i2 = 0, il = morphTargets.length; i2 < il; i2++) {
      const morphTarget = morphTargets[i2];
      const parts = morphTarget.name.match(pattern);
      if (parts && parts.length > 1) {
        const name = parts[1];
        let animationMorphTargets = animationToMorphTargets[name];
        if (!animationMorphTargets) {
          animationToMorphTargets[name] = animationMorphTargets = [];
        }
        animationMorphTargets.push(morphTarget);
      }
    }
    const clips = [];
    for (const name in animationToMorphTargets) {
      clips.push(this.CreateFromMorphTargetSequence(name, animationToMorphTargets[name], fps, noLoop));
    }
    return clips;
  }
  // parse the animation.hierarchy format
  static parseAnimation(animation, bones) {
    if (!animation) {
      console.error("THREE.AnimationClip: No animation in JSONLoader data.");
      return null;
    }
    const addNonemptyTrack = function(trackType, trackName, animationKeys, propertyName, destTracks) {
      if (animationKeys.length !== 0) {
        const times = [];
        const values = [];
        flattenJSON(animationKeys, times, values, propertyName);
        if (times.length !== 0) {
          destTracks.push(new trackType(trackName, times, values));
        }
      }
    };
    const tracks = [];
    const clipName = animation.name || "default";
    const fps = animation.fps || 30;
    const blendMode = animation.blendMode;
    let duration = animation.length || -1;
    const hierarchyTracks = animation.hierarchy || [];
    for (let h2 = 0; h2 < hierarchyTracks.length; h2++) {
      const animationKeys = hierarchyTracks[h2].keys;
      if (!animationKeys || animationKeys.length === 0) continue;
      if (animationKeys[0].morphTargets) {
        const morphTargetNames = {};
        let k2;
        for (k2 = 0; k2 < animationKeys.length; k2++) {
          if (animationKeys[k2].morphTargets) {
            for (let m2 = 0; m2 < animationKeys[k2].morphTargets.length; m2++) {
              morphTargetNames[animationKeys[k2].morphTargets[m2]] = -1;
            }
          }
        }
        for (const morphTargetName in morphTargetNames) {
          const times = [];
          const values = [];
          for (let m2 = 0; m2 !== animationKeys[k2].morphTargets.length; ++m2) {
            const animationKey = animationKeys[k2];
            times.push(animationKey.time);
            values.push(animationKey.morphTarget === morphTargetName ? 1 : 0);
          }
          tracks.push(new NumberKeyframeTrack(".morphTargetInfluence[" + morphTargetName + "]", times, values));
        }
        duration = morphTargetNames.length * fps;
      } else {
        const boneName = ".bones[" + bones[h2].name + "]";
        addNonemptyTrack(
          VectorKeyframeTrack,
          boneName + ".position",
          animationKeys,
          "pos",
          tracks
        );
        addNonemptyTrack(
          QuaternionKeyframeTrack,
          boneName + ".quaternion",
          animationKeys,
          "rot",
          tracks
        );
        addNonemptyTrack(
          VectorKeyframeTrack,
          boneName + ".scale",
          animationKeys,
          "scl",
          tracks
        );
      }
    }
    if (tracks.length === 0) {
      return null;
    }
    const clip = new this(clipName, duration, tracks, blendMode);
    return clip;
  }
  resetDuration() {
    const tracks = this.tracks;
    let duration = 0;
    for (let i2 = 0, n = tracks.length; i2 !== n; ++i2) {
      const track = this.tracks[i2];
      duration = Math.max(duration, track.times[track.times.length - 1]);
    }
    this.duration = duration;
    return this;
  }
  trim() {
    for (let i2 = 0; i2 < this.tracks.length; i2++) {
      this.tracks[i2].trim(0, this.duration);
    }
    return this;
  }
  validate() {
    let valid = true;
    for (let i2 = 0; i2 < this.tracks.length; i2++) {
      valid = valid && this.tracks[i2].validate();
    }
    return valid;
  }
  optimize() {
    for (let i2 = 0; i2 < this.tracks.length; i2++) {
      this.tracks[i2].optimize();
    }
    return this;
  }
  clone() {
    const tracks = [];
    for (let i2 = 0; i2 < this.tracks.length; i2++) {
      tracks.push(this.tracks[i2].clone());
    }
    return new this.constructor(this.name, this.duration, tracks, this.blendMode);
  }
  toJSON() {
    return this.constructor.toJSON(this);
  }
};
function getTrackTypeForValueTypeName(typeName) {
  switch (typeName.toLowerCase()) {
    case "scalar":
    case "double":
    case "float":
    case "number":
    case "integer":
      return NumberKeyframeTrack;
    case "vector":
    case "vector2":
    case "vector3":
    case "vector4":
      return VectorKeyframeTrack;
    case "color":
      return ColorKeyframeTrack;
    case "quaternion":
      return QuaternionKeyframeTrack;
    case "bool":
    case "boolean":
      return BooleanKeyframeTrack;
    case "string":
      return StringKeyframeTrack;
  }
  throw new Error("THREE.KeyframeTrack: Unsupported typeName: " + typeName);
}
function parseKeyframeTrack(json) {
  if (json.type === void 0) {
    throw new Error("THREE.KeyframeTrack: track type undefined, can not parse");
  }
  const trackType = getTrackTypeForValueTypeName(json.type);
  if (json.times === void 0) {
    const times = [], values = [];
    flattenJSON(json.keys, times, values, "value");
    json.times = times;
    json.values = values;
  }
  if (trackType.parse !== void 0) {
    return trackType.parse(json);
  } else {
    return new trackType(json.name, json.times, json.values, json.interpolation);
  }
}
var Cache = {
  enabled: false,
  files: {},
  add: function(key, file) {
    if (this.enabled === false) return;
    this.files[key] = file;
  },
  get: function(key) {
    if (this.enabled === false) return;
    return this.files[key];
  },
  remove: function(key) {
    delete this.files[key];
  },
  clear: function() {
    this.files = {};
  }
};
var LoadingManager = class {
  constructor(onLoad, onProgress, onError) {
    const scope = this;
    let isLoading = false;
    let itemsLoaded = 0;
    let itemsTotal = 0;
    let urlModifier = void 0;
    const handlers = [];
    this.onStart = void 0;
    this.onLoad = onLoad;
    this.onProgress = onProgress;
    this.onError = onError;
    this.itemStart = function(url) {
      itemsTotal++;
      if (isLoading === false) {
        if (scope.onStart !== void 0) {
          scope.onStart(url, itemsLoaded, itemsTotal);
        }
      }
      isLoading = true;
    };
    this.itemEnd = function(url) {
      itemsLoaded++;
      if (scope.onProgress !== void 0) {
        scope.onProgress(url, itemsLoaded, itemsTotal);
      }
      if (itemsLoaded === itemsTotal) {
        isLoading = false;
        if (scope.onLoad !== void 0) {
          scope.onLoad();
        }
      }
    };
    this.itemError = function(url) {
      if (scope.onError !== void 0) {
        scope.onError(url);
      }
    };
    this.resolveURL = function(url) {
      if (urlModifier) {
        return urlModifier(url);
      }
      return url;
    };
    this.setURLModifier = function(transform) {
      urlModifier = transform;
      return this;
    };
    this.addHandler = function(regex, loader) {
      handlers.push(regex, loader);
      return this;
    };
    this.removeHandler = function(regex) {
      const index = handlers.indexOf(regex);
      if (index !== -1) {
        handlers.splice(index, 2);
      }
      return this;
    };
    this.getHandler = function(file) {
      for (let i2 = 0, l2 = handlers.length; i2 < l2; i2 += 2) {
        const regex = handlers[i2];
        const loader = handlers[i2 + 1];
        if (regex.global) regex.lastIndex = 0;
        if (regex.test(file)) {
          return loader;
        }
      }
      return null;
    };
  }
};
var DefaultLoadingManager = new LoadingManager();
var Loader = class {
  constructor(manager) {
    this.manager = manager !== void 0 ? manager : DefaultLoadingManager;
    this.crossOrigin = "anonymous";
    this.withCredentials = false;
    this.path = "";
    this.resourcePath = "";
    this.requestHeader = {};
  }
  load() {
  }
  loadAsync(url, onProgress) {
    const scope = this;
    return new Promise(function(resolve, reject) {
      scope.load(url, resolve, onProgress, reject);
    });
  }
  parse() {
  }
  setCrossOrigin(crossOrigin) {
    this.crossOrigin = crossOrigin;
    return this;
  }
  setWithCredentials(value) {
    this.withCredentials = value;
    return this;
  }
  setPath(path) {
    this.path = path;
    return this;
  }
  setResourcePath(resourcePath) {
    this.resourcePath = resourcePath;
    return this;
  }
  setRequestHeader(requestHeader) {
    this.requestHeader = requestHeader;
    return this;
  }
};
var loading = {};
var HttpError = class extends Error {
  constructor(message, response) {
    super(message);
    this.response = response;
  }
};
var FileLoader = class extends Loader {
  constructor(manager) {
    super(manager);
  }
  load(url, onLoad, onProgress, onError) {
    if (url === void 0) url = "";
    if (this.path !== void 0) url = this.path + url;
    url = this.manager.resolveURL(url);
    const cached = Cache.get(url);
    if (cached !== void 0) {
      this.manager.itemStart(url);
      setTimeout(() => {
        if (onLoad) onLoad(cached);
        this.manager.itemEnd(url);
      }, 0);
      return cached;
    }
    if (loading[url] !== void 0) {
      loading[url].push({
        onLoad,
        onProgress,
        onError
      });
      return;
    }
    loading[url] = [];
    loading[url].push({
      onLoad,
      onProgress,
      onError
    });
    const req = new Request(url, {
      headers: new Headers(this.requestHeader),
      credentials: this.withCredentials ? "include" : "same-origin"
      // An abort controller could be added within a future PR
    });
    const mimeType = this.mimeType;
    const responseType = this.responseType;
    fetch(req).then((response) => {
      if (response.status === 200 || response.status === 0) {
        if (response.status === 0) {
          console.warn("THREE.FileLoader: HTTP Status 0 received.");
        }
        if (typeof ReadableStream === "undefined" || response.body === void 0 || response.body.getReader === void 0) {
          return response;
        }
        const callbacks = loading[url];
        const reader = response.body.getReader();
        const contentLength = response.headers.get("Content-Length") || response.headers.get("X-File-Size");
        const total = contentLength ? parseInt(contentLength) : 0;
        const lengthComputable = total !== 0;
        let loaded = 0;
        const stream = new ReadableStream({
          start(controller) {
            readData();
            function readData() {
              reader.read().then(({ done, value }) => {
                if (done) {
                  controller.close();
                } else {
                  loaded += value.byteLength;
                  const event = new ProgressEvent("progress", { lengthComputable, loaded, total });
                  for (let i2 = 0, il = callbacks.length; i2 < il; i2++) {
                    const callback = callbacks[i2];
                    if (callback.onProgress) callback.onProgress(event);
                  }
                  controller.enqueue(value);
                  readData();
                }
              });
            }
          }
        });
        return new Response(stream);
      } else {
        throw new HttpError(`fetch for "${response.url}" responded with ${response.status}: ${response.statusText}`, response);
      }
    }).then((response) => {
      switch (responseType) {
        case "arraybuffer":
          return response.arrayBuffer();
        case "blob":
          return response.blob();
        case "document":
          return response.text().then((text) => {
            const parser = new DOMParser();
            return parser.parseFromString(text, mimeType);
          });
        case "json":
          return response.json();
        default:
          if (mimeType === void 0) {
            return response.text();
          } else {
            const re = /charset="?([^;"\s]*)"?/i;
            const exec = re.exec(mimeType);
            const label = exec && exec[1] ? exec[1].toLowerCase() : void 0;
            const decoder = new TextDecoder(label);
            return response.arrayBuffer().then((ab) => decoder.decode(ab));
          }
      }
    }).then((data) => {
      Cache.add(url, data);
      const callbacks = loading[url];
      delete loading[url];
      for (let i2 = 0, il = callbacks.length; i2 < il; i2++) {
        const callback = callbacks[i2];
        if (callback.onLoad) callback.onLoad(data);
      }
    }).catch((err) => {
      const callbacks = loading[url];
      if (callbacks === void 0) {
        this.manager.itemError(url);
        throw err;
      }
      delete loading[url];
      for (let i2 = 0, il = callbacks.length; i2 < il; i2++) {
        const callback = callbacks[i2];
        if (callback.onError) callback.onError(err);
      }
      this.manager.itemError(url);
    }).finally(() => {
      this.manager.itemEnd(url);
    });
    this.manager.itemStart(url);
  }
  setResponseType(value) {
    this.responseType = value;
    return this;
  }
  setMimeType(value) {
    this.mimeType = value;
    return this;
  }
};
var AnimationLoader = class extends Loader {
  constructor(manager) {
    super(manager);
  }
  load(url, onLoad, onProgress, onError) {
    const scope = this;
    const loader = new FileLoader(this.manager);
    loader.setPath(this.path);
    loader.setRequestHeader(this.requestHeader);
    loader.setWithCredentials(this.withCredentials);
    loader.load(url, function(text) {
      try {
        onLoad(scope.parse(JSON.parse(text)));
      } catch (e2) {
        if (onError) {
          onError(e2);
        } else {
          console.error(e2);
        }
        scope.manager.itemError(url);
      }
    }, onProgress, onError);
  }
  parse(json) {
    const animations = [];
    for (let i2 = 0; i2 < json.length; i2++) {
      const clip = AnimationClip.parse(json[i2]);
      animations.push(clip);
    }
    return animations;
  }
};
var CompressedTextureLoader = class extends Loader {
  constructor(manager) {
    super(manager);
  }
  load(url, onLoad, onProgress, onError) {
    const scope = this;
    const images = [];
    const texture = new CompressedTexture();
    const loader = new FileLoader(this.manager);
    loader.setPath(this.path);
    loader.setResponseType("arraybuffer");
    loader.setRequestHeader(this.requestHeader);
    loader.setWithCredentials(scope.withCredentials);
    let loaded = 0;
    function loadTexture(i2) {
      loader.load(url[i2], function(buffer) {
        const texDatas = scope.parse(buffer, true);
        images[i2] = {
          width: texDatas.width,
          height: texDatas.height,
          format: texDatas.format,
          mipmaps: texDatas.mipmaps
        };
        loaded += 1;
        if (loaded === 6) {
          if (texDatas.mipmapCount === 1) texture.minFilter = LinearFilter;
          texture.image = images;
          texture.format = texDatas.format;
          texture.needsUpdate = true;
          if (onLoad) onLoad(texture);
        }
      }, onProgress, onError);
    }
    if (Array.isArray(url)) {
      for (let i2 = 0, il = url.length; i2 < il; ++i2) {
        loadTexture(i2);
      }
    } else {
      loader.load(url, function(buffer) {
        const texDatas = scope.parse(buffer, true);
        if (texDatas.isCubemap) {
          const faces = texDatas.mipmaps.length / texDatas.mipmapCount;
          for (let f2 = 0; f2 < faces; f2++) {
            images[f2] = { mipmaps: [] };
            for (let i2 = 0; i2 < texDatas.mipmapCount; i2++) {
              images[f2].mipmaps.push(texDatas.mipmaps[f2 * texDatas.mipmapCount + i2]);
              images[f2].format = texDatas.format;
              images[f2].width = texDatas.width;
              images[f2].height = texDatas.height;
            }
          }
          texture.image = images;
        } else {
          texture.image.width = texDatas.width;
          texture.image.height = texDatas.height;
          texture.mipmaps = texDatas.mipmaps;
        }
        if (texDatas.mipmapCount === 1) {
          texture.minFilter = LinearFilter;
        }
        texture.format = texDatas.format;
        texture.needsUpdate = true;
        if (onLoad) onLoad(texture);
      }, onProgress, onError);
    }
    return texture;
  }
};
var ImageLoader = class extends Loader {
  constructor(manager) {
    super(manager);
  }
  load(url, onLoad, onProgress, onError) {
    if (this.path !== void 0) url = this.path + url;
    url = this.manager.resolveURL(url);
    const scope = this;
    const cached = Cache.get(url);
    if (cached !== void 0) {
      scope.manager.itemStart(url);
      setTimeout(function() {
        if (onLoad) onLoad(cached);
        scope.manager.itemEnd(url);
      }, 0);
      return cached;
    }
    const image = createElementNS("img");
    function onImageLoad() {
      removeEventListeners();
      Cache.add(url, this);
      if (onLoad) onLoad(this);
      scope.manager.itemEnd(url);
    }
    function onImageError(event) {
      removeEventListeners();
      if (onError) onError(event);
      scope.manager.itemError(url);
      scope.manager.itemEnd(url);
    }
    function removeEventListeners() {
      image.removeEventListener("load", onImageLoad, false);
      image.removeEventListener("error", onImageError, false);
    }
    image.addEventListener("load", onImageLoad, false);
    image.addEventListener("error", onImageError, false);
    if (url.slice(0, 5) !== "data:") {
      if (this.crossOrigin !== void 0) image.crossOrigin = this.crossOrigin;
    }
    scope.manager.itemStart(url);
    image.src = url;
    return image;
  }
};
var CubeTextureLoader = class extends Loader {
  constructor(manager) {
    super(manager);
  }
  load(urls, onLoad, onProgress, onError) {
    const texture = new CubeTexture();
    texture.colorSpace = SRGBColorSpace;
    const loader = new ImageLoader(this.manager);
    loader.setCrossOrigin(this.crossOrigin);
    loader.setPath(this.path);
    let loaded = 0;
    function loadTexture(i2) {
      loader.load(urls[i2], function(image) {
        texture.images[i2] = image;
        loaded++;
        if (loaded === 6) {
          texture.needsUpdate = true;
          if (onLoad) onLoad(texture);
        }
      }, void 0, onError);
    }
    for (let i2 = 0; i2 < urls.length; ++i2) {
      loadTexture(i2);
    }
    return texture;
  }
};
var DataTextureLoader = class extends Loader {
  constructor(manager) {
    super(manager);
  }
  load(url, onLoad, onProgress, onError) {
    const scope = this;
    const texture = new DataTexture();
    const loader = new FileLoader(this.manager);
    loader.setResponseType("arraybuffer");
    loader.setRequestHeader(this.requestHeader);
    loader.setPath(this.path);
    loader.setWithCredentials(scope.withCredentials);
    loader.load(url, function(buffer) {
      const texData = scope.parse(buffer);
      if (!texData) return;
      if (texData.image !== void 0) {
        texture.image = texData.image;
      } else if (texData.data !== void 0) {
        texture.image.width = texData.width;
        texture.image.height = texData.height;
        texture.image.data = texData.data;
      }
      texture.wrapS = texData.wrapS !== void 0 ? texData.wrapS : ClampToEdgeWrapping;
      texture.wrapT = texData.wrapT !== void 0 ? texData.wrapT : ClampToEdgeWrapping;
      texture.magFilter = texData.magFilter !== void 0 ? texData.magFilter : LinearFilter;
      texture.minFilter = texData.minFilter !== void 0 ? texData.minFilter : LinearFilter;
      texture.anisotropy = texData.anisotropy !== void 0 ? texData.anisotropy : 1;
      if (texData.colorSpace !== void 0) {
        texture.colorSpace = texData.colorSpace;
      } else if (texData.encoding !== void 0) {
        texture.encoding = texData.encoding;
      }
      if (texData.flipY !== void 0) {
        texture.flipY = texData.flipY;
      }
      if (texData.format !== void 0) {
        texture.format = texData.format;
      }
      if (texData.type !== void 0) {
        texture.type = texData.type;
      }
      if (texData.mipmaps !== void 0) {
        texture.mipmaps = texData.mipmaps;
        texture.minFilter = LinearMipmapLinearFilter;
      }
      if (texData.mipmapCount === 1) {
        texture.minFilter = LinearFilter;
      }
      if (texData.generateMipmaps !== void 0) {
        texture.generateMipmaps = texData.generateMipmaps;
      }
      texture.needsUpdate = true;
      if (onLoad) onLoad(texture, texData);
    }, onProgress, onError);
    return texture;
  }
};
var TextureLoader = class extends Loader {
  constructor(manager) {
    super(manager);
  }
  load(url, onLoad, onProgress, onError) {
    const texture = new Texture();
    const loader = new ImageLoader(this.manager);
    loader.setCrossOrigin(this.crossOrigin);
    loader.setPath(this.path);
    loader.load(url, function(image) {
      texture.image = image;
      texture.needsUpdate = true;
      if (onLoad !== void 0) {
        onLoad(texture);
      }
    }, onProgress, onError);
    return texture;
  }
};
var Light = class extends Object3D {
  constructor(color, intensity = 1) {
    super();
    this.isLight = true;
    this.type = "Light";
    this.color = new Color(color);
    this.intensity = intensity;
  }
  dispose() {
  }
  copy(source, recursive) {
    super.copy(source, recursive);
    this.color.copy(source.color);
    this.intensity = source.intensity;
    return this;
  }
  toJSON(meta) {
    const data = super.toJSON(meta);
    data.object.color = this.color.getHex();
    data.object.intensity = this.intensity;
    if (this.groundColor !== void 0) data.object.groundColor = this.groundColor.getHex();
    if (this.distance !== void 0) data.object.distance = this.distance;
    if (this.angle !== void 0) data.object.angle = this.angle;
    if (this.decay !== void 0) data.object.decay = this.decay;
    if (this.penumbra !== void 0) data.object.penumbra = this.penumbra;
    if (this.shadow !== void 0) data.object.shadow = this.shadow.toJSON();
    return data;
  }
};
var HemisphereLight = class extends Light {
  constructor(skyColor, groundColor, intensity) {
    super(skyColor, intensity);
    this.isHemisphereLight = true;
    this.type = "HemisphereLight";
    this.position.copy(Object3D.DEFAULT_UP);
    this.updateMatrix();
    this.groundColor = new Color(groundColor);
  }
  copy(source, recursive) {
    super.copy(source, recursive);
    this.groundColor.copy(source.groundColor);
    return this;
  }
};
var _projScreenMatrix$1 = new Matrix4();
var _lightPositionWorld$1 = new Vector3();
var _lookTarget$1 = new Vector3();
var LightShadow = class {
  constructor(camera) {
    this.camera = camera;
    this.bias = 0;
    this.normalBias = 0;
    this.radius = 1;
    this.blurSamples = 8;
    this.mapSize = new Vector2(512, 512);
    this.map = null;
    this.mapPass = null;
    this.matrix = new Matrix4();
    this.autoUpdate = true;
    this.needsUpdate = false;
    this._frustum = new Frustum();
    this._frameExtents = new Vector2(1, 1);
    this._viewportCount = 1;
    this._viewports = [
      new Vector4(0, 0, 1, 1)
    ];
  }
  getViewportCount() {
    return this._viewportCount;
  }
  getFrustum() {
    return this._frustum;
  }
  updateMatrices(light) {
    const shadowCamera = this.camera;
    const shadowMatrix = this.matrix;
    _lightPositionWorld$1.setFromMatrixPosition(light.matrixWorld);
    shadowCamera.position.copy(_lightPositionWorld$1);
    _lookTarget$1.setFromMatrixPosition(light.target.matrixWorld);
    shadowCamera.lookAt(_lookTarget$1);
    shadowCamera.updateMatrixWorld();
    _projScreenMatrix$1.multiplyMatrices(shadowCamera.projectionMatrix, shadowCamera.matrixWorldInverse);
    this._frustum.setFromProjectionMatrix(_projScreenMatrix$1);
    shadowMatrix.set(
      0.5,
      0,
      0,
      0.5,
      0,
      0.5,
      0,
      0.5,
      0,
      0,
      0.5,
      0.5,
      0,
      0,
      0,
      1
    );
    shadowMatrix.multiply(_projScreenMatrix$1);
  }
  getViewport(viewportIndex) {
    return this._viewports[viewportIndex];
  }
  getFrameExtents() {
    return this._frameExtents;
  }
  dispose() {
    if (this.map) {
      this.map.dispose();
    }
    if (this.mapPass) {
      this.mapPass.dispose();
    }
  }
  copy(source) {
    this.camera = source.camera.clone();
    this.bias = source.bias;
    this.radius = source.radius;
    this.mapSize.copy(source.mapSize);
    return this;
  }
  clone() {
    return new this.constructor().copy(this);
  }
  toJSON() {
    const object = {};
    if (this.bias !== 0) object.bias = this.bias;
    if (this.normalBias !== 0) object.normalBias = this.normalBias;
    if (this.radius !== 1) object.radius = this.radius;
    if (this.mapSize.x !== 512 || this.mapSize.y !== 512) object.mapSize = this.mapSize.toArray();
    object.camera = this.camera.toJSON(false).object;
    delete object.camera.matrix;
    return object;
  }
};
var SpotLightShadow = class extends LightShadow {
  constructor() {
    super(new PerspectiveCamera(50, 1, 0.5, 500));
    this.isSpotLightShadow = true;
    this.focus = 1;
  }
  updateMatrices(light) {
    const camera = this.camera;
    const fov2 = RAD2DEG * 2 * light.angle * this.focus;
    const aspect2 = this.mapSize.width / this.mapSize.height;
    const far = light.distance || camera.far;
    if (fov2 !== camera.fov || aspect2 !== camera.aspect || far !== camera.far) {
      camera.fov = fov2;
      camera.aspect = aspect2;
      camera.far = far;
      camera.updateProjectionMatrix();
    }
    super.updateMatrices(light);
  }
  copy(source) {
    super.copy(source);
    this.focus = source.focus;
    return this;
  }
};
var SpotLight = class extends Light {
  constructor(color, intensity, distance = 0, angle = Math.PI / 3, penumbra = 0, decay = 2) {
    super(color, intensity);
    this.isSpotLight = true;
    this.type = "SpotLight";
    this.position.copy(Object3D.DEFAULT_UP);
    this.updateMatrix();
    this.target = new Object3D();
    this.distance = distance;
    this.angle = angle;
    this.penumbra = penumbra;
    this.decay = decay;
    this.map = null;
    this.shadow = new SpotLightShadow();
  }
  get power() {
    return this.intensity * Math.PI;
  }
  set power(power) {
    this.intensity = power / Math.PI;
  }
  dispose() {
    this.shadow.dispose();
  }
  copy(source, recursive) {
    super.copy(source, recursive);
    this.distance = source.distance;
    this.angle = source.angle;
    this.penumbra = source.penumbra;
    this.decay = source.decay;
    this.target = source.target.clone();
    this.shadow = source.shadow.clone();
    return this;
  }
};
var _projScreenMatrix = new Matrix4();
var _lightPositionWorld = new Vector3();
var _lookTarget = new Vector3();
var PointLightShadow = class extends LightShadow {
  constructor() {
    super(new PerspectiveCamera(90, 1, 0.5, 500));
    this.isPointLightShadow = true;
    this._frameExtents = new Vector2(4, 2);
    this._viewportCount = 6;
    this._viewports = [
      // These viewports map a cube-map onto a 2D texture with the
      // following orientation:
      //
      //  xzXZ
      //   y Y
      //
      // X - Positive x direction
      // x - Negative x direction
      // Y - Positive y direction
      // y - Negative y direction
      // Z - Positive z direction
      // z - Negative z direction
      // positive X
      new Vector4(2, 1, 1, 1),
      // negative X
      new Vector4(0, 1, 1, 1),
      // positive Z
      new Vector4(3, 1, 1, 1),
      // negative Z
      new Vector4(1, 1, 1, 1),
      // positive Y
      new Vector4(3, 0, 1, 1),
      // negative Y
      new Vector4(1, 0, 1, 1)
    ];
    this._cubeDirections = [
      new Vector3(1, 0, 0),
      new Vector3(-1, 0, 0),
      new Vector3(0, 0, 1),
      new Vector3(0, 0, -1),
      new Vector3(0, 1, 0),
      new Vector3(0, -1, 0)
    ];
    this._cubeUps = [
      new Vector3(0, 1, 0),
      new Vector3(0, 1, 0),
      new Vector3(0, 1, 0),
      new Vector3(0, 1, 0),
      new Vector3(0, 0, 1),
      new Vector3(0, 0, -1)
    ];
  }
  updateMatrices(light, viewportIndex = 0) {
    const camera = this.camera;
    const shadowMatrix = this.matrix;
    const far = light.distance || camera.far;
    if (far !== camera.far) {
      camera.far = far;
      camera.updateProjectionMatrix();
    }
    _lightPositionWorld.setFromMatrixPosition(light.matrixWorld);
    camera.position.copy(_lightPositionWorld);
    _lookTarget.copy(camera.position);
    _lookTarget.add(this._cubeDirections[viewportIndex]);
    camera.up.copy(this._cubeUps[viewportIndex]);
    camera.lookAt(_lookTarget);
    camera.updateMatrixWorld();
    shadowMatrix.makeTranslation(-_lightPositionWorld.x, -_lightPositionWorld.y, -_lightPositionWorld.z);
    _projScreenMatrix.multiplyMatrices(camera.projectionMatrix, camera.matrixWorldInverse);
    this._frustum.setFromProjectionMatrix(_projScreenMatrix);
  }
};
var PointLight = class extends Light {
  constructor(color, intensity, distance = 0, decay = 2) {
    super(color, intensity);
    this.isPointLight = true;
    this.type = "PointLight";
    this.distance = distance;
    this.decay = decay;
    this.shadow = new PointLightShadow();
  }
  get power() {
    return this.intensity * 4 * Math.PI;
  }
  set power(power) {
    this.intensity = power / (4 * Math.PI);
  }
  dispose() {
    this.shadow.dispose();
  }
  copy(source, recursive) {
    super.copy(source, recursive);
    this.distance = source.distance;
    this.decay = source.decay;
    this.shadow = source.shadow.clone();
    return this;
  }
};
var DirectionalLightShadow = class extends LightShadow {
  constructor() {
    super(new OrthographicCamera(-5, 5, 5, -5, 0.5, 500));
    this.isDirectionalLightShadow = true;
  }
};
var DirectionalLight = class extends Light {
  constructor(color, intensity) {
    super(color, intensity);
    this.isDirectionalLight = true;
    this.type = "DirectionalLight";
    this.position.copy(Object3D.DEFAULT_UP);
    this.updateMatrix();
    this.target = new Object3D();
    this.shadow = new DirectionalLightShadow();
  }
  dispose() {
    this.shadow.dispose();
  }
  copy(source) {
    super.copy(source);
    this.target = source.target.clone();
    this.shadow = source.shadow.clone();
    return this;
  }
};
var AmbientLight = class extends Light {
  constructor(color, intensity) {
    super(color, intensity);
    this.isAmbientLight = true;
    this.type = "AmbientLight";
  }
};
var RectAreaLight = class extends Light {
  constructor(color, intensity, width = 10, height = 10) {
    super(color, intensity);
    this.isRectAreaLight = true;
    this.type = "RectAreaLight";
    this.width = width;
    this.height = height;
  }
  get power() {
    return this.intensity * this.width * this.height * Math.PI;
  }
  set power(power) {
    this.intensity = power / (this.width * this.height * Math.PI);
  }
  copy(source) {
    super.copy(source);
    this.width = source.width;
    this.height = source.height;
    return this;
  }
  toJSON(meta) {
    const data = super.toJSON(meta);
    data.object.width = this.width;
    data.object.height = this.height;
    return data;
  }
};
var SphericalHarmonics3 = class {
  constructor() {
    this.isSphericalHarmonics3 = true;
    this.coefficients = [];
    for (let i2 = 0; i2 < 9; i2++) {
      this.coefficients.push(new Vector3());
    }
  }
  set(coefficients) {
    for (let i2 = 0; i2 < 9; i2++) {
      this.coefficients[i2].copy(coefficients[i2]);
    }
    return this;
  }
  zero() {
    for (let i2 = 0; i2 < 9; i2++) {
      this.coefficients[i2].set(0, 0, 0);
    }
    return this;
  }
  // get the radiance in the direction of the normal
  // target is a Vector3
  getAt(normal, target) {
    const x3 = normal.x, y2 = normal.y, z = normal.z;
    const coeff = this.coefficients;
    target.copy(coeff[0]).multiplyScalar(0.282095);
    target.addScaledVector(coeff[1], 0.488603 * y2);
    target.addScaledVector(coeff[2], 0.488603 * z);
    target.addScaledVector(coeff[3], 0.488603 * x3);
    target.addScaledVector(coeff[4], 1.092548 * (x3 * y2));
    target.addScaledVector(coeff[5], 1.092548 * (y2 * z));
    target.addScaledVector(coeff[6], 0.315392 * (3 * z * z - 1));
    target.addScaledVector(coeff[7], 1.092548 * (x3 * z));
    target.addScaledVector(coeff[8], 0.546274 * (x3 * x3 - y2 * y2));
    return target;
  }
  // get the irradiance (radiance convolved with cosine lobe) in the direction of the normal
  // target is a Vector3
  // https://graphics.stanford.edu/papers/envmap/envmap.pdf
  getIrradianceAt(normal, target) {
    const x3 = normal.x, y2 = normal.y, z = normal.z;
    const coeff = this.coefficients;
    target.copy(coeff[0]).multiplyScalar(0.886227);
    target.addScaledVector(coeff[1], 2 * 0.511664 * y2);
    target.addScaledVector(coeff[2], 2 * 0.511664 * z);
    target.addScaledVector(coeff[3], 2 * 0.511664 * x3);
    target.addScaledVector(coeff[4], 2 * 0.429043 * x3 * y2);
    target.addScaledVector(coeff[5], 2 * 0.429043 * y2 * z);
    target.addScaledVector(coeff[6], 0.743125 * z * z - 0.247708);
    target.addScaledVector(coeff[7], 2 * 0.429043 * x3 * z);
    target.addScaledVector(coeff[8], 0.429043 * (x3 * x3 - y2 * y2));
    return target;
  }
  add(sh) {
    for (let i2 = 0; i2 < 9; i2++) {
      this.coefficients[i2].add(sh.coefficients[i2]);
    }
    return this;
  }
  addScaledSH(sh, s2) {
    for (let i2 = 0; i2 < 9; i2++) {
      this.coefficients[i2].addScaledVector(sh.coefficients[i2], s2);
    }
    return this;
  }
  scale(s2) {
    for (let i2 = 0; i2 < 9; i2++) {
      this.coefficients[i2].multiplyScalar(s2);
    }
    return this;
  }
  lerp(sh, alpha) {
    for (let i2 = 0; i2 < 9; i2++) {
      this.coefficients[i2].lerp(sh.coefficients[i2], alpha);
    }
    return this;
  }
  equals(sh) {
    for (let i2 = 0; i2 < 9; i2++) {
      if (!this.coefficients[i2].equals(sh.coefficients[i2])) {
        return false;
      }
    }
    return true;
  }
  copy(sh) {
    return this.set(sh.coefficients);
  }
  clone() {
    return new this.constructor().copy(this);
  }
  fromArray(array, offset = 0) {
    const coefficients = this.coefficients;
    for (let i2 = 0; i2 < 9; i2++) {
      coefficients[i2].fromArray(array, offset + i2 * 3);
    }
    return this;
  }
  toArray(array = [], offset = 0) {
    const coefficients = this.coefficients;
    for (let i2 = 0; i2 < 9; i2++) {
      coefficients[i2].toArray(array, offset + i2 * 3);
    }
    return array;
  }
  // evaluate the basis functions
  // shBasis is an Array[ 9 ]
  static getBasisAt(normal, shBasis) {
    const x3 = normal.x, y2 = normal.y, z = normal.z;
    shBasis[0] = 0.282095;
    shBasis[1] = 0.488603 * y2;
    shBasis[2] = 0.488603 * z;
    shBasis[3] = 0.488603 * x3;
    shBasis[4] = 1.092548 * x3 * y2;
    shBasis[5] = 1.092548 * y2 * z;
    shBasis[6] = 0.315392 * (3 * z * z - 1);
    shBasis[7] = 1.092548 * x3 * z;
    shBasis[8] = 0.546274 * (x3 * x3 - y2 * y2);
  }
};
var LightProbe = class extends Light {
  constructor(sh = new SphericalHarmonics3(), intensity = 1) {
    super(void 0, intensity);
    this.isLightProbe = true;
    this.sh = sh;
  }
  copy(source) {
    super.copy(source);
    this.sh.copy(source.sh);
    return this;
  }
  fromJSON(json) {
    this.intensity = json.intensity;
    this.sh.fromArray(json.sh);
    return this;
  }
  toJSON(meta) {
    const data = super.toJSON(meta);
    data.object.sh = this.sh.toArray();
    return data;
  }
};
var MaterialLoader = class _MaterialLoader extends Loader {
  constructor(manager) {
    super(manager);
    this.textures = {};
  }
  load(url, onLoad, onProgress, onError) {
    const scope = this;
    const loader = new FileLoader(scope.manager);
    loader.setPath(scope.path);
    loader.setRequestHeader(scope.requestHeader);
    loader.setWithCredentials(scope.withCredentials);
    loader.load(url, function(text) {
      try {
        onLoad(scope.parse(JSON.parse(text)));
      } catch (e2) {
        if (onError) {
          onError(e2);
        } else {
          console.error(e2);
        }
        scope.manager.itemError(url);
      }
    }, onProgress, onError);
  }
  parse(json) {
    const textures = this.textures;
    function getTexture(name) {
      if (textures[name] === void 0) {
        console.warn("THREE.MaterialLoader: Undefined texture", name);
      }
      return textures[name];
    }
    const material = _MaterialLoader.createMaterialFromType(json.type);
    if (json.uuid !== void 0) material.uuid = json.uuid;
    if (json.name !== void 0) material.name = json.name;
    if (json.color !== void 0 && material.color !== void 0) material.color.setHex(json.color);
    if (json.roughness !== void 0) material.roughness = json.roughness;
    if (json.metalness !== void 0) material.metalness = json.metalness;
    if (json.sheen !== void 0) material.sheen = json.sheen;
    if (json.sheenColor !== void 0) material.sheenColor = new Color().setHex(json.sheenColor);
    if (json.sheenRoughness !== void 0) material.sheenRoughness = json.sheenRoughness;
    if (json.emissive !== void 0 && material.emissive !== void 0) material.emissive.setHex(json.emissive);
    if (json.specular !== void 0 && material.specular !== void 0) material.specular.setHex(json.specular);
    if (json.specularIntensity !== void 0) material.specularIntensity = json.specularIntensity;
    if (json.specularColor !== void 0 && material.specularColor !== void 0) material.specularColor.setHex(json.specularColor);
    if (json.shininess !== void 0) material.shininess = json.shininess;
    if (json.clearcoat !== void 0) material.clearcoat = json.clearcoat;
    if (json.clearcoatRoughness !== void 0) material.clearcoatRoughness = json.clearcoatRoughness;
    if (json.iridescence !== void 0) material.iridescence = json.iridescence;
    if (json.iridescenceIOR !== void 0) material.iridescenceIOR = json.iridescenceIOR;
    if (json.iridescenceThicknessRange !== void 0) material.iridescenceThicknessRange = json.iridescenceThicknessRange;
    if (json.transmission !== void 0) material.transmission = json.transmission;
    if (json.thickness !== void 0) material.thickness = json.thickness;
    if (json.attenuationDistance !== void 0) material.attenuationDistance = json.attenuationDistance;
    if (json.attenuationColor !== void 0 && material.attenuationColor !== void 0) material.attenuationColor.setHex(json.attenuationColor);
    if (json.anisotropy !== void 0) material.anisotropy = json.anisotropy;
    if (json.anisotropyRotation !== void 0) material.anisotropyRotation = json.anisotropyRotation;
    if (json.fog !== void 0) material.fog = json.fog;
    if (json.flatShading !== void 0) material.flatShading = json.flatShading;
    if (json.blending !== void 0) material.blending = json.blending;
    if (json.combine !== void 0) material.combine = json.combine;
    if (json.side !== void 0) material.side = json.side;
    if (json.shadowSide !== void 0) material.shadowSide = json.shadowSide;
    if (json.opacity !== void 0) material.opacity = json.opacity;
    if (json.transparent !== void 0) material.transparent = json.transparent;
    if (json.alphaTest !== void 0) material.alphaTest = json.alphaTest;
    if (json.depthTest !== void 0) material.depthTest = json.depthTest;
    if (json.depthWrite !== void 0) material.depthWrite = json.depthWrite;
    if (json.colorWrite !== void 0) material.colorWrite = json.colorWrite;
    if (json.stencilWrite !== void 0) material.stencilWrite = json.stencilWrite;
    if (json.stencilWriteMask !== void 0) material.stencilWriteMask = json.stencilWriteMask;
    if (json.stencilFunc !== void 0) material.stencilFunc = json.stencilFunc;
    if (json.stencilRef !== void 0) material.stencilRef = json.stencilRef;
    if (json.stencilFuncMask !== void 0) material.stencilFuncMask = json.stencilFuncMask;
    if (json.stencilFail !== void 0) material.stencilFail = json.stencilFail;
    if (json.stencilZFail !== void 0) material.stencilZFail = json.stencilZFail;
    if (json.stencilZPass !== void 0) material.stencilZPass = json.stencilZPass;
    if (json.wireframe !== void 0) material.wireframe = json.wireframe;
    if (json.wireframeLinewidth !== void 0) material.wireframeLinewidth = json.wireframeLinewidth;
    if (json.wireframeLinecap !== void 0) material.wireframeLinecap = json.wireframeLinecap;
    if (json.wireframeLinejoin !== void 0) material.wireframeLinejoin = json.wireframeLinejoin;
    if (json.rotation !== void 0) material.rotation = json.rotation;
    if (json.linewidth !== 1) material.linewidth = json.linewidth;
    if (json.dashSize !== void 0) material.dashSize = json.dashSize;
    if (json.gapSize !== void 0) material.gapSize = json.gapSize;
    if (json.scale !== void 0) material.scale = json.scale;
    if (json.polygonOffset !== void 0) material.polygonOffset = json.polygonOffset;
    if (json.polygonOffsetFactor !== void 0) material.polygonOffsetFactor = json.polygonOffsetFactor;
    if (json.polygonOffsetUnits !== void 0) material.polygonOffsetUnits = json.polygonOffsetUnits;
    if (json.dithering !== void 0) material.dithering = json.dithering;
    if (json.alphaToCoverage !== void 0) material.alphaToCoverage = json.alphaToCoverage;
    if (json.premultipliedAlpha !== void 0) material.premultipliedAlpha = json.premultipliedAlpha;
    if (json.forceSinglePass !== void 0) material.forceSinglePass = json.forceSinglePass;
    if (json.visible !== void 0) material.visible = json.visible;
    if (json.toneMapped !== void 0) material.toneMapped = json.toneMapped;
    if (json.userData !== void 0) material.userData = json.userData;
    if (json.vertexColors !== void 0) {
      if (typeof json.vertexColors === "number") {
        material.vertexColors = json.vertexColors > 0 ? true : false;
      } else {
        material.vertexColors = json.vertexColors;
      }
    }
    if (json.uniforms !== void 0) {
      for (const name in json.uniforms) {
        const uniform = json.uniforms[name];
        material.uniforms[name] = {};
        switch (uniform.type) {
          case "t":
            material.uniforms[name].value = getTexture(uniform.value);
            break;
          case "c":
            material.uniforms[name].value = new Color().setHex(uniform.value);
            break;
          case "v2":
            material.uniforms[name].value = new Vector2().fromArray(uniform.value);
            break;
          case "v3":
            material.uniforms[name].value = new Vector3().fromArray(uniform.value);
            break;
          case "v4":
            material.uniforms[name].value = new Vector4().fromArray(uniform.value);
            break;
          case "m3":
            material.uniforms[name].value = new Matrix3().fromArray(uniform.value);
            break;
          case "m4":
            material.uniforms[name].value = new Matrix4().fromArray(uniform.value);
            break;
          default:
            material.uniforms[name].value = uniform.value;
        }
      }
    }
    if (json.defines !== void 0) material.defines = json.defines;
    if (json.vertexShader !== void 0) material.vertexShader = json.vertexShader;
    if (json.fragmentShader !== void 0) material.fragmentShader = json.fragmentShader;
    if (json.glslVersion !== void 0) material.glslVersion = json.glslVersion;
    if (json.extensions !== void 0) {
      for (const key in json.extensions) {
        material.extensions[key] = json.extensions[key];
      }
    }
    if (json.lights !== void 0) material.lights = json.lights;
    if (json.clipping !== void 0) material.clipping = json.clipping;
    if (json.size !== void 0) material.size = json.size;
    if (json.sizeAttenuation !== void 0) material.sizeAttenuation = json.sizeAttenuation;
    if (json.map !== void 0) material.map = getTexture(json.map);
    if (json.matcap !== void 0) material.matcap = getTexture(json.matcap);
    if (json.alphaMap !== void 0) material.alphaMap = getTexture(json.alphaMap);
    if (json.bumpMap !== void 0) material.bumpMap = getTexture(json.bumpMap);
    if (json.bumpScale !== void 0) material.bumpScale = json.bumpScale;
    if (json.normalMap !== void 0) material.normalMap = getTexture(json.normalMap);
    if (json.normalMapType !== void 0) material.normalMapType = json.normalMapType;
    if (json.normalScale !== void 0) {
      let normalScale = json.normalScale;
      if (Array.isArray(normalScale) === false) {
        normalScale = [normalScale, normalScale];
      }
      material.normalScale = new Vector2().fromArray(normalScale);
    }
    if (json.displacementMap !== void 0) material.displacementMap = getTexture(json.displacementMap);
    if (json.displacementScale !== void 0) material.displacementScale = json.displacementScale;
    if (json.displacementBias !== void 0) material.displacementBias = json.displacementBias;
    if (json.roughnessMap !== void 0) material.roughnessMap = getTexture(json.roughnessMap);
    if (json.metalnessMap !== void 0) material.metalnessMap = getTexture(json.metalnessMap);
    if (json.emissiveMap !== void 0) material.emissiveMap = getTexture(json.emissiveMap);
    if (json.emissiveIntensity !== void 0) material.emissiveIntensity = json.emissiveIntensity;
    if (json.specularMap !== void 0) material.specularMap = getTexture(json.specularMap);
    if (json.specularIntensityMap !== void 0) material.specularIntensityMap = getTexture(json.specularIntensityMap);
    if (json.specularColorMap !== void 0) material.specularColorMap = getTexture(json.specularColorMap);
    if (json.envMap !== void 0) material.envMap = getTexture(json.envMap);
    if (json.envMapIntensity !== void 0) material.envMapIntensity = json.envMapIntensity;
    if (json.reflectivity !== void 0) material.reflectivity = json.reflectivity;
    if (json.refractionRatio !== void 0) material.refractionRatio = json.refractionRatio;
    if (json.lightMap !== void 0) material.lightMap = getTexture(json.lightMap);
    if (json.lightMapIntensity !== void 0) material.lightMapIntensity = json.lightMapIntensity;
    if (json.aoMap !== void 0) material.aoMap = getTexture(json.aoMap);
    if (json.aoMapIntensity !== void 0) material.aoMapIntensity = json.aoMapIntensity;
    if (json.gradientMap !== void 0) material.gradientMap = getTexture(json.gradientMap);
    if (json.clearcoatMap !== void 0) material.clearcoatMap = getTexture(json.clearcoatMap);
    if (json.clearcoatRoughnessMap !== void 0) material.clearcoatRoughnessMap = getTexture(json.clearcoatRoughnessMap);
    if (json.clearcoatNormalMap !== void 0) material.clearcoatNormalMap = getTexture(json.clearcoatNormalMap);
    if (json.clearcoatNormalScale !== void 0) material.clearcoatNormalScale = new Vector2().fromArray(json.clearcoatNormalScale);
    if (json.iridescenceMap !== void 0) material.iridescenceMap = getTexture(json.iridescenceMap);
    if (json.iridescenceThicknessMap !== void 0) material.iridescenceThicknessMap = getTexture(json.iridescenceThicknessMap);
    if (json.transmissionMap !== void 0) material.transmissionMap = getTexture(json.transmissionMap);
    if (json.thicknessMap !== void 0) material.thicknessMap = getTexture(json.thicknessMap);
    if (json.anisotropyMap !== void 0) material.anisotropyMap = getTexture(json.anisotropyMap);
    if (json.sheenColorMap !== void 0) material.sheenColorMap = getTexture(json.sheenColorMap);
    if (json.sheenRoughnessMap !== void 0) material.sheenRoughnessMap = getTexture(json.sheenRoughnessMap);
    return material;
  }
  setTextures(value) {
    this.textures = value;
    return this;
  }
  static createMaterialFromType(type) {
    const materialLib = {
      ShadowMaterial,
      SpriteMaterial,
      RawShaderMaterial,
      ShaderMaterial,
      PointsMaterial,
      MeshPhysicalMaterial,
      MeshStandardMaterial,
      MeshPhongMaterial,
      MeshToonMaterial,
      MeshNormalMaterial,
      MeshLambertMaterial,
      MeshDepthMaterial,
      MeshDistanceMaterial,
      MeshBasicMaterial,
      MeshMatcapMaterial,
      LineDashedMaterial,
      LineBasicMaterial,
      Material
    };
    return new materialLib[type]();
  }
};
var LoaderUtils = class {
  static decodeText(array) {
    if (typeof TextDecoder !== "undefined") {
      return new TextDecoder().decode(array);
    }
    let s2 = "";
    for (let i2 = 0, il = array.length; i2 < il; i2++) {
      s2 += String.fromCharCode(array[i2]);
    }
    try {
      return decodeURIComponent(escape(s2));
    } catch (e2) {
      return s2;
    }
  }
  static extractUrlBase(url) {
    const index = url.lastIndexOf("/");
    if (index === -1) return "./";
    return url.slice(0, index + 1);
  }
  static resolveURL(url, path) {
    if (typeof url !== "string" || url === "") return "";
    if (/^https?:\/\//i.test(path) && /^\//.test(url)) {
      path = path.replace(/(^https?:\/\/[^\/]+).*/i, "$1");
    }
    if (/^(https?:)?\/\//i.test(url)) return url;
    if (/^data:.*,.*$/i.test(url)) return url;
    if (/^blob:.*$/i.test(url)) return url;
    return path + url;
  }
};
var InstancedBufferGeometry = class extends BufferGeometry {
  constructor() {
    super();
    this.isInstancedBufferGeometry = true;
    this.type = "InstancedBufferGeometry";
    this.instanceCount = Infinity;
  }
  copy(source) {
    super.copy(source);
    this.instanceCount = source.instanceCount;
    return this;
  }
  toJSON() {
    const data = super.toJSON();
    data.instanceCount = this.instanceCount;
    data.isInstancedBufferGeometry = true;
    return data;
  }
};
var BufferGeometryLoader = class extends Loader {
  constructor(manager) {
    super(manager);
  }
  load(url, onLoad, onProgress, onError) {
    const scope = this;
    const loader = new FileLoader(scope.manager);
    loader.setPath(scope.path);
    loader.setRequestHeader(scope.requestHeader);
    loader.setWithCredentials(scope.withCredentials);
    loader.load(url, function(text) {
      try {
        onLoad(scope.parse(JSON.parse(text)));
      } catch (e2) {
        if (onError) {
          onError(e2);
        } else {
          console.error(e2);
        }
        scope.manager.itemError(url);
      }
    }, onProgress, onError);
  }
  parse(json) {
    const interleavedBufferMap = {};
    const arrayBufferMap = {};
    function getInterleavedBuffer(json2, uuid) {
      if (interleavedBufferMap[uuid] !== void 0) return interleavedBufferMap[uuid];
      const interleavedBuffers = json2.interleavedBuffers;
      const interleavedBuffer = interleavedBuffers[uuid];
      const buffer = getArrayBuffer(json2, interleavedBuffer.buffer);
      const array = getTypedArray(interleavedBuffer.type, buffer);
      const ib = new InterleavedBuffer(array, interleavedBuffer.stride);
      ib.uuid = interleavedBuffer.uuid;
      interleavedBufferMap[uuid] = ib;
      return ib;
    }
    function getArrayBuffer(json2, uuid) {
      if (arrayBufferMap[uuid] !== void 0) return arrayBufferMap[uuid];
      const arrayBuffers = json2.arrayBuffers;
      const arrayBuffer = arrayBuffers[uuid];
      const ab = new Uint32Array(arrayBuffer).buffer;
      arrayBufferMap[uuid] = ab;
      return ab;
    }
    const geometry = json.isInstancedBufferGeometry ? new InstancedBufferGeometry() : new BufferGeometry();
    const index = json.data.index;
    if (index !== void 0) {
      const typedArray = getTypedArray(index.type, index.array);
      geometry.setIndex(new BufferAttribute(typedArray, 1));
    }
    const attributes = json.data.attributes;
    for (const key in attributes) {
      const attribute = attributes[key];
      let bufferAttribute;
      if (attribute.isInterleavedBufferAttribute) {
        const interleavedBuffer = getInterleavedBuffer(json.data, attribute.data);
        bufferAttribute = new InterleavedBufferAttribute(interleavedBuffer, attribute.itemSize, attribute.offset, attribute.normalized);
      } else {
        const typedArray = getTypedArray(attribute.type, attribute.array);
        const bufferAttributeConstr = attribute.isInstancedBufferAttribute ? InstancedBufferAttribute : BufferAttribute;
        bufferAttribute = new bufferAttributeConstr(typedArray, attribute.itemSize, attribute.normalized);
      }
      if (attribute.name !== void 0) bufferAttribute.name = attribute.name;
      if (attribute.usage !== void 0) bufferAttribute.setUsage(attribute.usage);
      if (attribute.updateRange !== void 0) {
        bufferAttribute.updateRange.offset = attribute.updateRange.offset;
        bufferAttribute.updateRange.count = attribute.updateRange.count;
      }
      geometry.setAttribute(key, bufferAttribute);
    }
    const morphAttributes = json.data.morphAttributes;
    if (morphAttributes) {
      for (const key in morphAttributes) {
        const attributeArray = morphAttributes[key];
        const array = [];
        for (let i2 = 0, il = attributeArray.length; i2 < il; i2++) {
          const attribute = attributeArray[i2];
          let bufferAttribute;
          if (attribute.isInterleavedBufferAttribute) {
            const interleavedBuffer = getInterleavedBuffer(json.data, attribute.data);
            bufferAttribute = new InterleavedBufferAttribute(interleavedBuffer, attribute.itemSize, attribute.offset, attribute.normalized);
          } else {
            const typedArray = getTypedArray(attribute.type, attribute.array);
            bufferAttribute = new BufferAttribute(typedArray, attribute.itemSize, attribute.normalized);
          }
          if (attribute.name !== void 0) bufferAttribute.name = attribute.name;
          array.push(bufferAttribute);
        }
        geometry.morphAttributes[key] = array;
      }
    }
    const morphTargetsRelative = json.data.morphTargetsRelative;
    if (morphTargetsRelative) {
      geometry.morphTargetsRelative = true;
    }
    const groups2 = json.data.groups || json.data.drawcalls || json.data.offsets;
    if (groups2 !== void 0) {
      for (let i2 = 0, n = groups2.length; i2 !== n; ++i2) {
        const group = groups2[i2];
        geometry.addGroup(group.start, group.count, group.materialIndex);
      }
    }
    const boundingSphere = json.data.boundingSphere;
    if (boundingSphere !== void 0) {
      const center = new Vector3();
      if (boundingSphere.center !== void 0) {
        center.fromArray(boundingSphere.center);
      }
      geometry.boundingSphere = new Sphere(center, boundingSphere.radius);
    }
    if (json.name) geometry.name = json.name;
    if (json.userData) geometry.userData = json.userData;
    return geometry;
  }
};
var ObjectLoader = class extends Loader {
  constructor(manager) {
    super(manager);
  }
  load(url, onLoad, onProgress, onError) {
    const scope = this;
    const path = this.path === "" ? LoaderUtils.extractUrlBase(url) : this.path;
    this.resourcePath = this.resourcePath || path;
    const loader = new FileLoader(this.manager);
    loader.setPath(this.path);
    loader.setRequestHeader(this.requestHeader);
    loader.setWithCredentials(this.withCredentials);
    loader.load(url, function(text) {
      let json = null;
      try {
        json = JSON.parse(text);
      } catch (error) {
        if (onError !== void 0) onError(error);
        console.error("THREE:ObjectLoader: Can't parse " + url + ".", error.message);
        return;
      }
      const metadata = json.metadata;
      if (metadata === void 0 || metadata.type === void 0 || metadata.type.toLowerCase() === "geometry") {
        if (onError !== void 0) onError(new Error("THREE.ObjectLoader: Can't load " + url));
        console.error("THREE.ObjectLoader: Can't load " + url);
        return;
      }
      scope.parse(json, onLoad);
    }, onProgress, onError);
  }
  async loadAsync(url, onProgress) {
    const scope = this;
    const path = this.path === "" ? LoaderUtils.extractUrlBase(url) : this.path;
    this.resourcePath = this.resourcePath || path;
    const loader = new FileLoader(this.manager);
    loader.setPath(this.path);
    loader.setRequestHeader(this.requestHeader);
    loader.setWithCredentials(this.withCredentials);
    const text = await loader.loadAsync(url, onProgress);
    const json = JSON.parse(text);
    const metadata = json.metadata;
    if (metadata === void 0 || metadata.type === void 0 || metadata.type.toLowerCase() === "geometry") {
      throw new Error("THREE.ObjectLoader: Can't load " + url);
    }
    return await scope.parseAsync(json);
  }
  parse(json, onLoad) {
    const animations = this.parseAnimations(json.animations);
    const shapes = this.parseShapes(json.shapes);
    const geometries2 = this.parseGeometries(json.geometries, shapes);
    const images = this.parseImages(json.images, function() {
      if (onLoad !== void 0) onLoad(object);
    });
    const textures = this.parseTextures(json.textures, images);
    const materials2 = this.parseMaterials(json.materials, textures);
    const object = this.parseObject(json.object, geometries2, materials2, textures, animations);
    const skeletons = this.parseSkeletons(json.skeletons, object);
    this.bindSkeletons(object, skeletons);
    if (onLoad !== void 0) {
      let hasImages = false;
      for (const uuid in images) {
        if (images[uuid].data instanceof HTMLImageElement) {
          hasImages = true;
          break;
        }
      }
      if (hasImages === false) onLoad(object);
    }
    return object;
  }
  async parseAsync(json) {
    const animations = this.parseAnimations(json.animations);
    const shapes = this.parseShapes(json.shapes);
    const geometries2 = this.parseGeometries(json.geometries, shapes);
    const images = await this.parseImagesAsync(json.images);
    const textures = this.parseTextures(json.textures, images);
    const materials2 = this.parseMaterials(json.materials, textures);
    const object = this.parseObject(json.object, geometries2, materials2, textures, animations);
    const skeletons = this.parseSkeletons(json.skeletons, object);
    this.bindSkeletons(object, skeletons);
    return object;
  }
  parseShapes(json) {
    const shapes = {};
    if (json !== void 0) {
      for (let i2 = 0, l2 = json.length; i2 < l2; i2++) {
        const shape = new Shape().fromJSON(json[i2]);
        shapes[shape.uuid] = shape;
      }
    }
    return shapes;
  }
  parseSkeletons(json, object) {
    const skeletons = {};
    const bones = {};
    object.traverse(function(child) {
      if (child.isBone) bones[child.uuid] = child;
    });
    if (json !== void 0) {
      for (let i2 = 0, l2 = json.length; i2 < l2; i2++) {
        const skeleton = new Skeleton().fromJSON(json[i2], bones);
        skeletons[skeleton.uuid] = skeleton;
      }
    }
    return skeletons;
  }
  parseGeometries(json, shapes) {
    const geometries2 = {};
    if (json !== void 0) {
      const bufferGeometryLoader = new BufferGeometryLoader();
      for (let i2 = 0, l2 = json.length; i2 < l2; i2++) {
        let geometry;
        const data = json[i2];
        switch (data.type) {
          case "BufferGeometry":
          case "InstancedBufferGeometry":
            geometry = bufferGeometryLoader.parse(data);
            break;
          default:
            if (data.type in Geometries) {
              geometry = Geometries[data.type].fromJSON(data, shapes);
            } else {
              console.warn(`THREE.ObjectLoader: Unsupported geometry type "${data.type}"`);
            }
        }
        geometry.uuid = data.uuid;
        if (data.name !== void 0) geometry.name = data.name;
        if (data.userData !== void 0) geometry.userData = data.userData;
        geometries2[data.uuid] = geometry;
      }
    }
    return geometries2;
  }
  parseMaterials(json, textures) {
    const cache = {};
    const materials2 = {};
    if (json !== void 0) {
      const loader = new MaterialLoader();
      loader.setTextures(textures);
      for (let i2 = 0, l2 = json.length; i2 < l2; i2++) {
        const data = json[i2];
        if (cache[data.uuid] === void 0) {
          cache[data.uuid] = loader.parse(data);
        }
        materials2[data.uuid] = cache[data.uuid];
      }
    }
    return materials2;
  }
  parseAnimations(json) {
    const animations = {};
    if (json !== void 0) {
      for (let i2 = 0; i2 < json.length; i2++) {
        const data = json[i2];
        const clip = AnimationClip.parse(data);
        animations[clip.uuid] = clip;
      }
    }
    return animations;
  }
  parseImages(json, onLoad) {
    const scope = this;
    const images = {};
    let loader;
    function loadImage(url) {
      scope.manager.itemStart(url);
      return loader.load(url, function() {
        scope.manager.itemEnd(url);
      }, void 0, function() {
        scope.manager.itemError(url);
        scope.manager.itemEnd(url);
      });
    }
    function deserializeImage(image) {
      if (typeof image === "string") {
        const url = image;
        const path = /^(\/\/)|([a-z]+:(\/\/)?)/i.test(url) ? url : scope.resourcePath + url;
        return loadImage(path);
      } else {
        if (image.data) {
          return {
            data: getTypedArray(image.type, image.data),
            width: image.width,
            height: image.height
          };
        } else {
          return null;
        }
      }
    }
    if (json !== void 0 && json.length > 0) {
      const manager = new LoadingManager(onLoad);
      loader = new ImageLoader(manager);
      loader.setCrossOrigin(this.crossOrigin);
      for (let i2 = 0, il = json.length; i2 < il; i2++) {
        const image = json[i2];
        const url = image.url;
        if (Array.isArray(url)) {
          const imageArray = [];
          for (let j = 0, jl = url.length; j < jl; j++) {
            const currentUrl = url[j];
            const deserializedImage = deserializeImage(currentUrl);
            if (deserializedImage !== null) {
              if (deserializedImage instanceof HTMLImageElement) {
                imageArray.push(deserializedImage);
              } else {
                imageArray.push(new DataTexture(deserializedImage.data, deserializedImage.width, deserializedImage.height));
              }
            }
          }
          images[image.uuid] = new Source(imageArray);
        } else {
          const deserializedImage = deserializeImage(image.url);
          images[image.uuid] = new Source(deserializedImage);
        }
      }
    }
    return images;
  }
  async parseImagesAsync(json) {
    const scope = this;
    const images = {};
    let loader;
    async function deserializeImage(image) {
      if (typeof image === "string") {
        const url = image;
        const path = /^(\/\/)|([a-z]+:(\/\/)?)/i.test(url) ? url : scope.resourcePath + url;
        return await loader.loadAsync(path);
      } else {
        if (image.data) {
          return {
            data: getTypedArray(image.type, image.data),
            width: image.width,
            height: image.height
          };
        } else {
          return null;
        }
      }
    }
    if (json !== void 0 && json.length > 0) {
      loader = new ImageLoader(this.manager);
      loader.setCrossOrigin(this.crossOrigin);
      for (let i2 = 0, il = json.length; i2 < il; i2++) {
        const image = json[i2];
        const url = image.url;
        if (Array.isArray(url)) {
          const imageArray = [];
          for (let j = 0, jl = url.length; j < jl; j++) {
            const currentUrl = url[j];
            const deserializedImage = await deserializeImage(currentUrl);
            if (deserializedImage !== null) {
              if (deserializedImage instanceof HTMLImageElement) {
                imageArray.push(deserializedImage);
              } else {
                imageArray.push(new DataTexture(deserializedImage.data, deserializedImage.width, deserializedImage.height));
              }
            }
          }
          images[image.uuid] = new Source(imageArray);
        } else {
          const deserializedImage = await deserializeImage(image.url);
          images[image.uuid] = new Source(deserializedImage);
        }
      }
    }
    return images;
  }
  parseTextures(json, images) {
    function parseConstant(value, type) {
      if (typeof value === "number") return value;
      console.warn("THREE.ObjectLoader.parseTexture: Constant should be in numeric form.", value);
      return type[value];
    }
    const textures = {};
    if (json !== void 0) {
      for (let i2 = 0, l2 = json.length; i2 < l2; i2++) {
        const data = json[i2];
        if (data.image === void 0) {
          console.warn('THREE.ObjectLoader: No "image" specified for', data.uuid);
        }
        if (images[data.image] === void 0) {
          console.warn("THREE.ObjectLoader: Undefined image", data.image);
        }
        const source = images[data.image];
        const image = source.data;
        let texture;
        if (Array.isArray(image)) {
          texture = new CubeTexture();
          if (image.length === 6) texture.needsUpdate = true;
        } else {
          if (image && image.data) {
            texture = new DataTexture();
          } else {
            texture = new Texture();
          }
          if (image) texture.needsUpdate = true;
        }
        texture.source = source;
        texture.uuid = data.uuid;
        if (data.name !== void 0) texture.name = data.name;
        if (data.mapping !== void 0) texture.mapping = parseConstant(data.mapping, TEXTURE_MAPPING);
        if (data.channel !== void 0) texture.channel = data.channel;
        if (data.offset !== void 0) texture.offset.fromArray(data.offset);
        if (data.repeat !== void 0) texture.repeat.fromArray(data.repeat);
        if (data.center !== void 0) texture.center.fromArray(data.center);
        if (data.rotation !== void 0) texture.rotation = data.rotation;
        if (data.wrap !== void 0) {
          texture.wrapS = parseConstant(data.wrap[0], TEXTURE_WRAPPING);
          texture.wrapT = parseConstant(data.wrap[1], TEXTURE_WRAPPING);
        }
        if (data.format !== void 0) texture.format = data.format;
        if (data.internalFormat !== void 0) texture.internalFormat = data.internalFormat;
        if (data.type !== void 0) texture.type = data.type;
        if (data.colorSpace !== void 0) texture.colorSpace = data.colorSpace;
        if (data.encoding !== void 0) texture.encoding = data.encoding;
        if (data.minFilter !== void 0) texture.minFilter = parseConstant(data.minFilter, TEXTURE_FILTER);
        if (data.magFilter !== void 0) texture.magFilter = parseConstant(data.magFilter, TEXTURE_FILTER);
        if (data.anisotropy !== void 0) texture.anisotropy = data.anisotropy;
        if (data.flipY !== void 0) texture.flipY = data.flipY;
        if (data.generateMipmaps !== void 0) texture.generateMipmaps = data.generateMipmaps;
        if (data.premultiplyAlpha !== void 0) texture.premultiplyAlpha = data.premultiplyAlpha;
        if (data.unpackAlignment !== void 0) texture.unpackAlignment = data.unpackAlignment;
        if (data.compareFunction !== void 0) texture.compareFunction = data.compareFunction;
        if (data.userData !== void 0) texture.userData = data.userData;
        textures[data.uuid] = texture;
      }
    }
    return textures;
  }
  parseObject(data, geometries2, materials2, textures, animations) {
    let object;
    function getGeometry(name) {
      if (geometries2[name] === void 0) {
        console.warn("THREE.ObjectLoader: Undefined geometry", name);
      }
      return geometries2[name];
    }
    function getMaterial(name) {
      if (name === void 0) return void 0;
      if (Array.isArray(name)) {
        const array = [];
        for (let i2 = 0, l2 = name.length; i2 < l2; i2++) {
          const uuid = name[i2];
          if (materials2[uuid] === void 0) {
            console.warn("THREE.ObjectLoader: Undefined material", uuid);
          }
          array.push(materials2[uuid]);
        }
        return array;
      }
      if (materials2[name] === void 0) {
        console.warn("THREE.ObjectLoader: Undefined material", name);
      }
      return materials2[name];
    }
    function getTexture(uuid) {
      if (textures[uuid] === void 0) {
        console.warn("THREE.ObjectLoader: Undefined texture", uuid);
      }
      return textures[uuid];
    }
    let geometry, material;
    switch (data.type) {
      case "Scene":
        object = new Scene();
        if (data.background !== void 0) {
          if (Number.isInteger(data.background)) {
            object.background = new Color(data.background);
          } else {
            object.background = getTexture(data.background);
          }
        }
        if (data.environment !== void 0) {
          object.environment = getTexture(data.environment);
        }
        if (data.fog !== void 0) {
          if (data.fog.type === "Fog") {
            object.fog = new Fog(data.fog.color, data.fog.near, data.fog.far);
          } else if (data.fog.type === "FogExp2") {
            object.fog = new FogExp2(data.fog.color, data.fog.density);
          }
        }
        if (data.backgroundBlurriness !== void 0) object.backgroundBlurriness = data.backgroundBlurriness;
        if (data.backgroundIntensity !== void 0) object.backgroundIntensity = data.backgroundIntensity;
        break;
      case "PerspectiveCamera":
        object = new PerspectiveCamera(data.fov, data.aspect, data.near, data.far);
        if (data.focus !== void 0) object.focus = data.focus;
        if (data.zoom !== void 0) object.zoom = data.zoom;
        if (data.filmGauge !== void 0) object.filmGauge = data.filmGauge;
        if (data.filmOffset !== void 0) object.filmOffset = data.filmOffset;
        if (data.view !== void 0) object.view = Object.assign({}, data.view);
        break;
      case "OrthographicCamera":
        object = new OrthographicCamera(data.left, data.right, data.top, data.bottom, data.near, data.far);
        if (data.zoom !== void 0) object.zoom = data.zoom;
        if (data.view !== void 0) object.view = Object.assign({}, data.view);
        break;
      case "AmbientLight":
        object = new AmbientLight(data.color, data.intensity);
        break;
      case "DirectionalLight":
        object = new DirectionalLight(data.color, data.intensity);
        break;
      case "PointLight":
        object = new PointLight(data.color, data.intensity, data.distance, data.decay);
        break;
      case "RectAreaLight":
        object = new RectAreaLight(data.color, data.intensity, data.width, data.height);
        break;
      case "SpotLight":
        object = new SpotLight(data.color, data.intensity, data.distance, data.angle, data.penumbra, data.decay);
        break;
      case "HemisphereLight":
        object = new HemisphereLight(data.color, data.groundColor, data.intensity);
        break;
      case "LightProbe":
        object = new LightProbe().fromJSON(data);
        break;
      case "SkinnedMesh":
        geometry = getGeometry(data.geometry);
        material = getMaterial(data.material);
        object = new SkinnedMesh(geometry, material);
        if (data.bindMode !== void 0) object.bindMode = data.bindMode;
        if (data.bindMatrix !== void 0) object.bindMatrix.fromArray(data.bindMatrix);
        if (data.skeleton !== void 0) object.skeleton = data.skeleton;
        break;
      case "Mesh":
        geometry = getGeometry(data.geometry);
        material = getMaterial(data.material);
        object = new Mesh(geometry, material);
        break;
      case "InstancedMesh":
        geometry = getGeometry(data.geometry);
        material = getMaterial(data.material);
        const count = data.count;
        const instanceMatrix = data.instanceMatrix;
        const instanceColor = data.instanceColor;
        object = new InstancedMesh(geometry, material, count);
        object.instanceMatrix = new InstancedBufferAttribute(new Float32Array(instanceMatrix.array), 16);
        if (instanceColor !== void 0) object.instanceColor = new InstancedBufferAttribute(new Float32Array(instanceColor.array), instanceColor.itemSize);
        break;
      case "LOD":
        object = new LOD();
        break;
      case "Line":
        object = new Line(getGeometry(data.geometry), getMaterial(data.material));
        break;
      case "LineLoop":
        object = new LineLoop(getGeometry(data.geometry), getMaterial(data.material));
        break;
      case "LineSegments":
        object = new LineSegments(getGeometry(data.geometry), getMaterial(data.material));
        break;
      case "PointCloud":
      case "Points":
        object = new Points(getGeometry(data.geometry), getMaterial(data.material));
        break;
      case "Sprite":
        object = new Sprite(getMaterial(data.material));
        break;
      case "Group":
        object = new Group();
        break;
      case "Bone":
        object = new Bone();
        break;
      default:
        object = new Object3D();
    }
    object.uuid = data.uuid;
    if (data.name !== void 0) object.name = data.name;
    if (data.matrix !== void 0) {
      object.matrix.fromArray(data.matrix);
      if (data.matrixAutoUpdate !== void 0) object.matrixAutoUpdate = data.matrixAutoUpdate;
      if (object.matrixAutoUpdate) object.matrix.decompose(object.position, object.quaternion, object.scale);
    } else {
      if (data.position !== void 0) object.position.fromArray(data.position);
      if (data.rotation !== void 0) object.rotation.fromArray(data.rotation);
      if (data.quaternion !== void 0) object.quaternion.fromArray(data.quaternion);
      if (data.scale !== void 0) object.scale.fromArray(data.scale);
    }
    if (data.up !== void 0) object.up.fromArray(data.up);
    if (data.castShadow !== void 0) object.castShadow = data.castShadow;
    if (data.receiveShadow !== void 0) object.receiveShadow = data.receiveShadow;
    if (data.shadow) {
      if (data.shadow.bias !== void 0) object.shadow.bias = data.shadow.bias;
      if (data.shadow.normalBias !== void 0) object.shadow.normalBias = data.shadow.normalBias;
      if (data.shadow.radius !== void 0) object.shadow.radius = data.shadow.radius;
      if (data.shadow.mapSize !== void 0) object.shadow.mapSize.fromArray(data.shadow.mapSize);
      if (data.shadow.camera !== void 0) object.shadow.camera = this.parseObject(data.shadow.camera);
    }
    if (data.visible !== void 0) object.visible = data.visible;
    if (data.frustumCulled !== void 0) object.frustumCulled = data.frustumCulled;
    if (data.renderOrder !== void 0) object.renderOrder = data.renderOrder;
    if (data.userData !== void 0) object.userData = data.userData;
    if (data.layers !== void 0) object.layers.mask = data.layers;
    if (data.children !== void 0) {
      const children = data.children;
      for (let i2 = 0; i2 < children.length; i2++) {
        object.add(this.parseObject(children[i2], geometries2, materials2, textures, animations));
      }
    }
    if (data.animations !== void 0) {
      const objectAnimations = data.animations;
      for (let i2 = 0; i2 < objectAnimations.length; i2++) {
        const uuid = objectAnimations[i2];
        object.animations.push(animations[uuid]);
      }
    }
    if (data.type === "LOD") {
      if (data.autoUpdate !== void 0) object.autoUpdate = data.autoUpdate;
      const levels = data.levels;
      for (let l2 = 0; l2 < levels.length; l2++) {
        const level = levels[l2];
        const child = object.getObjectByProperty("uuid", level.object);
        if (child !== void 0) {
          object.addLevel(child, level.distance, level.hysteresis);
        }
      }
    }
    return object;
  }
  bindSkeletons(object, skeletons) {
    if (Object.keys(skeletons).length === 0) return;
    object.traverse(function(child) {
      if (child.isSkinnedMesh === true && child.skeleton !== void 0) {
        const skeleton = skeletons[child.skeleton];
        if (skeleton === void 0) {
          console.warn("THREE.ObjectLoader: No skeleton found with UUID:", child.skeleton);
        } else {
          child.bind(skeleton, child.bindMatrix);
        }
      }
    });
  }
};
var TEXTURE_MAPPING = {
  UVMapping,
  CubeReflectionMapping,
  CubeRefractionMapping,
  EquirectangularReflectionMapping,
  EquirectangularRefractionMapping,
  CubeUVReflectionMapping
};
var TEXTURE_WRAPPING = {
  RepeatWrapping,
  ClampToEdgeWrapping,
  MirroredRepeatWrapping
};
var TEXTURE_FILTER = {
  NearestFilter,
  NearestMipmapNearestFilter,
  NearestMipmapLinearFilter,
  LinearFilter,
  LinearMipmapNearestFilter,
  LinearMipmapLinearFilter
};
var ImageBitmapLoader = class extends Loader {
  constructor(manager) {
    super(manager);
    this.isImageBitmapLoader = true;
    if (typeof createImageBitmap === "undefined") {
      console.warn("THREE.ImageBitmapLoader: createImageBitmap() not supported.");
    }
    if (typeof fetch === "undefined") {
      console.warn("THREE.ImageBitmapLoader: fetch() not supported.");
    }
    this.options = { premultiplyAlpha: "none" };
  }
  setOptions(options2) {
    this.options = options2;
    return this;
  }
  load(url, onLoad, onProgress, onError) {
    if (url === void 0) url = "";
    if (this.path !== void 0) url = this.path + url;
    url = this.manager.resolveURL(url);
    const scope = this;
    const cached = Cache.get(url);
    if (cached !== void 0) {
      scope.manager.itemStart(url);
      setTimeout(function() {
        if (onLoad) onLoad(cached);
        scope.manager.itemEnd(url);
      }, 0);
      return cached;
    }
    const fetchOptions = {};
    fetchOptions.credentials = this.crossOrigin === "anonymous" ? "same-origin" : "include";
    fetchOptions.headers = this.requestHeader;
    fetch(url, fetchOptions).then(function(res) {
      return res.blob();
    }).then(function(blob) {
      return createImageBitmap(blob, Object.assign(scope.options, { colorSpaceConversion: "none" }));
    }).then(function(imageBitmap) {
      Cache.add(url, imageBitmap);
      if (onLoad) onLoad(imageBitmap);
      scope.manager.itemEnd(url);
    }).catch(function(e2) {
      if (onError) onError(e2);
      scope.manager.itemError(url);
      scope.manager.itemEnd(url);
    });
    scope.manager.itemStart(url);
  }
};
var _context;
var AudioContext = class {
  static getContext() {
    if (_context === void 0) {
      _context = new (window.AudioContext || window.webkitAudioContext)();
    }
    return _context;
  }
  static setContext(value) {
    _context = value;
  }
};
var AudioLoader = class extends Loader {
  constructor(manager) {
    super(manager);
  }
  load(url, onLoad, onProgress, onError) {
    const scope = this;
    const loader = new FileLoader(this.manager);
    loader.setResponseType("arraybuffer");
    loader.setPath(this.path);
    loader.setRequestHeader(this.requestHeader);
    loader.setWithCredentials(this.withCredentials);
    loader.load(url, function(buffer) {
      try {
        const bufferCopy = buffer.slice(0);
        const context = AudioContext.getContext();
        context.decodeAudioData(bufferCopy, function(audioBuffer) {
          onLoad(audioBuffer);
        }, handleError);
      } catch (e2) {
        handleError(e2);
      }
    }, onProgress, onError);
    function handleError(e2) {
      if (onError) {
        onError(e2);
      } else {
        console.error(e2);
      }
      scope.manager.itemError(url);
    }
  }
};
var HemisphereLightProbe = class extends LightProbe {
  constructor(skyColor, groundColor, intensity = 1) {
    super(void 0, intensity);
    this.isHemisphereLightProbe = true;
    const color1 = new Color().set(skyColor);
    const color2 = new Color().set(groundColor);
    const sky = new Vector3(color1.r, color1.g, color1.b);
    const ground = new Vector3(color2.r, color2.g, color2.b);
    const c0 = Math.sqrt(Math.PI);
    const c1 = c0 * Math.sqrt(0.75);
    this.sh.coefficients[0].copy(sky).add(ground).multiplyScalar(c0);
    this.sh.coefficients[1].copy(sky).sub(ground).multiplyScalar(c1);
  }
};
var AmbientLightProbe = class extends LightProbe {
  constructor(color, intensity = 1) {
    super(void 0, intensity);
    this.isAmbientLightProbe = true;
    const color1 = new Color().set(color);
    this.sh.coefficients[0].set(color1.r, color1.g, color1.b).multiplyScalar(2 * Math.sqrt(Math.PI));
  }
};
var _eyeRight = new Matrix4();
var _eyeLeft = new Matrix4();
var _projectionMatrix = new Matrix4();
var StereoCamera = class {
  constructor() {
    this.type = "StereoCamera";
    this.aspect = 1;
    this.eyeSep = 0.064;
    this.cameraL = new PerspectiveCamera();
    this.cameraL.layers.enable(1);
    this.cameraL.matrixAutoUpdate = false;
    this.cameraR = new PerspectiveCamera();
    this.cameraR.layers.enable(2);
    this.cameraR.matrixAutoUpdate = false;
    this._cache = {
      focus: null,
      fov: null,
      aspect: null,
      near: null,
      far: null,
      zoom: null,
      eyeSep: null
    };
  }
  update(camera) {
    const cache = this._cache;
    const needsUpdate = cache.focus !== camera.focus || cache.fov !== camera.fov || cache.aspect !== camera.aspect * this.aspect || cache.near !== camera.near || cache.far !== camera.far || cache.zoom !== camera.zoom || cache.eyeSep !== this.eyeSep;
    if (needsUpdate) {
      cache.focus = camera.focus;
      cache.fov = camera.fov;
      cache.aspect = camera.aspect * this.aspect;
      cache.near = camera.near;
      cache.far = camera.far;
      cache.zoom = camera.zoom;
      cache.eyeSep = this.eyeSep;
      _projectionMatrix.copy(camera.projectionMatrix);
      const eyeSepHalf = cache.eyeSep / 2;
      const eyeSepOnProjection = eyeSepHalf * cache.near / cache.focus;
      const ymax = cache.near * Math.tan(DEG2RAD * cache.fov * 0.5) / cache.zoom;
      let xmin, xmax;
      _eyeLeft.elements[12] = -eyeSepHalf;
      _eyeRight.elements[12] = eyeSepHalf;
      xmin = -ymax * cache.aspect + eyeSepOnProjection;
      xmax = ymax * cache.aspect + eyeSepOnProjection;
      _projectionMatrix.elements[0] = 2 * cache.near / (xmax - xmin);
      _projectionMatrix.elements[8] = (xmax + xmin) / (xmax - xmin);
      this.cameraL.projectionMatrix.copy(_projectionMatrix);
      xmin = -ymax * cache.aspect - eyeSepOnProjection;
      xmax = ymax * cache.aspect - eyeSepOnProjection;
      _projectionMatrix.elements[0] = 2 * cache.near / (xmax - xmin);
      _projectionMatrix.elements[8] = (xmax + xmin) / (xmax - xmin);
      this.cameraR.projectionMatrix.copy(_projectionMatrix);
    }
    this.cameraL.matrixWorld.copy(camera.matrixWorld).multiply(_eyeLeft);
    this.cameraR.matrixWorld.copy(camera.matrixWorld).multiply(_eyeRight);
  }
};
var Clock = class {
  constructor(autoStart = true) {
    this.autoStart = autoStart;
    this.startTime = 0;
    this.oldTime = 0;
    this.elapsedTime = 0;
    this.running = false;
  }
  start() {
    this.startTime = now();
    this.oldTime = this.startTime;
    this.elapsedTime = 0;
    this.running = true;
  }
  stop() {
    this.getElapsedTime();
    this.running = false;
    this.autoStart = false;
  }
  getElapsedTime() {
    this.getDelta();
    return this.elapsedTime;
  }
  getDelta() {
    let diff = 0;
    if (this.autoStart && !this.running) {
      this.start();
      return 0;
    }
    if (this.running) {
      const newTime = now();
      diff = (newTime - this.oldTime) / 1e3;
      this.oldTime = newTime;
      this.elapsedTime += diff;
    }
    return diff;
  }
};
function now() {
  return (typeof performance === "undefined" ? Date : performance).now();
}
var _position$1 = new Vector3();
var _quaternion$1 = new Quaternion();
var _scale$1 = new Vector3();
var _orientation$1 = new Vector3();
var AudioListener = class extends Object3D {
  constructor() {
    super();
    this.type = "AudioListener";
    this.context = AudioContext.getContext();
    this.gain = this.context.createGain();
    this.gain.connect(this.context.destination);
    this.filter = null;
    this.timeDelta = 0;
    this._clock = new Clock();
  }
  getInput() {
    return this.gain;
  }
  removeFilter() {
    if (this.filter !== null) {
      this.gain.disconnect(this.filter);
      this.filter.disconnect(this.context.destination);
      this.gain.connect(this.context.destination);
      this.filter = null;
    }
    return this;
  }
  getFilter() {
    return this.filter;
  }
  setFilter(value) {
    if (this.filter !== null) {
      this.gain.disconnect(this.filter);
      this.filter.disconnect(this.context.destination);
    } else {
      this.gain.disconnect(this.context.destination);
    }
    this.filter = value;
    this.gain.connect(this.filter);
    this.filter.connect(this.context.destination);
    return this;
  }
  getMasterVolume() {
    return this.gain.gain.value;
  }
  setMasterVolume(value) {
    this.gain.gain.setTargetAtTime(value, this.context.currentTime, 0.01);
    return this;
  }
  updateMatrixWorld(force) {
    super.updateMatrixWorld(force);
    const listener = this.context.listener;
    const up = this.up;
    this.timeDelta = this._clock.getDelta();
    this.matrixWorld.decompose(_position$1, _quaternion$1, _scale$1);
    _orientation$1.set(0, 0, -1).applyQuaternion(_quaternion$1);
    if (listener.positionX) {
      const endTime = this.context.currentTime + this.timeDelta;
      listener.positionX.linearRampToValueAtTime(_position$1.x, endTime);
      listener.positionY.linearRampToValueAtTime(_position$1.y, endTime);
      listener.positionZ.linearRampToValueAtTime(_position$1.z, endTime);
      listener.forwardX.linearRampToValueAtTime(_orientation$1.x, endTime);
      listener.forwardY.linearRampToValueAtTime(_orientation$1.y, endTime);
      listener.forwardZ.linearRampToValueAtTime(_orientation$1.z, endTime);
      listener.upX.linearRampToValueAtTime(up.x, endTime);
      listener.upY.linearRampToValueAtTime(up.y, endTime);
      listener.upZ.linearRampToValueAtTime(up.z, endTime);
    } else {
      listener.setPosition(_position$1.x, _position$1.y, _position$1.z);
      listener.setOrientation(_orientation$1.x, _orientation$1.y, _orientation$1.z, up.x, up.y, up.z);
    }
  }
};
var Audio = class extends Object3D {
  constructor(listener) {
    super();
    this.type = "Audio";
    this.listener = listener;
    this.context = listener.context;
    this.gain = this.context.createGain();
    this.gain.connect(listener.getInput());
    this.autoplay = false;
    this.buffer = null;
    this.detune = 0;
    this.loop = false;
    this.loopStart = 0;
    this.loopEnd = 0;
    this.offset = 0;
    this.duration = void 0;
    this.playbackRate = 1;
    this.isPlaying = false;
    this.hasPlaybackControl = true;
    this.source = null;
    this.sourceType = "empty";
    this._startedAt = 0;
    this._progress = 0;
    this._connected = false;
    this.filters = [];
  }
  getOutput() {
    return this.gain;
  }
  setNodeSource(audioNode) {
    this.hasPlaybackControl = false;
    this.sourceType = "audioNode";
    this.source = audioNode;
    this.connect();
    return this;
  }
  setMediaElementSource(mediaElement) {
    this.hasPlaybackControl = false;
    this.sourceType = "mediaNode";
    this.source = this.context.createMediaElementSource(mediaElement);
    this.connect();
    return this;
  }
  setMediaStreamSource(mediaStream) {
    this.hasPlaybackControl = false;
    this.sourceType = "mediaStreamNode";
    this.source = this.context.createMediaStreamSource(mediaStream);
    this.connect();
    return this;
  }
  setBuffer(audioBuffer) {
    this.buffer = audioBuffer;
    this.sourceType = "buffer";
    if (this.autoplay) this.play();
    return this;
  }
  play(delay = 0) {
    if (this.isPlaying === true) {
      console.warn("THREE.Audio: Audio is already playing.");
      return;
    }
    if (this.hasPlaybackControl === false) {
      console.warn("THREE.Audio: this Audio has no playback control.");
      return;
    }
    this._startedAt = this.context.currentTime + delay;
    const source = this.context.createBufferSource();
    source.buffer = this.buffer;
    source.loop = this.loop;
    source.loopStart = this.loopStart;
    source.loopEnd = this.loopEnd;
    source.onended = this.onEnded.bind(this);
    source.start(this._startedAt, this._progress + this.offset, this.duration);
    this.isPlaying = true;
    this.source = source;
    this.setDetune(this.detune);
    this.setPlaybackRate(this.playbackRate);
    return this.connect();
  }
  pause() {
    if (this.hasPlaybackControl === false) {
      console.warn("THREE.Audio: this Audio has no playback control.");
      return;
    }
    if (this.isPlaying === true) {
      this._progress += Math.max(this.context.currentTime - this._startedAt, 0) * this.playbackRate;
      if (this.loop === true) {
        this._progress = this._progress % (this.duration || this.buffer.duration);
      }
      this.source.stop();
      this.source.onended = null;
      this.isPlaying = false;
    }
    return this;
  }
  stop() {
    if (this.hasPlaybackControl === false) {
      console.warn("THREE.Audio: this Audio has no playback control.");
      return;
    }
    this._progress = 0;
    if (this.source !== null) {
      this.source.stop();
      this.source.onended = null;
    }
    this.isPlaying = false;
    return this;
  }
  connect() {
    if (this.filters.length > 0) {
      this.source.connect(this.filters[0]);
      for (let i2 = 1, l2 = this.filters.length; i2 < l2; i2++) {
        this.filters[i2 - 1].connect(this.filters[i2]);
      }
      this.filters[this.filters.length - 1].connect(this.getOutput());
    } else {
      this.source.connect(this.getOutput());
    }
    this._connected = true;
    return this;
  }
  disconnect() {
    if (this.filters.length > 0) {
      this.source.disconnect(this.filters[0]);
      for (let i2 = 1, l2 = this.filters.length; i2 < l2; i2++) {
        this.filters[i2 - 1].disconnect(this.filters[i2]);
      }
      this.filters[this.filters.length - 1].disconnect(this.getOutput());
    } else {
      this.source.disconnect(this.getOutput());
    }
    this._connected = false;
    return this;
  }
  getFilters() {
    return this.filters;
  }
  setFilters(value) {
    if (!value) value = [];
    if (this._connected === true) {
      this.disconnect();
      this.filters = value.slice();
      this.connect();
    } else {
      this.filters = value.slice();
    }
    return this;
  }
  setDetune(value) {
    this.detune = value;
    if (this.source.detune === void 0) return;
    if (this.isPlaying === true) {
      this.source.detune.setTargetAtTime(this.detune, this.context.currentTime, 0.01);
    }
    return this;
  }
  getDetune() {
    return this.detune;
  }
  getFilter() {
    return this.getFilters()[0];
  }
  setFilter(filter) {
    return this.setFilters(filter ? [filter] : []);
  }
  setPlaybackRate(value) {
    if (this.hasPlaybackControl === false) {
      console.warn("THREE.Audio: this Audio has no playback control.");
      return;
    }
    this.playbackRate = value;
    if (this.isPlaying === true) {
      this.source.playbackRate.setTargetAtTime(this.playbackRate, this.context.currentTime, 0.01);
    }
    return this;
  }
  getPlaybackRate() {
    return this.playbackRate;
  }
  onEnded() {
    this.isPlaying = false;
  }
  getLoop() {
    if (this.hasPlaybackControl === false) {
      console.warn("THREE.Audio: this Audio has no playback control.");
      return false;
    }
    return this.loop;
  }
  setLoop(value) {
    if (this.hasPlaybackControl === false) {
      console.warn("THREE.Audio: this Audio has no playback control.");
      return;
    }
    this.loop = value;
    if (this.isPlaying === true) {
      this.source.loop = this.loop;
    }
    return this;
  }
  setLoopStart(value) {
    this.loopStart = value;
    return this;
  }
  setLoopEnd(value) {
    this.loopEnd = value;
    return this;
  }
  getVolume() {
    return this.gain.gain.value;
  }
  setVolume(value) {
    this.gain.gain.setTargetAtTime(value, this.context.currentTime, 0.01);
    return this;
  }
};
var _position = new Vector3();
var _quaternion = new Quaternion();
var _scale = new Vector3();
var _orientation = new Vector3();
var PositionalAudio = class extends Audio {
  constructor(listener) {
    super(listener);
    this.panner = this.context.createPanner();
    this.panner.panningModel = "HRTF";
    this.panner.connect(this.gain);
  }
  connect() {
    super.connect();
    this.panner.connect(this.gain);
  }
  disconnect() {
    super.disconnect();
    this.panner.disconnect(this.gain);
  }
  getOutput() {
    return this.panner;
  }
  getRefDistance() {
    return this.panner.refDistance;
  }
  setRefDistance(value) {
    this.panner.refDistance = value;
    return this;
  }
  getRolloffFactor() {
    return this.panner.rolloffFactor;
  }
  setRolloffFactor(value) {
    this.panner.rolloffFactor = value;
    return this;
  }
  getDistanceModel() {
    return this.panner.distanceModel;
  }
  setDistanceModel(value) {
    this.panner.distanceModel = value;
    return this;
  }
  getMaxDistance() {
    return this.panner.maxDistance;
  }
  setMaxDistance(value) {
    this.panner.maxDistance = value;
    return this;
  }
  setDirectionalCone(coneInnerAngle, coneOuterAngle, coneOuterGain) {
    this.panner.coneInnerAngle = coneInnerAngle;
    this.panner.coneOuterAngle = coneOuterAngle;
    this.panner.coneOuterGain = coneOuterGain;
    return this;
  }
  updateMatrixWorld(force) {
    super.updateMatrixWorld(force);
    if (this.hasPlaybackControl === true && this.isPlaying === false) return;
    this.matrixWorld.decompose(_position, _quaternion, _scale);
    _orientation.set(0, 0, 1).applyQuaternion(_quaternion);
    const panner = this.panner;
    if (panner.positionX) {
      const endTime = this.context.currentTime + this.listener.timeDelta;
      panner.positionX.linearRampToValueAtTime(_position.x, endTime);
      panner.positionY.linearRampToValueAtTime(_position.y, endTime);
      panner.positionZ.linearRampToValueAtTime(_position.z, endTime);
      panner.orientationX.linearRampToValueAtTime(_orientation.x, endTime);
      panner.orientationY.linearRampToValueAtTime(_orientation.y, endTime);
      panner.orientationZ.linearRampToValueAtTime(_orientation.z, endTime);
    } else {
      panner.setPosition(_position.x, _position.y, _position.z);
      panner.setOrientation(_orientation.x, _orientation.y, _orientation.z);
    }
  }
};
var AudioAnalyser = class {
  constructor(audio, fftSize = 2048) {
    this.analyser = audio.context.createAnalyser();
    this.analyser.fftSize = fftSize;
    this.data = new Uint8Array(this.analyser.frequencyBinCount);
    audio.getOutput().connect(this.analyser);
  }
  getFrequencyData() {
    this.analyser.getByteFrequencyData(this.data);
    return this.data;
  }
  getAverageFrequency() {
    let value = 0;
    const data = this.getFrequencyData();
    for (let i2 = 0; i2 < data.length; i2++) {
      value += data[i2];
    }
    return value / data.length;
  }
};
var PropertyMixer = class {
  constructor(binding, typeName, valueSize) {
    this.binding = binding;
    this.valueSize = valueSize;
    let mixFunction, mixFunctionAdditive, setIdentity;
    switch (typeName) {
      case "quaternion":
        mixFunction = this._slerp;
        mixFunctionAdditive = this._slerpAdditive;
        setIdentity = this._setAdditiveIdentityQuaternion;
        this.buffer = new Float64Array(valueSize * 6);
        this._workIndex = 5;
        break;
      case "string":
      case "bool":
        mixFunction = this._select;
        mixFunctionAdditive = this._select;
        setIdentity = this._setAdditiveIdentityOther;
        this.buffer = new Array(valueSize * 5);
        break;
      default:
        mixFunction = this._lerp;
        mixFunctionAdditive = this._lerpAdditive;
        setIdentity = this._setAdditiveIdentityNumeric;
        this.buffer = new Float64Array(valueSize * 5);
    }
    this._mixBufferRegion = mixFunction;
    this._mixBufferRegionAdditive = mixFunctionAdditive;
    this._setIdentity = setIdentity;
    this._origIndex = 3;
    this._addIndex = 4;
    this.cumulativeWeight = 0;
    this.cumulativeWeightAdditive = 0;
    this.useCount = 0;
    this.referenceCount = 0;
  }
  // accumulate data in the 'incoming' region into 'accu<i>'
  accumulate(accuIndex, weight) {
    const buffer = this.buffer, stride = this.valueSize, offset = accuIndex * stride + stride;
    let currentWeight = this.cumulativeWeight;
    if (currentWeight === 0) {
      for (let i2 = 0; i2 !== stride; ++i2) {
        buffer[offset + i2] = buffer[i2];
      }
      currentWeight = weight;
    } else {
      currentWeight += weight;
      const mix = weight / currentWeight;
      this._mixBufferRegion(buffer, offset, 0, mix, stride);
    }
    this.cumulativeWeight = currentWeight;
  }
  // accumulate data in the 'incoming' region into 'add'
  accumulateAdditive(weight) {
    const buffer = this.buffer, stride = this.valueSize, offset = stride * this._addIndex;
    if (this.cumulativeWeightAdditive === 0) {
      this._setIdentity();
    }
    this._mixBufferRegionAdditive(buffer, offset, 0, weight, stride);
    this.cumulativeWeightAdditive += weight;
  }
  // apply the state of 'accu<i>' to the binding when accus differ
  apply(accuIndex) {
    const stride = this.valueSize, buffer = this.buffer, offset = accuIndex * stride + stride, weight = this.cumulativeWeight, weightAdditive = this.cumulativeWeightAdditive, binding = this.binding;
    this.cumulativeWeight = 0;
    this.cumulativeWeightAdditive = 0;
    if (weight < 1) {
      const originalValueOffset = stride * this._origIndex;
      this._mixBufferRegion(
        buffer,
        offset,
        originalValueOffset,
        1 - weight,
        stride
      );
    }
    if (weightAdditive > 0) {
      this._mixBufferRegionAdditive(buffer, offset, this._addIndex * stride, 1, stride);
    }
    for (let i2 = stride, e2 = stride + stride; i2 !== e2; ++i2) {
      if (buffer[i2] !== buffer[i2 + stride]) {
        binding.setValue(buffer, offset);
        break;
      }
    }
  }
  // remember the state of the bound property and copy it to both accus
  saveOriginalState() {
    const binding = this.binding;
    const buffer = this.buffer, stride = this.valueSize, originalValueOffset = stride * this._origIndex;
    binding.getValue(buffer, originalValueOffset);
    for (let i2 = stride, e2 = originalValueOffset; i2 !== e2; ++i2) {
      buffer[i2] = buffer[originalValueOffset + i2 % stride];
    }
    this._setIdentity();
    this.cumulativeWeight = 0;
    this.cumulativeWeightAdditive = 0;
  }
  // apply the state previously taken via 'saveOriginalState' to the binding
  restoreOriginalState() {
    const originalValueOffset = this.valueSize * 3;
    this.binding.setValue(this.buffer, originalValueOffset);
  }
  _setAdditiveIdentityNumeric() {
    const startIndex = this._addIndex * this.valueSize;
    const endIndex = startIndex + this.valueSize;
    for (let i2 = startIndex; i2 < endIndex; i2++) {
      this.buffer[i2] = 0;
    }
  }
  _setAdditiveIdentityQuaternion() {
    this._setAdditiveIdentityNumeric();
    this.buffer[this._addIndex * this.valueSize + 3] = 1;
  }
  _setAdditiveIdentityOther() {
    const startIndex = this._origIndex * this.valueSize;
    const targetIndex = this._addIndex * this.valueSize;
    for (let i2 = 0; i2 < this.valueSize; i2++) {
      this.buffer[targetIndex + i2] = this.buffer[startIndex + i2];
    }
  }
  // mix functions
  _select(buffer, dstOffset, srcOffset, t2, stride) {
    if (t2 >= 0.5) {
      for (let i2 = 0; i2 !== stride; ++i2) {
        buffer[dstOffset + i2] = buffer[srcOffset + i2];
      }
    }
  }
  _slerp(buffer, dstOffset, srcOffset, t2) {
    Quaternion.slerpFlat(buffer, dstOffset, buffer, dstOffset, buffer, srcOffset, t2);
  }
  _slerpAdditive(buffer, dstOffset, srcOffset, t2, stride) {
    const workOffset = this._workIndex * stride;
    Quaternion.multiplyQuaternionsFlat(buffer, workOffset, buffer, dstOffset, buffer, srcOffset);
    Quaternion.slerpFlat(buffer, dstOffset, buffer, dstOffset, buffer, workOffset, t2);
  }
  _lerp(buffer, dstOffset, srcOffset, t2, stride) {
    const s2 = 1 - t2;
    for (let i2 = 0; i2 !== stride; ++i2) {
      const j = dstOffset + i2;
      buffer[j] = buffer[j] * s2 + buffer[srcOffset + i2] * t2;
    }
  }
  _lerpAdditive(buffer, dstOffset, srcOffset, t2, stride) {
    for (let i2 = 0; i2 !== stride; ++i2) {
      const j = dstOffset + i2;
      buffer[j] = buffer[j] + buffer[srcOffset + i2] * t2;
    }
  }
};
var _RESERVED_CHARS_RE = "\\[\\]\\.:\\/";
var _reservedRe = new RegExp("[" + _RESERVED_CHARS_RE + "]", "g");
var _wordChar = "[^" + _RESERVED_CHARS_RE + "]";
var _wordCharOrDot = "[^" + _RESERVED_CHARS_RE.replace("\\.", "") + "]";
var _directoryRe = /((?:WC+[\/:])*)/.source.replace("WC", _wordChar);
var _nodeRe = /(WCOD+)?/.source.replace("WCOD", _wordCharOrDot);
var _objectRe = /(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace("WC", _wordChar);
var _propertyRe = /\.(WC+)(?:\[(.+)\])?/.source.replace("WC", _wordChar);
var _trackRe = new RegExp(
  "^" + _directoryRe + _nodeRe + _objectRe + _propertyRe + "$"
);
var _supportedObjectNames = ["material", "materials", "bones", "map"];
var Composite = class {
  constructor(targetGroup, path, optionalParsedPath) {
    const parsedPath = optionalParsedPath || PropertyBinding.parseTrackName(path);
    this._targetGroup = targetGroup;
    this._bindings = targetGroup.subscribe_(path, parsedPath);
  }
  getValue(array, offset) {
    this.bind();
    const firstValidIndex = this._targetGroup.nCachedObjects_, binding = this._bindings[firstValidIndex];
    if (binding !== void 0) binding.getValue(array, offset);
  }
  setValue(array, offset) {
    const bindings = this._bindings;
    for (let i2 = this._targetGroup.nCachedObjects_, n = bindings.length; i2 !== n; ++i2) {
      bindings[i2].setValue(array, offset);
    }
  }
  bind() {
    const bindings = this._bindings;
    for (let i2 = this._targetGroup.nCachedObjects_, n = bindings.length; i2 !== n; ++i2) {
      bindings[i2].bind();
    }
  }
  unbind() {
    const bindings = this._bindings;
    for (let i2 = this._targetGroup.nCachedObjects_, n = bindings.length; i2 !== n; ++i2) {
      bindings[i2].unbind();
    }
  }
};
var PropertyBinding = class _PropertyBinding {
  constructor(rootNode, path, parsedPath) {
    this.path = path;
    this.parsedPath = parsedPath || _PropertyBinding.parseTrackName(path);
    this.node = _PropertyBinding.findNode(rootNode, this.parsedPath.nodeName);
    this.rootNode = rootNode;
    this.getValue = this._getValue_unbound;
    this.setValue = this._setValue_unbound;
  }
  static create(root, path, parsedPath) {
    if (!(root && root.isAnimationObjectGroup)) {
      return new _PropertyBinding(root, path, parsedPath);
    } else {
      return new _PropertyBinding.Composite(root, path, parsedPath);
    }
  }
  /**
   * Replaces spaces with underscores and removes unsupported characters from
   * node names, to ensure compatibility with parseTrackName().
   *
   * @param {string} name Node name to be sanitized.
   * @return {string}
   */
  static sanitizeNodeName(name) {
    return name.replace(/\s/g, "_").replace(_reservedRe, "");
  }
  static parseTrackName(trackName) {
    const matches = _trackRe.exec(trackName);
    if (matches === null) {
      throw new Error("PropertyBinding: Cannot parse trackName: " + trackName);
    }
    const results = {
      // directoryName: matches[ 1 ], // (tschw) currently unused
      nodeName: matches[2],
      objectName: matches[3],
      objectIndex: matches[4],
      propertyName: matches[5],
      // required
      propertyIndex: matches[6]
    };
    const lastDot = results.nodeName && results.nodeName.lastIndexOf(".");
    if (lastDot !== void 0 && lastDot !== -1) {
      const objectName = results.nodeName.substring(lastDot + 1);
      if (_supportedObjectNames.indexOf(objectName) !== -1) {
        results.nodeName = results.nodeName.substring(0, lastDot);
        results.objectName = objectName;
      }
    }
    if (results.propertyName === null || results.propertyName.length === 0) {
      throw new Error("PropertyBinding: can not parse propertyName from trackName: " + trackName);
    }
    return results;
  }
  static findNode(root, nodeName) {
    if (nodeName === void 0 || nodeName === "" || nodeName === "." || nodeName === -1 || nodeName === root.name || nodeName === root.uuid) {
      return root;
    }
    if (root.skeleton) {
      const bone = root.skeleton.getBoneByName(nodeName);
      if (bone !== void 0) {
        return bone;
      }
    }
    if (root.children) {
      const searchNodeSubtree = function(children) {
        for (let i2 = 0; i2 < children.length; i2++) {
          const childNode = children[i2];
          if (childNode.name === nodeName || childNode.uuid === nodeName) {
            return childNode;
          }
          const result = searchNodeSubtree(childNode.children);
          if (result) return result;
        }
        return null;
      };
      const subTreeNode = searchNodeSubtree(root.children);
      if (subTreeNode) {
        return subTreeNode;
      }
    }
    return null;
  }
  // these are used to "bind" a nonexistent property
  _getValue_unavailable() {
  }
  _setValue_unavailable() {
  }
  // Getters
  _getValue_direct(buffer, offset) {
    buffer[offset] = this.targetObject[this.propertyName];
  }
  _getValue_array(buffer, offset) {
    const source = this.resolvedProperty;
    for (let i2 = 0, n = source.length; i2 !== n; ++i2) {
      buffer[offset++] = source[i2];
    }
  }
  _getValue_arrayElement(buffer, offset) {
    buffer[offset] = this.resolvedProperty[this.propertyIndex];
  }
  _getValue_toArray(buffer, offset) {
    this.resolvedProperty.toArray(buffer, offset);
  }
  // Direct
  _setValue_direct(buffer, offset) {
    this.targetObject[this.propertyName] = buffer[offset];
  }
  _setValue_direct_setNeedsUpdate(buffer, offset) {
    this.targetObject[this.propertyName] = buffer[offset];
    this.targetObject.needsUpdate = true;
  }
  _setValue_direct_setMatrixWorldNeedsUpdate(buffer, offset) {
    this.targetObject[this.propertyName] = buffer[offset];
    this.targetObject.matrixWorldNeedsUpdate = true;
  }
  // EntireArray
  _setValue_array(buffer, offset) {
    const dest = this.resolvedProperty;
    for (let i2 = 0, n = dest.length; i2 !== n; ++i2) {
      dest[i2] = buffer[offset++];
    }
  }
  _setValue_array_setNeedsUpdate(buffer, offset) {
    const dest = this.resolvedProperty;
    for (let i2 = 0, n = dest.length; i2 !== n; ++i2) {
      dest[i2] = buffer[offset++];
    }
    this.targetObject.needsUpdate = true;
  }
  _setValue_array_setMatrixWorldNeedsUpdate(buffer, offset) {
    const dest = this.resolvedProperty;
    for (let i2 = 0, n = dest.length; i2 !== n; ++i2) {
      dest[i2] = buffer[offset++];
    }
    this.targetObject.matrixWorldNeedsUpdate = true;
  }
  // ArrayElement
  _setValue_arrayElement(buffer, offset) {
    this.resolvedProperty[this.propertyIndex] = buffer[offset];
  }
  _setValue_arrayElement_setNeedsUpdate(buffer, offset) {
    this.resolvedProperty[this.propertyIndex] = buffer[offset];
    this.targetObject.needsUpdate = true;
  }
  _setValue_arrayElement_setMatrixWorldNeedsUpdate(buffer, offset) {
    this.resolvedProperty[this.propertyIndex] = buffer[offset];
    this.targetObject.matrixWorldNeedsUpdate = true;
  }
  // HasToFromArray
  _setValue_fromArray(buffer, offset) {
    this.resolvedProperty.fromArray(buffer, offset);
  }
  _setValue_fromArray_setNeedsUpdate(buffer, offset) {
    this.resolvedProperty.fromArray(buffer, offset);
    this.targetObject.needsUpdate = true;
  }
  _setValue_fromArray_setMatrixWorldNeedsUpdate(buffer, offset) {
    this.resolvedProperty.fromArray(buffer, offset);
    this.targetObject.matrixWorldNeedsUpdate = true;
  }
  _getValue_unbound(targetArray, offset) {
    this.bind();
    this.getValue(targetArray, offset);
  }
  _setValue_unbound(sourceArray, offset) {
    this.bind();
    this.setValue(sourceArray, offset);
  }
  // create getter / setter pair for a property in the scene graph
  bind() {
    let targetObject = this.node;
    const parsedPath = this.parsedPath;
    const objectName = parsedPath.objectName;
    const propertyName = parsedPath.propertyName;
    let propertyIndex = parsedPath.propertyIndex;
    if (!targetObject) {
      targetObject = _PropertyBinding.findNode(this.rootNode, parsedPath.nodeName);
      this.node = targetObject;
    }
    this.getValue = this._getValue_unavailable;
    this.setValue = this._setValue_unavailable;
    if (!targetObject) {
      console.error("THREE.PropertyBinding: Trying to update node for track: " + this.path + " but it wasn't found.");
      return;
    }
    if (objectName) {
      let objectIndex = parsedPath.objectIndex;
      switch (objectName) {
        case "materials":
          if (!targetObject.material) {
            console.error("THREE.PropertyBinding: Can not bind to material as node does not have a material.", this);
            return;
          }
          if (!targetObject.material.materials) {
            console.error("THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.", this);
            return;
          }
          targetObject = targetObject.material.materials;
          break;
        case "bones":
          if (!targetObject.skeleton) {
            console.error("THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.", this);
            return;
          }
          targetObject = targetObject.skeleton.bones;
          for (let i2 = 0; i2 < targetObject.length; i2++) {
            if (targetObject[i2].name === objectIndex) {
              objectIndex = i2;
              break;
            }
          }
          break;
        case "map":
          if ("map" in targetObject) {
            targetObject = targetObject.map;
            break;
          }
          if (!targetObject.material) {
            console.error("THREE.PropertyBinding: Can not bind to material as node does not have a material.", this);
            return;
          }
          if (!targetObject.material.map) {
            console.error("THREE.PropertyBinding: Can not bind to material.map as node.material does not have a map.", this);
            return;
          }
          targetObject = targetObject.material.map;
          break;
        default:
          if (targetObject[objectName] === void 0) {
            console.error("THREE.PropertyBinding: Can not bind to objectName of node undefined.", this);
            return;
          }
          targetObject = targetObject[objectName];
      }
      if (objectIndex !== void 0) {
        if (targetObject[objectIndex] === void 0) {
          console.error("THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.", this, targetObject);
          return;
        }
        targetObject = targetObject[objectIndex];
      }
    }
    const nodeProperty = targetObject[propertyName];
    if (nodeProperty === void 0) {
      const nodeName = parsedPath.nodeName;
      console.error("THREE.PropertyBinding: Trying to update property for track: " + nodeName + "." + propertyName + " but it wasn't found.", targetObject);
      return;
    }
    let versioning = this.Versioning.None;
    this.targetObject = targetObject;
    if (targetObject.needsUpdate !== void 0) {
      versioning = this.Versioning.NeedsUpdate;
    } else if (targetObject.matrixWorldNeedsUpdate !== void 0) {
      versioning = this.Versioning.MatrixWorldNeedsUpdate;
    }
    let bindingType = this.BindingType.Direct;
    if (propertyIndex !== void 0) {
      if (propertyName === "morphTargetInfluences") {
        if (!targetObject.geometry) {
          console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.", this);
          return;
        }
        if (!targetObject.geometry.morphAttributes) {
          console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.", this);
          return;
        }
        if (targetObject.morphTargetDictionary[propertyIndex] !== void 0) {
          propertyIndex = targetObject.morphTargetDictionary[propertyIndex];
        }
      }
      bindingType = this.BindingType.ArrayElement;
      this.resolvedProperty = nodeProperty;
      this.propertyIndex = propertyIndex;
    } else if (nodeProperty.fromArray !== void 0 && nodeProperty.toArray !== void 0) {
      bindingType = this.BindingType.HasFromToArray;
      this.resolvedProperty = nodeProperty;
    } else if (Array.isArray(nodeProperty)) {
      bindingType = this.BindingType.EntireArray;
      this.resolvedProperty = nodeProperty;
    } else {
      this.propertyName = propertyName;
    }
    this.getValue = this.GetterByBindingType[bindingType];
    this.setValue = this.SetterByBindingTypeAndVersioning[bindingType][versioning];
  }
  unbind() {
    this.node = null;
    this.getValue = this._getValue_unbound;
    this.setValue = this._setValue_unbound;
  }
};
PropertyBinding.Composite = Composite;
PropertyBinding.prototype.BindingType = {
  Direct: 0,
  EntireArray: 1,
  ArrayElement: 2,
  HasFromToArray: 3
};
PropertyBinding.prototype.Versioning = {
  None: 0,
  NeedsUpdate: 1,
  MatrixWorldNeedsUpdate: 2
};
PropertyBinding.prototype.GetterByBindingType = [
  PropertyBinding.prototype._getValue_direct,
  PropertyBinding.prototype._getValue_array,
  PropertyBinding.prototype._getValue_arrayElement,
  PropertyBinding.prototype._getValue_toArray
];
PropertyBinding.prototype.SetterByBindingTypeAndVersioning = [
  [
    // Direct
    PropertyBinding.prototype._setValue_direct,
    PropertyBinding.prototype._setValue_direct_setNeedsUpdate,
    PropertyBinding.prototype._setValue_direct_setMatrixWorldNeedsUpdate
  ],
  [
    // EntireArray
    PropertyBinding.prototype._setValue_array,
    PropertyBinding.prototype._setValue_array_setNeedsUpdate,
    PropertyBinding.prototype._setValue_array_setMatrixWorldNeedsUpdate
  ],
  [
    // ArrayElement
    PropertyBinding.prototype._setValue_arrayElement,
    PropertyBinding.prototype._setValue_arrayElement_setNeedsUpdate,
    PropertyBinding.prototype._setValue_arrayElement_setMatrixWorldNeedsUpdate
  ],
  [
    // HasToFromArray
    PropertyBinding.prototype._setValue_fromArray,
    PropertyBinding.prototype._setValue_fromArray_setNeedsUpdate,
    PropertyBinding.prototype._setValue_fromArray_setMatrixWorldNeedsUpdate
  ]
];
var AnimationObjectGroup = class {
  constructor() {
    this.isAnimationObjectGroup = true;
    this.uuid = generateUUID();
    this._objects = Array.prototype.slice.call(arguments);
    this.nCachedObjects_ = 0;
    const indices = {};
    this._indicesByUUID = indices;
    for (let i2 = 0, n = arguments.length; i2 !== n; ++i2) {
      indices[arguments[i2].uuid] = i2;
    }
    this._paths = [];
    this._parsedPaths = [];
    this._bindings = [];
    this._bindingsIndicesByPath = {};
    const scope = this;
    this.stats = {
      objects: {
        get total() {
          return scope._objects.length;
        },
        get inUse() {
          return this.total - scope.nCachedObjects_;
        }
      },
      get bindingsPerObject() {
        return scope._bindings.length;
      }
    };
  }
  add() {
    const objects = this._objects, indicesByUUID = this._indicesByUUID, paths = this._paths, parsedPaths = this._parsedPaths, bindings = this._bindings, nBindings = bindings.length;
    let knownObject = void 0, nObjects = objects.length, nCachedObjects = this.nCachedObjects_;
    for (let i2 = 0, n = arguments.length; i2 !== n; ++i2) {
      const object = arguments[i2], uuid = object.uuid;
      let index = indicesByUUID[uuid];
      if (index === void 0) {
        index = nObjects++;
        indicesByUUID[uuid] = index;
        objects.push(object);
        for (let j = 0, m2 = nBindings; j !== m2; ++j) {
          bindings[j].push(new PropertyBinding(object, paths[j], parsedPaths[j]));
        }
      } else if (index < nCachedObjects) {
        knownObject = objects[index];
        const firstActiveIndex = --nCachedObjects, lastCachedObject = objects[firstActiveIndex];
        indicesByUUID[lastCachedObject.uuid] = index;
        objects[index] = lastCachedObject;
        indicesByUUID[uuid] = firstActiveIndex;
        objects[firstActiveIndex] = object;
        for (let j = 0, m2 = nBindings; j !== m2; ++j) {
          const bindingsForPath = bindings[j], lastCached = bindingsForPath[firstActiveIndex];
          let binding = bindingsForPath[index];
          bindingsForPath[index] = lastCached;
          if (binding === void 0) {
            binding = new PropertyBinding(object, paths[j], parsedPaths[j]);
          }
          bindingsForPath[firstActiveIndex] = binding;
        }
      } else if (objects[index] !== knownObject) {
        console.error("THREE.AnimationObjectGroup: Different objects with the same UUID detected. Clean the caches or recreate your infrastructure when reloading scenes.");
      }
    }
    this.nCachedObjects_ = nCachedObjects;
  }
  remove() {
    const objects = this._objects, indicesByUUID = this._indicesByUUID, bindings = this._bindings, nBindings = bindings.length;
    let nCachedObjects = this.nCachedObjects_;
    for (let i2 = 0, n = arguments.length; i2 !== n; ++i2) {
      const object = arguments[i2], uuid = object.uuid, index = indicesByUUID[uuid];
      if (index !== void 0 && index >= nCachedObjects) {
        const lastCachedIndex = nCachedObjects++, firstActiveObject = objects[lastCachedIndex];
        indicesByUUID[firstActiveObject.uuid] = index;
        objects[index] = firstActiveObject;
        indicesByUUID[uuid] = lastCachedIndex;
        objects[lastCachedIndex] = object;
        for (let j = 0, m2 = nBindings; j !== m2; ++j) {
          const bindingsForPath = bindings[j], firstActive = bindingsForPath[lastCachedIndex], binding = bindingsForPath[index];
          bindingsForPath[index] = firstActive;
          bindingsForPath[lastCachedIndex] = binding;
        }
      }
    }
    this.nCachedObjects_ = nCachedObjects;
  }
  // remove & forget
  uncache() {
    const objects = this._objects, indicesByUUID = this._indicesByUUID, bindings = this._bindings, nBindings = bindings.length;
    let nCachedObjects = this.nCachedObjects_, nObjects = objects.length;
    for (let i2 = 0, n = arguments.length; i2 !== n; ++i2) {
      const object = arguments[i2], uuid = object.uuid, index = indicesByUUID[uuid];
      if (index !== void 0) {
        delete indicesByUUID[uuid];
        if (index < nCachedObjects) {
          const firstActiveIndex = --nCachedObjects, lastCachedObject = objects[firstActiveIndex], lastIndex = --nObjects, lastObject = objects[lastIndex];
          indicesByUUID[lastCachedObject.uuid] = index;
          objects[index] = lastCachedObject;
          indicesByUUID[lastObject.uuid] = firstActiveIndex;
          objects[firstActiveIndex] = lastObject;
          objects.pop();
          for (let j = 0, m2 = nBindings; j !== m2; ++j) {
            const bindingsForPath = bindings[j], lastCached = bindingsForPath[firstActiveIndex], last = bindingsForPath[lastIndex];
            bindingsForPath[index] = lastCached;
            bindingsForPath[firstActiveIndex] = last;
            bindingsForPath.pop();
          }
        } else {
          const lastIndex = --nObjects, lastObject = objects[lastIndex];
          if (lastIndex > 0) {
            indicesByUUID[lastObject.uuid] = index;
          }
          objects[index] = lastObject;
          objects.pop();
          for (let j = 0, m2 = nBindings; j !== m2; ++j) {
            const bindingsForPath = bindings[j];
            bindingsForPath[index] = bindingsForPath[lastIndex];
            bindingsForPath.pop();
          }
        }
      }
    }
    this.nCachedObjects_ = nCachedObjects;
  }
  // Internal interface used by befriended PropertyBinding.Composite:
  subscribe_(path, parsedPath) {
    const indicesByPath = this._bindingsIndicesByPath;
    let index = indicesByPath[path];
    const bindings = this._bindings;
    if (index !== void 0) return bindings[index];
    const paths = this._paths, parsedPaths = this._parsedPaths, objects = this._objects, nObjects = objects.length, nCachedObjects = this.nCachedObjects_, bindingsForPath = new Array(nObjects);
    index = bindings.length;
    indicesByPath[path] = index;
    paths.push(path);
    parsedPaths.push(parsedPath);
    bindings.push(bindingsForPath);
    for (let i2 = nCachedObjects, n = objects.length; i2 !== n; ++i2) {
      const object = objects[i2];
      bindingsForPath[i2] = new PropertyBinding(object, path, parsedPath);
    }
    return bindingsForPath;
  }
  unsubscribe_(path) {
    const indicesByPath = this._bindingsIndicesByPath, index = indicesByPath[path];
    if (index !== void 0) {
      const paths = this._paths, parsedPaths = this._parsedPaths, bindings = this._bindings, lastBindingsIndex = bindings.length - 1, lastBindings = bindings[lastBindingsIndex], lastBindingsPath = path[lastBindingsIndex];
      indicesByPath[lastBindingsPath] = index;
      bindings[index] = lastBindings;
      bindings.pop();
      parsedPaths[index] = parsedPaths[lastBindingsIndex];
      parsedPaths.pop();
      paths[index] = paths[lastBindingsIndex];
      paths.pop();
    }
  }
};
var AnimationAction = class {
  constructor(mixer, clip, localRoot = null, blendMode = clip.blendMode) {
    this._mixer = mixer;
    this._clip = clip;
    this._localRoot = localRoot;
    this.blendMode = blendMode;
    const tracks = clip.tracks, nTracks = tracks.length, interpolants = new Array(nTracks);
    const interpolantSettings = {
      endingStart: ZeroCurvatureEnding,
      endingEnd: ZeroCurvatureEnding
    };
    for (let i2 = 0; i2 !== nTracks; ++i2) {
      const interpolant = tracks[i2].createInterpolant(null);
      interpolants[i2] = interpolant;
      interpolant.settings = interpolantSettings;
    }
    this._interpolantSettings = interpolantSettings;
    this._interpolants = interpolants;
    this._propertyBindings = new Array(nTracks);
    this._cacheIndex = null;
    this._byClipCacheIndex = null;
    this._timeScaleInterpolant = null;
    this._weightInterpolant = null;
    this.loop = LoopRepeat;
    this._loopCount = -1;
    this._startTime = null;
    this.time = 0;
    this.timeScale = 1;
    this._effectiveTimeScale = 1;
    this.weight = 1;
    this._effectiveWeight = 1;
    this.repetitions = Infinity;
    this.paused = false;
    this.enabled = true;
    this.clampWhenFinished = false;
    this.zeroSlopeAtStart = true;
    this.zeroSlopeAtEnd = true;
  }
  // State & Scheduling
  play() {
    this._mixer._activateAction(this);
    return this;
  }
  stop() {
    this._mixer._deactivateAction(this);
    return this.reset();
  }
  reset() {
    this.paused = false;
    this.enabled = true;
    this.time = 0;
    this._loopCount = -1;
    this._startTime = null;
    return this.stopFading().stopWarping();
  }
  isRunning() {
    return this.enabled && !this.paused && this.timeScale !== 0 && this._startTime === null && this._mixer._isActiveAction(this);
  }
  // return true when play has been called
  isScheduled() {
    return this._mixer._isActiveAction(this);
  }
  startAt(time) {
    this._startTime = time;
    return this;
  }
  setLoop(mode, repetitions) {
    this.loop = mode;
    this.repetitions = repetitions;
    return this;
  }
  // Weight
  // set the weight stopping any scheduled fading
  // although .enabled = false yields an effective weight of zero, this
  // method does *not* change .enabled, because it would be confusing
  setEffectiveWeight(weight) {
    this.weight = weight;
    this._effectiveWeight = this.enabled ? weight : 0;
    return this.stopFading();
  }
  // return the weight considering fading and .enabled
  getEffectiveWeight() {
    return this._effectiveWeight;
  }
  fadeIn(duration) {
    return this._scheduleFading(duration, 0, 1);
  }
  fadeOut(duration) {
    return this._scheduleFading(duration, 1, 0);
  }
  crossFadeFrom(fadeOutAction, duration, warp) {
    fadeOutAction.fadeOut(duration);
    this.fadeIn(duration);
    if (warp) {
      const fadeInDuration = this._clip.duration, fadeOutDuration = fadeOutAction._clip.duration, startEndRatio = fadeOutDuration / fadeInDuration, endStartRatio = fadeInDuration / fadeOutDuration;
      fadeOutAction.warp(1, startEndRatio, duration);
      this.warp(endStartRatio, 1, duration);
    }
    return this;
  }
  crossFadeTo(fadeInAction, duration, warp) {
    return fadeInAction.crossFadeFrom(this, duration, warp);
  }
  stopFading() {
    const weightInterpolant = this._weightInterpolant;
    if (weightInterpolant !== null) {
      this._weightInterpolant = null;
      this._mixer._takeBackControlInterpolant(weightInterpolant);
    }
    return this;
  }
  // Time Scale Control
  // set the time scale stopping any scheduled warping
  // although .paused = true yields an effective time scale of zero, this
  // method does *not* change .paused, because it would be confusing
  setEffectiveTimeScale(timeScale) {
    this.timeScale = timeScale;
    this._effectiveTimeScale = this.paused ? 0 : timeScale;
    return this.stopWarping();
  }
  // return the time scale considering warping and .paused
  getEffectiveTimeScale() {
    return this._effectiveTimeScale;
  }
  setDuration(duration) {
    this.timeScale = this._clip.duration / duration;
    return this.stopWarping();
  }
  syncWith(action) {
    this.time = action.time;
    this.timeScale = action.timeScale;
    return this.stopWarping();
  }
  halt(duration) {
    return this.warp(this._effectiveTimeScale, 0, duration);
  }
  warp(startTimeScale, endTimeScale, duration) {
    const mixer = this._mixer, now3 = mixer.time, timeScale = this.timeScale;
    let interpolant = this._timeScaleInterpolant;
    if (interpolant === null) {
      interpolant = mixer._lendControlInterpolant();
      this._timeScaleInterpolant = interpolant;
    }
    const times = interpolant.parameterPositions, values = interpolant.sampleValues;
    times[0] = now3;
    times[1] = now3 + duration;
    values[0] = startTimeScale / timeScale;
    values[1] = endTimeScale / timeScale;
    return this;
  }
  stopWarping() {
    const timeScaleInterpolant = this._timeScaleInterpolant;
    if (timeScaleInterpolant !== null) {
      this._timeScaleInterpolant = null;
      this._mixer._takeBackControlInterpolant(timeScaleInterpolant);
    }
    return this;
  }
  // Object Accessors
  getMixer() {
    return this._mixer;
  }
  getClip() {
    return this._clip;
  }
  getRoot() {
    return this._localRoot || this._mixer._root;
  }
  // Interna
  _update(time, deltaTime, timeDirection, accuIndex) {
    if (!this.enabled) {
      this._updateWeight(time);
      return;
    }
    const startTime = this._startTime;
    if (startTime !== null) {
      const timeRunning = (time - startTime) * timeDirection;
      if (timeRunning < 0 || timeDirection === 0) {
        deltaTime = 0;
      } else {
        this._startTime = null;
        deltaTime = timeDirection * timeRunning;
      }
    }
    deltaTime *= this._updateTimeScale(time);
    const clipTime = this._updateTime(deltaTime);
    const weight = this._updateWeight(time);
    if (weight > 0) {
      const interpolants = this._interpolants;
      const propertyMixers = this._propertyBindings;
      switch (this.blendMode) {
        case AdditiveAnimationBlendMode:
          for (let j = 0, m2 = interpolants.length; j !== m2; ++j) {
            interpolants[j].evaluate(clipTime);
            propertyMixers[j].accumulateAdditive(weight);
          }
          break;
        case NormalAnimationBlendMode:
        default:
          for (let j = 0, m2 = interpolants.length; j !== m2; ++j) {
            interpolants[j].evaluate(clipTime);
            propertyMixers[j].accumulate(accuIndex, weight);
          }
      }
    }
  }
  _updateWeight(time) {
    let weight = 0;
    if (this.enabled) {
      weight = this.weight;
      const interpolant = this._weightInterpolant;
      if (interpolant !== null) {
        const interpolantValue = interpolant.evaluate(time)[0];
        weight *= interpolantValue;
        if (time > interpolant.parameterPositions[1]) {
          this.stopFading();
          if (interpolantValue === 0) {
            this.enabled = false;
          }
        }
      }
    }
    this._effectiveWeight = weight;
    return weight;
  }
  _updateTimeScale(time) {
    let timeScale = 0;
    if (!this.paused) {
      timeScale = this.timeScale;
      const interpolant = this._timeScaleInterpolant;
      if (interpolant !== null) {
        const interpolantValue = interpolant.evaluate(time)[0];
        timeScale *= interpolantValue;
        if (time > interpolant.parameterPositions[1]) {
          this.stopWarping();
          if (timeScale === 0) {
            this.paused = true;
          } else {
            this.timeScale = timeScale;
          }
        }
      }
    }
    this._effectiveTimeScale = timeScale;
    return timeScale;
  }
  _updateTime(deltaTime) {
    const duration = this._clip.duration;
    const loop = this.loop;
    let time = this.time + deltaTime;
    let loopCount = this._loopCount;
    const pingPong = loop === LoopPingPong;
    if (deltaTime === 0) {
      if (loopCount === -1) return time;
      return pingPong && (loopCount & 1) === 1 ? duration - time : time;
    }
    if (loop === LoopOnce) {
      if (loopCount === -1) {
        this._loopCount = 0;
        this._setEndings(true, true, false);
      }
      handle_stop: {
        if (time >= duration) {
          time = duration;
        } else if (time < 0) {
          time = 0;
        } else {
          this.time = time;
          break handle_stop;
        }
        if (this.clampWhenFinished) this.paused = true;
        else this.enabled = false;
        this.time = time;
        this._mixer.dispatchEvent({
          type: "finished",
          action: this,
          direction: deltaTime < 0 ? -1 : 1
        });
      }
    } else {
      if (loopCount === -1) {
        if (deltaTime >= 0) {
          loopCount = 0;
          this._setEndings(true, this.repetitions === 0, pingPong);
        } else {
          this._setEndings(this.repetitions === 0, true, pingPong);
        }
      }
      if (time >= duration || time < 0) {
        const loopDelta = Math.floor(time / duration);
        time -= duration * loopDelta;
        loopCount += Math.abs(loopDelta);
        const pending = this.repetitions - loopCount;
        if (pending <= 0) {
          if (this.clampWhenFinished) this.paused = true;
          else this.enabled = false;
          time = deltaTime > 0 ? duration : 0;
          this.time = time;
          this._mixer.dispatchEvent({
            type: "finished",
            action: this,
            direction: deltaTime > 0 ? 1 : -1
          });
        } else {
          if (pending === 1) {
            const atStart = deltaTime < 0;
            this._setEndings(atStart, !atStart, pingPong);
          } else {
            this._setEndings(false, false, pingPong);
          }
          this._loopCount = loopCount;
          this.time = time;
          this._mixer.dispatchEvent({
            type: "loop",
            action: this,
            loopDelta
          });
        }
      } else {
        this.time = time;
      }
      if (pingPong && (loopCount & 1) === 1) {
        return duration - time;
      }
    }
    return time;
  }
  _setEndings(atStart, atEnd, pingPong) {
    const settings2 = this._interpolantSettings;
    if (pingPong) {
      settings2.endingStart = ZeroSlopeEnding;
      settings2.endingEnd = ZeroSlopeEnding;
    } else {
      if (atStart) {
        settings2.endingStart = this.zeroSlopeAtStart ? ZeroSlopeEnding : ZeroCurvatureEnding;
      } else {
        settings2.endingStart = WrapAroundEnding;
      }
      if (atEnd) {
        settings2.endingEnd = this.zeroSlopeAtEnd ? ZeroSlopeEnding : ZeroCurvatureEnding;
      } else {
        settings2.endingEnd = WrapAroundEnding;
      }
    }
  }
  _scheduleFading(duration, weightNow, weightThen) {
    const mixer = this._mixer, now3 = mixer.time;
    let interpolant = this._weightInterpolant;
    if (interpolant === null) {
      interpolant = mixer._lendControlInterpolant();
      this._weightInterpolant = interpolant;
    }
    const times = interpolant.parameterPositions, values = interpolant.sampleValues;
    times[0] = now3;
    values[0] = weightNow;
    times[1] = now3 + duration;
    values[1] = weightThen;
    return this;
  }
};
var _controlInterpolantsResultBuffer = new Float32Array(1);
var AnimationMixer = class extends EventDispatcher {
  constructor(root) {
    super();
    this._root = root;
    this._initMemoryManager();
    this._accuIndex = 0;
    this.time = 0;
    this.timeScale = 1;
  }
  _bindAction(action, prototypeAction) {
    const root = action._localRoot || this._root, tracks = action._clip.tracks, nTracks = tracks.length, bindings = action._propertyBindings, interpolants = action._interpolants, rootUuid = root.uuid, bindingsByRoot = this._bindingsByRootAndName;
    let bindingsByName = bindingsByRoot[rootUuid];
    if (bindingsByName === void 0) {
      bindingsByName = {};
      bindingsByRoot[rootUuid] = bindingsByName;
    }
    for (let i2 = 0; i2 !== nTracks; ++i2) {
      const track = tracks[i2], trackName = track.name;
      let binding = bindingsByName[trackName];
      if (binding !== void 0) {
        ++binding.referenceCount;
        bindings[i2] = binding;
      } else {
        binding = bindings[i2];
        if (binding !== void 0) {
          if (binding._cacheIndex === null) {
            ++binding.referenceCount;
            this._addInactiveBinding(binding, rootUuid, trackName);
          }
          continue;
        }
        const path = prototypeAction && prototypeAction._propertyBindings[i2].binding.parsedPath;
        binding = new PropertyMixer(
          PropertyBinding.create(root, trackName, path),
          track.ValueTypeName,
          track.getValueSize()
        );
        ++binding.referenceCount;
        this._addInactiveBinding(binding, rootUuid, trackName);
        bindings[i2] = binding;
      }
      interpolants[i2].resultBuffer = binding.buffer;
    }
  }
  _activateAction(action) {
    if (!this._isActiveAction(action)) {
      if (action._cacheIndex === null) {
        const rootUuid = (action._localRoot || this._root).uuid, clipUuid = action._clip.uuid, actionsForClip = this._actionsByClip[clipUuid];
        this._bindAction(
          action,
          actionsForClip && actionsForClip.knownActions[0]
        );
        this._addInactiveAction(action, clipUuid, rootUuid);
      }
      const bindings = action._propertyBindings;
      for (let i2 = 0, n = bindings.length; i2 !== n; ++i2) {
        const binding = bindings[i2];
        if (binding.useCount++ === 0) {
          this._lendBinding(binding);
          binding.saveOriginalState();
        }
      }
      this._lendAction(action);
    }
  }
  _deactivateAction(action) {
    if (this._isActiveAction(action)) {
      const bindings = action._propertyBindings;
      for (let i2 = 0, n = bindings.length; i2 !== n; ++i2) {
        const binding = bindings[i2];
        if (--binding.useCount === 0) {
          binding.restoreOriginalState();
          this._takeBackBinding(binding);
        }
      }
      this._takeBackAction(action);
    }
  }
  // Memory manager
  _initMemoryManager() {
    this._actions = [];
    this._nActiveActions = 0;
    this._actionsByClip = {};
    this._bindings = [];
    this._nActiveBindings = 0;
    this._bindingsByRootAndName = {};
    this._controlInterpolants = [];
    this._nActiveControlInterpolants = 0;
    const scope = this;
    this.stats = {
      actions: {
        get total() {
          return scope._actions.length;
        },
        get inUse() {
          return scope._nActiveActions;
        }
      },
      bindings: {
        get total() {
          return scope._bindings.length;
        },
        get inUse() {
          return scope._nActiveBindings;
        }
      },
      controlInterpolants: {
        get total() {
          return scope._controlInterpolants.length;
        },
        get inUse() {
          return scope._nActiveControlInterpolants;
        }
      }
    };
  }
  // Memory management for AnimationAction objects
  _isActiveAction(action) {
    const index = action._cacheIndex;
    return index !== null && index < this._nActiveActions;
  }
  _addInactiveAction(action, clipUuid, rootUuid) {
    const actions2 = this._actions, actionsByClip = this._actionsByClip;
    let actionsForClip = actionsByClip[clipUuid];
    if (actionsForClip === void 0) {
      actionsForClip = {
        knownActions: [action],
        actionByRoot: {}
      };
      action._byClipCacheIndex = 0;
      actionsByClip[clipUuid] = actionsForClip;
    } else {
      const knownActions = actionsForClip.knownActions;
      action._byClipCacheIndex = knownActions.length;
      knownActions.push(action);
    }
    action._cacheIndex = actions2.length;
    actions2.push(action);
    actionsForClip.actionByRoot[rootUuid] = action;
  }
  _removeInactiveAction(action) {
    const actions2 = this._actions, lastInactiveAction = actions2[actions2.length - 1], cacheIndex = action._cacheIndex;
    lastInactiveAction._cacheIndex = cacheIndex;
    actions2[cacheIndex] = lastInactiveAction;
    actions2.pop();
    action._cacheIndex = null;
    const clipUuid = action._clip.uuid, actionsByClip = this._actionsByClip, actionsForClip = actionsByClip[clipUuid], knownActionsForClip = actionsForClip.knownActions, lastKnownAction = knownActionsForClip[knownActionsForClip.length - 1], byClipCacheIndex = action._byClipCacheIndex;
    lastKnownAction._byClipCacheIndex = byClipCacheIndex;
    knownActionsForClip[byClipCacheIndex] = lastKnownAction;
    knownActionsForClip.pop();
    action._byClipCacheIndex = null;
    const actionByRoot = actionsForClip.actionByRoot, rootUuid = (action._localRoot || this._root).uuid;
    delete actionByRoot[rootUuid];
    if (knownActionsForClip.length === 0) {
      delete actionsByClip[clipUuid];
    }
    this._removeInactiveBindingsForAction(action);
  }
  _removeInactiveBindingsForAction(action) {
    const bindings = action._propertyBindings;
    for (let i2 = 0, n = bindings.length; i2 !== n; ++i2) {
      const binding = bindings[i2];
      if (--binding.referenceCount === 0) {
        this._removeInactiveBinding(binding);
      }
    }
  }
  _lendAction(action) {
    const actions2 = this._actions, prevIndex = action._cacheIndex, lastActiveIndex = this._nActiveActions++, firstInactiveAction = actions2[lastActiveIndex];
    action._cacheIndex = lastActiveIndex;
    actions2[lastActiveIndex] = action;
    firstInactiveAction._cacheIndex = prevIndex;
    actions2[prevIndex] = firstInactiveAction;
  }
  _takeBackAction(action) {
    const actions2 = this._actions, prevIndex = action._cacheIndex, firstInactiveIndex = --this._nActiveActions, lastActiveAction = actions2[firstInactiveIndex];
    action._cacheIndex = firstInactiveIndex;
    actions2[firstInactiveIndex] = action;
    lastActiveAction._cacheIndex = prevIndex;
    actions2[prevIndex] = lastActiveAction;
  }
  // Memory management for PropertyMixer objects
  _addInactiveBinding(binding, rootUuid, trackName) {
    const bindingsByRoot = this._bindingsByRootAndName, bindings = this._bindings;
    let bindingByName = bindingsByRoot[rootUuid];
    if (bindingByName === void 0) {
      bindingByName = {};
      bindingsByRoot[rootUuid] = bindingByName;
    }
    bindingByName[trackName] = binding;
    binding._cacheIndex = bindings.length;
    bindings.push(binding);
  }
  _removeInactiveBinding(binding) {
    const bindings = this._bindings, propBinding = binding.binding, rootUuid = propBinding.rootNode.uuid, trackName = propBinding.path, bindingsByRoot = this._bindingsByRootAndName, bindingByName = bindingsByRoot[rootUuid], lastInactiveBinding = bindings[bindings.length - 1], cacheIndex = binding._cacheIndex;
    lastInactiveBinding._cacheIndex = cacheIndex;
    bindings[cacheIndex] = lastInactiveBinding;
    bindings.pop();
    delete bindingByName[trackName];
    if (Object.keys(bindingByName).length === 0) {
      delete bindingsByRoot[rootUuid];
    }
  }
  _lendBinding(binding) {
    const bindings = this._bindings, prevIndex = binding._cacheIndex, lastActiveIndex = this._nActiveBindings++, firstInactiveBinding = bindings[lastActiveIndex];
    binding._cacheIndex = lastActiveIndex;
    bindings[lastActiveIndex] = binding;
    firstInactiveBinding._cacheIndex = prevIndex;
    bindings[prevIndex] = firstInactiveBinding;
  }
  _takeBackBinding(binding) {
    const bindings = this._bindings, prevIndex = binding._cacheIndex, firstInactiveIndex = --this._nActiveBindings, lastActiveBinding = bindings[firstInactiveIndex];
    binding._cacheIndex = firstInactiveIndex;
    bindings[firstInactiveIndex] = binding;
    lastActiveBinding._cacheIndex = prevIndex;
    bindings[prevIndex] = lastActiveBinding;
  }
  // Memory management of Interpolants for weight and time scale
  _lendControlInterpolant() {
    const interpolants = this._controlInterpolants, lastActiveIndex = this._nActiveControlInterpolants++;
    let interpolant = interpolants[lastActiveIndex];
    if (interpolant === void 0) {
      interpolant = new LinearInterpolant(
        new Float32Array(2),
        new Float32Array(2),
        1,
        _controlInterpolantsResultBuffer
      );
      interpolant.__cacheIndex = lastActiveIndex;
      interpolants[lastActiveIndex] = interpolant;
    }
    return interpolant;
  }
  _takeBackControlInterpolant(interpolant) {
    const interpolants = this._controlInterpolants, prevIndex = interpolant.__cacheIndex, firstInactiveIndex = --this._nActiveControlInterpolants, lastActiveInterpolant = interpolants[firstInactiveIndex];
    interpolant.__cacheIndex = firstInactiveIndex;
    interpolants[firstInactiveIndex] = interpolant;
    lastActiveInterpolant.__cacheIndex = prevIndex;
    interpolants[prevIndex] = lastActiveInterpolant;
  }
  // return an action for a clip optionally using a custom root target
  // object (this method allocates a lot of dynamic memory in case a
  // previously unknown clip/root combination is specified)
  clipAction(clip, optionalRoot, blendMode) {
    const root = optionalRoot || this._root, rootUuid = root.uuid;
    let clipObject = typeof clip === "string" ? AnimationClip.findByName(root, clip) : clip;
    const clipUuid = clipObject !== null ? clipObject.uuid : clip;
    const actionsForClip = this._actionsByClip[clipUuid];
    let prototypeAction = null;
    if (blendMode === void 0) {
      if (clipObject !== null) {
        blendMode = clipObject.blendMode;
      } else {
        blendMode = NormalAnimationBlendMode;
      }
    }
    if (actionsForClip !== void 0) {
      const existingAction = actionsForClip.actionByRoot[rootUuid];
      if (existingAction !== void 0 && existingAction.blendMode === blendMode) {
        return existingAction;
      }
      prototypeAction = actionsForClip.knownActions[0];
      if (clipObject === null)
        clipObject = prototypeAction._clip;
    }
    if (clipObject === null) return null;
    const newAction = new AnimationAction(this, clipObject, optionalRoot, blendMode);
    this._bindAction(newAction, prototypeAction);
    this._addInactiveAction(newAction, clipUuid, rootUuid);
    return newAction;
  }
  // get an existing action
  existingAction(clip, optionalRoot) {
    const root = optionalRoot || this._root, rootUuid = root.uuid, clipObject = typeof clip === "string" ? AnimationClip.findByName(root, clip) : clip, clipUuid = clipObject ? clipObject.uuid : clip, actionsForClip = this._actionsByClip[clipUuid];
    if (actionsForClip !== void 0) {
      return actionsForClip.actionByRoot[rootUuid] || null;
    }
    return null;
  }
  // deactivates all previously scheduled actions
  stopAllAction() {
    const actions2 = this._actions, nActions = this._nActiveActions;
    for (let i2 = nActions - 1; i2 >= 0; --i2) {
      actions2[i2].stop();
    }
    return this;
  }
  // advance the time and update apply the animation
  update(deltaTime) {
    deltaTime *= this.timeScale;
    const actions2 = this._actions, nActions = this._nActiveActions, time = this.time += deltaTime, timeDirection = Math.sign(deltaTime), accuIndex = this._accuIndex ^= 1;
    for (let i2 = 0; i2 !== nActions; ++i2) {
      const action = actions2[i2];
      action._update(time, deltaTime, timeDirection, accuIndex);
    }
    const bindings = this._bindings, nBindings = this._nActiveBindings;
    for (let i2 = 0; i2 !== nBindings; ++i2) {
      bindings[i2].apply(accuIndex);
    }
    return this;
  }
  // Allows you to seek to a specific time in an animation.
  setTime(timeInSeconds) {
    this.time = 0;
    for (let i2 = 0; i2 < this._actions.length; i2++) {
      this._actions[i2].time = 0;
    }
    return this.update(timeInSeconds);
  }
  // return this mixer's root target object
  getRoot() {
    return this._root;
  }
  // free all resources specific to a particular clip
  uncacheClip(clip) {
    const actions2 = this._actions, clipUuid = clip.uuid, actionsByClip = this._actionsByClip, actionsForClip = actionsByClip[clipUuid];
    if (actionsForClip !== void 0) {
      const actionsToRemove = actionsForClip.knownActions;
      for (let i2 = 0, n = actionsToRemove.length; i2 !== n; ++i2) {
        const action = actionsToRemove[i2];
        this._deactivateAction(action);
        const cacheIndex = action._cacheIndex, lastInactiveAction = actions2[actions2.length - 1];
        action._cacheIndex = null;
        action._byClipCacheIndex = null;
        lastInactiveAction._cacheIndex = cacheIndex;
        actions2[cacheIndex] = lastInactiveAction;
        actions2.pop();
        this._removeInactiveBindingsForAction(action);
      }
      delete actionsByClip[clipUuid];
    }
  }
  // free all resources specific to a particular root target object
  uncacheRoot(root) {
    const rootUuid = root.uuid, actionsByClip = this._actionsByClip;
    for (const clipUuid in actionsByClip) {
      const actionByRoot = actionsByClip[clipUuid].actionByRoot, action = actionByRoot[rootUuid];
      if (action !== void 0) {
        this._deactivateAction(action);
        this._removeInactiveAction(action);
      }
    }
    const bindingsByRoot = this._bindingsByRootAndName, bindingByName = bindingsByRoot[rootUuid];
    if (bindingByName !== void 0) {
      for (const trackName in bindingByName) {
        const binding = bindingByName[trackName];
        binding.restoreOriginalState();
        this._removeInactiveBinding(binding);
      }
    }
  }
  // remove a targeted clip from the cache
  uncacheAction(clip, optionalRoot) {
    const action = this.existingAction(clip, optionalRoot);
    if (action !== null) {
      this._deactivateAction(action);
      this._removeInactiveAction(action);
    }
  }
};
var Uniform = class _Uniform {
  constructor(value) {
    this.value = value;
  }
  clone() {
    return new _Uniform(this.value.clone === void 0 ? this.value : this.value.clone());
  }
};
var id = 0;
var UniformsGroup = class extends EventDispatcher {
  constructor() {
    super();
    this.isUniformsGroup = true;
    Object.defineProperty(this, "id", { value: id++ });
    this.name = "";
    this.usage = StaticDrawUsage;
    this.uniforms = [];
  }
  add(uniform) {
    this.uniforms.push(uniform);
    return this;
  }
  remove(uniform) {
    const index = this.uniforms.indexOf(uniform);
    if (index !== -1) this.uniforms.splice(index, 1);
    return this;
  }
  setName(name) {
    this.name = name;
    return this;
  }
  setUsage(value) {
    this.usage = value;
    return this;
  }
  dispose() {
    this.dispatchEvent({ type: "dispose" });
    return this;
  }
  copy(source) {
    this.name = source.name;
    this.usage = source.usage;
    const uniformsSource = source.uniforms;
    this.uniforms.length = 0;
    for (let i2 = 0, l2 = uniformsSource.length; i2 < l2; i2++) {
      this.uniforms.push(uniformsSource[i2].clone());
    }
    return this;
  }
  clone() {
    return new this.constructor().copy(this);
  }
};
var InstancedInterleavedBuffer = class extends InterleavedBuffer {
  constructor(array, stride, meshPerAttribute = 1) {
    super(array, stride);
    this.isInstancedInterleavedBuffer = true;
    this.meshPerAttribute = meshPerAttribute;
  }
  copy(source) {
    super.copy(source);
    this.meshPerAttribute = source.meshPerAttribute;
    return this;
  }
  clone(data) {
    const ib = super.clone(data);
    ib.meshPerAttribute = this.meshPerAttribute;
    return ib;
  }
  toJSON(data) {
    const json = super.toJSON(data);
    json.isInstancedInterleavedBuffer = true;
    json.meshPerAttribute = this.meshPerAttribute;
    return json;
  }
};
var GLBufferAttribute = class {
  constructor(buffer, type, itemSize, elementSize, count) {
    this.isGLBufferAttribute = true;
    this.name = "";
    this.buffer = buffer;
    this.type = type;
    this.itemSize = itemSize;
    this.elementSize = elementSize;
    this.count = count;
    this.version = 0;
  }
  set needsUpdate(value) {
    if (value === true) this.version++;
  }
  setBuffer(buffer) {
    this.buffer = buffer;
    return this;
  }
  setType(type, elementSize) {
    this.type = type;
    this.elementSize = elementSize;
    return this;
  }
  setItemSize(itemSize) {
    this.itemSize = itemSize;
    return this;
  }
  setCount(count) {
    this.count = count;
    return this;
  }
};
var Raycaster = class {
  constructor(origin, direction2, near = 0, far = Infinity) {
    this.ray = new Ray(origin, direction2);
    this.near = near;
    this.far = far;
    this.camera = null;
    this.layers = new Layers();
    this.params = {
      Mesh: {},
      Line: { threshold: 1 },
      LOD: {},
      Points: { threshold: 1 },
      Sprite: {}
    };
  }
  set(origin, direction2) {
    this.ray.set(origin, direction2);
  }
  setFromCamera(coords, camera) {
    if (camera.isPerspectiveCamera) {
      this.ray.origin.setFromMatrixPosition(camera.matrixWorld);
      this.ray.direction.set(coords.x, coords.y, 0.5).unproject(camera).sub(this.ray.origin).normalize();
      this.camera = camera;
    } else if (camera.isOrthographicCamera) {
      this.ray.origin.set(coords.x, coords.y, (camera.near + camera.far) / (camera.near - camera.far)).unproject(camera);
      this.ray.direction.set(0, 0, -1).transformDirection(camera.matrixWorld);
      this.camera = camera;
    } else {
      console.error("THREE.Raycaster: Unsupported camera type: " + camera.type);
    }
  }
  intersectObject(object, recursive = true, intersects2 = []) {
    intersectObject(object, this, intersects2, recursive);
    intersects2.sort(ascSort);
    return intersects2;
  }
  intersectObjects(objects, recursive = true, intersects2 = []) {
    for (let i2 = 0, l2 = objects.length; i2 < l2; i2++) {
      intersectObject(objects[i2], this, intersects2, recursive);
    }
    intersects2.sort(ascSort);
    return intersects2;
  }
};
function ascSort(a2, b2) {
  return a2.distance - b2.distance;
}
function intersectObject(object, raycaster, intersects2, recursive) {
  if (object.layers.test(raycaster.layers)) {
    object.raycast(raycaster, intersects2);
  }
  if (recursive === true) {
    const children = object.children;
    for (let i2 = 0, l2 = children.length; i2 < l2; i2++) {
      intersectObject(children[i2], raycaster, intersects2, true);
    }
  }
}
var Spherical = class {
  constructor(radius = 1, phi = 0, theta = 0) {
    this.radius = radius;
    this.phi = phi;
    this.theta = theta;
    return this;
  }
  set(radius, phi, theta) {
    this.radius = radius;
    this.phi = phi;
    this.theta = theta;
    return this;
  }
  copy(other) {
    this.radius = other.radius;
    this.phi = other.phi;
    this.theta = other.theta;
    return this;
  }
  // restrict phi to be between EPS and PI-EPS
  makeSafe() {
    const EPS = 1e-6;
    this.phi = Math.max(EPS, Math.min(Math.PI - EPS, this.phi));
    return this;
  }
  setFromVector3(v2) {
    return this.setFromCartesianCoords(v2.x, v2.y, v2.z);
  }
  setFromCartesianCoords(x3, y2, z) {
    this.radius = Math.sqrt(x3 * x3 + y2 * y2 + z * z);
    if (this.radius === 0) {
      this.theta = 0;
      this.phi = 0;
    } else {
      this.theta = Math.atan2(x3, z);
      this.phi = Math.acos(clamp(y2 / this.radius, -1, 1));
    }
    return this;
  }
  clone() {
    return new this.constructor().copy(this);
  }
};
var Cylindrical = class {
  constructor(radius = 1, theta = 0, y2 = 0) {
    this.radius = radius;
    this.theta = theta;
    this.y = y2;
    return this;
  }
  set(radius, theta, y2) {
    this.radius = radius;
    this.theta = theta;
    this.y = y2;
    return this;
  }
  copy(other) {
    this.radius = other.radius;
    this.theta = other.theta;
    this.y = other.y;
    return this;
  }
  setFromVector3(v2) {
    return this.setFromCartesianCoords(v2.x, v2.y, v2.z);
  }
  setFromCartesianCoords(x3, y2, z) {
    this.radius = Math.sqrt(x3 * x3 + z * z);
    this.theta = Math.atan2(x3, z);
    this.y = y2;
    return this;
  }
  clone() {
    return new this.constructor().copy(this);
  }
};
var _vector$4 = new Vector2();
var Box2 = class {
  constructor(min = new Vector2(Infinity, Infinity), max = new Vector2(-Infinity, -Infinity)) {
    this.isBox2 = true;
    this.min = min;
    this.max = max;
  }
  set(min, max) {
    this.min.copy(min);
    this.max.copy(max);
    return this;
  }
  setFromPoints(points) {
    this.makeEmpty();
    for (let i2 = 0, il = points.length; i2 < il; i2++) {
      this.expandByPoint(points[i2]);
    }
    return this;
  }
  setFromCenterAndSize(center, size) {
    const halfSize = _vector$4.copy(size).multiplyScalar(0.5);
    this.min.copy(center).sub(halfSize);
    this.max.copy(center).add(halfSize);
    return this;
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(box) {
    this.min.copy(box.min);
    this.max.copy(box.max);
    return this;
  }
  makeEmpty() {
    this.min.x = this.min.y = Infinity;
    this.max.x = this.max.y = -Infinity;
    return this;
  }
  isEmpty() {
    return this.max.x < this.min.x || this.max.y < this.min.y;
  }
  getCenter(target) {
    return this.isEmpty() ? target.set(0, 0) : target.addVectors(this.min, this.max).multiplyScalar(0.5);
  }
  getSize(target) {
    return this.isEmpty() ? target.set(0, 0) : target.subVectors(this.max, this.min);
  }
  expandByPoint(point) {
    this.min.min(point);
    this.max.max(point);
    return this;
  }
  expandByVector(vector) {
    this.min.sub(vector);
    this.max.add(vector);
    return this;
  }
  expandByScalar(scalar) {
    this.min.addScalar(-scalar);
    this.max.addScalar(scalar);
    return this;
  }
  containsPoint(point) {
    return point.x < this.min.x || point.x > this.max.x || point.y < this.min.y || point.y > this.max.y ? false : true;
  }
  containsBox(box) {
    return this.min.x <= box.min.x && box.max.x <= this.max.x && this.min.y <= box.min.y && box.max.y <= this.max.y;
  }
  getParameter(point, target) {
    return target.set(
      (point.x - this.min.x) / (this.max.x - this.min.x),
      (point.y - this.min.y) / (this.max.y - this.min.y)
    );
  }
  intersectsBox(box) {
    return box.max.x < this.min.x || box.min.x > this.max.x || box.max.y < this.min.y || box.min.y > this.max.y ? false : true;
  }
  clampPoint(point, target) {
    return target.copy(point).clamp(this.min, this.max);
  }
  distanceToPoint(point) {
    return this.clampPoint(point, _vector$4).distanceTo(point);
  }
  intersect(box) {
    this.min.max(box.min);
    this.max.min(box.max);
    if (this.isEmpty()) this.makeEmpty();
    return this;
  }
  union(box) {
    this.min.min(box.min);
    this.max.max(box.max);
    return this;
  }
  translate(offset) {
    this.min.add(offset);
    this.max.add(offset);
    return this;
  }
  equals(box) {
    return box.min.equals(this.min) && box.max.equals(this.max);
  }
};
var _startP = new Vector3();
var _startEnd = new Vector3();
var Line3 = class {
  constructor(start = new Vector3(), end = new Vector3()) {
    this.start = start;
    this.end = end;
  }
  set(start, end) {
    this.start.copy(start);
    this.end.copy(end);
    return this;
  }
  copy(line) {
    this.start.copy(line.start);
    this.end.copy(line.end);
    return this;
  }
  getCenter(target) {
    return target.addVectors(this.start, this.end).multiplyScalar(0.5);
  }
  delta(target) {
    return target.subVectors(this.end, this.start);
  }
  distanceSq() {
    return this.start.distanceToSquared(this.end);
  }
  distance() {
    return this.start.distanceTo(this.end);
  }
  at(t2, target) {
    return this.delta(target).multiplyScalar(t2).add(this.start);
  }
  closestPointToPointParameter(point, clampToLine) {
    _startP.subVectors(point, this.start);
    _startEnd.subVectors(this.end, this.start);
    const startEnd2 = _startEnd.dot(_startEnd);
    const startEnd_startP = _startEnd.dot(_startP);
    let t2 = startEnd_startP / startEnd2;
    if (clampToLine) {
      t2 = clamp(t2, 0, 1);
    }
    return t2;
  }
  closestPointToPoint(point, clampToLine, target) {
    const t2 = this.closestPointToPointParameter(point, clampToLine);
    return this.delta(target).multiplyScalar(t2).add(this.start);
  }
  applyMatrix4(matrix) {
    this.start.applyMatrix4(matrix);
    this.end.applyMatrix4(matrix);
    return this;
  }
  equals(line) {
    return line.start.equals(this.start) && line.end.equals(this.end);
  }
  clone() {
    return new this.constructor().copy(this);
  }
};
var _vector$3 = new Vector3();
var SpotLightHelper = class extends Object3D {
  constructor(light, color) {
    super();
    this.light = light;
    this.matrix = light.matrixWorld;
    this.matrixAutoUpdate = false;
    this.color = color;
    this.type = "SpotLightHelper";
    const geometry = new BufferGeometry();
    const positions = [
      0,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      1,
      0,
      1,
      0,
      0,
      0,
      -1,
      0,
      1,
      0,
      0,
      0,
      0,
      1,
      1,
      0,
      0,
      0,
      0,
      -1,
      1
    ];
    for (let i2 = 0, j = 1, l2 = 32; i2 < l2; i2++, j++) {
      const p1 = i2 / l2 * Math.PI * 2;
      const p2 = j / l2 * Math.PI * 2;
      positions.push(
        Math.cos(p1),
        Math.sin(p1),
        1,
        Math.cos(p2),
        Math.sin(p2),
        1
      );
    }
    geometry.setAttribute("position", new Float32BufferAttribute(positions, 3));
    const material = new LineBasicMaterial({ fog: false, toneMapped: false });
    this.cone = new LineSegments(geometry, material);
    this.add(this.cone);
    this.update();
  }
  dispose() {
    this.cone.geometry.dispose();
    this.cone.material.dispose();
  }
  update() {
    this.light.updateWorldMatrix(true, false);
    this.light.target.updateWorldMatrix(true, false);
    const coneLength = this.light.distance ? this.light.distance : 1e3;
    const coneWidth = coneLength * Math.tan(this.light.angle);
    this.cone.scale.set(coneWidth, coneWidth, coneLength);
    _vector$3.setFromMatrixPosition(this.light.target.matrixWorld);
    this.cone.lookAt(_vector$3);
    if (this.color !== void 0) {
      this.cone.material.color.set(this.color);
    } else {
      this.cone.material.color.copy(this.light.color);
    }
  }
};
var _vector$2 = new Vector3();
var _boneMatrix = new Matrix4();
var _matrixWorldInv = new Matrix4();
var SkeletonHelper = class extends LineSegments {
  constructor(object) {
    const bones = getBoneList(object);
    const geometry = new BufferGeometry();
    const vertices = [];
    const colors = [];
    const color1 = new Color(0, 0, 1);
    const color2 = new Color(0, 1, 0);
    for (let i2 = 0; i2 < bones.length; i2++) {
      const bone = bones[i2];
      if (bone.parent && bone.parent.isBone) {
        vertices.push(0, 0, 0);
        vertices.push(0, 0, 0);
        colors.push(color1.r, color1.g, color1.b);
        colors.push(color2.r, color2.g, color2.b);
      }
    }
    geometry.setAttribute("position", new Float32BufferAttribute(vertices, 3));
    geometry.setAttribute("color", new Float32BufferAttribute(colors, 3));
    const material = new LineBasicMaterial({ vertexColors: true, depthTest: false, depthWrite: false, toneMapped: false, transparent: true });
    super(geometry, material);
    this.isSkeletonHelper = true;
    this.type = "SkeletonHelper";
    this.root = object;
    this.bones = bones;
    this.matrix = object.matrixWorld;
    this.matrixAutoUpdate = false;
  }
  updateMatrixWorld(force) {
    const bones = this.bones;
    const geometry = this.geometry;
    const position = geometry.getAttribute("position");
    _matrixWorldInv.copy(this.root.matrixWorld).invert();
    for (let i2 = 0, j = 0; i2 < bones.length; i2++) {
      const bone = bones[i2];
      if (bone.parent && bone.parent.isBone) {
        _boneMatrix.multiplyMatrices(_matrixWorldInv, bone.matrixWorld);
        _vector$2.setFromMatrixPosition(_boneMatrix);
        position.setXYZ(j, _vector$2.x, _vector$2.y, _vector$2.z);
        _boneMatrix.multiplyMatrices(_matrixWorldInv, bone.parent.matrixWorld);
        _vector$2.setFromMatrixPosition(_boneMatrix);
        position.setXYZ(j + 1, _vector$2.x, _vector$2.y, _vector$2.z);
        j += 2;
      }
    }
    geometry.getAttribute("position").needsUpdate = true;
    super.updateMatrixWorld(force);
  }
  dispose() {
    this.geometry.dispose();
    this.material.dispose();
  }
};
function getBoneList(object) {
  const boneList = [];
  if (object.isBone === true) {
    boneList.push(object);
  }
  for (let i2 = 0; i2 < object.children.length; i2++) {
    boneList.push.apply(boneList, getBoneList(object.children[i2]));
  }
  return boneList;
}
var PointLightHelper = class extends Mesh {
  constructor(light, sphereSize, color) {
    const geometry = new SphereGeometry(sphereSize, 4, 2);
    const material = new MeshBasicMaterial({ wireframe: true, fog: false, toneMapped: false });
    super(geometry, material);
    this.light = light;
    this.color = color;
    this.type = "PointLightHelper";
    this.matrix = this.light.matrixWorld;
    this.matrixAutoUpdate = false;
    this.update();
  }
  dispose() {
    this.geometry.dispose();
    this.material.dispose();
  }
  update() {
    this.light.updateWorldMatrix(true, false);
    if (this.color !== void 0) {
      this.material.color.set(this.color);
    } else {
      this.material.color.copy(this.light.color);
    }
  }
};
var _vector$1 = new Vector3();
var _color1 = new Color();
var _color2 = new Color();
var HemisphereLightHelper = class extends Object3D {
  constructor(light, size, color) {
    super();
    this.light = light;
    this.matrix = light.matrixWorld;
    this.matrixAutoUpdate = false;
    this.color = color;
    this.type = "HemisphereLightHelper";
    const geometry = new OctahedronGeometry(size);
    geometry.rotateY(Math.PI * 0.5);
    this.material = new MeshBasicMaterial({ wireframe: true, fog: false, toneMapped: false });
    if (this.color === void 0) this.material.vertexColors = true;
    const position = geometry.getAttribute("position");
    const colors = new Float32Array(position.count * 3);
    geometry.setAttribute("color", new BufferAttribute(colors, 3));
    this.add(new Mesh(geometry, this.material));
    this.update();
  }
  dispose() {
    this.children[0].geometry.dispose();
    this.children[0].material.dispose();
  }
  update() {
    const mesh = this.children[0];
    if (this.color !== void 0) {
      this.material.color.set(this.color);
    } else {
      const colors = mesh.geometry.getAttribute("color");
      _color1.copy(this.light.color);
      _color2.copy(this.light.groundColor);
      for (let i2 = 0, l2 = colors.count; i2 < l2; i2++) {
        const color = i2 < l2 / 2 ? _color1 : _color2;
        colors.setXYZ(i2, color.r, color.g, color.b);
      }
      colors.needsUpdate = true;
    }
    this.light.updateWorldMatrix(true, false);
    mesh.lookAt(_vector$1.setFromMatrixPosition(this.light.matrixWorld).negate());
  }
};
var GridHelper = class extends LineSegments {
  constructor(size = 10, divisions = 10, color1 = 4473924, color2 = 8947848) {
    color1 = new Color(color1);
    color2 = new Color(color2);
    const center = divisions / 2;
    const step = size / divisions;
    const halfSize = size / 2;
    const vertices = [], colors = [];
    for (let i2 = 0, j = 0, k2 = -halfSize; i2 <= divisions; i2++, k2 += step) {
      vertices.push(-halfSize, 0, k2, halfSize, 0, k2);
      vertices.push(k2, 0, -halfSize, k2, 0, halfSize);
      const color = i2 === center ? color1 : color2;
      color.toArray(colors, j);
      j += 3;
      color.toArray(colors, j);
      j += 3;
      color.toArray(colors, j);
      j += 3;
      color.toArray(colors, j);
      j += 3;
    }
    const geometry = new BufferGeometry();
    geometry.setAttribute("position", new Float32BufferAttribute(vertices, 3));
    geometry.setAttribute("color", new Float32BufferAttribute(colors, 3));
    const material = new LineBasicMaterial({ vertexColors: true, toneMapped: false });
    super(geometry, material);
    this.type = "GridHelper";
  }
  dispose() {
    this.geometry.dispose();
    this.material.dispose();
  }
};
var PolarGridHelper = class extends LineSegments {
  constructor(radius = 10, sectors = 16, rings = 8, divisions = 64, color1 = 4473924, color2 = 8947848) {
    color1 = new Color(color1);
    color2 = new Color(color2);
    const vertices = [];
    const colors = [];
    if (sectors > 1) {
      for (let i2 = 0; i2 < sectors; i2++) {
        const v2 = i2 / sectors * (Math.PI * 2);
        const x3 = Math.sin(v2) * radius;
        const z = Math.cos(v2) * radius;
        vertices.push(0, 0, 0);
        vertices.push(x3, 0, z);
        const color = i2 & 1 ? color1 : color2;
        colors.push(color.r, color.g, color.b);
        colors.push(color.r, color.g, color.b);
      }
    }
    for (let i2 = 0; i2 < rings; i2++) {
      const color = i2 & 1 ? color1 : color2;
      const r2 = radius - radius / rings * i2;
      for (let j = 0; j < divisions; j++) {
        let v2 = j / divisions * (Math.PI * 2);
        let x3 = Math.sin(v2) * r2;
        let z = Math.cos(v2) * r2;
        vertices.push(x3, 0, z);
        colors.push(color.r, color.g, color.b);
        v2 = (j + 1) / divisions * (Math.PI * 2);
        x3 = Math.sin(v2) * r2;
        z = Math.cos(v2) * r2;
        vertices.push(x3, 0, z);
        colors.push(color.r, color.g, color.b);
      }
    }
    const geometry = new BufferGeometry();
    geometry.setAttribute("position", new Float32BufferAttribute(vertices, 3));
    geometry.setAttribute("color", new Float32BufferAttribute(colors, 3));
    const material = new LineBasicMaterial({ vertexColors: true, toneMapped: false });
    super(geometry, material);
    this.type = "PolarGridHelper";
  }
  dispose() {
    this.geometry.dispose();
    this.material.dispose();
  }
};
var _v1 = new Vector3();
var _v2 = new Vector3();
var _v3 = new Vector3();
var DirectionalLightHelper = class extends Object3D {
  constructor(light, size, color) {
    super();
    this.light = light;
    this.matrix = light.matrixWorld;
    this.matrixAutoUpdate = false;
    this.color = color;
    this.type = "DirectionalLightHelper";
    if (size === void 0) size = 1;
    let geometry = new BufferGeometry();
    geometry.setAttribute("position", new Float32BufferAttribute([
      -size,
      size,
      0,
      size,
      size,
      0,
      size,
      -size,
      0,
      -size,
      -size,
      0,
      -size,
      size,
      0
    ], 3));
    const material = new LineBasicMaterial({ fog: false, toneMapped: false });
    this.lightPlane = new Line(geometry, material);
    this.add(this.lightPlane);
    geometry = new BufferGeometry();
    geometry.setAttribute("position", new Float32BufferAttribute([0, 0, 0, 0, 0, 1], 3));
    this.targetLine = new Line(geometry, material);
    this.add(this.targetLine);
    this.update();
  }
  dispose() {
    this.lightPlane.geometry.dispose();
    this.lightPlane.material.dispose();
    this.targetLine.geometry.dispose();
    this.targetLine.material.dispose();
  }
  update() {
    this.light.updateWorldMatrix(true, false);
    this.light.target.updateWorldMatrix(true, false);
    _v1.setFromMatrixPosition(this.light.matrixWorld);
    _v2.setFromMatrixPosition(this.light.target.matrixWorld);
    _v3.subVectors(_v2, _v1);
    this.lightPlane.lookAt(_v2);
    if (this.color !== void 0) {
      this.lightPlane.material.color.set(this.color);
      this.targetLine.material.color.set(this.color);
    } else {
      this.lightPlane.material.color.copy(this.light.color);
      this.targetLine.material.color.copy(this.light.color);
    }
    this.targetLine.lookAt(_v2);
    this.targetLine.scale.z = _v3.length();
  }
};
var _vector = new Vector3();
var _camera = new Camera();
var CameraHelper = class extends LineSegments {
  constructor(camera) {
    const geometry = new BufferGeometry();
    const material = new LineBasicMaterial({ color: 16777215, vertexColors: true, toneMapped: false });
    const vertices = [];
    const colors = [];
    const pointMap = {};
    addLine("n1", "n2");
    addLine("n2", "n4");
    addLine("n4", "n3");
    addLine("n3", "n1");
    addLine("f1", "f2");
    addLine("f2", "f4");
    addLine("f4", "f3");
    addLine("f3", "f1");
    addLine("n1", "f1");
    addLine("n2", "f2");
    addLine("n3", "f3");
    addLine("n4", "f4");
    addLine("p", "n1");
    addLine("p", "n2");
    addLine("p", "n3");
    addLine("p", "n4");
    addLine("u1", "u2");
    addLine("u2", "u3");
    addLine("u3", "u1");
    addLine("c", "t");
    addLine("p", "c");
    addLine("cn1", "cn2");
    addLine("cn3", "cn4");
    addLine("cf1", "cf2");
    addLine("cf3", "cf4");
    function addLine(a2, b2) {
      addPoint(a2);
      addPoint(b2);
    }
    function addPoint(id2) {
      vertices.push(0, 0, 0);
      colors.push(0, 0, 0);
      if (pointMap[id2] === void 0) {
        pointMap[id2] = [];
      }
      pointMap[id2].push(vertices.length / 3 - 1);
    }
    geometry.setAttribute("position", new Float32BufferAttribute(vertices, 3));
    geometry.setAttribute("color", new Float32BufferAttribute(colors, 3));
    super(geometry, material);
    this.type = "CameraHelper";
    this.camera = camera;
    if (this.camera.updateProjectionMatrix) this.camera.updateProjectionMatrix();
    this.matrix = camera.matrixWorld;
    this.matrixAutoUpdate = false;
    this.pointMap = pointMap;
    this.update();
    const colorFrustum = new Color(16755200);
    const colorCone = new Color(16711680);
    const colorUp = new Color(43775);
    const colorTarget = new Color(16777215);
    const colorCross = new Color(3355443);
    this.setColors(colorFrustum, colorCone, colorUp, colorTarget, colorCross);
  }
  setColors(frustum, cone, up, target, cross) {
    const geometry = this.geometry;
    const colorAttribute = geometry.getAttribute("color");
    colorAttribute.setXYZ(0, frustum.r, frustum.g, frustum.b);
    colorAttribute.setXYZ(1, frustum.r, frustum.g, frustum.b);
    colorAttribute.setXYZ(2, frustum.r, frustum.g, frustum.b);
    colorAttribute.setXYZ(3, frustum.r, frustum.g, frustum.b);
    colorAttribute.setXYZ(4, frustum.r, frustum.g, frustum.b);
    colorAttribute.setXYZ(5, frustum.r, frustum.g, frustum.b);
    colorAttribute.setXYZ(6, frustum.r, frustum.g, frustum.b);
    colorAttribute.setXYZ(7, frustum.r, frustum.g, frustum.b);
    colorAttribute.setXYZ(8, frustum.r, frustum.g, frustum.b);
    colorAttribute.setXYZ(9, frustum.r, frustum.g, frustum.b);
    colorAttribute.setXYZ(10, frustum.r, frustum.g, frustum.b);
    colorAttribute.setXYZ(11, frustum.r, frustum.g, frustum.b);
    colorAttribute.setXYZ(12, frustum.r, frustum.g, frustum.b);
    colorAttribute.setXYZ(13, frustum.r, frustum.g, frustum.b);
    colorAttribute.setXYZ(14, frustum.r, frustum.g, frustum.b);
    colorAttribute.setXYZ(15, frustum.r, frustum.g, frustum.b);
    colorAttribute.setXYZ(16, frustum.r, frustum.g, frustum.b);
    colorAttribute.setXYZ(17, frustum.r, frustum.g, frustum.b);
    colorAttribute.setXYZ(18, frustum.r, frustum.g, frustum.b);
    colorAttribute.setXYZ(19, frustum.r, frustum.g, frustum.b);
    colorAttribute.setXYZ(20, frustum.r, frustum.g, frustum.b);
    colorAttribute.setXYZ(21, frustum.r, frustum.g, frustum.b);
    colorAttribute.setXYZ(22, frustum.r, frustum.g, frustum.b);
    colorAttribute.setXYZ(23, frustum.r, frustum.g, frustum.b);
    colorAttribute.setXYZ(24, cone.r, cone.g, cone.b);
    colorAttribute.setXYZ(25, cone.r, cone.g, cone.b);
    colorAttribute.setXYZ(26, cone.r, cone.g, cone.b);
    colorAttribute.setXYZ(27, cone.r, cone.g, cone.b);
    colorAttribute.setXYZ(28, cone.r, cone.g, cone.b);
    colorAttribute.setXYZ(29, cone.r, cone.g, cone.b);
    colorAttribute.setXYZ(30, cone.r, cone.g, cone.b);
    colorAttribute.setXYZ(31, cone.r, cone.g, cone.b);
    colorAttribute.setXYZ(32, up.r, up.g, up.b);
    colorAttribute.setXYZ(33, up.r, up.g, up.b);
    colorAttribute.setXYZ(34, up.r, up.g, up.b);
    colorAttribute.setXYZ(35, up.r, up.g, up.b);
    colorAttribute.setXYZ(36, up.r, up.g, up.b);
    colorAttribute.setXYZ(37, up.r, up.g, up.b);
    colorAttribute.setXYZ(38, target.r, target.g, target.b);
    colorAttribute.setXYZ(39, target.r, target.g, target.b);
    colorAttribute.setXYZ(40, cross.r, cross.g, cross.b);
    colorAttribute.setXYZ(41, cross.r, cross.g, cross.b);
    colorAttribute.setXYZ(42, cross.r, cross.g, cross.b);
    colorAttribute.setXYZ(43, cross.r, cross.g, cross.b);
    colorAttribute.setXYZ(44, cross.r, cross.g, cross.b);
    colorAttribute.setXYZ(45, cross.r, cross.g, cross.b);
    colorAttribute.setXYZ(46, cross.r, cross.g, cross.b);
    colorAttribute.setXYZ(47, cross.r, cross.g, cross.b);
    colorAttribute.setXYZ(48, cross.r, cross.g, cross.b);
    colorAttribute.setXYZ(49, cross.r, cross.g, cross.b);
    colorAttribute.needsUpdate = true;
  }
  update() {
    const geometry = this.geometry;
    const pointMap = this.pointMap;
    const w2 = 1, h2 = 1;
    _camera.projectionMatrixInverse.copy(this.camera.projectionMatrixInverse);
    setPoint("c", pointMap, geometry, _camera, 0, 0, -1);
    setPoint("t", pointMap, geometry, _camera, 0, 0, 1);
    setPoint("n1", pointMap, geometry, _camera, -w2, -h2, -1);
    setPoint("n2", pointMap, geometry, _camera, w2, -h2, -1);
    setPoint("n3", pointMap, geometry, _camera, -w2, h2, -1);
    setPoint("n4", pointMap, geometry, _camera, w2, h2, -1);
    setPoint("f1", pointMap, geometry, _camera, -w2, -h2, 1);
    setPoint("f2", pointMap, geometry, _camera, w2, -h2, 1);
    setPoint("f3", pointMap, geometry, _camera, -w2, h2, 1);
    setPoint("f4", pointMap, geometry, _camera, w2, h2, 1);
    setPoint("u1", pointMap, geometry, _camera, w2 * 0.7, h2 * 1.1, -1);
    setPoint("u2", pointMap, geometry, _camera, -w2 * 0.7, h2 * 1.1, -1);
    setPoint("u3", pointMap, geometry, _camera, 0, h2 * 2, -1);
    setPoint("cf1", pointMap, geometry, _camera, -w2, 0, 1);
    setPoint("cf2", pointMap, geometry, _camera, w2, 0, 1);
    setPoint("cf3", pointMap, geometry, _camera, 0, -h2, 1);
    setPoint("cf4", pointMap, geometry, _camera, 0, h2, 1);
    setPoint("cn1", pointMap, geometry, _camera, -w2, 0, -1);
    setPoint("cn2", pointMap, geometry, _camera, w2, 0, -1);
    setPoint("cn3", pointMap, geometry, _camera, 0, -h2, -1);
    setPoint("cn4", pointMap, geometry, _camera, 0, h2, -1);
    geometry.getAttribute("position").needsUpdate = true;
  }
  dispose() {
    this.geometry.dispose();
    this.material.dispose();
  }
};
function setPoint(point, pointMap, geometry, camera, x3, y2, z) {
  _vector.set(x3, y2, z).unproject(camera);
  const points = pointMap[point];
  if (points !== void 0) {
    const position = geometry.getAttribute("position");
    for (let i2 = 0, l2 = points.length; i2 < l2; i2++) {
      position.setXYZ(points[i2], _vector.x, _vector.y, _vector.z);
    }
  }
}
var _box = new Box3();
var BoxHelper = class extends LineSegments {
  constructor(object, color = 16776960) {
    const indices = new Uint16Array([0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7]);
    const positions = new Float32Array(8 * 3);
    const geometry = new BufferGeometry();
    geometry.setIndex(new BufferAttribute(indices, 1));
    geometry.setAttribute("position", new BufferAttribute(positions, 3));
    super(geometry, new LineBasicMaterial({ color, toneMapped: false }));
    this.object = object;
    this.type = "BoxHelper";
    this.matrixAutoUpdate = false;
    this.update();
  }
  update(object) {
    if (object !== void 0) {
      console.warn("THREE.BoxHelper: .update() has no longer arguments.");
    }
    if (this.object !== void 0) {
      _box.setFromObject(this.object);
    }
    if (_box.isEmpty()) return;
    const min = _box.min;
    const max = _box.max;
    const position = this.geometry.attributes.position;
    const array = position.array;
    array[0] = max.x;
    array[1] = max.y;
    array[2] = max.z;
    array[3] = min.x;
    array[4] = max.y;
    array[5] = max.z;
    array[6] = min.x;
    array[7] = min.y;
    array[8] = max.z;
    array[9] = max.x;
    array[10] = min.y;
    array[11] = max.z;
    array[12] = max.x;
    array[13] = max.y;
    array[14] = min.z;
    array[15] = min.x;
    array[16] = max.y;
    array[17] = min.z;
    array[18] = min.x;
    array[19] = min.y;
    array[20] = min.z;
    array[21] = max.x;
    array[22] = min.y;
    array[23] = min.z;
    position.needsUpdate = true;
    this.geometry.computeBoundingSphere();
  }
  setFromObject(object) {
    this.object = object;
    this.update();
    return this;
  }
  copy(source, recursive) {
    super.copy(source, recursive);
    this.object = source.object;
    return this;
  }
  dispose() {
    this.geometry.dispose();
    this.material.dispose();
  }
};
var Box3Helper = class extends LineSegments {
  constructor(box, color = 16776960) {
    const indices = new Uint16Array([0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7]);
    const positions = [1, 1, 1, -1, 1, 1, -1, -1, 1, 1, -1, 1, 1, 1, -1, -1, 1, -1, -1, -1, -1, 1, -1, -1];
    const geometry = new BufferGeometry();
    geometry.setIndex(new BufferAttribute(indices, 1));
    geometry.setAttribute("position", new Float32BufferAttribute(positions, 3));
    super(geometry, new LineBasicMaterial({ color, toneMapped: false }));
    this.box = box;
    this.type = "Box3Helper";
    this.geometry.computeBoundingSphere();
  }
  updateMatrixWorld(force) {
    const box = this.box;
    if (box.isEmpty()) return;
    box.getCenter(this.position);
    box.getSize(this.scale);
    this.scale.multiplyScalar(0.5);
    super.updateMatrixWorld(force);
  }
  dispose() {
    this.geometry.dispose();
    this.material.dispose();
  }
};
var PlaneHelper = class extends Line {
  constructor(plane, size = 1, hex = 16776960) {
    const color = hex;
    const positions = [1, -1, 0, -1, 1, 0, -1, -1, 0, 1, 1, 0, -1, 1, 0, -1, -1, 0, 1, -1, 0, 1, 1, 0];
    const geometry = new BufferGeometry();
    geometry.setAttribute("position", new Float32BufferAttribute(positions, 3));
    geometry.computeBoundingSphere();
    super(geometry, new LineBasicMaterial({ color, toneMapped: false }));
    this.type = "PlaneHelper";
    this.plane = plane;
    this.size = size;
    const positions2 = [1, 1, 0, -1, 1, 0, -1, -1, 0, 1, 1, 0, -1, -1, 0, 1, -1, 0];
    const geometry2 = new BufferGeometry();
    geometry2.setAttribute("position", new Float32BufferAttribute(positions2, 3));
    geometry2.computeBoundingSphere();
    this.add(new Mesh(geometry2, new MeshBasicMaterial({ color, opacity: 0.2, transparent: true, depthWrite: false, toneMapped: false })));
  }
  updateMatrixWorld(force) {
    this.position.set(0, 0, 0);
    this.scale.set(0.5 * this.size, 0.5 * this.size, 1);
    this.lookAt(this.plane.normal);
    this.translateZ(-this.plane.constant);
    super.updateMatrixWorld(force);
  }
  dispose() {
    this.geometry.dispose();
    this.material.dispose();
    this.children[0].geometry.dispose();
    this.children[0].material.dispose();
  }
};
var _axis = new Vector3();
var _lineGeometry;
var _coneGeometry;
var ArrowHelper = class extends Object3D {
  // dir is assumed to be normalized
  constructor(dir = new Vector3(0, 0, 1), origin = new Vector3(0, 0, 0), length = 1, color = 16776960, headLength = length * 0.2, headWidth = headLength * 0.2) {
    super();
    this.type = "ArrowHelper";
    if (_lineGeometry === void 0) {
      _lineGeometry = new BufferGeometry();
      _lineGeometry.setAttribute("position", new Float32BufferAttribute([0, 0, 0, 0, 1, 0], 3));
      _coneGeometry = new CylinderGeometry(0, 0.5, 1, 5, 1);
      _coneGeometry.translate(0, -0.5, 0);
    }
    this.position.copy(origin);
    this.line = new Line(_lineGeometry, new LineBasicMaterial({ color, toneMapped: false }));
    this.line.matrixAutoUpdate = false;
    this.add(this.line);
    this.cone = new Mesh(_coneGeometry, new MeshBasicMaterial({ color, toneMapped: false }));
    this.cone.matrixAutoUpdate = false;
    this.add(this.cone);
    this.setDirection(dir);
    this.setLength(length, headLength, headWidth);
  }
  setDirection(dir) {
    if (dir.y > 0.99999) {
      this.quaternion.set(0, 0, 0, 1);
    } else if (dir.y < -0.99999) {
      this.quaternion.set(1, 0, 0, 0);
    } else {
      _axis.set(dir.z, 0, -dir.x).normalize();
      const radians = Math.acos(dir.y);
      this.quaternion.setFromAxisAngle(_axis, radians);
    }
  }
  setLength(length, headLength = length * 0.2, headWidth = headLength * 0.2) {
    this.line.scale.set(1, Math.max(1e-4, length - headLength), 1);
    this.line.updateMatrix();
    this.cone.scale.set(headWidth, headLength, headWidth);
    this.cone.position.y = length;
    this.cone.updateMatrix();
  }
  setColor(color) {
    this.line.material.color.set(color);
    this.cone.material.color.set(color);
  }
  copy(source) {
    super.copy(source, false);
    this.line.copy(source.line);
    this.cone.copy(source.cone);
    return this;
  }
  dispose() {
    this.line.geometry.dispose();
    this.line.material.dispose();
    this.cone.geometry.dispose();
    this.cone.material.dispose();
  }
};
var AxesHelper = class extends LineSegments {
  constructor(size = 1) {
    const vertices = [
      0,
      0,
      0,
      size,
      0,
      0,
      0,
      0,
      0,
      0,
      size,
      0,
      0,
      0,
      0,
      0,
      0,
      size
    ];
    const colors = [
      1,
      0,
      0,
      1,
      0.6,
      0,
      0,
      1,
      0,
      0.6,
      1,
      0,
      0,
      0,
      1,
      0,
      0.6,
      1
    ];
    const geometry = new BufferGeometry();
    geometry.setAttribute("position", new Float32BufferAttribute(vertices, 3));
    geometry.setAttribute("color", new Float32BufferAttribute(colors, 3));
    const material = new LineBasicMaterial({ vertexColors: true, toneMapped: false });
    super(geometry, material);
    this.type = "AxesHelper";
  }
  setColors(xAxisColor, yAxisColor, zAxisColor) {
    const color = new Color();
    const array = this.geometry.attributes.color.array;
    color.set(xAxisColor);
    color.toArray(array, 0);
    color.toArray(array, 3);
    color.set(yAxisColor);
    color.toArray(array, 6);
    color.toArray(array, 9);
    color.set(zAxisColor);
    color.toArray(array, 12);
    color.toArray(array, 15);
    this.geometry.attributes.color.needsUpdate = true;
    return this;
  }
  dispose() {
    this.geometry.dispose();
    this.material.dispose();
  }
};
var ShapePath = class {
  constructor() {
    this.type = "ShapePath";
    this.color = new Color();
    this.subPaths = [];
    this.currentPath = null;
  }
  moveTo(x3, y2) {
    this.currentPath = new Path();
    this.subPaths.push(this.currentPath);
    this.currentPath.moveTo(x3, y2);
    return this;
  }
  lineTo(x3, y2) {
    this.currentPath.lineTo(x3, y2);
    return this;
  }
  quadraticCurveTo(aCPx, aCPy, aX, aY) {
    this.currentPath.quadraticCurveTo(aCPx, aCPy, aX, aY);
    return this;
  }
  bezierCurveTo(aCP1x, aCP1y, aCP2x, aCP2y, aX, aY) {
    this.currentPath.bezierCurveTo(aCP1x, aCP1y, aCP2x, aCP2y, aX, aY);
    return this;
  }
  splineThru(pts) {
    this.currentPath.splineThru(pts);
    return this;
  }
  toShapes(isCCW) {
    function toShapesNoHoles(inSubpaths) {
      const shapes2 = [];
      for (let i2 = 0, l2 = inSubpaths.length; i2 < l2; i2++) {
        const tmpPath2 = inSubpaths[i2];
        const tmpShape2 = new Shape();
        tmpShape2.curves = tmpPath2.curves;
        shapes2.push(tmpShape2);
      }
      return shapes2;
    }
    function isPointInsidePolygon(inPt, inPolygon) {
      const polyLen = inPolygon.length;
      let inside = false;
      for (let p2 = polyLen - 1, q = 0; q < polyLen; p2 = q++) {
        let edgeLowPt = inPolygon[p2];
        let edgeHighPt = inPolygon[q];
        let edgeDx = edgeHighPt.x - edgeLowPt.x;
        let edgeDy = edgeHighPt.y - edgeLowPt.y;
        if (Math.abs(edgeDy) > Number.EPSILON) {
          if (edgeDy < 0) {
            edgeLowPt = inPolygon[q];
            edgeDx = -edgeDx;
            edgeHighPt = inPolygon[p2];
            edgeDy = -edgeDy;
          }
          if (inPt.y < edgeLowPt.y || inPt.y > edgeHighPt.y) continue;
          if (inPt.y === edgeLowPt.y) {
            if (inPt.x === edgeLowPt.x) return true;
          } else {
            const perpEdge = edgeDy * (inPt.x - edgeLowPt.x) - edgeDx * (inPt.y - edgeLowPt.y);
            if (perpEdge === 0) return true;
            if (perpEdge < 0) continue;
            inside = !inside;
          }
        } else {
          if (inPt.y !== edgeLowPt.y) continue;
          if (edgeHighPt.x <= inPt.x && inPt.x <= edgeLowPt.x || edgeLowPt.x <= inPt.x && inPt.x <= edgeHighPt.x) return true;
        }
      }
      return inside;
    }
    const isClockWise = ShapeUtils.isClockWise;
    const subPaths = this.subPaths;
    if (subPaths.length === 0) return [];
    let solid, tmpPath, tmpShape;
    const shapes = [];
    if (subPaths.length === 1) {
      tmpPath = subPaths[0];
      tmpShape = new Shape();
      tmpShape.curves = tmpPath.curves;
      shapes.push(tmpShape);
      return shapes;
    }
    let holesFirst = !isClockWise(subPaths[0].getPoints());
    holesFirst = isCCW ? !holesFirst : holesFirst;
    const betterShapeHoles = [];
    const newShapes = [];
    let newShapeHoles = [];
    let mainIdx = 0;
    let tmpPoints;
    newShapes[mainIdx] = void 0;
    newShapeHoles[mainIdx] = [];
    for (let i2 = 0, l2 = subPaths.length; i2 < l2; i2++) {
      tmpPath = subPaths[i2];
      tmpPoints = tmpPath.getPoints();
      solid = isClockWise(tmpPoints);
      solid = isCCW ? !solid : solid;
      if (solid) {
        if (!holesFirst && newShapes[mainIdx]) mainIdx++;
        newShapes[mainIdx] = { s: new Shape(), p: tmpPoints };
        newShapes[mainIdx].s.curves = tmpPath.curves;
        if (holesFirst) mainIdx++;
        newShapeHoles[mainIdx] = [];
      } else {
        newShapeHoles[mainIdx].push({ h: tmpPath, p: tmpPoints[0] });
      }
    }
    if (!newShapes[0]) return toShapesNoHoles(subPaths);
    if (newShapes.length > 1) {
      let ambiguous = false;
      let toChange = 0;
      for (let sIdx = 0, sLen = newShapes.length; sIdx < sLen; sIdx++) {
        betterShapeHoles[sIdx] = [];
      }
      for (let sIdx = 0, sLen = newShapes.length; sIdx < sLen; sIdx++) {
        const sho = newShapeHoles[sIdx];
        for (let hIdx = 0; hIdx < sho.length; hIdx++) {
          const ho = sho[hIdx];
          let hole_unassigned = true;
          for (let s2Idx = 0; s2Idx < newShapes.length; s2Idx++) {
            if (isPointInsidePolygon(ho.p, newShapes[s2Idx].p)) {
              if (sIdx !== s2Idx) toChange++;
              if (hole_unassigned) {
                hole_unassigned = false;
                betterShapeHoles[s2Idx].push(ho);
              } else {
                ambiguous = true;
              }
            }
          }
          if (hole_unassigned) {
            betterShapeHoles[sIdx].push(ho);
          }
        }
      }
      if (toChange > 0 && ambiguous === false) {
        newShapeHoles = betterShapeHoles;
      }
    }
    let tmpHoles;
    for (let i2 = 0, il = newShapes.length; i2 < il; i2++) {
      tmpShape = newShapes[i2].s;
      shapes.push(tmpShape);
      tmpHoles = newShapeHoles[i2];
      for (let j = 0, jl = tmpHoles.length; j < jl; j++) {
        tmpShape.holes.push(tmpHoles[j].h);
      }
    }
    return shapes;
  }
};
var BoxBufferGeometry = class extends BoxGeometry {
  // @deprecated, r144
  constructor(width, height, depth, widthSegments, heightSegments, depthSegments) {
    console.warn("THREE.BoxBufferGeometry has been renamed to THREE.BoxGeometry.");
    super(width, height, depth, widthSegments, heightSegments, depthSegments);
  }
};
var CapsuleBufferGeometry = class extends CapsuleGeometry {
  // @deprecated, r144
  constructor(radius, length, capSegments, radialSegments) {
    console.warn("THREE.CapsuleBufferGeometry has been renamed to THREE.CapsuleGeometry.");
    super(radius, length, capSegments, radialSegments);
  }
};
var CircleBufferGeometry = class extends CircleGeometry {
  // @deprecated, r144
  constructor(radius, segments, thetaStart, thetaLength) {
    console.warn("THREE.CircleBufferGeometry has been renamed to THREE.CircleGeometry.");
    super(radius, segments, thetaStart, thetaLength);
  }
};
var ConeBufferGeometry = class extends ConeGeometry {
  // @deprecated, r144
  constructor(radius, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength) {
    console.warn("THREE.ConeBufferGeometry has been renamed to THREE.ConeGeometry.");
    super(radius, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength);
  }
};
var CylinderBufferGeometry = class extends CylinderGeometry {
  // @deprecated, r144
  constructor(radiusTop, radiusBottom, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength) {
    console.warn("THREE.CylinderBufferGeometry has been renamed to THREE.CylinderGeometry.");
    super(radiusTop, radiusBottom, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength);
  }
};
var DodecahedronBufferGeometry = class extends DodecahedronGeometry {
  // @deprecated, r144
  constructor(radius, detail) {
    console.warn("THREE.DodecahedronBufferGeometry has been renamed to THREE.DodecahedronGeometry.");
    super(radius, detail);
  }
};
var ExtrudeBufferGeometry = class extends ExtrudeGeometry {
  // @deprecated, r144
  constructor(shapes, options2) {
    console.warn("THREE.ExtrudeBufferGeometry has been renamed to THREE.ExtrudeGeometry.");
    super(shapes, options2);
  }
};
var IcosahedronBufferGeometry = class extends IcosahedronGeometry {
  // @deprecated, r144
  constructor(radius, detail) {
    console.warn("THREE.IcosahedronBufferGeometry has been renamed to THREE.IcosahedronGeometry.");
    super(radius, detail);
  }
};
var LatheBufferGeometry = class extends LatheGeometry {
  // @deprecated, r144
  constructor(points, segments, phiStart, phiLength) {
    console.warn("THREE.LatheBufferGeometry has been renamed to THREE.LatheGeometry.");
    super(points, segments, phiStart, phiLength);
  }
};
var OctahedronBufferGeometry = class extends OctahedronGeometry {
  // @deprecated, r144
  constructor(radius, detail) {
    console.warn("THREE.OctahedronBufferGeometry has been renamed to THREE.OctahedronGeometry.");
    super(radius, detail);
  }
};
var PlaneBufferGeometry = class extends PlaneGeometry {
  // @deprecated, r144
  constructor(width, height, widthSegments, heightSegments) {
    console.warn("THREE.PlaneBufferGeometry has been renamed to THREE.PlaneGeometry.");
    super(width, height, widthSegments, heightSegments);
  }
};
var PolyhedronBufferGeometry = class extends PolyhedronGeometry {
  // @deprecated, r144
  constructor(vertices, indices, radius, detail) {
    console.warn("THREE.PolyhedronBufferGeometry has been renamed to THREE.PolyhedronGeometry.");
    super(vertices, indices, radius, detail);
  }
};
var RingBufferGeometry = class extends RingGeometry {
  // @deprecated, r144
  constructor(innerRadius, outerRadius, thetaSegments, phiSegments, thetaStart, thetaLength) {
    console.warn("THREE.RingBufferGeometry has been renamed to THREE.RingGeometry.");
    super(innerRadius, outerRadius, thetaSegments, phiSegments, thetaStart, thetaLength);
  }
};
var ShapeBufferGeometry = class extends ShapeGeometry {
  // @deprecated, r144
  constructor(shapes, curveSegments) {
    console.warn("THREE.ShapeBufferGeometry has been renamed to THREE.ShapeGeometry.");
    super(shapes, curveSegments);
  }
};
var SphereBufferGeometry = class extends SphereGeometry {
  // @deprecated, r144
  constructor(radius, widthSegments, heightSegments, phiStart, phiLength, thetaStart, thetaLength) {
    console.warn("THREE.SphereBufferGeometry has been renamed to THREE.SphereGeometry.");
    super(radius, widthSegments, heightSegments, phiStart, phiLength, thetaStart, thetaLength);
  }
};
var TetrahedronBufferGeometry = class extends TetrahedronGeometry {
  // @deprecated, r144
  constructor(radius, detail) {
    console.warn("THREE.TetrahedronBufferGeometry has been renamed to THREE.TetrahedronGeometry.");
    super(radius, detail);
  }
};
var TorusBufferGeometry = class extends TorusGeometry {
  // @deprecated, r144
  constructor(radius, tube, radialSegments, tubularSegments, arc) {
    console.warn("THREE.TorusBufferGeometry has been renamed to THREE.TorusGeometry.");
    super(radius, tube, radialSegments, tubularSegments, arc);
  }
};
var TorusKnotBufferGeometry = class extends TorusKnotGeometry {
  // @deprecated, r144
  constructor(radius, tube, tubularSegments, radialSegments, p2, q) {
    console.warn("THREE.TorusKnotBufferGeometry has been renamed to THREE.TorusKnotGeometry.");
    super(radius, tube, tubularSegments, radialSegments, p2, q);
  }
};
var TubeBufferGeometry = class extends TubeGeometry {
  // @deprecated, r144
  constructor(path, tubularSegments, radius, radialSegments, closed) {
    console.warn("THREE.TubeBufferGeometry has been renamed to THREE.TubeGeometry.");
    super(path, tubularSegments, radius, radialSegments, closed);
  }
};
if (typeof __THREE_DEVTOOLS__ !== "undefined") {
  __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("register", { detail: {
    revision: REVISION
  } }));
}
if (typeof window !== "undefined") {
  if (window.__THREE__) {
    console.warn("WARNING: Multiple instances of Three.js being imported.");
  } else {
    window.__THREE__ = REVISION;
  }
}

// node_modules/miew/dist/Miew.module.js
var __webpack_modules__ = {
  /***/
  89: (
    /***/
    (module) => {
      var parser = function() {
        var o2 = function(k2, v2, o3, l2) {
          for (o3 = o3 || {}, l2 = k2.length; l2--; o3[k2[l2]] = v2) ;
          return o3;
        }, $V0 = [1, 60], $V1 = [1, 62], $V2 = [1, 63], $V3 = [1, 65], $V4 = [1, 66], $V5 = [1, 67], $V6 = [1, 68], $V7 = [1, 69], $V8 = [1, 80], $V9 = [1, 72], $Va = [1, 73], $Vb = [1, 74], $Vc = [1, 75], $Vd = [1, 99], $Ve = [1, 76], $Vf = [1, 100], $Vg = [1, 79], $Vh = [1, 51], $Vi = [1, 81], $Vj = [1, 82], $Vk = [1, 84], $Vl = [1, 83], $Vm = [1, 85], $Vn = [1, 96], $Vo = [1, 97], $Vp = [1, 98], $Vq = [1, 86], $Vr = [1, 87], $Vs = [1, 64], $Vt = [1, 70], $Vu = [1, 71], $Vv = [1, 77], $Vw = [1, 78], $Vx = [1, 53], $Vy = [1, 54], $Vz = [1, 55], $VA = [1, 61], $VB = [1, 88], $VC = [1, 89], $VD = [1, 90], $VE = [1, 91], $VF = [1, 92], $VG = [1, 93], $VH = [1, 94], $VI = [1, 95], $VJ = [1, 101], $VK = [1, 102], $VL = [1, 103], $VM = [1, 104], $VN = [1, 105], $VO = [1, 56], $VP = [1, 57], $VQ = [1, 58], $VR = [1, 59], $VS = [1, 115], $VT = [1, 111], $VU = [1, 114], $VV = [1, 112], $VW = [1, 113], $VX = [1, 118], $VY = [1, 117], $VZ = [1, 134], $V_ = [1, 149], $V$ = [1, 150], $V01 = [1, 157], $V11 = [5, 6, 7, 9, 13, 14, 15, 17, 18, 19, 20, 23, 25, 26, 27, 30, 33, 34, 35, 37, 38, 41, 43, 45, 46, 49, 52, 54, 55, 56, 58, 59, 62, 64, 65, 66, 70, 72, 74, 77, 78, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 101], $V21 = [5, 6, 7, 9, 13, 14, 15, 17, 18, 19, 20, 23, 25, 26, 27, 30, 33, 34, 35, 37, 38, 41, 43, 45, 46, 49, 52, 54, 55, 56, 58, 59, 62, 64, 65, 66, 70, 71, 72, 74, 77, 78, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 101], $V31 = [5, 6, 7, 9, 13, 15, 17, 18, 19, 20, 23, 25, 26, 27, 30, 33, 34, 37, 38, 41, 43, 45, 46, 49, 52, 54, 55, 56, 58, 59, 62, 64, 65, 66, 70, 72, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95], $V41 = [5, 70, 72], $V51 = [5, 74], $V61 = [71, 101];
        var parser2 = {
          trace: function trace() {
          },
          yy: {},
          symbols_: {
            "error": 2,
            "Program": 3,
            "Command": 4,
            "EOF": 5,
            "RESET": 6,
            "BUILD": 7,
            "ALL": 8,
            "HELP": 9,
            "Path": 10,
            "MOTM": 11,
            "OneArgCommand": 12,
            "GET": 13,
            "STRING": 14,
            "SET": 15,
            "Value": 16,
            "SET_SAVE": 17,
            "SET_RESTORE": 18,
            "SET_RESET": 19,
            "PRESET": 20,
            "AddRepresentation": 21,
            "EditRepresentation": 22,
            "REMOVE": 23,
            "RepresentationReference": 24,
            "HIDE": 25,
            "SHOW": 26,
            "LIST": 27,
            "EXPAND_KEY": 28,
            "SELECTOR_KEY": 29,
            "SELECT": 30,
            "AS": 31,
            "WordAll": 32,
            "SELECTOR": 33,
            "WITHIN": 34,
            "NUMBER": 35,
            "OF": 36,
            "MATERIAL": 37,
            "IDENTIFIER": 38,
            "ModeCMD": 39,
            "ColorCMD": 40,
            "VIEW": 41,
            "BASE_64": 42,
            "UNIT": 43,
            "DSSP": 44,
            "SCALE": 45,
            "ROTATE": 46,
            "AxesList": 47,
            "TRANSLATE": 48,
            "CENTER": 49,
            "GetURLBranch": 50,
            "Screenshot": 51,
            "LINE": 52,
            "ArgList": 53,
            "LISTOBJ": 54,
            "REMOVEOBJ": 55,
            "URL": 56,
            "VIEW_KEY": 57,
            "SCREENSHOT": 58,
            "LOAD": 59,
            "Url": 60,
            "FILE_KEY": 61,
            "ADD": 62,
            "Description": 63,
            "REP": 64,
            "MODE": 65,
            "COLOR": 66,
            "Descriptor": 67,
            "RepresentationOwnProperty": 68,
            "RepresentationOwnPropertyOpts": 69,
            "DESC_KEY": 70,
            "=": 71,
            "DESC_KEY_OPTS": 72,
            "AxesArg": 73,
            "DESC_KEY_AXES": 74,
            "Arg": 75,
            "PathWoDescKey": 76,
            "HEX": 77,
            "BOOL": 78,
            "Word": 79,
            "CommandSetWoDESC_KEY": 80,
            "DescKeys": 81,
            "CLEAR": 82,
            "FILE_LIST": 83,
            "FILE_REGISTER": 84,
            "FILE_DELETE": 85,
            "PRESET_ADD": 86,
            "PRESET_DELETE": 87,
            "PRESET_UPDATE": 88,
            "PRESET_RENAME": 89,
            "PRESET_OPEN": 90,
            "CREATE_SCENARIO": 91,
            "RESET_SCENARIO": 92,
            "DELETE_SCENARIO": 93,
            "ADD_SCENARIO_ITEM": 94,
            "LIST_SCENARIO": 95,
            "PDB_KEY": 96,
            "DELAY_KEY": 97,
            "PRST_KEY": 98,
            "DESCRIPTION_KEY": 99,
            "CommandSet": 100,
            ".": 101,
            "PresetPath": 102,
            "/": 103,
            "HexOrNumber": 104,
            "$accept": 0,
            "$end": 1
          },
          terminals_: {
            2: "error",
            5: "EOF",
            6: "RESET",
            7: "BUILD",
            8: "ALL",
            9: "HELP",
            11: "MOTM",
            13: "GET",
            14: "STRING",
            15: "SET",
            17: "SET_SAVE",
            18: "SET_RESTORE",
            19: "SET_RESET",
            20: "PRESET",
            23: "REMOVE",
            25: "HIDE",
            26: "SHOW",
            27: "LIST",
            28: "EXPAND_KEY",
            29: "SELECTOR_KEY",
            30: "SELECT",
            31: "AS",
            33: "SELECTOR",
            34: "WITHIN",
            35: "NUMBER",
            36: "OF",
            37: "MATERIAL",
            38: "IDENTIFIER",
            41: "VIEW",
            42: "BASE_64",
            43: "UNIT",
            44: "DSSP",
            45: "SCALE",
            46: "ROTATE",
            48: "TRANSLATE",
            49: "CENTER",
            52: "LINE",
            54: "LISTOBJ",
            55: "REMOVEOBJ",
            56: "URL",
            57: "VIEW_KEY",
            58: "SCREENSHOT",
            59: "LOAD",
            61: "FILE_KEY",
            62: "ADD",
            64: "REP",
            65: "MODE",
            66: "COLOR",
            70: "DESC_KEY",
            71: "=",
            72: "DESC_KEY_OPTS",
            74: "DESC_KEY_AXES",
            77: "HEX",
            78: "BOOL",
            82: "CLEAR",
            83: "FILE_LIST",
            84: "FILE_REGISTER",
            85: "FILE_DELETE",
            86: "PRESET_ADD",
            87: "PRESET_DELETE",
            88: "PRESET_UPDATE",
            89: "PRESET_RENAME",
            90: "PRESET_OPEN",
            91: "CREATE_SCENARIO",
            92: "RESET_SCENARIO",
            93: "DELETE_SCENARIO",
            94: "ADD_SCENARIO_ITEM",
            95: "LIST_SCENARIO",
            96: "PDB_KEY",
            97: "DELAY_KEY",
            98: "PRST_KEY",
            99: "DESCRIPTION_KEY",
            101: ".",
            103: "/"
          },
          productions_: [0, [3, 2], [3, 1], [4, 1], [4, 1], [4, 2], [4, 1], [4, 2], [4, 1], [4, 1], [4, 2], [4, 2], [4, 3], [4, 3], [4, 1], [4, 1], [4, 1], [4, 1], [4, 2], [4, 1], [4, 1], [4, 2], [4, 2], [4, 2], [4, 2], [4, 1], [4, 2], [4, 2], [4, 2], [4, 4], [4, 2], [4, 6], [4, 2], [4, 1], [4, 1], [4, 1], [4, 2], [4, 2], [4, 1], [4, 2], [4, 1], [4, 2], [4, 2], [4, 2], [4, 1], [4, 2], [4, 1], [4, 1], [4, 3], [4, 3], [4, 4], [4, 4], [4, 1], [4, 2], [50, 1], [50, 2], [50, 2], [50, 3], [50, 3], [51, 1], [51, 2], [51, 3], [12, 2], [12, 2], [12, 2], [21, 1], [21, 2], [21, 2], [21, 3], [22, 2], [22, 3], [39, 2], [39, 3], [40, 2], [40, 3], [24, 1], [24, 1], [63, 1], [63, 2], [63, 3], [63, 4], [67, 1], [67, 1], [67, 2], [68, 3], [69, 3], [47, 1], [47, 2], [73, 2], [53, 1], [53, 2], [75, 3], [16, 1], [16, 1], [16, 1], [16, 1], [16, 1], [79, 1], [79, 1], [32, 1], [32, 1], [80, 1], [80, 1], [80, 1], [80, 1], [80, 1], [80, 1], [80, 1], [80, 1], [80, 1], [80, 1], [80, 1], [80, 1], [80, 1], [80, 1], [80, 1], [80, 1], [80, 1], [80, 1], [80, 1], [80, 1], [80, 1], [80, 1], [80, 1], [80, 1], [80, 1], [80, 1], [80, 1], [80, 1], [80, 1], [80, 1], [80, 1], [80, 1], [80, 1], [80, 1], [80, 1], [80, 1], [80, 1], [80, 1], [80, 1], [80, 1], [80, 1], [80, 1], [80, 1], [80, 1], [80, 1], [80, 1], [81, 1], [81, 1], [81, 1], [81, 1], [81, 1], [81, 1], [81, 1], [100, 1], [100, 1], [76, 1], [76, 3], [76, 3], [10, 1], [10, 1], [10, 3], [10, 3], [10, 3], [60, 1], [102, 1], [102, 3], [104, 1], [104, 1]],
          performAction: function anonymous(yytext, yyleng, yylineno, yy, yystate, $$, _$) {
            var $0 = $$.length - 1;
            switch (yystate) {
              case 1:
                return $$[$0 - 1];
                break;
              case 3:
                this.$ = yy.miew.reset(false);
                yy.ClearContext();
                yy.miew.resetReps("empty");
                break;
              case 4:
                this.$ = yy.miew.rebuild();
                break;
              case 5:
                this.$ = yy.miew.rebuildAll();
                yy.miew.rebuild();
                break;
              case 6:
                this.$ = yy.echo(yy.utils.help().toString());
                break;
              case 7:
                this.$ = yy.echo(yy.utils.help($$[$0]).toString());
                break;
              case 8:
                this.$ = yy.miew.motm();
                break;
              case 10:
              case 11:
                this.$ = yy.utils.propagateProp($$[$0]);
                yy.echo(yy.miew.get($$[$0]).toString());
                break;
              case 12:
              case 13:
                this.$ = yy.miew.set($$[$0 - 1], yy.utils.propagateProp($$[$0 - 1], $$[$0]));
                ;
                break;
              case 14:
                this.$ = yy.miew.saveSettings();
                ;
                break;
              case 15:
                this.$ = yy.miew.restoreSettings();
                ;
                break;
              case 16:
                this.$ = yy.miew.resetSettings();
                ;
                break;
              case 17:
                this.$ = yy.miew.resetReps();
                break;
              case 18:
                this.$ = yy.miew.applyPreset($$[$0]);
                break;
              case 21:
                this.$ = yy.miew.repRemove($$[$0]);
                yy.representations.remove($$[$0]);
                break;
              case 22:
                this.$ = yy.miew.repHide($$[$0]);
                break;
              case 23:
                this.$ = yy.miew.repHide($$[$0], false);
                break;
              case 24:
                this.$ = yy.echo(yy.utils.listRep(yy.miew, yy.representations, $$[$0], "-e"));
                break;
              case 25:
                this.$ = yy.echo(yy.utils.list(yy.miew, yy.representations));
                break;
              case 26:
                this.$ = yy.echo(yy.utils.list(yy.miew, yy.representations, $$[$0]));
                break;
              case 27:
                this.$ = yy.echo(yy.utils.listSelector(yy.miew, yy.Context));
                break;
              case 28:
                this.$ = yy.miew.select(yy.utils.checkArg($$[$0 - 1].toLowerCase(), $$[$0], true));
                break;
              case 29:
                this.$ = yy.Context[$$[$0].toLowerCase()] = yy.utils.checkArg($$[$0 - 3].toLowerCase(), $$[$0 - 2], true);
                yy.miew.select(yy.Context[$$[$0].toLowerCase()]);
                break;
              case 30:
                this.$ = yy.miew.rep(yy.miew.repCurrent(), {
                  selector: yy.utils.checkArg($$[$0 - 1].toLowerCase(), $$[$0])
                });
                break;
              case 31:
                this.$ = yy.Context[$$[$0].toLowerCase()] = yy.miew.within(yy.utils.checkArg("select", $$[$0 - 2], true), Number($$[$0 - 4]));
                break;
              case 32:
                this.$ = yy.miew.rep(yy.miew.repCurrent(), {
                  material: yy.utils.checkArg($$[$0 - 1].toLowerCase(), $$[$0].toUpperCase())
                });
                break;
              case 35:
                this.$ = yy.echo(yy.miew.view());
                break;
              case 36:
              case 37:
                this.$ = yy.miew.view($$[$0]);
                break;
              case 38:
                this.$ = yy.echo(yy.miew.changeUnit());
                break;
              case 39:
                this.$ = yy.echo(yy.miew.changeUnit($$[$0]));
                break;
              case 40:
                this.$ = yy.miew.dssp();
                break;
              case 41:
                this.$ = yy.miew.scale($$[$0]);
                break;
              case 42:
                for (var i2 = 0, n = $$[$0].length; i2 < n; i2++) {
                  yy.miew.rotate($$[$0][i2]["x"] * Math.PI / 180, $$[$0][i2]["y"] * Math.PI / 180, $$[$0][i2]["z"] * Math.PI / 180);
                }
                break;
              case 43:
                for (var i2 = 0, n = $$[$0].length; i2 < n; i2++) {
                  yy.miew.translate($$[$0][i2]["x"] || 0, $$[$0][i2]["y"] || 0, $$[$0][i2]["z"] || 0);
                }
                break;
              case 44:
                this.$ = yy.miew.center();
                break;
              case 45:
                this.$ = yy.miew.center($$[$0]);
                break;
              case 48:
              case 49:
                this.$ = yy.miew.addObject({
                  type: "line",
                  params: [$$[$0 - 1], $$[$0]]
                }, true);
                break;
              case 50:
              case 51:
                this.$ = yy.miew.addObject({
                  type: "line",
                  params: [$$[$0 - 2], $$[$0 - 1]],
                  opts: $$[$0].toJSO(yy.utils, "objects", "line")
                }, true);
                break;
              case 52:
                this.$ = yy.echo(yy.utils.listObjs(yy.miew));
                break;
              case 53:
                this.$ = yy.miew.removeObject($$[$0]);
                break;
              case 54:
                this.$ = yy.echo(yy.miew.getURL({
                  view: false,
                  settings: false
                }));
                break;
              case 55:
                this.$ = yy.echo(yy.miew.getURL({
                  view: false,
                  settings: true
                }));
                break;
              case 56:
                this.$ = yy.echo(yy.miew.getURL({
                  view: true,
                  settings: false
                }));
                break;
              case 57:
              case 58:
                this.$ = yy.echo(yy.miew.getURL({
                  view: true,
                  settings: true
                }));
                break;
              case 59:
                this.$ = yy.miew.screenshotSave();
                break;
              case 60:
                this.$ = yy.miew.screenshotSave("", Number($$[$0]));
                break;
              case 61:
                this.$ = yy.miew.screenshotSave("", Number($$[$0 - 1]), Number($$[$0]));
                break;
              case 62:
              case 63:
              case 64:
                this.$ = yy.utils.load(yy.miew, $$[$0]);
                yy.representations.clear();
                break;
              case 65:
                this.$ = yy.echo(yy.representations.add(yy.miew.repAdd()));
                break;
              case 66:
                this.$ = yy.echo(yy.representations.add($$[$0], yy.miew.repAdd()));
                break;
              case 67:
                this.$ = yy.echo(yy.representations.add(yy.miew.repAdd($$[$0])));
                break;
              case 68:
                this.$ = yy.echo(yy.representations.add($$[$0 - 1], yy.miew.repAdd($$[$0])));
                break;
              case 69:
                this.$ = yy.miew.rep($$[$0]);
                yy.miew.repCurrent($$[$0]);
                break;
              case 70:
                this.$ = yy.miew.rep($$[$0 - 1], $$[$0]);
                yy.miew.repCurrent($$[$0 - 1]);
                break;
              case 71:
                this.$ = yy.miew.rep(yy.miew.repCurrent(), {
                  mode: yy.utils.checkArg($$[$0 - 1].toLowerCase(), $$[$0].toUpperCase())
                });
                break;
              case 72:
                this.$ = yy.miew.rep(yy.miew.repCurrent(), {
                  mode: new Array(yy.utils.checkArg($$[$0 - 2].toLowerCase(), $$[$0 - 1].toUpperCase()), $$[$0].toJSO(yy.utils, $$[$0 - 2], $$[$0 - 1].toUpperCase()))
                });
                break;
              case 73:
                this.$ = yy.miew.rep(yy.miew.repCurrent(), {
                  colorer: yy.utils.checkArg($$[$0 - 1].toLowerCase(), $$[$0].toUpperCase())
                });
                break;
              case 74:
                this.$ = yy.miew.rep(yy.miew.repCurrent(), {
                  colorer: new Array(yy.utils.checkArg($$[$0 - 2].toLowerCase(), $$[$0 - 1].toUpperCase()), $$[$0].toJSO(yy.utils, $$[$0 - 2], $$[$0 - 1].toUpperCase()))
                });
                break;
              case 75:
                this.$ = Number(yy.representations.get($$[$0]));
                break;
              case 76:
              case 92:
                this.$ = Number($$[$0]);
                break;
              case 77:
                this.$ = $$[$0];
                break;
              case 78:
                this.$ = yy._.assign($$[$0 - 1], $$[$0]);
                break;
              case 79:
                this.$ = yy._.assign($$[$0 - 2], $$[$0 - 1], $$[$0]);
                break;
              case 80:
                this.$ = yy._.assign($$[$0 - 3], $$[$0 - 2], $$[$0 - 1], $$[$0]);
                break;
              case 81:
              case 82:
                this.$ = yy.CreateObjectPair($$[$0].key, $$[$0].val);
                break;
              case 83:
                this.$ = yy.CreateObjectPair($$[$0 - 1].key, new Array($$[$0 - 1].val, $$[$0].toJSO(yy.utils, $$[$0 - 1].key, $$[$0 - 1].val)));
                break;
              case 84:
              case 85:
                this.$ = /* @__PURE__ */ Object.create({
                  "key": yy.keyRemap($$[$0 - 2]),
                  "val": yy.utils.checkArg($$[$0 - 2], $$[$0])
                });
                break;
              case 86:
                this.$ = [$$[$0]];
                break;
              case 87:
                this.$ = $$[$0 - 1].concat($$[$0]);
                break;
              case 88:
                this.$ = yy.CreateObjectPair($$[$0 - 1].toLowerCase(), Number($$[$0]));
                break;
              case 89:
                this.$ = new yy.ArgList($$[$0]);
                break;
              case 90:
                this.$ = $$[$0 - 1].append($$[$0]);
                break;
              case 91:
                this.$ = new yy.Arg($$[$0 - 2], $$[$0]);
                break;
              case 93:
                this.$ = parseInt($$[$0]);
                break;
              case 94:
                this.$ = JSON.parse($$[$0]);
                break;
              case 95:
              case 96:
                this.$ = String($$[$0]);
                break;
              case 157:
              case 158:
              case 161:
              case 162:
              case 163:
                this.$ = $$[$0 - 2] + $$[$0 - 1] + $$[$0];
                break;
              case 166:
                this.$ = $$[$0 - 2] = $$[$0 - 2] + $$[$0 - 1] + $$[$0];
                break;
            }
          },
          table: [{
            3: 1,
            4: 2,
            5: [1, 3],
            6: [1, 4],
            7: [1, 5],
            9: [1, 6],
            11: [1, 7],
            12: 8,
            13: [1, 9],
            15: [1, 10],
            17: [1, 11],
            18: [1, 12],
            19: [1, 13],
            20: [1, 14],
            21: 15,
            22: 16,
            23: [1, 17],
            25: [1, 18],
            26: [1, 19],
            27: [1, 20],
            30: [1, 21],
            33: [1, 22],
            34: [1, 23],
            37: [1, 24],
            39: 25,
            40: 26,
            41: [1, 27],
            43: [1, 28],
            44: [1, 29],
            45: [1, 30],
            46: [1, 31],
            48: [1, 32],
            49: [1, 33],
            50: 34,
            51: 35,
            52: [1, 36],
            54: [1, 37],
            55: [1, 38],
            56: [1, 44],
            58: [1, 45],
            59: [1, 39],
            62: [1, 40],
            64: [1, 41],
            65: [1, 42],
            66: [1, 43]
          }, {
            1: [3]
          }, {
            5: [1, 46]
          }, {
            1: [2, 2]
          }, {
            5: [2, 3]
          }, {
            5: [2, 4],
            8: [1, 47]
          }, {
            5: [2, 6],
            6: $V0,
            7: $V1,
            9: $V2,
            10: 48,
            13: $V3,
            15: $V4,
            17: $V5,
            18: $V6,
            19: $V7,
            20: $V8,
            23: $V9,
            25: $Va,
            26: $Vb,
            27: $Vc,
            30: $Vd,
            33: $Ve,
            34: $Vf,
            37: $Vg,
            38: $Vh,
            41: $Vi,
            43: $Vj,
            45: $Vk,
            46: $Vl,
            49: $Vm,
            52: $Vn,
            54: $Vo,
            55: $Vp,
            56: $Vq,
            58: $Vr,
            59: $Vs,
            62: $Vt,
            64: $Vu,
            65: $Vv,
            66: $Vw,
            70: $Vx,
            72: $Vy,
            74: $Vz,
            79: 49,
            80: 52,
            81: 50,
            82: $VA,
            83: $VB,
            84: $VC,
            85: $VD,
            86: $VE,
            87: $VF,
            88: $VG,
            89: $VH,
            90: $VI,
            91: $VJ,
            92: $VK,
            93: $VL,
            94: $VM,
            95: $VN,
            96: $VO,
            97: $VP,
            98: $VQ,
            99: $VR
          }, {
            5: [2, 8]
          }, {
            5: [2, 9]
          }, {
            6: $V0,
            7: $V1,
            9: $V2,
            10: 106,
            13: $V3,
            14: [1, 107],
            15: $V4,
            17: $V5,
            18: $V6,
            19: $V7,
            20: $V8,
            23: $V9,
            25: $Va,
            26: $Vb,
            27: $Vc,
            30: $Vd,
            33: $Ve,
            34: $Vf,
            37: $Vg,
            38: $Vh,
            41: $Vi,
            43: $Vj,
            45: $Vk,
            46: $Vl,
            49: $Vm,
            52: $Vn,
            54: $Vo,
            55: $Vp,
            56: $Vq,
            58: $Vr,
            59: $Vs,
            62: $Vt,
            64: $Vu,
            65: $Vv,
            66: $Vw,
            70: $Vx,
            72: $Vy,
            74: $Vz,
            79: 49,
            80: 52,
            81: 50,
            82: $VA,
            83: $VB,
            84: $VC,
            85: $VD,
            86: $VE,
            87: $VF,
            88: $VG,
            89: $VH,
            90: $VI,
            91: $VJ,
            92: $VK,
            93: $VL,
            94: $VM,
            95: $VN,
            96: $VO,
            97: $VP,
            98: $VQ,
            99: $VR
          }, {
            6: $V0,
            7: $V1,
            9: $V2,
            10: 108,
            13: $V3,
            14: [1, 109],
            15: $V4,
            17: $V5,
            18: $V6,
            19: $V7,
            20: $V8,
            23: $V9,
            25: $Va,
            26: $Vb,
            27: $Vc,
            30: $Vd,
            33: $Ve,
            34: $Vf,
            37: $Vg,
            38: $Vh,
            41: $Vi,
            43: $Vj,
            45: $Vk,
            46: $Vl,
            49: $Vm,
            52: $Vn,
            54: $Vo,
            55: $Vp,
            56: $Vq,
            58: $Vr,
            59: $Vs,
            62: $Vt,
            64: $Vu,
            65: $Vv,
            66: $Vw,
            70: $Vx,
            72: $Vy,
            74: $Vz,
            79: 49,
            80: 52,
            81: 50,
            82: $VA,
            83: $VB,
            84: $VC,
            85: $VD,
            86: $VE,
            87: $VF,
            88: $VG,
            89: $VH,
            90: $VI,
            91: $VJ,
            92: $VK,
            93: $VL,
            94: $VM,
            95: $VN,
            96: $VO,
            97: $VP,
            98: $VQ,
            99: $VR
          }, {
            5: [2, 14]
          }, {
            5: [2, 15]
          }, {
            5: [2, 16]
          }, {
            5: [2, 17],
            14: $VS,
            16: 110,
            35: $VT,
            38: $VU,
            77: $VV,
            78: $VW
          }, {
            5: [2, 19]
          }, {
            5: [2, 20]
          }, {
            24: 116,
            35: $VX,
            38: $VY
          }, {
            24: 119,
            35: $VX,
            38: $VY
          }, {
            24: 120,
            35: $VX,
            38: $VY
          }, {
            5: [2, 25],
            24: 121,
            28: [1, 122],
            29: [1, 123],
            35: $VX,
            38: $VY
          }, {
            14: [1, 124]
          }, {
            14: [1, 125]
          }, {
            35: [1, 126]
          }, {
            38: [1, 127]
          }, {
            5: [2, 33]
          }, {
            5: [2, 34]
          }, {
            5: [2, 35],
            14: [1, 128],
            42: [1, 129]
          }, {
            5: [2, 38],
            35: [1, 130]
          }, {
            5: [2, 40]
          }, {
            35: [1, 131]
          }, {
            47: 132,
            73: 133,
            74: $VZ
          }, {
            47: 135,
            73: 133,
            74: $VZ
          }, {
            5: [2, 44],
            14: [1, 136]
          }, {
            5: [2, 46]
          }, {
            5: [2, 47]
          }, {
            6: $V0,
            7: $V1,
            9: $V2,
            10: 138,
            13: $V3,
            14: [1, 137],
            15: $V4,
            17: $V5,
            18: $V6,
            19: $V7,
            20: $V8,
            23: $V9,
            25: $Va,
            26: $Vb,
            27: $Vc,
            30: $Vd,
            33: $Ve,
            34: $Vf,
            37: $Vg,
            38: $Vh,
            41: $Vi,
            43: $Vj,
            45: $Vk,
            46: $Vl,
            49: $Vm,
            52: $Vn,
            54: $Vo,
            55: $Vp,
            56: $Vq,
            58: $Vr,
            59: $Vs,
            62: $Vt,
            64: $Vu,
            65: $Vv,
            66: $Vw,
            70: $Vx,
            72: $Vy,
            74: $Vz,
            79: 49,
            80: 52,
            81: 50,
            82: $VA,
            83: $VB,
            84: $VC,
            85: $VD,
            86: $VE,
            87: $VF,
            88: $VG,
            89: $VH,
            90: $VI,
            91: $VJ,
            92: $VK,
            93: $VL,
            94: $VM,
            95: $VN,
            96: $VO,
            97: $VP,
            98: $VQ,
            99: $VR
          }, {
            5: [2, 52]
          }, {
            35: [1, 139]
          }, {
            14: [1, 143],
            38: [1, 141],
            60: 140,
            61: [1, 142]
          }, {
            5: [2, 65],
            38: [1, 144],
            63: 145,
            67: 146,
            68: 147,
            69: 148,
            70: $V_,
            72: $V$
          }, {
            24: 151,
            35: $VX,
            38: $VY
          }, {
            38: [1, 152]
          }, {
            38: [1, 153]
          }, {
            5: [2, 54],
            29: [1, 154],
            57: [1, 155]
          }, {
            5: [2, 59],
            35: [1, 156]
          }, {
            1: [2, 1]
          }, {
            5: [2, 5]
          }, {
            5: [2, 7],
            101: $V01
          }, o2($V11, [2, 159]), o2($V11, [2, 160]), o2($V21, [2, 97]), o2($V21, [2, 98]), o2($V11, [2, 147]), o2($V11, [2, 148]), o2($V11, [2, 149]), o2($V11, [2, 150]), o2($V11, [2, 151]), o2($V11, [2, 152]), o2($V11, [2, 153]), o2($V21, [2, 101]), o2($V21, [2, 102]), o2($V21, [2, 103]), o2($V21, [2, 104]), o2($V21, [2, 105]), o2($V21, [2, 106]), o2($V21, [2, 107]), o2($V21, [2, 108]), o2($V21, [2, 109]), o2($V21, [2, 110]), o2($V21, [2, 111]), o2($V21, [2, 112]), o2($V21, [2, 113]), o2($V21, [2, 114]), o2($V21, [2, 115]), o2($V21, [2, 116]), o2($V21, [2, 117]), o2($V21, [2, 118]), o2($V21, [2, 119]), o2($V21, [2, 120]), o2($V21, [2, 121]), o2($V21, [2, 122]), o2($V21, [2, 123]), o2($V21, [2, 124]), o2($V21, [2, 125]), o2($V21, [2, 126]), o2($V21, [2, 127]), o2($V21, [2, 128]), o2($V21, [2, 129]), o2($V21, [2, 130]), o2($V21, [2, 131]), o2($V21, [2, 132]), o2($V21, [2, 133]), o2($V21, [2, 134]), o2($V21, [2, 135]), o2($V21, [2, 136]), o2($V21, [2, 137]), o2($V21, [2, 138]), o2($V21, [2, 139]), o2($V21, [2, 140]), o2($V21, [2, 141]), o2($V21, [2, 142]), o2($V21, [2, 143]), o2($V21, [2, 144]), o2($V21, [2, 145]), o2($V21, [2, 146]), {
            5: [2, 10],
            101: $V01
          }, {
            5: [2, 11]
          }, {
            14: $VS,
            16: 158,
            35: $VT,
            38: $VU,
            77: $VV,
            78: $VW,
            101: $V01
          }, {
            14: $VS,
            16: 159,
            35: $VT,
            38: $VU,
            77: $VV,
            78: $VW
          }, {
            5: [2, 18]
          }, o2($V31, [2, 92]), o2($V31, [2, 93]), o2($V31, [2, 94]), o2($V31, [2, 95]), o2($V31, [2, 96]), {
            5: [2, 21]
          }, o2($V41, [2, 75]), o2($V41, [2, 76]), {
            5: [2, 22]
          }, {
            5: [2, 23]
          }, {
            5: [2, 24]
          }, {
            5: [2, 26]
          }, {
            5: [2, 27]
          }, {
            5: [2, 28],
            31: [1, 160]
          }, {
            5: [2, 30]
          }, {
            36: [1, 161]
          }, {
            5: [2, 32]
          }, {
            5: [2, 36]
          }, {
            5: [2, 37]
          }, {
            5: [2, 39]
          }, {
            5: [2, 41]
          }, {
            5: [2, 42],
            73: 162,
            74: $VZ
          }, o2($V51, [2, 86]), {
            35: [1, 163]
          }, {
            5: [2, 43],
            73: 162,
            74: $VZ
          }, {
            5: [2, 45]
          }, {
            14: [1, 164]
          }, {
            6: $V0,
            7: $V1,
            9: $V2,
            10: 165,
            13: $V3,
            15: $V4,
            17: $V5,
            18: $V6,
            19: $V7,
            20: $V8,
            23: $V9,
            25: $Va,
            26: $Vb,
            27: $Vc,
            30: $Vd,
            33: $Ve,
            34: $Vf,
            37: $Vg,
            38: $Vh,
            41: $Vi,
            43: $Vj,
            45: $Vk,
            46: $Vl,
            49: $Vm,
            52: $Vn,
            54: $Vo,
            55: $Vp,
            56: $Vq,
            58: $Vr,
            59: $Vs,
            62: $Vt,
            64: $Vu,
            65: $Vv,
            66: $Vw,
            70: $Vx,
            72: $Vy,
            74: $Vz,
            79: 49,
            80: 52,
            81: 50,
            82: $VA,
            83: $VB,
            84: $VC,
            85: $VD,
            86: $VE,
            87: $VF,
            88: $VG,
            89: $VH,
            90: $VI,
            91: $VJ,
            92: $VK,
            93: $VL,
            94: $VM,
            95: $VN,
            96: $VO,
            97: $VP,
            98: $VQ,
            99: $VR,
            101: $V01
          }, {
            5: [2, 53]
          }, {
            5: [2, 62]
          }, {
            5: [2, 63]
          }, {
            5: [2, 64]
          }, {
            5: [2, 164]
          }, {
            5: [2, 66],
            63: 166,
            67: 146,
            68: 147,
            69: 148,
            70: $V_,
            72: $V$
          }, {
            5: [2, 67]
          }, {
            5: [2, 77],
            67: 167,
            68: 147,
            69: 148,
            70: $V_,
            72: $V$
          }, o2($V41, [2, 81]), o2($V41, [2, 82], {
            80: 52,
            53: 168,
            75: 169,
            76: 170,
            79: 171,
            6: $V0,
            7: $V1,
            9: $V2,
            13: $V3,
            15: $V4,
            17: $V5,
            18: $V6,
            19: $V7,
            20: $V8,
            23: $V9,
            25: $Va,
            26: $Vb,
            27: $Vc,
            30: $Vd,
            33: $Ve,
            34: $Vf,
            37: $Vg,
            38: $Vh,
            41: $Vi,
            43: $Vj,
            45: $Vk,
            46: $Vl,
            49: $Vm,
            52: $Vn,
            54: $Vo,
            55: $Vp,
            56: $Vq,
            58: $Vr,
            59: $Vs,
            62: $Vt,
            64: $Vu,
            65: $Vv,
            66: $Vw,
            82: $VA,
            83: $VB,
            84: $VC,
            85: $VD,
            86: $VE,
            87: $VF,
            88: $VG,
            89: $VH,
            90: $VI,
            91: $VJ,
            92: $VK,
            93: $VL,
            94: $VM,
            95: $VN
          }), {
            71: [1, 172]
          }, {
            71: [1, 173]
          }, {
            5: [2, 69],
            63: 174,
            67: 146,
            68: 147,
            69: 148,
            70: $V_,
            72: $V$
          }, {
            5: [2, 71],
            6: $V0,
            7: $V1,
            9: $V2,
            13: $V3,
            15: $V4,
            17: $V5,
            18: $V6,
            19: $V7,
            20: $V8,
            23: $V9,
            25: $Va,
            26: $Vb,
            27: $Vc,
            30: $Vd,
            33: $Ve,
            34: $Vf,
            37: $Vg,
            38: $Vh,
            41: $Vi,
            43: $Vj,
            45: $Vk,
            46: $Vl,
            49: $Vm,
            52: $Vn,
            53: 175,
            54: $Vo,
            55: $Vp,
            56: $Vq,
            58: $Vr,
            59: $Vs,
            62: $Vt,
            64: $Vu,
            65: $Vv,
            66: $Vw,
            75: 169,
            76: 170,
            79: 171,
            80: 52,
            82: $VA,
            83: $VB,
            84: $VC,
            85: $VD,
            86: $VE,
            87: $VF,
            88: $VG,
            89: $VH,
            90: $VI,
            91: $VJ,
            92: $VK,
            93: $VL,
            94: $VM,
            95: $VN
          }, {
            5: [2, 73],
            6: $V0,
            7: $V1,
            9: $V2,
            13: $V3,
            15: $V4,
            17: $V5,
            18: $V6,
            19: $V7,
            20: $V8,
            23: $V9,
            25: $Va,
            26: $Vb,
            27: $Vc,
            30: $Vd,
            33: $Ve,
            34: $Vf,
            37: $Vg,
            38: $Vh,
            41: $Vi,
            43: $Vj,
            45: $Vk,
            46: $Vl,
            49: $Vm,
            52: $Vn,
            53: 176,
            54: $Vo,
            55: $Vp,
            56: $Vq,
            58: $Vr,
            59: $Vs,
            62: $Vt,
            64: $Vu,
            65: $Vv,
            66: $Vw,
            75: 169,
            76: 170,
            79: 171,
            80: 52,
            82: $VA,
            83: $VB,
            84: $VC,
            85: $VD,
            86: $VE,
            87: $VF,
            88: $VG,
            89: $VH,
            90: $VI,
            91: $VJ,
            92: $VK,
            93: $VL,
            94: $VM,
            95: $VN
          }, {
            5: [2, 55],
            57: [1, 177]
          }, {
            5: [2, 56],
            29: [1, 178]
          }, {
            5: [2, 60],
            35: [1, 179]
          }, {
            6: $V0,
            7: $V1,
            9: $V2,
            13: $V3,
            15: $V4,
            17: $V5,
            18: $V6,
            19: $V7,
            20: $V8,
            23: $V9,
            25: $Va,
            26: $Vb,
            27: $Vc,
            30: $Vd,
            33: $Ve,
            34: $Vf,
            35: [1, 181],
            37: $Vg,
            38: $Vh,
            41: $Vi,
            43: $Vj,
            45: $Vk,
            46: $Vl,
            49: $Vm,
            52: $Vn,
            54: $Vo,
            55: $Vp,
            56: $Vq,
            58: $Vr,
            59: $Vs,
            62: $Vt,
            64: $Vu,
            65: $Vv,
            66: $Vw,
            70: $Vx,
            72: $Vy,
            74: $Vz,
            79: 180,
            80: 52,
            81: 182,
            82: $VA,
            83: $VB,
            84: $VC,
            85: $VD,
            86: $VE,
            87: $VF,
            88: $VG,
            89: $VH,
            90: $VI,
            91: $VJ,
            92: $VK,
            93: $VL,
            94: $VM,
            95: $VN,
            96: $VO,
            97: $VP,
            98: $VQ,
            99: $VR
          }, {
            5: [2, 12]
          }, {
            5: [2, 13]
          }, {
            6: $V0,
            7: $V1,
            9: $V2,
            13: $V3,
            15: $V4,
            17: $V5,
            18: $V6,
            19: $V7,
            20: $V8,
            23: $V9,
            25: $Va,
            26: $Vb,
            27: $Vc,
            30: $Vd,
            32: 183,
            33: $Ve,
            34: $Vf,
            37: $Vg,
            38: $Vh,
            41: $Vi,
            43: $Vj,
            45: $Vk,
            46: $Vl,
            49: $Vm,
            52: $Vn,
            54: $Vo,
            55: $Vp,
            56: $Vq,
            58: $Vr,
            59: $Vs,
            62: $Vt,
            64: $Vu,
            65: $Vv,
            66: $Vw,
            70: $Vx,
            72: $Vy,
            74: $Vz,
            79: 184,
            80: 52,
            81: 185,
            82: $VA,
            83: $VB,
            84: $VC,
            85: $VD,
            86: $VE,
            87: $VF,
            88: $VG,
            89: $VH,
            90: $VI,
            91: $VJ,
            92: $VK,
            93: $VL,
            94: $VM,
            95: $VN,
            96: $VO,
            97: $VP,
            98: $VQ,
            99: $VR
          }, {
            14: [1, 186]
          }, o2($V51, [2, 87]), o2($V51, [2, 88]), {
            5: [2, 48],
            6: $V0,
            7: $V1,
            9: $V2,
            13: $V3,
            15: $V4,
            17: $V5,
            18: $V6,
            19: $V7,
            20: $V8,
            23: $V9,
            25: $Va,
            26: $Vb,
            27: $Vc,
            30: $Vd,
            33: $Ve,
            34: $Vf,
            37: $Vg,
            38: $Vh,
            41: $Vi,
            43: $Vj,
            45: $Vk,
            46: $Vl,
            49: $Vm,
            52: $Vn,
            53: 187,
            54: $Vo,
            55: $Vp,
            56: $Vq,
            58: $Vr,
            59: $Vs,
            62: $Vt,
            64: $Vu,
            65: $Vv,
            66: $Vw,
            75: 169,
            76: 170,
            79: 171,
            80: 52,
            82: $VA,
            83: $VB,
            84: $VC,
            85: $VD,
            86: $VE,
            87: $VF,
            88: $VG,
            89: $VH,
            90: $VI,
            91: $VJ,
            92: $VK,
            93: $VL,
            94: $VM,
            95: $VN
          }, {
            5: [2, 49],
            6: $V0,
            7: $V1,
            9: $V2,
            13: $V3,
            15: $V4,
            17: $V5,
            18: $V6,
            19: $V7,
            20: $V8,
            23: $V9,
            25: $Va,
            26: $Vb,
            27: $Vc,
            30: $Vd,
            33: $Ve,
            34: $Vf,
            37: $Vg,
            38: $Vh,
            41: $Vi,
            43: $Vj,
            45: $Vk,
            46: $Vl,
            49: $Vm,
            52: $Vn,
            53: 188,
            54: $Vo,
            55: $Vp,
            56: $Vq,
            58: $Vr,
            59: $Vs,
            62: $Vt,
            64: $Vu,
            65: $Vv,
            66: $Vw,
            75: 169,
            76: 170,
            79: 171,
            80: 52,
            82: $VA,
            83: $VB,
            84: $VC,
            85: $VD,
            86: $VE,
            87: $VF,
            88: $VG,
            89: $VH,
            90: $VI,
            91: $VJ,
            92: $VK,
            93: $VL,
            94: $VM,
            95: $VN,
            101: $V01
          }, {
            5: [2, 68]
          }, {
            5: [2, 78],
            67: 189,
            68: 147,
            69: 148,
            70: $V_,
            72: $V$
          }, o2($V41, [2, 83], {
            80: 52,
            76: 170,
            79: 171,
            75: 190,
            6: $V0,
            7: $V1,
            9: $V2,
            13: $V3,
            15: $V4,
            17: $V5,
            18: $V6,
            19: $V7,
            20: $V8,
            23: $V9,
            25: $Va,
            26: $Vb,
            27: $Vc,
            30: $Vd,
            33: $Ve,
            34: $Vf,
            37: $Vg,
            38: $Vh,
            41: $Vi,
            43: $Vj,
            45: $Vk,
            46: $Vl,
            49: $Vm,
            52: $Vn,
            54: $Vo,
            55: $Vp,
            56: $Vq,
            58: $Vr,
            59: $Vs,
            62: $Vt,
            64: $Vu,
            65: $Vv,
            66: $Vw,
            82: $VA,
            83: $VB,
            84: $VC,
            85: $VD,
            86: $VE,
            87: $VF,
            88: $VG,
            89: $VH,
            90: $VI,
            91: $VJ,
            92: $VK,
            93: $VL,
            94: $VM,
            95: $VN
          }), o2($V31, [2, 89]), {
            71: [1, 191],
            101: [1, 192]
          }, o2($V61, [2, 156]), {
            14: $VS,
            16: 193,
            35: $VT,
            38: $VU,
            77: $VV,
            78: $VW
          }, {
            14: $VS,
            16: 194,
            35: $VT,
            38: $VU,
            77: $VV,
            78: $VW
          }, {
            5: [2, 70]
          }, {
            5: [2, 72],
            6: $V0,
            7: $V1,
            9: $V2,
            13: $V3,
            15: $V4,
            17: $V5,
            18: $V6,
            19: $V7,
            20: $V8,
            23: $V9,
            25: $Va,
            26: $Vb,
            27: $Vc,
            30: $Vd,
            33: $Ve,
            34: $Vf,
            37: $Vg,
            38: $Vh,
            41: $Vi,
            43: $Vj,
            45: $Vk,
            46: $Vl,
            49: $Vm,
            52: $Vn,
            54: $Vo,
            55: $Vp,
            56: $Vq,
            58: $Vr,
            59: $Vs,
            62: $Vt,
            64: $Vu,
            65: $Vv,
            66: $Vw,
            75: 190,
            76: 170,
            79: 171,
            80: 52,
            82: $VA,
            83: $VB,
            84: $VC,
            85: $VD,
            86: $VE,
            87: $VF,
            88: $VG,
            89: $VH,
            90: $VI,
            91: $VJ,
            92: $VK,
            93: $VL,
            94: $VM,
            95: $VN
          }, {
            5: [2, 74],
            6: $V0,
            7: $V1,
            9: $V2,
            13: $V3,
            15: $V4,
            17: $V5,
            18: $V6,
            19: $V7,
            20: $V8,
            23: $V9,
            25: $Va,
            26: $Vb,
            27: $Vc,
            30: $Vd,
            33: $Ve,
            34: $Vf,
            37: $Vg,
            38: $Vh,
            41: $Vi,
            43: $Vj,
            45: $Vk,
            46: $Vl,
            49: $Vm,
            52: $Vn,
            54: $Vo,
            55: $Vp,
            56: $Vq,
            58: $Vr,
            59: $Vs,
            62: $Vt,
            64: $Vu,
            65: $Vv,
            66: $Vw,
            75: 190,
            76: 170,
            79: 171,
            80: 52,
            82: $VA,
            83: $VB,
            84: $VC,
            85: $VD,
            86: $VE,
            87: $VF,
            88: $VG,
            89: $VH,
            90: $VI,
            91: $VJ,
            92: $VK,
            93: $VL,
            94: $VM,
            95: $VN
          }, {
            5: [2, 57]
          }, {
            5: [2, 58]
          }, {
            5: [2, 61]
          }, o2($V11, [2, 161]), o2($V11, [2, 162]), o2($V11, [2, 163]), {
            5: [2, 29]
          }, {
            5: [2, 99]
          }, {
            5: [2, 100]
          }, {
            31: [1, 195]
          }, {
            5: [2, 50],
            6: $V0,
            7: $V1,
            9: $V2,
            13: $V3,
            15: $V4,
            17: $V5,
            18: $V6,
            19: $V7,
            20: $V8,
            23: $V9,
            25: $Va,
            26: $Vb,
            27: $Vc,
            30: $Vd,
            33: $Ve,
            34: $Vf,
            37: $Vg,
            38: $Vh,
            41: $Vi,
            43: $Vj,
            45: $Vk,
            46: $Vl,
            49: $Vm,
            52: $Vn,
            54: $Vo,
            55: $Vp,
            56: $Vq,
            58: $Vr,
            59: $Vs,
            62: $Vt,
            64: $Vu,
            65: $Vv,
            66: $Vw,
            75: 190,
            76: 170,
            79: 171,
            80: 52,
            82: $VA,
            83: $VB,
            84: $VC,
            85: $VD,
            86: $VE,
            87: $VF,
            88: $VG,
            89: $VH,
            90: $VI,
            91: $VJ,
            92: $VK,
            93: $VL,
            94: $VM,
            95: $VN
          }, {
            5: [2, 51],
            6: $V0,
            7: $V1,
            9: $V2,
            13: $V3,
            15: $V4,
            17: $V5,
            18: $V6,
            19: $V7,
            20: $V8,
            23: $V9,
            25: $Va,
            26: $Vb,
            27: $Vc,
            30: $Vd,
            33: $Ve,
            34: $Vf,
            37: $Vg,
            38: $Vh,
            41: $Vi,
            43: $Vj,
            45: $Vk,
            46: $Vl,
            49: $Vm,
            52: $Vn,
            54: $Vo,
            55: $Vp,
            56: $Vq,
            58: $Vr,
            59: $Vs,
            62: $Vt,
            64: $Vu,
            65: $Vv,
            66: $Vw,
            75: 190,
            76: 170,
            79: 171,
            80: 52,
            82: $VA,
            83: $VB,
            84: $VC,
            85: $VD,
            86: $VE,
            87: $VF,
            88: $VG,
            89: $VH,
            90: $VI,
            91: $VJ,
            92: $VK,
            93: $VL,
            94: $VM,
            95: $VN
          }, {
            5: [2, 79],
            67: 196,
            68: 147,
            69: 148,
            70: $V_,
            72: $V$
          }, o2($V31, [2, 90]), {
            14: $VS,
            16: 197,
            35: $VT,
            38: $VU,
            77: $VV,
            78: $VW
          }, {
            6: $V0,
            7: $V1,
            9: $V2,
            13: $V3,
            15: $V4,
            17: $V5,
            18: $V6,
            19: $V7,
            20: $V8,
            23: $V9,
            25: $Va,
            26: $Vb,
            27: $Vc,
            30: $Vd,
            33: $Ve,
            34: $Vf,
            35: [1, 199],
            37: $Vg,
            38: $Vh,
            41: $Vi,
            43: $Vj,
            45: $Vk,
            46: $Vl,
            49: $Vm,
            52: $Vn,
            54: $Vo,
            55: $Vp,
            56: $Vq,
            58: $Vr,
            59: $Vs,
            62: $Vt,
            64: $Vu,
            65: $Vv,
            66: $Vw,
            79: 198,
            80: 52,
            82: $VA,
            83: $VB,
            84: $VC,
            85: $VD,
            86: $VE,
            87: $VF,
            88: $VG,
            89: $VH,
            90: $VI,
            91: $VJ,
            92: $VK,
            93: $VL,
            94: $VM,
            95: $VN
          }, o2($V41, [2, 84]), o2($V31, [2, 85]), {
            6: $V0,
            7: $V1,
            9: $V2,
            13: $V3,
            15: $V4,
            17: $V5,
            18: $V6,
            19: $V7,
            20: $V8,
            23: $V9,
            25: $Va,
            26: $Vb,
            27: $Vc,
            30: $Vd,
            32: 200,
            33: $Ve,
            34: $Vf,
            37: $Vg,
            38: $Vh,
            41: $Vi,
            43: $Vj,
            45: $Vk,
            46: $Vl,
            49: $Vm,
            52: $Vn,
            54: $Vo,
            55: $Vp,
            56: $Vq,
            58: $Vr,
            59: $Vs,
            62: $Vt,
            64: $Vu,
            65: $Vv,
            66: $Vw,
            70: $Vx,
            72: $Vy,
            74: $Vz,
            79: 184,
            80: 52,
            81: 185,
            82: $VA,
            83: $VB,
            84: $VC,
            85: $VD,
            86: $VE,
            87: $VF,
            88: $VG,
            89: $VH,
            90: $VI,
            91: $VJ,
            92: $VK,
            93: $VL,
            94: $VM,
            95: $VN,
            96: $VO,
            97: $VP,
            98: $VQ,
            99: $VR
          }, {
            5: [2, 80]
          }, o2($V31, [2, 91]), o2($V61, [2, 157]), o2($V61, [2, 158]), {
            5: [2, 31]
          }],
          defaultActions: {
            3: [2, 2],
            4: [2, 3],
            7: [2, 8],
            8: [2, 9],
            11: [2, 14],
            12: [2, 15],
            13: [2, 16],
            15: [2, 19],
            16: [2, 20],
            25: [2, 33],
            26: [2, 34],
            29: [2, 40],
            34: [2, 46],
            35: [2, 47],
            37: [2, 52],
            46: [2, 1],
            47: [2, 5],
            107: [2, 11],
            110: [2, 18],
            116: [2, 21],
            119: [2, 22],
            120: [2, 23],
            121: [2, 24],
            122: [2, 26],
            123: [2, 27],
            125: [2, 30],
            127: [2, 32],
            128: [2, 36],
            129: [2, 37],
            130: [2, 39],
            131: [2, 41],
            136: [2, 45],
            139: [2, 53],
            140: [2, 62],
            141: [2, 63],
            142: [2, 64],
            143: [2, 164],
            145: [2, 67],
            158: [2, 12],
            159: [2, 13],
            166: [2, 68],
            174: [2, 70],
            177: [2, 57],
            178: [2, 58],
            179: [2, 61],
            183: [2, 29],
            184: [2, 99],
            185: [2, 100],
            196: [2, 80],
            200: [2, 31]
          },
          parseError: function parseError(str, hash) {
            if (hash.recoverable) {
              this.trace(str);
            } else {
              var error = new Error(str);
              error.hash = hash;
              throw error;
            }
          },
          parse: function parse(input) {
            var self2 = this, stack = [0], tstack = [], vstack = [null], lstack = [], table = this.table, yytext = "", yylineno = 0, yyleng = 0, recovering = 0, TERROR = 2, EOF = 1;
            var args = lstack.slice.call(arguments, 1);
            var lexer2 = Object.create(this.lexer);
            var sharedState = {
              yy: {}
            };
            for (var k2 in this.yy) {
              if (Object.prototype.hasOwnProperty.call(this.yy, k2)) {
                sharedState.yy[k2] = this.yy[k2];
              }
            }
            lexer2.setInput(input, sharedState.yy);
            sharedState.yy.lexer = lexer2;
            sharedState.yy.parser = this;
            if (typeof lexer2.yylloc == "undefined") {
              lexer2.yylloc = {};
            }
            var yyloc = lexer2.yylloc;
            lstack.push(yyloc);
            var ranges = lexer2.options && lexer2.options.ranges;
            if (typeof sharedState.yy.parseError === "function") {
              this.parseError = sharedState.yy.parseError;
            } else {
              this.parseError = Object.getPrototypeOf(this).parseError;
            }
            function popStack(n) {
              stack.length = stack.length - 2 * n;
              vstack.length = vstack.length - n;
              lstack.length = lstack.length - n;
            }
            function lex() {
              var token;
              token = tstack.pop() || lexer2.lex() || EOF;
              if (typeof token !== "number") {
                if (token instanceof Array) {
                  tstack = token;
                  token = tstack.pop();
                }
                token = self2.symbols_[token] || token;
              }
              return token;
            }
            var symbol, preErrorSymbol, state, action, a2, r2, yyval = {}, p2, len, newState, expected;
            while (true) {
              state = stack[stack.length - 1];
              if (this.defaultActions[state]) {
                action = this.defaultActions[state];
              } else {
                if (symbol === null || typeof symbol == "undefined") {
                  symbol = lex();
                }
                action = table[state] && table[state][symbol];
              }
              if (typeof action === "undefined" || !action.length || !action[0]) {
                var errStr = "";
                expected = [];
                for (p2 in table[state]) {
                  if (this.terminals_[p2] && p2 > TERROR) {
                    expected.push("'" + this.terminals_[p2] + "'");
                  }
                }
                if (lexer2.showPosition) {
                  errStr = "Parse error on line " + (yylineno + 1) + ":\n" + lexer2.showPosition() + "\nExpecting " + expected.join(", ") + ", got '" + (this.terminals_[symbol] || symbol) + "'";
                } else {
                  errStr = "Parse error on line " + (yylineno + 1) + ": Unexpected " + (symbol == EOF ? "end of input" : "'" + (this.terminals_[symbol] || symbol) + "'");
                }
                this.parseError(errStr, {
                  text: lexer2.match,
                  token: this.terminals_[symbol] || symbol,
                  line: lexer2.yylineno,
                  loc: yyloc,
                  expected
                });
              }
              if (action[0] instanceof Array && action.length > 1) {
                throw new Error("Parse Error: multiple actions possible at state: " + state + ", token: " + symbol);
              }
              switch (action[0]) {
                case 1:
                  stack.push(symbol);
                  vstack.push(lexer2.yytext);
                  lstack.push(lexer2.yylloc);
                  stack.push(action[1]);
                  symbol = null;
                  if (!preErrorSymbol) {
                    yyleng = lexer2.yyleng;
                    yytext = lexer2.yytext;
                    yylineno = lexer2.yylineno;
                    yyloc = lexer2.yylloc;
                    if (recovering > 0) {
                      recovering--;
                    }
                  } else {
                    symbol = preErrorSymbol;
                    preErrorSymbol = null;
                  }
                  break;
                case 2:
                  len = this.productions_[action[1]][1];
                  yyval.$ = vstack[vstack.length - len];
                  yyval._$ = {
                    first_line: lstack[lstack.length - (len || 1)].first_line,
                    last_line: lstack[lstack.length - 1].last_line,
                    first_column: lstack[lstack.length - (len || 1)].first_column,
                    last_column: lstack[lstack.length - 1].last_column
                  };
                  if (ranges) {
                    yyval._$.range = [lstack[lstack.length - (len || 1)].range[0], lstack[lstack.length - 1].range[1]];
                  }
                  r2 = this.performAction.apply(yyval, [yytext, yyleng, yylineno, sharedState.yy, action[1], vstack, lstack].concat(args));
                  if (typeof r2 !== "undefined") {
                    return r2;
                  }
                  if (len) {
                    stack = stack.slice(0, -1 * len * 2);
                    vstack = vstack.slice(0, -1 * len);
                    lstack = lstack.slice(0, -1 * len);
                  }
                  stack.push(this.productions_[action[1]][0]);
                  vstack.push(yyval.$);
                  lstack.push(yyval._$);
                  newState = table[stack[stack.length - 2]][stack[stack.length - 1]];
                  stack.push(newState);
                  break;
                case 3:
                  return true;
              }
            }
            return true;
          }
        };
        var lexer = /* @__PURE__ */ function() {
          var lexer2 = {
            EOF: 1,
            parseError: function parseError(str, hash) {
              if (this.yy.parser) {
                this.yy.parser.parseError(str, hash);
              } else {
                throw new Error(str);
              }
            },
            // resets the lexer, sets new input
            setInput: function(input, yy) {
              this.yy = yy || this.yy || {};
              this._input = input;
              this._more = this._backtrack = this.done = false;
              this.yylineno = this.yyleng = 0;
              this.yytext = this.matched = this.match = "";
              this.conditionStack = ["INITIAL"];
              this.yylloc = {
                first_line: 1,
                first_column: 0,
                last_line: 1,
                last_column: 0
              };
              if (this.options.ranges) {
                this.yylloc.range = [0, 0];
              }
              this.offset = 0;
              return this;
            },
            // consumes and returns one char from the input
            input: function() {
              var ch = this._input[0];
              this.yytext += ch;
              this.yyleng++;
              this.offset++;
              this.match += ch;
              this.matched += ch;
              var lines = ch.match(/(?:\r\n?|\n).*/g);
              if (lines) {
                this.yylineno++;
                this.yylloc.last_line++;
              } else {
                this.yylloc.last_column++;
              }
              if (this.options.ranges) {
                this.yylloc.range[1]++;
              }
              this._input = this._input.slice(1);
              return ch;
            },
            // unshifts one char (or a string) into the input
            unput: function(ch) {
              var len = ch.length;
              var lines = ch.split(/(?:\r\n?|\n)/g);
              this._input = ch + this._input;
              this.yytext = this.yytext.substr(0, this.yytext.length - len);
              this.offset -= len;
              var oldLines = this.match.split(/(?:\r\n?|\n)/g);
              this.match = this.match.substr(0, this.match.length - 1);
              this.matched = this.matched.substr(0, this.matched.length - 1);
              if (lines.length - 1) {
                this.yylineno -= lines.length - 1;
              }
              var r2 = this.yylloc.range;
              this.yylloc = {
                first_line: this.yylloc.first_line,
                last_line: this.yylineno + 1,
                first_column: this.yylloc.first_column,
                last_column: lines ? (lines.length === oldLines.length ? this.yylloc.first_column : 0) + oldLines[oldLines.length - lines.length].length - lines[0].length : this.yylloc.first_column - len
              };
              if (this.options.ranges) {
                this.yylloc.range = [r2[0], r2[0] + this.yyleng - len];
              }
              this.yyleng = this.yytext.length;
              return this;
            },
            // When called from action, caches matched text and appends it on next action
            more: function() {
              this._more = true;
              return this;
            },
            // When called from action, signals the lexer that this rule fails to match the input, so the next matching rule (regex) should be tested instead.
            reject: function() {
              if (this.options.backtrack_lexer) {
                this._backtrack = true;
              } else {
                return this.parseError("Lexical error on line " + (this.yylineno + 1) + ". You can only invoke reject() in the lexer when the lexer is of the backtracking persuasion (options.backtrack_lexer = true).\n" + this.showPosition(), {
                  text: "",
                  token: null,
                  line: this.yylineno
                });
              }
              return this;
            },
            // retain first n characters of the match
            less: function(n) {
              this.unput(this.match.slice(n));
            },
            // displays already matched input, i.e. for error messages
            pastInput: function() {
              var past = this.matched.substr(0, this.matched.length - this.match.length);
              return (past.length > 20 ? "..." : "") + past.substr(-20).replace(/\n/g, "");
            },
            // displays upcoming input, i.e. for error messages
            upcomingInput: function() {
              var next = this.match;
              if (next.length < 20) {
                next += this._input.substr(0, 20 - next.length);
              }
              return (next.substr(0, 20) + (next.length > 20 ? "..." : "")).replace(/\n/g, "");
            },
            // displays the character position where the lexing error occurred, i.e. for error messages
            showPosition: function() {
              var pre = this.pastInput();
              var c2 = new Array(pre.length + 1).join("-");
              return pre + this.upcomingInput() + "\n" + c2 + "^";
            },
            // test the lexed token: return FALSE when not a match, otherwise return token
            test_match: function(match, indexed_rule) {
              var token, lines, backup;
              if (this.options.backtrack_lexer) {
                backup = {
                  yylineno: this.yylineno,
                  yylloc: {
                    first_line: this.yylloc.first_line,
                    last_line: this.last_line,
                    first_column: this.yylloc.first_column,
                    last_column: this.yylloc.last_column
                  },
                  yytext: this.yytext,
                  match: this.match,
                  matches: this.matches,
                  matched: this.matched,
                  yyleng: this.yyleng,
                  offset: this.offset,
                  _more: this._more,
                  _input: this._input,
                  yy: this.yy,
                  conditionStack: this.conditionStack.slice(0),
                  done: this.done
                };
                if (this.options.ranges) {
                  backup.yylloc.range = this.yylloc.range.slice(0);
                }
              }
              lines = match[0].match(/(?:\r\n?|\n).*/g);
              if (lines) {
                this.yylineno += lines.length;
              }
              this.yylloc = {
                first_line: this.yylloc.last_line,
                last_line: this.yylineno + 1,
                first_column: this.yylloc.last_column,
                last_column: lines ? lines[lines.length - 1].length - lines[lines.length - 1].match(/\r?\n?/)[0].length : this.yylloc.last_column + match[0].length
              };
              this.yytext += match[0];
              this.match += match[0];
              this.matches = match;
              this.yyleng = this.yytext.length;
              if (this.options.ranges) {
                this.yylloc.range = [this.offset, this.offset += this.yyleng];
              }
              this._more = false;
              this._backtrack = false;
              this._input = this._input.slice(match[0].length);
              this.matched += match[0];
              token = this.performAction.call(this, this.yy, this, indexed_rule, this.conditionStack[this.conditionStack.length - 1]);
              if (this.done && this._input) {
                this.done = false;
              }
              if (token) {
                return token;
              } else if (this._backtrack) {
                for (var k2 in backup) {
                  this[k2] = backup[k2];
                }
                return false;
              }
              return false;
            },
            // return next match in input
            next: function() {
              if (this.done) {
                return this.EOF;
              }
              if (!this._input) {
                this.done = true;
              }
              var token, match, tempMatch, index;
              if (!this._more) {
                this.yytext = "";
                this.match = "";
              }
              var rules = this._currentRules();
              for (var i2 = 0; i2 < rules.length; i2++) {
                tempMatch = this._input.match(this.rules[rules[i2]]);
                if (tempMatch && (!match || tempMatch[0].length > match[0].length)) {
                  match = tempMatch;
                  index = i2;
                  if (this.options.backtrack_lexer) {
                    token = this.test_match(tempMatch, rules[i2]);
                    if (token !== false) {
                      return token;
                    } else if (this._backtrack) {
                      match = false;
                      continue;
                    } else {
                      return false;
                    }
                  } else if (!this.options.flex) {
                    break;
                  }
                }
              }
              if (match) {
                token = this.test_match(match, rules[index]);
                if (token !== false) {
                  return token;
                }
                return false;
              }
              if (this._input === "") {
                return this.EOF;
              } else {
                return this.parseError("Lexical error on line " + (this.yylineno + 1) + ". Unrecognized text.\n" + this.showPosition(), {
                  text: "",
                  token: null,
                  line: this.yylineno
                });
              }
            },
            // return next match that has a token
            lex: function lex() {
              var r2 = this.next();
              if (r2) {
                return r2;
              } else {
                return this.lex();
              }
            },
            // activates a new lexer condition state (pushes the new lexer condition state onto the condition stack)
            begin: function begin(condition) {
              this.conditionStack.push(condition);
            },
            // pop the previously active lexer condition state off the condition stack
            popState: function popState() {
              var n = this.conditionStack.length - 1;
              if (n > 0) {
                return this.conditionStack.pop();
              } else {
                return this.conditionStack[0];
              }
            },
            // produce the lexer rule set which is active for the currently active lexer condition state
            _currentRules: function _currentRules() {
              if (this.conditionStack.length && this.conditionStack[this.conditionStack.length - 1]) {
                return this.conditions[this.conditionStack[this.conditionStack.length - 1]].rules;
              } else {
                return this.conditions["INITIAL"].rules;
              }
            },
            // return the currently active lexer condition state; when an index argument is provided it produces the N-th previous condition state, if available
            topState: function topState(n) {
              n = this.conditionStack.length - 1 - Math.abs(n || 0);
              if (n >= 0) {
                return this.conditionStack[n];
              } else {
                return "INITIAL";
              }
            },
            // alias for begin(condition)
            pushState: function pushState(condition) {
              this.begin(condition);
            },
            // return the number of states currently on the stack
            stateStackSize: function stateStackSize() {
              return this.conditionStack.length;
            },
            options: {
              "case-insensitive": true
            },
            performAction: function anonymous(yy, yy_, $avoiding_name_collisions, YY_START) {
              var YYSTATE = YY_START;
              switch ($avoiding_name_collisions) {
                case 0:
                  break;
                case 1:
                  return "";
                  break;
                case 2:
                  return "";
                  break;
                case 3:
                  return 42;
                  break;
                case 4:
                  return 35;
                  break;
                case 5:
                  return 77;
                  break;
                case 6:
                  return 78;
                  break;
                case 7:
                  return 78;
                  break;
                case 8:
                  return 8;
                  break;
                case 9:
                  return 6;
                  break;
                case 10:
                  return 82;
                  break;
                case 11:
                  return 7;
                  break;
                case 12:
                  return 9;
                  break;
                case 13:
                  return 59;
                  break;
                case 14:
                  return 13;
                  break;
                case 15:
                  return 15;
                  break;
                case 16:
                  return 17;
                  break;
                case 17:
                  return 18;
                  break;
                case 18:
                  return 19;
                  break;
                case 19:
                  return 20;
                  break;
                case 20:
                  return 11;
                  break;
                case 21:
                  return 62;
                  break;
                case 22:
                  return 64;
                  break;
                case 23:
                  return 23;
                  break;
                case 24:
                  return 25;
                  break;
                case 25:
                  return 26;
                  break;
                case 26:
                  return 27;
                  break;
                case 27:
                  return 30;
                  break;
                case 28:
                  return 34;
                  break;
                case 29:
                  return 33;
                  break;
                case 30:
                  return 65;
                  break;
                case 31:
                  return 66;
                  break;
                case 32:
                  return 37;
                  break;
                case 33:
                  return 41;
                  break;
                case 34:
                  return 43;
                  break;
                case 35:
                  return 52;
                  break;
                case 36:
                  return 54;
                  break;
                case 37:
                  return 55;
                  break;
                case 38:
                  return 46;
                  break;
                case 39:
                  return 48;
                  break;
                case 40:
                  return 45;
                  break;
                case 41:
                  return 49;
                  break;
                case 42:
                  return 56;
                  break;
                case 43:
                  return 58;
                  break;
                case 44:
                  return 44;
                  break;
                case 45:
                  return 83;
                  break;
                case 46:
                  return 84;
                  break;
                case 47:
                  return 85;
                  break;
                case 48:
                  return 86;
                  break;
                case 49:
                  return 87;
                  break;
                case 50:
                  return 88;
                  break;
                case 51:
                  return 89;
                  break;
                case 52:
                  return 90;
                  break;
                case 53:
                  return 91;
                  break;
                case 54:
                  return 92;
                  break;
                case 55:
                  return 93;
                  break;
                case 56:
                  return 94;
                  break;
                case 57:
                  return 95;
                  break;
                case 58:
                  return 70;
                  break;
                case 59:
                  return 70;
                  break;
                case 60:
                  return 72;
                  break;
                case 61:
                  return 72;
                  break;
                case 62:
                  return 74;
                  break;
                case 63:
                  return 74;
                  break;
                case 64:
                  return 74;
                  break;
                case 65:
                  return 31;
                  break;
                case 66:
                  return 36;
                  break;
                case 67:
                  return 96;
                  break;
                case 68:
                  return 97;
                  break;
                case 69:
                  return 98;
                  break;
                case 70:
                  return 99;
                  break;
                case 71:
                  yy_.yytext = yy.utils.unquoteString(yy_.yytext);
                  return 14;
                  break;
                case 72:
                  return 38;
                  break;
                case 73:
                  return 5;
                  break;
                case 74:
                  return 101;
                  break;
                case 75:
                  return 103;
                  break;
                case 76:
                  return "\\";
                  break;
                case 77:
                  return 28;
                  break;
                case 78:
                  return 61;
                  break;
                case 79:
                  return 29;
                  break;
                case 80:
                  return 57;
                  break;
                case 81:
                  return 71;
                  break;
              }
            },
            rules: [/^(?:\s+)/i, /^(?:[#].*)/i, /^(?:\/\/.*)/i, /^(?:([_A-Z0-9\/\+]+==))/i, /^(?:-?[0-9]+(\.[0-9]+)?\b)/i, /^(?:0[xX][0-9A-F]+\b)/i, /^(?:false\b)/i, /^(?:true\b)/i, /^(?:all\b)/i, /^(?:reset\b)/i, /^(?:clear\b)/i, /^(?:build\b)/i, /^(?:help\b)/i, /^(?:load\b)/i, /^(?:get\b)/i, /^(?:set\b)/i, /^(?:set_save\b)/i, /^(?:set_restore\b)/i, /^(?:set_reset\b)/i, /^(?:preset\b)/i, /^(?:motm\b)/i, /^(?:add\b)/i, /^(?:rep\b)/i, /^(?:remove\b)/i, /^(?:hide\b)/i, /^(?:show\b)/i, /^(?:list\b)/i, /^(?:select\b)/i, /^(?:within\b)/i, /^(?:selector\b)/i, /^(?:mode\b)/i, /^(?:color\b)/i, /^(?:material\b)/i, /^(?:view\b)/i, /^(?:unit\b)/i, /^(?:line\b)/i, /^(?:listobj\b)/i, /^(?:removeobj\b)/i, /^(?:rotate\b)/i, /^(?:translate\b)/i, /^(?:scale\b)/i, /^(?:center\b)/i, /^(?:url\b)/i, /^(?:screenshot\b)/i, /^(?:dssp\b)/i, /^(?:file_list\b)/i, /^(?:file_register\b)/i, /^(?:file_delete\b)/i, /^(?:preset_add\b)/i, /^(?:preset_delete\b)/i, /^(?:preset_update\b)/i, /^(?:preset_rename\b)/i, /^(?:preset_open\b)/i, /^(?:create_scenario\b)/i, /^(?:reset_scenario\b)/i, /^(?:delete_scenario\b)/i, /^(?:add_scenario_item\b)/i, /^(?:list_scenario\b)/i, /^(?:s\b)/i, /^(?:mt\b)/i, /^(?:m\b)/i, /^(?:c\b)/i, /^(?:x\b)/i, /^(?:y\b)/i, /^(?:z\b)/i, /^(?:as\b)/i, /^(?:of\b)/i, /^(?:pdb\b)/i, /^(?:delay\b)/i, /^(?:prst\b)/i, /^(?:desc\b)/i, /^(?:((?:"(?:\\.|[^\\"])*"|'(?:\\.|[^\\'])*')))/i, /^(?:([_A-Z0-9]+))/i, /^(?:$)/i, /^(?:\.)/i, /^(?:\/)/i, /^(?:\\)/i, /^(?:-e\b)/i, /^(?:-f\b)/i, /^(?:-s\b)/i, /^(?:-v\b)/i, /^(?:=)/i],
            conditions: {
              "INITIAL": {
                "rules": [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81],
                "inclusive": true
              }
            }
          };
          return lexer2;
        }();
        parser2.lexer = lexer;
        function Parser2() {
          this.yy = {};
        }
        Parser2.prototype = parser2;
        parser2.Parser = Parser2;
        return new Parser2();
      }();
      module.exports = {
        parser
      };
    }
  ),
  /***/
  99: (
    /***/
    (module) => {
      var parser = function() {
        var o2 = function(k2, v2, o3, l2) {
          for (o3 = o3 || {}, l2 = k2.length; l2--; o3[k2[l2]] = v2) ;
          return o3;
        }, $V0 = [1, 4], $V1 = [1, 5], $V2 = [1, 6], $V3 = [1, 7], $V4 = [1, 8], $V5 = [1, 9], $V6 = [1, 11], $V7 = [1, 12], $V8 = [5, 7, 8, 11], $V9 = [1, 17], $Va = [1, 22], $Vb = [1, 20], $Vc = [1, 21], $Vd = [5, 7, 8, 11, 19];
        var parser2 = {
          trace: function trace() {
          },
          yy: {},
          symbols_: {
            "error": 2,
            "Program": 3,
            "Expression": 4,
            "EOF": 5,
            "Selector": 6,
            "OR": 7,
            "AND": 8,
            "NOT": 9,
            "(": 10,
            ")": 11,
            "SELECTOR": 12,
            "NAMED_SELECTOR": 13,
            "SELECTOR_RANGED": 14,
            "RangeList": 15,
            "SELECTOR_NAMED": 16,
            "NameList": 17,
            "Range": 18,
            ",": 19,
            "NUMBER": 20,
            ":": 21,
            "Name": 22,
            "IDENTIFIER": 23,
            "STRING": 24,
            "$accept": 0,
            "$end": 1
          },
          terminals_: {
            2: "error",
            5: "EOF",
            7: "OR",
            8: "AND",
            9: "NOT",
            10: "(",
            11: ")",
            12: "SELECTOR",
            13: "NAMED_SELECTOR",
            14: "SELECTOR_RANGED",
            16: "SELECTOR_NAMED",
            19: ",",
            20: "NUMBER",
            21: ":",
            23: "IDENTIFIER",
            24: "STRING"
          },
          productions_: [0, [3, 2], [4, 1], [4, 3], [4, 3], [4, 2], [4, 3], [6, 1], [6, 1], [6, 2], [6, 2], [15, 1], [15, 3], [18, 1], [18, 3], [17, 1], [17, 3], [22, 1], [22, 1], [22, 1]],
          performAction: function anonymous(yytext, yyleng, yylineno, yy, yystate, $$, _$) {
            var $0 = $$.length - 1;
            switch (yystate) {
              case 1:
                return $$[$0 - 1];
                break;
              case 3:
                this.$ = yy.keyword("or")($$[$0 - 2], $$[$0]);
                break;
              case 4:
                this.$ = yy.keyword("and")($$[$0 - 2], $$[$0]);
                break;
              case 5:
                this.$ = yy.keyword("not")($$[$0]);
                break;
              case 6:
                this.$ = $$[$0 - 1];
                break;
              case 7:
                this.$ = yy.keyword($$[$0])();
                break;
              case 8:
                this.$ = yy.GetSelector($$[$0].toLowerCase().slice(1, $$[$0].length));
                break;
              case 9:
              case 10:
                this.$ = yy.keyword($$[$0 - 1])($$[$0]);
                break;
              case 11:
                this.$ = new yy.RangeList($$[$0]);
                break;
              case 12:
              case 16:
                this.$ = $$[$0 - 2].append($$[$0]);
                break;
              case 13:
                this.$ = new yy.Range(Number($$[$0]));
                break;
              case 14:
                this.$ = new yy.Range(Number($$[$0 - 2]), Number($$[$0]));
                break;
              case 15:
                this.$ = new yy.ValueList($$[$0]);
                break;
            }
          },
          table: [{
            3: 1,
            4: 2,
            6: 3,
            9: $V0,
            10: $V1,
            12: $V2,
            13: $V3,
            14: $V4,
            16: $V5
          }, {
            1: [3]
          }, {
            5: [1, 10],
            7: $V6,
            8: $V7
          }, o2($V8, [2, 2]), {
            4: 13,
            6: 3,
            9: $V0,
            10: $V1,
            12: $V2,
            13: $V3,
            14: $V4,
            16: $V5
          }, {
            4: 14,
            6: 3,
            9: $V0,
            10: $V1,
            12: $V2,
            13: $V3,
            14: $V4,
            16: $V5
          }, o2($V8, [2, 7]), o2($V8, [2, 8]), {
            15: 15,
            18: 16,
            20: $V9
          }, {
            17: 18,
            20: $Va,
            22: 19,
            23: $Vb,
            24: $Vc
          }, {
            1: [2, 1]
          }, {
            4: 23,
            6: 3,
            9: $V0,
            10: $V1,
            12: $V2,
            13: $V3,
            14: $V4,
            16: $V5
          }, {
            4: 24,
            6: 3,
            9: $V0,
            10: $V1,
            12: $V2,
            13: $V3,
            14: $V4,
            16: $V5
          }, o2($V8, [2, 5]), {
            7: $V6,
            8: $V7,
            11: [1, 25]
          }, o2($V8, [2, 9], {
            19: [1, 26]
          }), o2($Vd, [2, 11]), o2($Vd, [2, 13], {
            21: [1, 27]
          }), o2($V8, [2, 10], {
            19: [1, 28]
          }), o2($Vd, [2, 15]), o2($Vd, [2, 17]), o2($Vd, [2, 18]), o2($Vd, [2, 19]), o2([5, 7, 11], [2, 3], {
            8: $V7
          }), o2($V8, [2, 4]), o2($V8, [2, 6]), {
            18: 29,
            20: $V9
          }, {
            20: [1, 30]
          }, {
            20: $Va,
            22: 31,
            23: $Vb,
            24: $Vc
          }, o2($Vd, [2, 12]), o2($Vd, [2, 14]), o2($Vd, [2, 16])],
          defaultActions: {
            10: [2, 1]
          },
          parseError: function parseError(str, hash) {
            if (hash.recoverable) {
              this.trace(str);
            } else {
              var error = new Error(str);
              error.hash = hash;
              throw error;
            }
          },
          parse: function parse(input) {
            var self2 = this, stack = [0], tstack = [], vstack = [null], lstack = [], table = this.table, yytext = "", yylineno = 0, yyleng = 0, recovering = 0, TERROR = 2, EOF = 1;
            var args = lstack.slice.call(arguments, 1);
            var lexer2 = Object.create(this.lexer);
            var sharedState = {
              yy: {}
            };
            for (var k2 in this.yy) {
              if (Object.prototype.hasOwnProperty.call(this.yy, k2)) {
                sharedState.yy[k2] = this.yy[k2];
              }
            }
            lexer2.setInput(input, sharedState.yy);
            sharedState.yy.lexer = lexer2;
            sharedState.yy.parser = this;
            if (typeof lexer2.yylloc == "undefined") {
              lexer2.yylloc = {};
            }
            var yyloc = lexer2.yylloc;
            lstack.push(yyloc);
            var ranges = lexer2.options && lexer2.options.ranges;
            if (typeof sharedState.yy.parseError === "function") {
              this.parseError = sharedState.yy.parseError;
            } else {
              this.parseError = Object.getPrototypeOf(this).parseError;
            }
            function popStack(n) {
              stack.length = stack.length - 2 * n;
              vstack.length = vstack.length - n;
              lstack.length = lstack.length - n;
            }
            function lex() {
              var token;
              token = tstack.pop() || lexer2.lex() || EOF;
              if (typeof token !== "number") {
                if (token instanceof Array) {
                  tstack = token;
                  token = tstack.pop();
                }
                token = self2.symbols_[token] || token;
              }
              return token;
            }
            var symbol, preErrorSymbol, state, action, a2, r2, yyval = {}, p2, len, newState, expected;
            while (true) {
              state = stack[stack.length - 1];
              if (this.defaultActions[state]) {
                action = this.defaultActions[state];
              } else {
                if (symbol === null || typeof symbol == "undefined") {
                  symbol = lex();
                }
                action = table[state] && table[state][symbol];
              }
              if (typeof action === "undefined" || !action.length || !action[0]) {
                var errStr = "";
                expected = [];
                for (p2 in table[state]) {
                  if (this.terminals_[p2] && p2 > TERROR) {
                    expected.push("'" + this.terminals_[p2] + "'");
                  }
                }
                if (lexer2.showPosition) {
                  errStr = "Parse error on line " + (yylineno + 1) + ":\n" + lexer2.showPosition() + "\nExpecting " + expected.join(", ") + ", got '" + (this.terminals_[symbol] || symbol) + "'";
                } else {
                  errStr = "Parse error on line " + (yylineno + 1) + ": Unexpected " + (symbol == EOF ? "end of input" : "'" + (this.terminals_[symbol] || symbol) + "'");
                }
                this.parseError(errStr, {
                  text: lexer2.match,
                  token: this.terminals_[symbol] || symbol,
                  line: lexer2.yylineno,
                  loc: yyloc,
                  expected
                });
              }
              if (action[0] instanceof Array && action.length > 1) {
                throw new Error("Parse Error: multiple actions possible at state: " + state + ", token: " + symbol);
              }
              switch (action[0]) {
                case 1:
                  stack.push(symbol);
                  vstack.push(lexer2.yytext);
                  lstack.push(lexer2.yylloc);
                  stack.push(action[1]);
                  symbol = null;
                  if (!preErrorSymbol) {
                    yyleng = lexer2.yyleng;
                    yytext = lexer2.yytext;
                    yylineno = lexer2.yylineno;
                    yyloc = lexer2.yylloc;
                    if (recovering > 0) {
                      recovering--;
                    }
                  } else {
                    symbol = preErrorSymbol;
                    preErrorSymbol = null;
                  }
                  break;
                case 2:
                  len = this.productions_[action[1]][1];
                  yyval.$ = vstack[vstack.length - len];
                  yyval._$ = {
                    first_line: lstack[lstack.length - (len || 1)].first_line,
                    last_line: lstack[lstack.length - 1].last_line,
                    first_column: lstack[lstack.length - (len || 1)].first_column,
                    last_column: lstack[lstack.length - 1].last_column
                  };
                  if (ranges) {
                    yyval._$.range = [lstack[lstack.length - (len || 1)].range[0], lstack[lstack.length - 1].range[1]];
                  }
                  r2 = this.performAction.apply(yyval, [yytext, yyleng, yylineno, sharedState.yy, action[1], vstack, lstack].concat(args));
                  if (typeof r2 !== "undefined") {
                    return r2;
                  }
                  if (len) {
                    stack = stack.slice(0, -1 * len * 2);
                    vstack = vstack.slice(0, -1 * len);
                    lstack = lstack.slice(0, -1 * len);
                  }
                  stack.push(this.productions_[action[1]][0]);
                  vstack.push(yyval.$);
                  lstack.push(yyval._$);
                  newState = table[stack[stack.length - 2]][stack[stack.length - 1]];
                  stack.push(newState);
                  break;
                case 3:
                  return true;
              }
            }
            return true;
          }
        };
        var lexer = /* @__PURE__ */ function() {
          var lexer2 = {
            EOF: 1,
            parseError: function parseError(str, hash) {
              if (this.yy.parser) {
                this.yy.parser.parseError(str, hash);
              } else {
                throw new Error(str);
              }
            },
            // resets the lexer, sets new input
            setInput: function(input, yy) {
              this.yy = yy || this.yy || {};
              this._input = input;
              this._more = this._backtrack = this.done = false;
              this.yylineno = this.yyleng = 0;
              this.yytext = this.matched = this.match = "";
              this.conditionStack = ["INITIAL"];
              this.yylloc = {
                first_line: 1,
                first_column: 0,
                last_line: 1,
                last_column: 0
              };
              if (this.options.ranges) {
                this.yylloc.range = [0, 0];
              }
              this.offset = 0;
              return this;
            },
            // consumes and returns one char from the input
            input: function() {
              var ch = this._input[0];
              this.yytext += ch;
              this.yyleng++;
              this.offset++;
              this.match += ch;
              this.matched += ch;
              var lines = ch.match(/(?:\r\n?|\n).*/g);
              if (lines) {
                this.yylineno++;
                this.yylloc.last_line++;
              } else {
                this.yylloc.last_column++;
              }
              if (this.options.ranges) {
                this.yylloc.range[1]++;
              }
              this._input = this._input.slice(1);
              return ch;
            },
            // unshifts one char (or a string) into the input
            unput: function(ch) {
              var len = ch.length;
              var lines = ch.split(/(?:\r\n?|\n)/g);
              this._input = ch + this._input;
              this.yytext = this.yytext.substr(0, this.yytext.length - len);
              this.offset -= len;
              var oldLines = this.match.split(/(?:\r\n?|\n)/g);
              this.match = this.match.substr(0, this.match.length - 1);
              this.matched = this.matched.substr(0, this.matched.length - 1);
              if (lines.length - 1) {
                this.yylineno -= lines.length - 1;
              }
              var r2 = this.yylloc.range;
              this.yylloc = {
                first_line: this.yylloc.first_line,
                last_line: this.yylineno + 1,
                first_column: this.yylloc.first_column,
                last_column: lines ? (lines.length === oldLines.length ? this.yylloc.first_column : 0) + oldLines[oldLines.length - lines.length].length - lines[0].length : this.yylloc.first_column - len
              };
              if (this.options.ranges) {
                this.yylloc.range = [r2[0], r2[0] + this.yyleng - len];
              }
              this.yyleng = this.yytext.length;
              return this;
            },
            // When called from action, caches matched text and appends it on next action
            more: function() {
              this._more = true;
              return this;
            },
            // When called from action, signals the lexer that this rule fails to match the input, so the next matching rule (regex) should be tested instead.
            reject: function() {
              if (this.options.backtrack_lexer) {
                this._backtrack = true;
              } else {
                return this.parseError("Lexical error on line " + (this.yylineno + 1) + ". You can only invoke reject() in the lexer when the lexer is of the backtracking persuasion (options.backtrack_lexer = true).\n" + this.showPosition(), {
                  text: "",
                  token: null,
                  line: this.yylineno
                });
              }
              return this;
            },
            // retain first n characters of the match
            less: function(n) {
              this.unput(this.match.slice(n));
            },
            // displays already matched input, i.e. for error messages
            pastInput: function() {
              var past = this.matched.substr(0, this.matched.length - this.match.length);
              return (past.length > 20 ? "..." : "") + past.substr(-20).replace(/\n/g, "");
            },
            // displays upcoming input, i.e. for error messages
            upcomingInput: function() {
              var next = this.match;
              if (next.length < 20) {
                next += this._input.substr(0, 20 - next.length);
              }
              return (next.substr(0, 20) + (next.length > 20 ? "..." : "")).replace(/\n/g, "");
            },
            // displays the character position where the lexing error occurred, i.e. for error messages
            showPosition: function() {
              var pre = this.pastInput();
              var c2 = new Array(pre.length + 1).join("-");
              return pre + this.upcomingInput() + "\n" + c2 + "^";
            },
            // test the lexed token: return FALSE when not a match, otherwise return token
            test_match: function(match, indexed_rule) {
              var token, lines, backup;
              if (this.options.backtrack_lexer) {
                backup = {
                  yylineno: this.yylineno,
                  yylloc: {
                    first_line: this.yylloc.first_line,
                    last_line: this.last_line,
                    first_column: this.yylloc.first_column,
                    last_column: this.yylloc.last_column
                  },
                  yytext: this.yytext,
                  match: this.match,
                  matches: this.matches,
                  matched: this.matched,
                  yyleng: this.yyleng,
                  offset: this.offset,
                  _more: this._more,
                  _input: this._input,
                  yy: this.yy,
                  conditionStack: this.conditionStack.slice(0),
                  done: this.done
                };
                if (this.options.ranges) {
                  backup.yylloc.range = this.yylloc.range.slice(0);
                }
              }
              lines = match[0].match(/(?:\r\n?|\n).*/g);
              if (lines) {
                this.yylineno += lines.length;
              }
              this.yylloc = {
                first_line: this.yylloc.last_line,
                last_line: this.yylineno + 1,
                first_column: this.yylloc.last_column,
                last_column: lines ? lines[lines.length - 1].length - lines[lines.length - 1].match(/\r?\n?/)[0].length : this.yylloc.last_column + match[0].length
              };
              this.yytext += match[0];
              this.match += match[0];
              this.matches = match;
              this.yyleng = this.yytext.length;
              if (this.options.ranges) {
                this.yylloc.range = [this.offset, this.offset += this.yyleng];
              }
              this._more = false;
              this._backtrack = false;
              this._input = this._input.slice(match[0].length);
              this.matched += match[0];
              token = this.performAction.call(this, this.yy, this, indexed_rule, this.conditionStack[this.conditionStack.length - 1]);
              if (this.done && this._input) {
                this.done = false;
              }
              if (token) {
                return token;
              } else if (this._backtrack) {
                for (var k2 in backup) {
                  this[k2] = backup[k2];
                }
                return false;
              }
              return false;
            },
            // return next match in input
            next: function() {
              if (this.done) {
                return this.EOF;
              }
              if (!this._input) {
                this.done = true;
              }
              var token, match, tempMatch, index;
              if (!this._more) {
                this.yytext = "";
                this.match = "";
              }
              var rules = this._currentRules();
              for (var i2 = 0; i2 < rules.length; i2++) {
                tempMatch = this._input.match(this.rules[rules[i2]]);
                if (tempMatch && (!match || tempMatch[0].length > match[0].length)) {
                  match = tempMatch;
                  index = i2;
                  if (this.options.backtrack_lexer) {
                    token = this.test_match(tempMatch, rules[i2]);
                    if (token !== false) {
                      return token;
                    } else if (this._backtrack) {
                      match = false;
                      continue;
                    } else {
                      return false;
                    }
                  } else if (!this.options.flex) {
                    break;
                  }
                }
              }
              if (match) {
                token = this.test_match(match, rules[index]);
                if (token !== false) {
                  return token;
                }
                return false;
              }
              if (this._input === "") {
                return this.EOF;
              } else {
                return this.parseError("Lexical error on line " + (this.yylineno + 1) + ". Unrecognized text.\n" + this.showPosition(), {
                  text: "",
                  token: null,
                  line: this.yylineno
                });
              }
            },
            // return next match that has a token
            lex: function lex() {
              var r2 = this.next();
              if (r2) {
                return r2;
              } else {
                return this.lex();
              }
            },
            // activates a new lexer condition state (pushes the new lexer condition state onto the condition stack)
            begin: function begin(condition) {
              this.conditionStack.push(condition);
            },
            // pop the previously active lexer condition state off the condition stack
            popState: function popState() {
              var n = this.conditionStack.length - 1;
              if (n > 0) {
                return this.conditionStack.pop();
              } else {
                return this.conditionStack[0];
              }
            },
            // produce the lexer rule set which is active for the currently active lexer condition state
            _currentRules: function _currentRules() {
              if (this.conditionStack.length && this.conditionStack[this.conditionStack.length - 1]) {
                return this.conditions[this.conditionStack[this.conditionStack.length - 1]].rules;
              } else {
                return this.conditions["INITIAL"].rules;
              }
            },
            // return the currently active lexer condition state; when an index argument is provided it produces the N-th previous condition state, if available
            topState: function topState(n) {
              n = this.conditionStack.length - 1 - Math.abs(n || 0);
              if (n >= 0) {
                return this.conditionStack[n];
              } else {
                return "INITIAL";
              }
            },
            // alias for begin(condition)
            pushState: function pushState(condition) {
              this.begin(condition);
            },
            // return the number of states currently on the stack
            stateStackSize: function stateStackSize() {
              return this.conditionStack.length;
            },
            options: {
              "case-insensitive": true
            },
            performAction: function anonymous(yy, yy_, $avoiding_name_collisions, YY_START) {
              var YYSTATE = YY_START;
              switch ($avoiding_name_collisions) {
                case 0:
                  break;
                case 1:
                  return 20;
                  break;
                case 2:
                  return 7;
                  break;
                case 3:
                  return 8;
                  break;
                case 4:
                  return 9;
                  break;
                case 5:
                  return 12;
                  break;
                case 6:
                  return 16;
                  break;
                case 7:
                  return 14;
                  break;
                case 8:
                  return 10;
                  break;
                case 9:
                  return 11;
                  break;
                case 10:
                  return 19;
                  break;
                case 11:
                  return 21;
                  break;
                case 12:
                  return "<=";
                  break;
                case 13:
                  return ">=";
                  break;
                case 14:
                  return "<";
                  break;
                case 15:
                  return ">";
                  break;
                case 16:
                  yy_.yytext = yy_.yytext.substr(1, yy_.yyleng - 2);
                  return 24;
                  break;
                case 17:
                  return 13;
                  break;
                case 18:
                  return 23;
                  break;
                case 19:
                  return 5;
                  break;
                case 20:
                  return "INVALID";
                  break;
              }
            },
            rules: [/^(?:\s+)/i, /^(?:(-?(?:[1-9][0-9]+|[0-9]))\b)/i, /^(?:OR\b)/i, /^(?:AND\b)/i, /^(?:NOT\b)/i, /^(?:((ALL|NONE|HETATM|PROTEIN|BASIC|ACIDIC|CHARGED|POLAR|NONPOLAR|AROMATIC|NUCLEIC|PURINE|PYRIMIDINE|WATER|POLARH|NONPOLARH))\b)/i, /^(?:((NAME|ELEM|TYPE|RESIDUE|ICODE|CHAIN|ALTLOC))\b)/i, /^(?:((SERIAL|SEQUENCE|RESIDX))\b)/i, /^(?:\()/i, /^(?:\))/i, /^(?:,)/i, /^(?::)/i, /^(?:<=)/i, /^(?:>=)/i, /^(?:<)/i, /^(?:>)/i, /^(?:((?:"(?:\\.|[^\\"])*"|'(?:\\.|[^\\'])*')))/i, /^(?:(@[_A-Z0-9]+))/i, /^(?:([_A-Z0-9]+))/i, /^(?:$)/i, /^(?:.)/i],
            conditions: {
              "INITIAL": {
                "rules": [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20],
                "inclusive": true
              }
            }
          };
          return lexer2;
        }();
        parser2.lexer = lexer;
        function Parser2() {
          this.yy = {};
        }
        Parser2.prototype = parser2;
        parser2.Parser = Parser2;
        return new Parser2();
      }();
      module.exports = {
        parser
      };
    }
  ),
  /***/
  690: (
    /***/
    function(__unused_webpack_module, exports) {
      (function() {
        var AbstractInterpolator, CubicInterpolator, Enum, LinearInterpolator, NearestInterpolator, PI, SincFilterInterpolator, Smooth2, clipClamp, clipMirror, clipPeriodic, defaultConfig, getColumn, getType, isValidNumber, k2, makeLanczosWindow, makeScaledFunction, makeSincKernel, normalizeScaleTo, shallowCopy, sin, sinc, v2, validateNumber, validateVector, __hasProp = Object.prototype.hasOwnProperty, __extends = function(child, parent) {
          for (var key in parent) {
            if (__hasProp.call(parent, key)) child[key] = parent[key];
          }
          function ctor() {
            this.constructor = child;
          }
          ctor.prototype = parent.prototype;
          child.prototype = new ctor();
          child.__super__ = parent.prototype;
          return child;
        };
        Enum = {
          /*Interpolation methods
          */
          METHOD_NEAREST: "nearest",
          METHOD_LINEAR: "linear",
          METHOD_CUBIC: "cubic",
          METHOD_LANCZOS: "lanczos",
          METHOD_SINC: "sinc",
          /*Input clipping modes
          */
          CLIP_CLAMP: "clamp",
          CLIP_ZERO: "zero",
          CLIP_PERIODIC: "periodic",
          CLIP_MIRROR: "mirror",
          /* Constants for control over the cubic interpolation tension
          */
          CUBIC_TENSION_DEFAULT: 0,
          CUBIC_TENSION_CATMULL_ROM: 0
        };
        defaultConfig = {
          method: Enum.METHOD_CUBIC,
          cubicTension: Enum.CUBIC_TENSION_DEFAULT,
          clip: Enum.CLIP_CLAMP,
          scaleTo: 0,
          sincFilterSize: 2,
          sincWindow: void 0
        };
        clipClamp = function(i2, n) {
          return Math.max(0, Math.min(i2, n - 1));
        };
        clipPeriodic = function(i2, n) {
          i2 = i2 % n;
          if (i2 < 0) i2 += n;
          return i2;
        };
        clipMirror = function(i2, n) {
          var period;
          period = 2 * (n - 1);
          i2 = clipPeriodic(i2, period);
          if (i2 > n - 1) i2 = period - i2;
          return i2;
        };
        AbstractInterpolator = function() {
          function AbstractInterpolator2(array, config) {
            this.array = array.slice(0);
            this.length = this.array.length;
            if (!(this.clipHelper = {
              clamp: this.clipHelperClamp,
              zero: this.clipHelperZero,
              periodic: this.clipHelperPeriodic,
              mirror: this.clipHelperMirror
            }[config.clip])) {
              throw "Invalid clip: " + config.clip;
            }
          }
          AbstractInterpolator2.prototype.getClippedInput = function(i2) {
            if (0 <= i2 && i2 < this.length) {
              return this.array[i2];
            } else {
              return this.clipHelper(i2);
            }
          };
          AbstractInterpolator2.prototype.clipHelperClamp = function(i2) {
            return this.array[clipClamp(i2, this.length)];
          };
          AbstractInterpolator2.prototype.clipHelperZero = function(i2) {
            return 0;
          };
          AbstractInterpolator2.prototype.clipHelperPeriodic = function(i2) {
            return this.array[clipPeriodic(i2, this.length)];
          };
          AbstractInterpolator2.prototype.clipHelperMirror = function(i2) {
            return this.array[clipMirror(i2, this.length)];
          };
          AbstractInterpolator2.prototype.interpolate = function(t2) {
            throw "Subclasses of AbstractInterpolator must override the interpolate() method.";
          };
          return AbstractInterpolator2;
        }();
        NearestInterpolator = function(_super) {
          __extends(NearestInterpolator2, _super);
          function NearestInterpolator2() {
            NearestInterpolator2.__super__.constructor.apply(this, arguments);
          }
          NearestInterpolator2.prototype.interpolate = function(t2) {
            return this.getClippedInput(Math.round(t2));
          };
          return NearestInterpolator2;
        }(AbstractInterpolator);
        LinearInterpolator = function(_super) {
          __extends(LinearInterpolator2, _super);
          function LinearInterpolator2() {
            LinearInterpolator2.__super__.constructor.apply(this, arguments);
          }
          LinearInterpolator2.prototype.interpolate = function(t2) {
            var k3;
            k3 = Math.floor(t2);
            t2 -= k3;
            return (1 - t2) * this.getClippedInput(k3) + t2 * this.getClippedInput(k3 + 1);
          };
          return LinearInterpolator2;
        }(AbstractInterpolator);
        CubicInterpolator = function(_super) {
          __extends(CubicInterpolator2, _super);
          function CubicInterpolator2(array, config) {
            this.tangentFactor = 1 - Math.max(-1, Math.min(1, config.cubicTension));
            CubicInterpolator2.__super__.constructor.apply(this, arguments);
          }
          CubicInterpolator2.prototype.getTangent = function(k3) {
            return this.tangentFactor * (this.getClippedInput(k3 + 1) - this.getClippedInput(k3 - 1)) / 2;
          };
          CubicInterpolator2.prototype.interpolate = function(t2) {
            var k3, m2, p2, t22, t3;
            k3 = Math.floor(t2);
            m2 = [this.getTangent(k3), this.getTangent(k3 + 1)];
            p2 = [this.getClippedInput(k3), this.getClippedInput(k3 + 1)];
            t2 -= k3;
            t22 = t2 * t2;
            t3 = t2 * t22;
            return (2 * t3 - 3 * t22 + 1) * p2[0] + (t3 - 2 * t22 + t2) * m2[0] + (-2 * t3 + 3 * t22) * p2[1] + (t3 - t22) * m2[1];
          };
          return CubicInterpolator2;
        }(AbstractInterpolator);
        sin = Math.sin, PI = Math.PI;
        sinc = function(x3) {
          if (x3 === 0) {
            return 1;
          } else {
            return sin(PI * x3) / (PI * x3);
          }
        };
        makeLanczosWindow = function(a2) {
          return function(x3) {
            return sinc(x3 / a2);
          };
        };
        makeSincKernel = function(window2) {
          return function(x3) {
            return sinc(x3) * window2(x3);
          };
        };
        SincFilterInterpolator = function(_super) {
          __extends(SincFilterInterpolator2, _super);
          function SincFilterInterpolator2(array, config) {
            SincFilterInterpolator2.__super__.constructor.apply(this, arguments);
            this.a = config.sincFilterSize;
            if (!config.sincWindow) throw "No sincWindow provided";
            this.kernel = makeSincKernel(config.sincWindow);
          }
          SincFilterInterpolator2.prototype.interpolate = function(t2) {
            var k3, n, sum, _ref, _ref2;
            k3 = Math.floor(t2);
            sum = 0;
            for (n = _ref = k3 - this.a + 1, _ref2 = k3 + this.a; _ref <= _ref2 ? n <= _ref2 : n >= _ref2; _ref <= _ref2 ? n++ : n--) {
              sum += this.kernel(t2 - n) * this.getClippedInput(n);
            }
            return sum;
          };
          return SincFilterInterpolator2;
        }(AbstractInterpolator);
        getColumn = function(arr, i2) {
          var row, _i, _len, _results;
          _results = [];
          for (_i = 0, _len = arr.length; _i < _len; _i++) {
            row = arr[_i];
            _results.push(row[i2]);
          }
          return _results;
        };
        makeScaledFunction = function(f2, baseScale, scaleRange) {
          var scaleFactor, translation;
          if (scaleRange.join === "0,1") {
            return f2;
          } else {
            scaleFactor = baseScale / (scaleRange[1] - scaleRange[0]);
            translation = scaleRange[0];
            return function(t2) {
              return f2(scaleFactor * (t2 - translation));
            };
          }
        };
        getType = function(x3) {
          return Object.prototype.toString.call(x3).slice("[object ".length, -1);
        };
        validateNumber = function(n) {
          if (isNaN(n)) throw "NaN in Smooth() input";
          if (getType(n) !== "Number") throw "Non-number in Smooth() input";
          if (!isFinite(n)) throw "Infinity in Smooth() input";
        };
        validateVector = function(v3, dimension) {
          var n, _i, _len;
          if (getType(v3) !== "Array") throw "Non-vector in Smooth() input";
          if (v3.length !== dimension) throw "Inconsistent dimension in Smooth() input";
          for (_i = 0, _len = v3.length; _i < _len; _i++) {
            n = v3[_i];
            validateNumber(n);
          }
        };
        isValidNumber = function(n) {
          return getType(n) === "Number" && isFinite(n) && !isNaN(n);
        };
        normalizeScaleTo = function(s2) {
          var invalidErr;
          invalidErr = "scaleTo param must be number or array of two numbers";
          switch (getType(s2)) {
            case "Number":
              if (!isValidNumber(s2)) throw invalidErr;
              s2 = [0, s2];
              break;
            case "Array":
              if (s2.length !== 2) throw invalidErr;
              if (!(isValidNumber(s2[0]) && isValidNumber(s2[1]))) throw invalidErr;
              break;
            default:
              throw invalidErr;
          }
          return s2;
        };
        shallowCopy = function(obj) {
          var copy, k3, v3;
          copy = {};
          for (k3 in obj) {
            if (!__hasProp.call(obj, k3)) continue;
            v3 = obj[k3];
            copy[k3] = v3;
          }
          return copy;
        };
        Smooth2 = function(arr, config) {
          var baseDomainEnd, dimension, i2, interpolator, interpolatorClass, interpolators, k3, n, properties, smoothFunc, v3;
          if (config == null) config = {};
          properties = {};
          config = shallowCopy(config);
          properties.config = shallowCopy(config);
          if (config.scaleTo == null) config.scaleTo = config.period;
          if (config.sincFilterSize == null) {
            config.sincFilterSize = config.lanczosFilterSize;
          }
          for (k3 in defaultConfig) {
            if (!__hasProp.call(defaultConfig, k3)) continue;
            v3 = defaultConfig[k3];
            if (config[k3] == null) config[k3] = v3;
          }
          if (!(interpolatorClass = {
            nearest: NearestInterpolator,
            linear: LinearInterpolator,
            cubic: CubicInterpolator,
            lanczos: SincFilterInterpolator,
            sinc: SincFilterInterpolator
          }[config.method])) {
            throw "Invalid method: " + config.method;
          }
          if (config.method === "lanczos") {
            config.sincWindow = makeLanczosWindow(config.sincFilterSize);
          }
          if (arr.length < 2) throw "Array must have at least two elements";
          properties.count = arr.length;
          smoothFunc = function() {
            var _i, _j, _len, _len2;
            switch (getType(arr[0])) {
              case "Number":
                properties.dimension = "scalar";
                if (Smooth2.deepValidation) {
                  for (_i = 0, _len = arr.length; _i < _len; _i++) {
                    n = arr[_i];
                    validateNumber(n);
                  }
                }
                interpolator = new interpolatorClass(arr, config);
                return function(t2) {
                  return interpolator.interpolate(t2);
                };
              case "Array":
                properties.dimension = dimension = arr[0].length;
                if (!dimension) throw "Vectors must be non-empty";
                if (Smooth2.deepValidation) {
                  for (_j = 0, _len2 = arr.length; _j < _len2; _j++) {
                    v3 = arr[_j];
                    validateVector(v3, dimension);
                  }
                }
                interpolators = function() {
                  var _results;
                  _results = [];
                  for (i2 = 0; 0 <= dimension ? i2 < dimension : i2 > dimension; 0 <= dimension ? i2++ : i2--) {
                    _results.push(new interpolatorClass(getColumn(arr, i2), config));
                  }
                  return _results;
                }();
                return function(t2) {
                  var interpolator2, _k, _len3, _results;
                  _results = [];
                  for (_k = 0, _len3 = interpolators.length; _k < _len3; _k++) {
                    interpolator2 = interpolators[_k];
                    _results.push(interpolator2.interpolate(t2));
                  }
                  return _results;
                };
              default:
                throw "Invalid element type: " + getType(arr[0]);
            }
          }();
          if (config.clip === "periodic") {
            baseDomainEnd = arr.length;
          } else {
            baseDomainEnd = arr.length - 1;
          }
          config.scaleTo || (config.scaleTo = baseDomainEnd);
          properties.domain = normalizeScaleTo(config.scaleTo);
          smoothFunc = makeScaledFunction(smoothFunc, baseDomainEnd, properties.domain);
          properties.domain.sort();
          for (k3 in properties) {
            if (!__hasProp.call(properties, k3)) continue;
            v3 = properties[k3];
            smoothFunc[k3] = v3;
          }
          return smoothFunc;
        };
        for (k2 in Enum) {
          if (!__hasProp.call(Enum, k2)) continue;
          v2 = Enum[k2];
          Smooth2[k2] = v2;
        }
        Smooth2.deepValidation = true;
        (exports !== null ? exports : window).Smooth = Smooth2;
      }).call(this);
    }
  ),
  /***/
  660: (
    /***/
    function(module, exports) {
      var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;
      !function(r2, t2) {
        if (true) !(__WEBPACK_AMD_DEFINE_ARRAY__ = [exports], __WEBPACK_AMD_DEFINE_FACTORY__ = t2, __WEBPACK_AMD_DEFINE_RESULT__ = typeof __WEBPACK_AMD_DEFINE_FACTORY__ === "function" ? __WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__) : __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_RESULT__ !== void 0 && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
        else {
        }
      }(this, function(r2) {
        "use strict";
        function t2(r3, t3, n2) {
          for (var e3 = (r3.byteLength, 0), i3 = n2.length; i3 > e3; e3++) {
            var o3 = n2.charCodeAt(e3);
            if (128 > o3) r3.setUint8(t3++, o3 >>> 0 & 127 | 0);
            else if (2048 > o3) r3.setUint8(t3++, o3 >>> 6 & 31 | 192), r3.setUint8(t3++, o3 >>> 0 & 63 | 128);
            else if (65536 > o3) r3.setUint8(t3++, o3 >>> 12 & 15 | 224), r3.setUint8(t3++, o3 >>> 6 & 63 | 128), r3.setUint8(t3++, o3 >>> 0 & 63 | 128);
            else {
              if (!(1114112 > o3)) throw new Error("bad codepoint " + o3);
              r3.setUint8(t3++, o3 >>> 18 & 7 | 240), r3.setUint8(t3++, o3 >>> 12 & 63 | 128), r3.setUint8(t3++, o3 >>> 6 & 63 | 128), r3.setUint8(t3++, o3 >>> 0 & 63 | 128);
            }
          }
        }
        function n(r3) {
          for (var t3 = 0, n2 = 0, e3 = r3.length; e3 > n2; n2++) {
            var i3 = r3.charCodeAt(n2);
            if (128 > i3) t3 += 1;
            else if (2048 > i3) t3 += 2;
            else if (65536 > i3) t3 += 3;
            else {
              if (!(1114112 > i3)) throw new Error("bad codepoint " + i3);
              t3 += 4;
            }
          }
          return t3;
        }
        function e2(r3, i3, o3) {
          var a3 = typeof r3;
          if ("string" === a3) {
            var u3 = n(r3);
            if (32 > u3) return i3.setUint8(o3, 160 | u3), t2(i3, o3 + 1, r3), 1 + u3;
            if (256 > u3) return i3.setUint8(o3, 217), i3.setUint8(o3 + 1, u3), t2(i3, o3 + 2, r3), 2 + u3;
            if (65536 > u3) return i3.setUint8(o3, 218), i3.setUint16(o3 + 1, u3), t2(i3, o3 + 3, r3), 3 + u3;
            if (4294967296 > u3) return i3.setUint8(o3, 219), i3.setUint32(o3 + 1, u3), t2(i3, o3 + 5, r3), 5 + u3;
          }
          if (r3 instanceof Uint8Array) {
            var u3 = r3.byteLength, s3 = new Uint8Array(i3.buffer);
            if (256 > u3) return i3.setUint8(o3, 196), i3.setUint8(o3 + 1, u3), s3.set(r3, o3 + 2), 2 + u3;
            if (65536 > u3) return i3.setUint8(o3, 197), i3.setUint16(o3 + 1, u3), s3.set(r3, o3 + 3), 3 + u3;
            if (4294967296 > u3) return i3.setUint8(o3, 198), i3.setUint32(o3 + 1, u3), s3.set(r3, o3 + 5), 5 + u3;
          }
          if ("number" === a3) {
            if (!isFinite(r3)) throw new Error("Number not finite: " + r3);
            if (Math.floor(r3) !== r3) return i3.setUint8(o3, 203), i3.setFloat64(o3 + 1, r3), 9;
            if (r3 >= 0) {
              if (128 > r3) return i3.setUint8(o3, r3), 1;
              if (256 > r3) return i3.setUint8(o3, 204), i3.setUint8(o3 + 1, r3), 2;
              if (65536 > r3) return i3.setUint8(o3, 205), i3.setUint16(o3 + 1, r3), 3;
              if (4294967296 > r3) return i3.setUint8(o3, 206), i3.setUint32(o3 + 1, r3), 5;
              throw new Error("Number too big 0x" + r3.toString(16));
            }
            if (r3 >= -32) return i3.setInt8(o3, r3), 1;
            if (r3 >= -128) return i3.setUint8(o3, 208), i3.setInt8(o3 + 1, r3), 2;
            if (r3 >= -32768) return i3.setUint8(o3, 209), i3.setInt16(o3 + 1, r3), 3;
            if (r3 >= -2147483648) return i3.setUint8(o3, 210), i3.setInt32(o3 + 1, r3), 5;
            throw new Error("Number too small -0x" + (-r3).toString(16).substr(1));
          }
          if (null === r3) return i3.setUint8(o3, 192), 1;
          if ("boolean" === a3) return i3.setUint8(o3, r3 ? 195 : 194), 1;
          if ("object" === a3) {
            var u3, f3 = 0, c3 = Array.isArray(r3);
            if (c3) u3 = r3.length;
            else {
              var d3 = Object.keys(r3);
              u3 = d3.length;
            }
            var f3;
            if (16 > u3 ? (i3.setUint8(o3, u3 | (c3 ? 144 : 128)), f3 = 1) : 65536 > u3 ? (i3.setUint8(o3, c3 ? 220 : 222), i3.setUint16(o3 + 1, u3), f3 = 3) : 4294967296 > u3 && (i3.setUint8(o3, c3 ? 221 : 223), i3.setUint32(o3 + 1, u3), f3 = 5), c3) for (var l3 = 0; u3 > l3; l3++) f3 += e2(r3[l3], i3, o3 + f3);
            else for (var l3 = 0; u3 > l3; l3++) {
              var v3 = d3[l3];
              f3 += e2(v3, i3, o3 + f3), f3 += e2(r3[v3], i3, o3 + f3);
            }
            return f3;
          }
          throw new Error("Unknown type " + a3);
        }
        function i2(r3) {
          var t3 = typeof r3;
          if ("string" === t3) {
            var e3 = n(r3);
            if (32 > e3) return 1 + e3;
            if (256 > e3) return 2 + e3;
            if (65536 > e3) return 3 + e3;
            if (4294967296 > e3) return 5 + e3;
          }
          if (r3 instanceof Uint8Array) {
            var e3 = r3.byteLength;
            if (256 > e3) return 2 + e3;
            if (65536 > e3) return 3 + e3;
            if (4294967296 > e3) return 5 + e3;
          }
          if ("number" === t3) {
            if (Math.floor(r3) !== r3) return 9;
            if (r3 >= 0) {
              if (128 > r3) return 1;
              if (256 > r3) return 2;
              if (65536 > r3) return 3;
              if (4294967296 > r3) return 5;
              throw new Error("Number too big 0x" + r3.toString(16));
            }
            if (r3 >= -32) return 1;
            if (r3 >= -128) return 2;
            if (r3 >= -32768) return 3;
            if (r3 >= -2147483648) return 5;
            throw new Error("Number too small -0x" + r3.toString(16).substr(1));
          }
          if ("boolean" === t3 || null === r3) return 1;
          if ("object" === t3) {
            var e3, o3 = 0;
            if (Array.isArray(r3)) {
              e3 = r3.length;
              for (var a3 = 0; e3 > a3; a3++) o3 += i2(r3[a3]);
            } else {
              var u3 = Object.keys(r3);
              e3 = u3.length;
              for (var a3 = 0; e3 > a3; a3++) {
                var s3 = u3[a3];
                o3 += i2(s3) + i2(r3[s3]);
              }
            }
            if (16 > e3) return 1 + o3;
            if (65536 > e3) return 3 + o3;
            if (4294967296 > e3) return 5 + o3;
            throw new Error("Array or object too long 0x" + e3.toString(16));
          }
          throw new Error("Unknown type " + t3);
        }
        function o2(r3) {
          var t3 = new ArrayBuffer(i2(r3)), n2 = new DataView(t3);
          return e2(r3, n2, 0), new Uint8Array(t3);
        }
        function a2(r3, t3, n2) {
          return t3 ? new r3(t3.buffer, t3.byteOffset, t3.byteLength / (n2 || 1)) : void 0;
        }
        function u2(r3) {
          return a2(DataView, r3);
        }
        function s2(r3) {
          return a2(Uint8Array, r3);
        }
        function f2(r3) {
          return a2(Int8Array, r3);
        }
        function c2(r3) {
          return a2(Int32Array, r3, 4);
        }
        function d2(r3) {
          return a2(Float32Array, r3, 4);
        }
        function l2(r3, t3) {
          var n2 = r3.length / 2;
          t3 || (t3 = new Int16Array(n2));
          for (var e3 = 0, i3 = 0; n2 > e3; ++e3, i3 += 2) t3[e3] = r3[i3] << 8 ^ r3[i3 + 1] << 0;
          return t3;
        }
        function v2(r3, t3) {
          var n2 = r3.length;
          t3 || (t3 = new Uint8Array(2 * n2));
          for (var e3 = u2(t3), i3 = 0; n2 > i3; ++i3) e3.setInt16(2 * i3, r3[i3]);
          return s2(t3);
        }
        function g2(r3, t3) {
          var n2 = r3.length / 4;
          t3 || (t3 = new Int32Array(n2));
          for (var e3 = 0, i3 = 0; n2 > e3; ++e3, i3 += 4) t3[e3] = r3[i3] << 24 ^ r3[i3 + 1] << 16 ^ r3[i3 + 2] << 8 ^ r3[i3 + 3] << 0;
          return t3;
        }
        function L(r3, t3) {
          var n2 = r3.length;
          t3 || (t3 = new Uint8Array(4 * n2));
          for (var e3 = u2(t3), i3 = 0; n2 > i3; ++i3) e3.setInt32(4 * i3, r3[i3]);
          return s2(t3);
        }
        function h2(r3, t3) {
          var n2 = r3.length;
          t3 || (t3 = new Float32Array(n2 / 4));
          for (var e3 = u2(t3), i3 = u2(r3), o3 = 0, a3 = 0, s3 = n2 / 4; s3 > o3; ++o3, a3 += 4) e3.setFloat32(a3, i3.getFloat32(a3), true);
          return t3;
        }
        function y2(r3, t3, n2) {
          var e3 = r3.length, i3 = 1 / t3;
          n2 || (n2 = new Float32Array(e3));
          for (var o3 = 0; e3 > o3; ++o3) n2[o3] = r3[o3] * i3;
          return n2;
        }
        function m2(r3, t3, n2) {
          var e3 = r3.length;
          n2 || (n2 = new Int32Array(e3));
          for (var i3 = 0; e3 > i3; ++i3) n2[i3] = Math.round(r3[i3] * t3);
          return n2;
        }
        function p2(r3, t3) {
          var n2, e3;
          if (!t3) {
            var i3 = 0;
            for (n2 = 0, e3 = r3.length; e3 > n2; n2 += 2) i3 += r3[n2 + 1];
            t3 = new r3.constructor(i3);
          }
          var o3 = 0;
          for (n2 = 0, e3 = r3.length; e3 > n2; n2 += 2) for (var a3 = r3[n2], u3 = r3[n2 + 1], s3 = 0; u3 > s3; ++s3) t3[o3] = a3, ++o3;
          return t3;
        }
        function U(r3) {
          if (0 === r3.length) return new Int32Array();
          var t3, n2, e3 = 2;
          for (t3 = 1, n2 = r3.length; n2 > t3; ++t3) r3[t3 - 1] !== r3[t3] && (e3 += 2);
          var i3 = new Int32Array(e3), o3 = 0, a3 = 1;
          for (t3 = 1, n2 = r3.length; n2 > t3; ++t3) r3[t3 - 1] !== r3[t3] ? (i3[o3] = r3[t3 - 1], i3[o3 + 1] = a3, a3 = 1, o3 += 2) : ++a3;
          return i3[o3] = r3[r3.length - 1], i3[o3 + 1] = a3, i3;
        }
        function b2(r3, t3) {
          var n2 = r3.length;
          t3 || (t3 = new r3.constructor(n2)), n2 && (t3[0] = r3[0]);
          for (var e3 = 1; n2 > e3; ++e3) t3[e3] = r3[e3] + t3[e3 - 1];
          return t3;
        }
        function I2(r3, t3) {
          var n2 = r3.length;
          t3 || (t3 = new r3.constructor(n2)), t3[0] = r3[0];
          for (var e3 = 1; n2 > e3; ++e3) t3[e3] = r3[e3] - r3[e3 - 1];
          return t3;
        }
        function w2(r3, t3) {
          var n2, e3, i3 = r3 instanceof Int8Array ? 127 : 32767, o3 = -i3 - 1, a3 = r3.length;
          if (!t3) {
            var u3 = 0;
            for (n2 = 0; a3 > n2; ++n2) r3[n2] < i3 && r3[n2] > o3 && ++u3;
            t3 = new Int32Array(u3);
          }
          for (n2 = 0, e3 = 0; a3 > n2; ) {
            for (var s3 = 0; r3[n2] === i3 || r3[n2] === o3; ) s3 += r3[n2], ++n2;
            s3 += r3[n2], ++n2, t3[e3] = s3, ++e3;
          }
          return t3;
        }
        function C2(r3, t3) {
          var n2, e3 = t3 ? 127 : 32767, i3 = -e3 - 1, o3 = r3.length, a3 = 0;
          for (n2 = 0; o3 > n2; ++n2) {
            var u3 = r3[n2];
            0 === u3 ? ++a3 : a3 += u3 === e3 || u3 === i3 ? 2 : u3 > 0 ? Math.ceil(u3 / e3) : Math.ceil(u3 / i3);
          }
          var s3 = t3 ? new Int8Array(a3) : new Int16Array(a3), f3 = 0;
          for (n2 = 0; o3 > n2; ++n2) {
            var u3 = r3[n2];
            if (u3 >= 0) for (; u3 >= e3; ) s3[f3] = e3, ++f3, u3 -= e3;
            else for (; i3 >= u3; ) s3[f3] = i3, ++f3, u3 -= i3;
            s3[f3] = u3, ++f3;
          }
          return s3;
        }
        function A2(r3, t3) {
          return b2(p2(r3), t3);
        }
        function x3(r3) {
          return U(I2(r3));
        }
        function M(r3, t3, n2) {
          return y2(p2(r3, c2(n2)), t3, n2);
        }
        function F(r3, t3) {
          return U(m2(r3, t3));
        }
        function S(r3, t3, n2) {
          return y2(b2(r3, c2(n2)), t3, n2);
        }
        function E2(r3, t3, n2) {
          return I2(m2(r3, t3), n2);
        }
        function N(r3, t3, n2) {
          return y2(w2(r3, c2(n2)), t3, n2);
        }
        function O(r3, t3, n2) {
          var e3 = w2(r3, c2(n2));
          return S(e3, t3, d2(e3));
        }
        function T(r3, t3, n2) {
          return C2(E2(r3, t3), n2);
        }
        function k2(r3) {
          var t3 = u2(r3), n2 = t3.getInt32(0), e3 = t3.getInt32(4), i3 = r3.subarray(8, 12), r3 = r3.subarray(12);
          return [n2, r3, e3, i3];
        }
        function j(r3, t3, n2, e3) {
          var i3 = new ArrayBuffer(12 + e3.byteLength), o3 = new Uint8Array(i3), a3 = new DataView(i3);
          return a3.setInt32(0, r3), a3.setInt32(4, t3), n2 && o3.set(n2, 8), o3.set(e3, 12), o3;
        }
        function q(r3) {
          var t3 = r3.length, n2 = s2(r3);
          return j(2, t3, void 0, n2);
        }
        function D(r3) {
          var t3 = r3.length, n2 = L(r3);
          return j(4, t3, void 0, n2);
        }
        function P(r3, t3) {
          var n2 = r3.length / t3, e3 = L([t3]), i3 = s2(r3);
          return j(5, n2, e3, i3);
        }
        function z(r3) {
          var t3 = r3.length, n2 = L(U(r3));
          return j(6, t3, void 0, n2);
        }
        function B2(r3) {
          var t3 = r3.length, n2 = L(x3(r3));
          return j(8, t3, void 0, n2);
        }
        function V(r3, t3) {
          var n2 = r3.length, e3 = L([t3]), i3 = L(F(r3, t3));
          return j(9, n2, e3, i3);
        }
        function G(r3, t3) {
          var n2 = r3.length, e3 = L([t3]), i3 = v2(T(r3, t3));
          return j(10, n2, e3, i3);
        }
        function R(r3) {
          var t3 = {};
          return rr.forEach(function(n2) {
            void 0 !== r3[n2] && (t3[n2] = r3[n2]);
          }), r3.bondAtomList && (t3.bondAtomList = D(r3.bondAtomList)), r3.bondOrderList && (t3.bondOrderList = q(r3.bondOrderList)), t3.xCoordList = G(r3.xCoordList, 1e3), t3.yCoordList = G(r3.yCoordList, 1e3), t3.zCoordList = G(r3.zCoordList, 1e3), r3.bFactorList && (t3.bFactorList = G(r3.bFactorList, 100)), r3.atomIdList && (t3.atomIdList = B2(r3.atomIdList)), r3.altLocList && (t3.altLocList = z(r3.altLocList)), r3.occupancyList && (t3.occupancyList = V(r3.occupancyList, 100)), t3.groupIdList = B2(r3.groupIdList), t3.groupTypeList = D(r3.groupTypeList), r3.secStructList && (t3.secStructList = q(r3.secStructList, 1)), r3.insCodeList && (t3.insCodeList = z(r3.insCodeList)), r3.sequenceIndexList && (t3.sequenceIndexList = B2(r3.sequenceIndexList)), t3.chainIdList = P(r3.chainIdList, 4), r3.chainNameList && (t3.chainNameList = P(r3.chainNameList, 4)), t3;
        }
        function H(r3) {
          function t3(r4) {
            for (var t4 = {}, n3 = 0; r4 > n3; n3++) {
              var e4 = o3();
              t4[e4] = o3();
            }
            return t4;
          }
          function n2(t4) {
            var n3 = r3.subarray(a3, a3 + t4);
            return a3 += t4, n3;
          }
          function e3(t4) {
            var n3 = r3.subarray(a3, a3 + t4);
            a3 += t4;
            var e4 = 65535;
            if (t4 > e4) {
              for (var i4 = [], o4 = 0; o4 < n3.length; o4 += e4) i4.push(String.fromCharCode.apply(null, n3.subarray(o4, o4 + e4)));
              return i4.join("");
            }
            return String.fromCharCode.apply(null, n3);
          }
          function i3(r4) {
            for (var t4 = new Array(r4), n3 = 0; r4 > n3; n3++) t4[n3] = o3();
            return t4;
          }
          function o3() {
            var o4, s3, f3 = r3[a3];
            if (0 === (128 & f3)) return a3++, f3;
            if (128 === (240 & f3)) return s3 = 15 & f3, a3++, t3(s3);
            if (144 === (240 & f3)) return s3 = 15 & f3, a3++, i3(s3);
            if (160 === (224 & f3)) return s3 = 31 & f3, a3++, e3(s3);
            if (224 === (224 & f3)) return o4 = u3.getInt8(a3), a3++, o4;
            switch (f3) {
              case 192:
                return a3++, null;
              case 194:
                return a3++, false;
              case 195:
                return a3++, true;
              case 196:
                return s3 = u3.getUint8(a3 + 1), a3 += 2, n2(s3);
              case 197:
                return s3 = u3.getUint16(a3 + 1), a3 += 3, n2(s3);
              case 198:
                return s3 = u3.getUint32(a3 + 1), a3 += 5, n2(s3);
              case 202:
                return o4 = u3.getFloat32(a3 + 1), a3 += 5, o4;
              case 203:
                return o4 = u3.getFloat64(a3 + 1), a3 += 9, o4;
              case 204:
                return o4 = r3[a3 + 1], a3 += 2, o4;
              case 205:
                return o4 = u3.getUint16(a3 + 1), a3 += 3, o4;
              case 206:
                return o4 = u3.getUint32(a3 + 1), a3 += 5, o4;
              case 208:
                return o4 = u3.getInt8(a3 + 1), a3 += 2, o4;
              case 209:
                return o4 = u3.getInt16(a3 + 1), a3 += 3, o4;
              case 210:
                return o4 = u3.getInt32(a3 + 1), a3 += 5, o4;
              case 217:
                return s3 = u3.getUint8(a3 + 1), a3 += 2, e3(s3);
              case 218:
                return s3 = u3.getUint16(a3 + 1), a3 += 3, e3(s3);
              case 219:
                return s3 = u3.getUint32(a3 + 1), a3 += 5, e3(s3);
              case 220:
                return s3 = u3.getUint16(a3 + 1), a3 += 3, i3(s3);
              case 221:
                return s3 = u3.getUint32(a3 + 1), a3 += 5, i3(s3);
              case 222:
                return s3 = u3.getUint16(a3 + 1), a3 += 3, t3(s3);
              case 223:
                return s3 = u3.getUint32(a3 + 1), a3 += 5, t3(s3);
            }
            throw new Error("Unknown type 0x" + f3.toString(16));
          }
          var a3 = 0, u3 = new DataView(r3.buffer);
          return o3();
        }
        function W(r3, t3, n2, e3) {
          switch (r3) {
            case 1:
              return h2(t3);
            case 2:
              return f2(t3);
            case 3:
              return l2(t3);
            case 4:
              return g2(t3);
            case 5:
              return s2(t3);
            case 6:
              return p2(g2(t3), new Uint8Array(n2));
            case 7:
              return p2(g2(t3));
            case 8:
              return A2(g2(t3));
            case 9:
              return M(g2(t3), g2(e3)[0]);
            case 10:
              return O(l2(t3), g2(e3)[0]);
            case 11:
              return y2(l2(t3), g2(e3)[0]);
            case 12:
              return N(l2(t3), g2(e3)[0]);
            case 13:
              return N(f2(t3), g2(e3)[0]);
            case 14:
              return w2(l2(t3));
            case 15:
              return w2(f2(t3));
          }
        }
        function X(r3, t3) {
          t3 = t3 || {};
          var n2 = t3.ignoreFields, e3 = {};
          return nr.forEach(function(t4) {
            var i3 = n2 ? -1 !== n2.indexOf(t4) : false, o3 = r3[t4];
            i3 || void 0 === o3 || (o3 instanceof Uint8Array ? e3[t4] = W.apply(null, k2(o3)) : e3[t4] = o3);
          }), e3;
        }
        function J(r3) {
          return String.fromCharCode.apply(null, r3).replace(/\0/g, "");
        }
        function K(r3, t3, n2) {
          n2 = n2 || {};
          var e3, i3, o3, a3, u3, s3, f3 = n2.firstModelOnly, c3 = t3.onModel, d3 = t3.onChain, l3 = t3.onGroup, v3 = t3.onAtom, g3 = t3.onBond, L2 = 0, h3 = 0, y3 = 0, m3 = 0, p3 = 0, U2 = -1, b3 = r3.chainNameList, I3 = r3.secStructList, w3 = r3.insCodeList, C3 = r3.sequenceIndexList, A3 = r3.atomIdList, x4 = r3.bFactorList, M2 = r3.altLocList, F2 = r3.occupancyList, S2 = r3.bondAtomList, E3 = r3.bondOrderList;
          for (e3 = 0, i3 = r3.chainsPerModel.length; i3 > e3 && !(f3 && L2 > 0); ++e3) {
            var N2 = r3.chainsPerModel[L2];
            for (c3 && c3({
              chainCount: N2,
              modelIndex: L2
            }), o3 = 0; N2 > o3; ++o3) {
              var O2 = r3.groupsPerChain[h3];
              if (d3) {
                var T2 = J(r3.chainIdList.subarray(4 * h3, 4 * h3 + 4)), k3 = null;
                b3 && (k3 = J(b3.subarray(4 * h3, 4 * h3 + 4))), d3({
                  groupCount: O2,
                  chainIndex: h3,
                  modelIndex: L2,
                  chainId: T2,
                  chainName: k3
                });
              }
              for (a3 = 0; O2 > a3; ++a3) {
                var j2 = r3.groupList[r3.groupTypeList[y3]], q2 = j2.atomNameList.length;
                if (l3) {
                  var D2 = null;
                  I3 && (D2 = I3[y3]);
                  var P2 = null;
                  r3.insCodeList && (P2 = String.fromCharCode(w3[y3]));
                  var z2 = null;
                  C3 && (z2 = C3[y3]), l3({
                    atomCount: q2,
                    groupIndex: y3,
                    chainIndex: h3,
                    modelIndex: L2,
                    groupId: r3.groupIdList[y3],
                    groupType: r3.groupTypeList[y3],
                    groupName: j2.groupName,
                    singleLetterCode: j2.singleLetterCode,
                    chemCompType: j2.chemCompType,
                    secStruct: D2,
                    insCode: P2,
                    sequenceIndex: z2
                  });
                }
                for (u3 = 0; q2 > u3; ++u3) {
                  if (v3) {
                    var B3 = null;
                    A3 && (B3 = A3[m3]);
                    var V2 = null;
                    x4 && (V2 = x4[m3]);
                    var G2 = null;
                    M2 && (G2 = String.fromCharCode(M2[m3]));
                    var R2 = null;
                    F2 && (R2 = F2[m3]), v3({
                      atomIndex: m3,
                      groupIndex: y3,
                      chainIndex: h3,
                      modelIndex: L2,
                      atomId: B3,
                      element: j2.elementList[u3],
                      atomName: j2.atomNameList[u3],
                      formalCharge: j2.formalChargeList[u3],
                      xCoord: r3.xCoordList[m3],
                      yCoord: r3.yCoordList[m3],
                      zCoord: r3.zCoordList[m3],
                      bFactor: V2,
                      altLoc: G2,
                      occupancy: R2
                    });
                  }
                  m3 += 1;
                }
                if (g3) {
                  var H2 = j2.bondAtomList;
                  for (u3 = 0, s3 = j2.bondOrderList.length; s3 > u3; ++u3) g3({
                    atomIndex1: m3 - q2 + H2[2 * u3],
                    atomIndex2: m3 - q2 + H2[2 * u3 + 1],
                    bondOrder: j2.bondOrderList[u3]
                  });
                }
                y3 += 1;
              }
              h3 += 1;
            }
            if (p3 = U2 + 1, U2 = m3 - 1, g3 && S2) for (u3 = 0, s3 = S2.length; s3 > u3; u3 += 2) {
              var W2 = S2[u3], X2 = S2[u3 + 1];
              (W2 >= p3 && U2 >= W2 || X2 >= p3 && U2 >= X2) && g3({
                atomIndex1: W2,
                atomIndex2: X2,
                bondOrder: E3 ? E3[u3 / 2] : null
              });
            }
            L2 += 1;
          }
        }
        function Q(r3) {
          return o2(R(r3));
        }
        function Y(r3, t3) {
          r3 instanceof ArrayBuffer && (r3 = new Uint8Array(r3));
          var n2;
          return n2 = r3 instanceof Uint8Array ? H(r3) : r3, X(n2, t3);
        }
        function Z(r3, t3, n2, e3) {
          function i3() {
            try {
              var r4 = Y(o3.response);
              n2(r4);
            } catch (t4) {
              e3(t4);
            }
          }
          var o3 = new XMLHttpRequest();
          o3.addEventListener("load", i3, true), o3.addEventListener("error", e3, true), o3.responseType = "arraybuffer", o3.open("GET", t3 + r3.toUpperCase()), o3.send();
        }
        function $(r3, t3, n2) {
          Z(r3, or, t3, n2);
        }
        function _(r3, t3, n2) {
          Z(r3, ar, t3, n2);
        }
        var rr = ["mmtfVersion", "mmtfProducer", "unitCell", "spaceGroup", "structureId", "title", "depositionDate", "releaseDate", "experimentalMethods", "resolution", "rFree", "rWork", "bioAssemblyList", "ncsOperatorList", "entityList", "groupList", "numBonds", "numAtoms", "numGroups", "numChains", "numModels", "groupsPerChain", "chainsPerModel"], tr = ["xCoordList", "yCoordList", "zCoordList", "groupIdList", "groupTypeList", "chainIdList", "bFactorList", "atomIdList", "altLocList", "occupancyList", "secStructList", "insCodeList", "sequenceIndexList", "chainNameList", "bondAtomList", "bondOrderList"], nr = rr.concat(tr), er = "v1.1.0dev", ir = "//mmtf.rcsb.org/v1.0/", or = ir + "full/", ar = ir + "reduced/";
        r2.encode = Q, r2.decode = Y, r2.traverse = K, r2.fetch = $, r2.fetchReduced = _, r2.version = er, r2.fetchUrl = or, r2.fetchReducedUrl = ar, r2.encodeMsgpack = o2, r2.encodeMmtf = R, r2.decodeMsgpack = H, r2.decodeMmtf = X;
      });
    }
  )
  /******/
};
var __webpack_module_cache__ = {};
function __webpack_require__(moduleId) {
  var cachedModule = __webpack_module_cache__[moduleId];
  if (cachedModule !== void 0) {
    return cachedModule.exports;
  }
  var module = __webpack_module_cache__[moduleId] = {
    /******/
    // no module.id needed
    /******/
    // no module.loaded needed
    /******/
    exports: {}
    /******/
  };
  __webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);
  return module.exports;
}
(() => {
  __webpack_require__.n = (module) => {
    var getter = module && module.__esModule ? (
      /******/
      () => module["default"]
    ) : (
      /******/
      () => module
    );
    __webpack_require__.d(getter, { a: getter });
    return getter;
  };
})();
(() => {
  __webpack_require__.d = (exports, definition) => {
    for (var key in definition) {
      if (__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
        Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
      }
    }
  };
})();
(() => {
  __webpack_require__.o = (obj, prop) => Object.prototype.hasOwnProperty.call(obj, prop);
})();
var __webpack_exports__ = {};
__webpack_require__.d(__webpack_exports__, {
  A: () => (
    /* binding */
    src
  )
});
var x = (y2) => {
  var x3 = {};
  __webpack_require__.d(x3, y2);
  return x3;
};
var external_module_lodash_commonjs_lodash_commonjs2_lodash_amd_lodash_root_namespaceObject = x({ ["default"]: () => __WEBPACK_EXTERNAL_MODULE_lodash__["default"] });
var external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject = three_module_exports;
var __assign = function() {
  __assign = Object.assign || function(t2) {
    for (var s2, i2 = 1, n = arguments.length; i2 < n; i2++) {
      s2 = arguments[i2];
      for (var p2 in s2) if (Object.prototype.hasOwnProperty.call(s2, p2)) t2[p2] = s2[p2];
    }
    return t2;
  };
  return __assign.apply(this, arguments);
};
var defaults = {
  lines: 12,
  length: 7,
  width: 5,
  radius: 10,
  scale: 1,
  corners: 1,
  color: "#000",
  fadeColor: "transparent",
  animation: "spinner-line-fade-default",
  rotate: 0,
  direction: 1,
  speed: 1,
  zIndex: 2e9,
  className: "spinner",
  top: "50%",
  left: "50%",
  shadow: "0 0 1px transparent",
  // prevent aliased lines
  position: "absolute"
};
var Spinner = (
  /** @class */
  function() {
    function Spinner2(opts) {
      if (opts === void 0) {
        opts = {};
      }
      this.opts = __assign(__assign({}, defaults), opts);
    }
    Spinner2.prototype.spin = function(target) {
      this.stop();
      this.el = document.createElement("div");
      this.el.className = this.opts.className;
      this.el.setAttribute("role", "progressbar");
      this.el.style.position = this.opts.position;
      this.el.style.width = "0";
      this.el.style.zIndex = this.opts.zIndex.toString();
      this.el.style.left = this.opts.left;
      this.el.style.top = this.opts.top;
      this.el.style.transform = "scale(".concat(this.opts.scale, ")");
      if (target) {
        target.insertBefore(this.el, target.firstChild || null);
      }
      drawLines(this.el, this.opts);
      return this;
    };
    Spinner2.prototype.stop = function() {
      if (this.el) {
        if (this.el.parentNode) {
          this.el.parentNode.removeChild(this.el);
        }
        this.el = void 0;
      }
      return this;
    };
    return Spinner2;
  }()
);
function getColor(color, idx) {
  return typeof color == "string" ? color : color[idx % color.length];
}
function drawLines(el, opts) {
  var borderRadius = Math.round(opts.corners * opts.width * 500) / 1e3 + "px";
  var shadow = "none";
  if (opts.shadow === true) {
    shadow = "0 2px 4px #000";
  } else if (typeof opts.shadow === "string") {
    shadow = opts.shadow;
  }
  var shadows = parseBoxShadow(shadow);
  for (var i2 = 0; i2 < opts.lines; i2++) {
    var degrees = ~~(360 / opts.lines * i2 + opts.rotate);
    var backgroundLine = document.createElement("div");
    backgroundLine.style.position = "absolute";
    backgroundLine.style.top = "".concat(-opts.width / 2, "px");
    backgroundLine.style.width = opts.length + opts.width + "px";
    backgroundLine.style.height = opts.width + "px";
    backgroundLine.style.background = getColor(opts.fadeColor, i2);
    backgroundLine.style.borderRadius = borderRadius;
    backgroundLine.style.transformOrigin = "left";
    backgroundLine.style.transform = "rotate(".concat(degrees, "deg) translateX(").concat(opts.radius, "px)");
    var delay = i2 * opts.direction / opts.lines / opts.speed;
    delay -= 1 / opts.speed;
    var line = document.createElement("div");
    line.style.width = "100%";
    line.style.height = "100%";
    line.style.background = getColor(opts.color, i2);
    line.style.borderRadius = borderRadius;
    line.style.boxShadow = normalizeShadow(shadows, degrees);
    line.style.animation = "".concat(1 / opts.speed, "s linear ").concat(delay, "s infinite ").concat(opts.animation);
    backgroundLine.appendChild(line);
    el.appendChild(backgroundLine);
  }
}
function parseBoxShadow(boxShadow) {
  var regex = /^\s*([a-zA-Z]+\s+)?(-?\d+(\.\d+)?)([a-zA-Z]*)\s+(-?\d+(\.\d+)?)([a-zA-Z]*)(.*)$/;
  var shadows = [];
  for (var _i = 0, _a = boxShadow.split(","); _i < _a.length; _i++) {
    var shadow = _a[_i];
    var matches = shadow.match(regex);
    if (matches === null) {
      continue;
    }
    var x3 = +matches[2];
    var y2 = +matches[5];
    var xUnits = matches[4];
    var yUnits = matches[7];
    if (x3 === 0 && !xUnits) {
      xUnits = yUnits;
    }
    if (y2 === 0 && !yUnits) {
      yUnits = xUnits;
    }
    if (xUnits !== yUnits) {
      continue;
    }
    shadows.push({
      prefix: matches[1] || "",
      // could have value of 'inset' or undefined
      x: x3,
      y: y2,
      xUnits,
      yUnits,
      end: matches[8]
    });
  }
  return shadows;
}
function normalizeShadow(shadows, degrees) {
  var normalized = [];
  for (var _i = 0, shadows_1 = shadows; _i < shadows_1.length; _i++) {
    var shadow = shadows_1[_i];
    var xy = convertOffset(shadow.x, shadow.y, degrees);
    normalized.push(shadow.prefix + xy[0] + shadow.xUnits + " " + xy[1] + shadow.yUnits + shadow.end);
  }
  return normalized.join(", ");
}
function convertOffset(x3, y2, degrees) {
  var radians = degrees * Math.PI / 180;
  var sin = Math.sin(radians);
  var cos = Math.cos(radians);
  return [Math.round((x3 * cos + y2 * sin) * 1e3) / 1e3, Math.round((-x3 * sin + y2 * cos) * 1e3) / 1e3];
}
var Timer = class _Timer {
  constructor() {
    this.startTime = 0;
    this.oldTime = 0;
    this.elapsedTime = 0;
    this.running = false;
  }
  start() {
    this.startTime = _Timer.now();
    this.oldTime = this.startTime;
    this.running = true;
  }
  stop() {
    this.getElapsedTime();
    this.running = false;
  }
  getElapsedTime() {
    this.update();
    return this.elapsedTime;
  }
  update() {
    let delta = 0;
    if (this.running) {
      const newTime = _Timer.now();
      delta = 1e-3 * (newTime - this.oldTime);
      this.oldTime = newTime;
      this.elapsedTime += delta;
    }
    return delta;
  }
};
Timer.now = function() {
  const p2 = typeof window !== "undefined" && window.performance;
  return p2 && p2.now ? p2.now.bind(p2) : Date.now;
}();
var {
  now: now2
} = Timer;
function createElement(tag, id2, css) {
  const element = document.createElement(tag);
  element.id = id2;
  element.style.cssText = css;
  return element;
}
var Stats = class {
  constructor() {
    this.domElement = createElement("div", "stats", "padding:8px");
    this._text = createElement("p", "fps", "margin:0;color:silver;font-size:large");
    this.domElement.appendChild(this._text);
    this._startTime = now2();
    this._prevTime = this._startTime;
    this._deltas = new Array(20);
    this._index = 0;
    this._total = 0;
    this._count = 0;
  }
  end() {
    const time = now2();
    const delta = time - this._startTime;
    if (this._count < this._deltas.length) {
      this._count++;
    } else {
      this._total -= this._deltas[this._index];
    }
    this._total += delta;
    this._deltas[this._index] = delta;
    this._index = (this._index + 1) % this._deltas.length;
    this.ms = this._total / this._count;
    this.fps = 1e3 / this.ms;
    if (time > this._prevTime + 1e3) {
      this._text.textContent = this.fps.toPrecision(2);
      this._prevTime = time;
    }
    return time;
  }
  update() {
    this._startTime = this.end();
  }
  show(on) {
    if (on === void 0) {
      on = true;
    }
    this.domElement.style.display = on ? "block" : "none";
  }
};
var gfx_Stats = Stats;
function isUndefOrEqual(param, value) {
  return !param || param === value;
}
function EventDispatcher2() {
  this._handlers = {};
}
EventDispatcher2.prototype.addEventListener = function(type, callback, context) {
  let handlers = this._handlers[type];
  if (!handlers) {
    this._handlers[type] = [];
    handlers = this._handlers[type];
  }
  const params = [callback, context];
  function _checkPar(par) {
    return par[0] === params[0] && par[1] === params[1];
  }
  if (external_module_lodash_commonjs_lodash_commonjs2_lodash_amd_lodash_root_namespaceObject["default"].find(handlers, _checkPar) === void 0) {
    handlers.push(params);
  }
};
EventDispatcher2.prototype.removeEventListener = function(type, callback, context) {
  const self2 = this;
  external_module_lodash_commonjs_lodash_commonjs2_lodash_amd_lodash_root_namespaceObject["default"].forEach(self2._handlers, (handler, ev) => {
    external_module_lodash_commonjs_lodash_commonjs2_lodash_amd_lodash_root_namespaceObject["default"].remove(handler, (values) => isUndefOrEqual(type, ev) && isUndefOrEqual(callback, values[0]) && isUndefOrEqual(context, values[1] || self2));
  });
  this._handlers = external_module_lodash_commonjs_lodash_commonjs2_lodash_amd_lodash_root_namespaceObject["default"].omitBy(self2._handlers, (handler) => handler.length === 0);
};
EventDispatcher2.prototype.dispatchEvent = function(event) {
  const self2 = this;
  external_module_lodash_commonjs_lodash_commonjs2_lodash_amd_lodash_root_namespaceObject["default"].forEach(this._handlers[event.type], (callback) => {
    const context = callback[1] || self2;
    callback[0].apply(context, [event]);
  });
};
var utils_EventDispatcher = EventDispatcher2;
var priorities = {
  debug: 0,
  info: 1,
  report: 2,
  warn: 3,
  error: 4
};
function Logger() {
  utils_EventDispatcher.call(this);
  this.console = false;
  this._priority = priorities.warn;
}
Logger.prototype = Object.create(utils_EventDispatcher.prototype);
Logger.prototype.constructor = Logger;
Logger.prototype.instantiate = function() {
  return new Logger();
};
function verify(number) {
  if (!external_module_lodash_commonjs_lodash_commonjs2_lodash_amd_lodash_root_namespaceObject["default"].isNumber(number)) {
    throw new Error("Wrong log level specified!");
  }
  return number;
}
Object.defineProperty(Logger.prototype, "level", {
  get() {
    return external_module_lodash_commonjs_lodash_commonjs2_lodash_amd_lodash_root_namespaceObject["default"].findKey(priorities, (value) => value === this._priority);
  },
  set(level) {
    this._priority = verify(priorities[level]);
  }
});
Logger.prototype.levels = function() {
  return Object.keys(priorities);
};
Logger.prototype.message = function(level, message) {
  const priority = verify(priorities[level]);
  this._message(priority, message);
};
Logger.prototype.debug = function(message) {
  this._message(priorities.debug, message);
};
Logger.prototype.info = function(message) {
  this._message(priorities.info, message);
};
Logger.prototype.report = function(message) {
  this._message(priorities.report, message);
};
Logger.prototype.warn = function(message) {
  this._message(priorities.warn, message);
};
Logger.prototype.error = function(message) {
  this._message(priorities.error, message);
};
Logger.prototype._message = function(priority, message) {
  if (priority < this._priority) {
    return;
  }
  const level = external_module_lodash_commonjs_lodash_commonjs2_lodash_amd_lodash_root_namespaceObject["default"].findKey(priorities, (value) => value === priority);
  message = String(message);
  if (this.console) {
    const output = `miew:${level}: ${message}`;
    if (level === "error") {
      console.error(output);
    } else if (level === "warn") {
      console.warn(output);
    } else {
      console.log(output);
    }
  }
  this.dispatchEvent({
    type: "message",
    level,
    message
  });
};
var logger = new Logger();
var browserType = {
  DEFAULT: 0,
  SAFARI: 1
};
function encodeQueryComponent(text, excludeExp) {
  const encode = (code) => String.fromCharCode(parseInt(code.substr(1), 16));
  return encodeURIComponent(text).replace(excludeExp, encode).replace(/%20/g, "+");
}
function decodeQueryComponent(text) {
  return decodeURIComponent(text.replace(/\+/g, " "));
}
function getUrlParameters(url) {
  url = url || window.location.search;
  const query = url.substring(url.indexOf("?") + 1);
  const search = /([^&=]+)=?([^&]*)/g;
  const result = [];
  let match;
  while ((match = search.exec(query)) !== null) {
    result.push([decodeQueryComponent(match[1]), decodeQueryComponent(match[2])]);
  }
  return result;
}
function getUrlParametersAsDict(url) {
  const result = {};
  const a2 = getUrlParameters(url);
  for (let i2 = 0; i2 < a2.length; ++i2) {
    const [key, value] = a2[i2];
    result[key] = value;
  }
  return result;
}
function resolveURL(str) {
  if (typeof URL !== "undefined") {
    try {
      if (typeof window !== "undefined") {
        return new URL(str, window.location).href;
      }
      return new URL(str).href;
    } catch (error) {
    }
  }
  if (typeof document !== "undefined") {
    const anchor = document.createElement("a");
    anchor.href = str;
    return anchor.href;
  }
  return str;
}
function generateRegExp(symbolStr) {
  const symbolList = [];
  for (let i2 = 0, n = symbolStr.length; i2 < n; ++i2) {
    symbolList[symbolList.length] = symbolStr[i2].charCodeAt(0).toString(16);
  }
  const listStr = symbolList.join("|");
  return new RegExp(`%(?:${listStr})`, "gi");
}
function utils_createElement(tag, attrs, content) {
  const element = document.createElement(tag);
  let i2;
  let n;
  if (attrs) {
    const keys = Object.keys(attrs);
    for (i2 = 0, n = keys.length; i2 < n; ++i2) {
      const key = keys[i2];
      element.setAttribute(key, attrs[key]);
    }
  }
  if (content) {
    if (!(content instanceof Array)) {
      content = [content];
    }
    for (i2 = 0, n = content.length; i2 < n; ++i2) {
      const child = content[i2];
      if (typeof child === "string") {
        element.appendChild(document.createTextNode(child));
      } else if (child instanceof HTMLElement) {
        element.appendChild(child);
      }
    }
  }
  return element;
}
function deriveClass(cls, base, members, statics) {
  cls.prototype = external_module_lodash_commonjs_lodash_commonjs2_lodash_amd_lodash_root_namespaceObject["default"].assign(Object.create(base.prototype), {
    constructor: cls
  }, members);
  if (statics) {
    external_module_lodash_commonjs_lodash_commonjs2_lodash_amd_lodash_root_namespaceObject["default"].assign(cls, statics);
  }
  return cls;
}
function deriveDeep(obj, needZeroOwnProperties) {
  let res = obj;
  let i2;
  let n;
  if (obj instanceof Array) {
    res = new Array(obj.length);
    for (i2 = 0, n = obj.length; i2 < n; ++i2) {
      res[i2] = deriveDeep(obj[i2]);
    }
  } else if (obj instanceof Object) {
    res = Object.create(obj);
    const keys = Object.keys(obj);
    for (i2 = 0, n = keys.length; i2 < n; ++i2) {
      const key = keys[i2];
      const value = obj[key];
      const copy = deriveDeep(value);
      if (copy !== value) {
        res[key] = copy;
      }
    }
    if (needZeroOwnProperties && Object.keys(res).length > 0) {
      res = Object.create(res);
    }
  }
  return res;
}
function hexColor(color) {
  const hex = `0000000${color.toString(16)}`.substr(-6);
  return `#${hex}`;
}
function DebugTracer(namespace) {
  let enabled = false;
  this.enable = function(on) {
    enabled = on;
  };
  let indent = 0;
  const methods = Object.keys(namespace);
  function wrap(method_, name_) {
    return function() {
      const spaces = DebugTracer.spaces.substr(0, indent * 2);
      if (enabled) {
        logger.debug(`${spaces + name_} {`);
      }
      indent++;
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      const result = method_.apply(this, args);
      indent--;
      if (enabled) {
        logger.debug(`${spaces}} // ${name_}`);
      }
      return result;
    };
  }
  for (let i2 = 0, n = methods.length; i2 < n; ++i2) {
    const name = methods[i2];
    const method = namespace[name];
    if (method instanceof Function && name !== "constructor") {
      namespace[name] = wrap(method, name);
    }
  }
}
DebugTracer.spaces = "                                                                                          ";
var OutOfMemoryError = class extends Error {
  constructor(message) {
    super();
    this.name = "OutOfMemoryError";
    this.message = message;
  }
};
function allocateTyped(TypedArrayName, size) {
  let result = null;
  try {
    result = new TypedArrayName(size);
  } catch (e2) {
    if (e2 instanceof RangeError) {
      throw new OutOfMemoryError(e2.message);
    } else {
      throw e2;
    }
  }
  return result;
}
function bytesToBase64(buffer) {
  const bytes = new Uint8Array(buffer);
  let binary = "";
  for (let i2 = 0; i2 < bytes.byteLength; i2++) {
    binary += String.fromCharCode(bytes[i2]);
  }
  return window.btoa(binary);
}
function bytesFromBase64(str) {
  const binary = window.atob(str);
  const bytes = new Uint8Array(binary.length);
  for (let i2 = 0; i2 < bytes.length; ++i2) {
    bytes[i2] = binary[i2].charCodeAt(0);
  }
  return bytes.buffer;
}
function arrayToBase64(array, TypedArrayClass) {
  return bytesToBase64(new TypedArrayClass(array).buffer);
}
function arrayFromBase64(str, TypedArrayClass) {
  return Array.prototype.slice.call(new TypedArrayClass(bytesFromBase64(str)));
}
function compareOptionsWithDefaults(opts, defOpts) {
  const optsStr = [];
  if (defOpts && opts) {
    const keys = Object.keys(opts);
    for (let p2 = 0; p2 < keys.length; ++p2) {
      const key = keys[p2];
      const value = opts[key];
      if (!(value instanceof Object) && typeof defOpts[key] !== "undefined" && defOpts[key] !== value) {
        optsStr.push(`${key}:${value}`);
      }
    }
    if (optsStr.length > 0) {
      return `!${optsStr.join()}`;
    }
  }
  return "";
}
function isAlmostPlainObject(o2) {
  if (external_module_lodash_commonjs_lodash_commonjs2_lodash_amd_lodash_root_namespaceObject["default"].isPlainObject(o2)) {
    return true;
  }
  const proto = o2 && Object.getPrototypeOf(o2);
  return !!proto && !proto.hasOwnProperty("constructor") && isAlmostPlainObject(proto);
}
function objectsDiff(src2, dst) {
  const diff = {};
  external_module_lodash_commonjs_lodash_commonjs2_lodash_amd_lodash_root_namespaceObject["default"].forIn(src2, (srcValue, key) => {
    const dstValue = dst[key];
    if (isAlmostPlainObject(srcValue) && isAlmostPlainObject(dstValue)) {
      const deepDiff = objectsDiff(srcValue, dstValue);
      if (!external_module_lodash_commonjs_lodash_commonjs2_lodash_amd_lodash_root_namespaceObject["default"].isEmpty(deepDiff)) {
        diff[key] = deepDiff;
      }
    } else if (!external_module_lodash_commonjs_lodash_commonjs2_lodash_amd_lodash_root_namespaceObject["default"].isEqual(srcValue, dstValue)) {
      diff[key] = srcValue;
    }
  });
  return diff;
}
function forInRecursive(object, callback) {
  function iterateThrough(obj, prefix) {
    external_module_lodash_commonjs_lodash_commonjs2_lodash_amd_lodash_root_namespaceObject["default"].forIn(obj, (value, key) => {
      const newPref = prefix + (prefix.length > 0 ? "." : "");
      if (value instanceof Object) {
        iterateThrough(value, newPref + key);
      } else if (value !== void 0) {
        callback(value, newPref + key);
      }
    });
  }
  iterateThrough(object, "");
}
function enquoteString(value) {
  if (external_module_lodash_commonjs_lodash_commonjs2_lodash_amd_lodash_root_namespaceObject["default"].isString(value)) {
    return `"${value.replace(/"/g, '\\"')}"`;
  }
  return value;
}
function unquoteString(value) {
  if (!external_module_lodash_commonjs_lodash_commonjs2_lodash_amd_lodash_root_namespaceObject["default"].isString(value)) {
    return value;
  }
  if (value[0] === '"' && value[value.length - 1] === '"') {
    value = value.slice(1, value.length - 1);
    return value.replace(/\\"/g, '"');
  }
  if (value[0] === "'" && value[value.length - 1] === "'") {
    value = value.slice(1, value.length - 1);
    return value.replace(/\\'/g, "'");
  }
  throw new SyntaxError("Incorrect string format, can't unqute it");
}
function getFileExtension(fileName) {
  return fileName.slice(Math.max(0, fileName.lastIndexOf(".")) || Infinity);
}
function splitFileName(fileName) {
  const ext = getFileExtension(fileName);
  const name = fileName.slice(0, fileName.length - ext.length);
  return [name, ext];
}
function dataUrlToBlob(url) {
  const parts = url.split(/[:;,]/);
  const partsCount = parts.length;
  if (partsCount >= 3 && parts[partsCount - 2] === "base64") {
    return new Blob([bytesFromBase64(parts[partsCount - 1])]);
  }
  return null;
}
function getBrowser() {
  if (navigator.vendor && navigator.vendor.indexOf("Apple") > -1 && navigator.userAgent && navigator.userAgent.indexOf("CriOS") === -1 && navigator.userAgent.indexOf("FxiOS") === -1) {
    return browserType.SAFARI;
  }
  return browserType.DEFAULT;
}
function shotOpen(url) {
  if (typeof window !== "undefined") {
    window.open().document.write(`<body style="margin:0"><img src="${url}" /></body>`);
  }
}
function shotDownload(dataUrl, filename) {
  if (!dataUrl || dataUrl.substr(0, 5) !== "data:") {
    return;
  }
  if (!filename) {
    filename = ["screenshot-", +/* @__PURE__ */ new Date(), ".png"].join("");
  }
  if (typeof window !== "undefined" && window.navigator && window.navigator.msSaveBlob) {
    window.navigator.msSaveBlob(dataUrlToBlob(dataUrl), filename);
  } else if (typeof document !== "undefined") {
    const link = document.createElement("a");
    link.download = filename;
    link.innerHTML = "download";
    link.href = window.URL.createObjectURL(dataUrlToBlob(dataUrl));
    document.body.appendChild(link);
    link.click();
    document.body.removeChild(link);
  }
}
function download(data, filename, type) {
  const blobData = new Blob([data]);
  if (!filename) {
    filename = ["data", +/* @__PURE__ */ new Date()].join("");
  }
  if (!type) {
    filename += blobData.type || ".bin";
  } else {
    filename += `.${type}`;
  }
  if (typeof window !== "undefined" && window.navigator && window.navigator.msSaveBlob) {
    window.navigator.msSaveBlob(blobData, filename);
  } else if (typeof document !== "undefined") {
    const link = document.createElement("a");
    link.download = filename;
    link.innerHTML = "download";
    link.href = window.URL.createObjectURL(blobData);
    document.body.appendChild(link);
    link.click();
    document.body.removeChild(link);
  }
}
function copySubArrays(src2, dst, indices, itemSize) {
  for (let i2 = 0, n = indices.length; i2 < n; ++i2) {
    for (let j = 0; j < itemSize; ++j) {
      dst[i2 * itemSize + j] = src2[indices[i2] * itemSize + j];
    }
  }
}
function shallowCloneNode(node) {
  const newNode = node.cloneNode(true);
  newNode.worldPos = node.worldPos;
  return newNode;
}
var unquotedStringRE = /^[a-zA-Z0-9_]*$/;
var enquoteHelper = ['"', "", '"'];
function correctSelectorIdentifier(value) {
  if (unquotedStringRE.test(value)) {
    return value;
  }
  enquoteHelper[1] = value;
  return enquoteHelper.join("");
}
function concatTypedArraysUnsafe(first, second) {
  const result = new first.constructor(first.length + second.length);
  result.set(first);
  result.set(second, first.length);
  return result;
}
function mergeTypedArraysUnsafe(array) {
  if (array.length <= 0) {
    return null;
  }
  const size = array.reduce((acc, cur) => acc + cur.length, 0);
  const result = new array[0].constructor(size);
  for (let i2 = 0, start = 0; i2 < array.length; i2++) {
    const count = array[i2].length;
    result.set(array[i2], start);
    start += count;
  }
  return result;
}
var utils = {
  browserType,
  encodeQueryComponent,
  decodeQueryComponent,
  getUrlParameters,
  getUrlParametersAsDict,
  resolveURL,
  generateRegExp,
  createElement: utils_createElement,
  deriveClass,
  deriveDeep,
  hexColor,
  DebugTracer,
  OutOfMemoryError,
  allocateTyped,
  bytesFromBase64,
  bytesToBase64,
  arrayFromBase64,
  arrayToBase64,
  compareOptionsWithDefaults,
  objectsDiff,
  forInRecursive,
  enquoteString,
  unquoteString,
  getBrowser,
  shotOpen,
  shotDownload,
  copySubArrays,
  shallowCloneNode,
  correctSelectorIdentifier,
  getFileExtension,
  splitFileName,
  download,
  concatTypedArraysUnsafe,
  mergeTypedArraysUnsafe
};
var JobHandle = class extends utils_EventDispatcher {
  constructor() {
    super();
    this._shouldCancel = false;
  }
  cancel() {
    this._shouldCancel = true;
    this.dispatchEvent({
      type: "cancel"
    });
  }
  shouldCancel() {
    return this._shouldCancel;
  }
  // slaves use this to notify master about their events
  // master routes these notifications to a single event slot
  notify(event) {
    this.dispatchEvent({
      type: "notification",
      slaveEvent: event
    });
  }
};
var VERSION = 0;
var settings_defaults = {
  /**
   * Default options for all available modes.
   * Use {@link Mode.id} as a dictionary key to access mode options.
   *
   * Usually you don't need to override these settings. You may specify mode options as a parameter during
   * {@link Mode} construction.
   *
   * @memberof SettingsObject#
   * @type {Object.<string, object>}
   *
   * @property {LinesModeOptions} LN - Lines mode options.
   * @property {LicoriceModeOptions} LC - Licorice mode options.
   * @property {BallsAndSticksModeOptions} BS - Balls and Sticks mode options.
   * @property {VanDerWaalsModeOptions} VW - Van der Waals mode options.
   * @property {TraceModeOptions} TR - Trace mode options.
   * @property {TubeModeOptions} TU - Tube mode options.
   * @property {CartoonModeOptions} CA - Cartoon mode options.
   * @property {QuickSurfaceModeOptions} QS - Contact Surface mode options.
   * @property {IsoSurfaceSASModeOptions} SA - Solvent Accessible Surface mode options.
   * @property {IsoSurfaceSESModeOptions} SE - Solvent Excluded Surface mode options.
   * @property {ContactSurfaceModeOptions} CS - Contact Surface mode options.
   * @property {TextModeOptions} TX - Text mode options.
   * @property {VolumeDensityModeOptions} VD - Volume Density mode options.
   */
  modes: {
    //----------------------------------------------------------------------------
    // BALLS AND STICKS
    //----------------------------------------------------------------------------
    /**
     * Balls and Sticks mode options.
     *
     * @typedef BallsAndSticksModeOptions
     *
     * @property {number} atom - Sphere radius as a fraction of Van der Waals atom radius.
     * @property {number} bond - Cylinder radius in angstroms.
     * @property {number} space - Fraction of the space around one cylinder. Zero means that cylinder fills all
     *   available space.
     * @property {boolean} multibond - Toggles rendering of multiple ordered bonds.
     * @property {number} aromrad - Minor radius of a torus for aromatic loops.
     * @property {boolean} showarom - Toggles rendering of aromatic loops.
     * @property {PolyComplexity} polyComplexity - Polygonal complexity settings for different resolutions.
     */
    BS: {
      atom: 0.23,
      bond: 0.15,
      space: 0.5,
      multibond: true,
      aromrad: 0.1,
      showarom: true,
      polyComplexity: {
        poor: 3,
        low: 4,
        medium: 6,
        high: 12,
        ultra: 32
      }
    },
    //----------------------------------------------------------------------------
    // VAN DER WAALS
    //----------------------------------------------------------------------------
    /**
     * Van der Waals mode options.
     *
     * @typedef VanDerWaalsModeOptions
     *
     * @property {PolyComplexity} polyComplexity - Polygonal complexity settings for different resolutions.
     */
    VW: {
      polyComplexity: {
        poor: 4,
        low: 6,
        medium: 8,
        high: 16,
        ultra: 32
      }
    },
    //----------------------------------------------------------------------------
    // LINES
    //----------------------------------------------------------------------------
    /**
     * Lines mode options.
     *
     * @typedef LinesModeOptions
     *
     * @property {boolean} multibond - Flag, that toggles rendering of multiple ordered bonds.
     * @property {boolean} showarom - Flag, that toggles rendering of aromatic loops.
     * @property {number} offsarom - Offset between bonds and aromatic cycle.
     * @property {number} chunkarom - Number of pieces in a-loop arc, corresponding to atom.
     * @property {number} atom - Collision radius for atoms picking.
     * @property {number} lineWidth - Line width in pixels (not used in thin lines).
     */
    LN: {
      multibond: true,
      showarom: true,
      offsarom: 0.2,
      chunkarom: 10,
      atom: 0.23,
      lineWidth: 2
    },
    //----------------------------------------------------------------------------
    // LICORICE
    //----------------------------------------------------------------------------
    /**
     * Licorice mode options.
     *
     * @typedef LicoriceModeOptions
     *
     * @property {number} bond - Bond cylinder radius.
     * @property {number} space - Fraction of the space around one cylinder. Zero means that cylinder fills all
     *   available space.
     * @property {boolean} multibond - Flag, that toggles rendering of multiple ordered bonds.
     * @property {number} aromrad - Minor radius of a torus for aromatic loops.
     * @property {boolean} showarom - Flag, that toggles rendering of aromatic loops.
     * @property {PolyComplexity} polyComplexity - Poly complexity values for render modes.
     */
    LC: {
      bond: 0.2,
      space: 0,
      multibond: true,
      aromrad: 0.1,
      showarom: true,
      polyComplexity: {
        poor: 3,
        low: 4,
        medium: 6,
        high: 12,
        ultra: 32
      }
    },
    //----------------------------------------------------------------------------
    // SURFACE SAS
    //----------------------------------------------------------------------------
    /**
     * Solvent Accessible Surface mode options.
     *
     * @typedef IsoSurfaceSASModeOptions
     *
     * @property {boolean} zClip - Flag, that toggles z-clipping.
     * @property {number} probeRadius - Radius of the probe.
     * @property {string} subset - Only parts of surface close to selected atoms will be visible.
     *   Empty string means whole surface is visible.
     * @property {boolean} wireframe - Flag that specifies whether or not surface rendered in wireframe mode.
     * @property {PolyComplexity} polyComplexity - Polygonal complexity settings for different resolutions.
     */
    SA: {
      zClip: false,
      probeRadius: 1.5,
      subset: "",
      wireframe: false,
      polyComplexity: {
        poor: 6,
        low: 8,
        medium: 16,
        high: 30,
        ultra: 60
      }
    },
    //----------------------------------------------------------------------------
    // SURFACE SES
    //----------------------------------------------------------------------------
    /**
     * Solvent Excluded Surface mode options.
     *
     * @typedef IsoSurfaceSESModeOptions
     *
     * @property {boolean} zClip - Flag, that toggles z-clipping.
     * @property {number} probeRadius - Radius of the probe.
     * @property {string} subset - Only parts of surface close to selected atoms will be visible.
     *   Empty string means whole surface is visible.
     * @property {boolean} wireframe - Flag that specifies whether or not surface rendered in wireframe mode.
     * @property {PolyComplexity} polyComplexity - Polygonal complexity settings for different resolutions.
     */
    SE: {
      zClip: false,
      probeRadius: 1.5,
      subset: "",
      wireframe: false,
      polyComplexity: {
        poor: 6,
        low: 8,
        medium: 16,
        high: 30,
        ultra: 60
      }
    },
    //----------------------------------------------------------------------------
    // QUICK SURFACE
    //----------------------------------------------------------------------------
    /**
     * Quick Surface mode options.
     *
     * @typedef QuickSurfaceModeOptions
     *
     * @property {number} isoValue - Isovalue of the surface to extract.
     * @property {number} scale - Radius scale for the surface being built.
     * @property {boolean} zClip - Flag, that toggles z-clipping.
     * @property {string} subset - Only parts of surface close to selected atoms will be visible.
     *   Empty string means whole surface is visible.
     * @property {boolean} wireframe - Flag that specifies whether or not surface rendered in wireframe mode.
     * @property {PolyComplexity} gaussLim - Gauss lim for coloring the bigger the value, the smoother our colors are.
     * @property {PolyComplexity} gridSpacing - Poly complexity values for render modes. In this case the value
     *   corresponds to the grid density.
     */
    QS: {
      isoValue: 0.5,
      gaussLim: {
        poor: 1.5,
        low: 2,
        medium: 2.5,
        high: 3,
        ultra: 4
      },
      scale: 1,
      wireframe: false,
      gridSpacing: {
        poor: 2,
        low: 1.5,
        medium: 1,
        high: 0.5,
        ultra: 0.25
      },
      subset: "",
      zClip: false
    },
    //----------------------------------------------------------------------------
    // CONTACT SURFACE
    //----------------------------------------------------------------------------
    /**
     * Contact Surface mode options.
     *
     * @typedef ContactSurfaceModeOptions
     *
     * @property {number} isoValue - Isovalue of the surface to extract.
     * @property {number} probeRadius - Probe radius.
     * @property {number} probePositions
     * @property {boolean} zClip - Flag, that toggles z-clipping.
     * @property {string} subset - Only parts of surface close to selected atoms will be visible.
     *   Empty string means whole surface is visible.
     * @property {boolean} wireframe - Flag that specifies whether or not surface rendered in wireframe mode.
     * @property {PolyComplexity} polyComplexity - Radius scale for the surface being built.
     *   Poly complexity values for render modes. In this case the value corresponds to the grid density.
     */
    CS: {
      probeRadius: 1.4,
      isoValue: 1.5,
      wireframe: false,
      probePositions: 30,
      polyComplexity: {
        poor: 0.5,
        low: 1,
        medium: 1.5,
        high: 1.75,
        ultra: 2
      },
      subset: "",
      zClip: false
    },
    //----------------------------------------------------------------------------
    // TRACE
    //----------------------------------------------------------------------------
    /**
     * Trace mode options.
     *
     * @typedef TraceModeOptions
     *
     * @property {number} radius - Cylinder radius.
     * @property {PolyComplexity} polyComplexity - Polygonal complexity settings for different resolutions.
     */
    TR: {
      radius: 0.3,
      polyComplexity: {
        poor: 12,
        low: 16,
        medium: 32,
        high: 64,
        ultra: 64
      }
    },
    //----------------------------------------------------------------------------
    // TUBE
    //----------------------------------------------------------------------------
    /**
     * Tube mode options.
     *
     * @typedef TubeModeOptions
     *
     * @property {number} radius - Cylinder radius.
     * @property {number} tension - Tension for interpolation.
     * @property {PolyComplexity} polyComplexity - Polygonal complexity settings for different resolutions.
     * @property {number} heightSegmentsRatio - Poly complexity multiplier for height segments.
     */
    TU: {
      radius: 0.3,
      heightSegmentsRatio: 1.5,
      tension: -0.7,
      polyComplexity: {
        poor: 4,
        low: 6,
        medium: 10,
        high: 18,
        ultra: 34
      }
    },
    //----------------------------------------------------------------------------
    // CARTOON
    //----------------------------------------------------------------------------
    /**
     * Cartoon mode options.
     *
     * @typedef CartoonModeOptions
     *
     * @property {number} radius - Standard tube radius.
     * @property {number} depth - Height of the secondary structure ribbon.
     * @property {number} tension - Tension for interpolation.
     * @proprety {object} ss - Secondary structure parameters.
     * @proprety {object} ss.helix - Options for helices render.
     * @proprety {number} ss.helix.width - Width of the secondary structure ribbon.
     * @proprety {number} ss.helix.arrow - Secondary structure's arrow width.
     * @proprety {object} ss.strand - Options for strands render.
     * @property {PolyComplexity} polyComplexity - Polygonal complexity settings for different resolutions.
     * polyComplexity must be even for producing symmetric arrows.
     * @property {number} heightSegmentsRatio - Poly complexity multiplier for height segments.
     */
    CA: {
      radius: 0.3,
      depth: 0.25,
      ss: {
        helix: {
          width: 1,
          arrow: 2
        },
        strand: {
          width: 1,
          arrow: 2
        }
      },
      heightSegmentsRatio: 1.5,
      tension: -0.7,
      polyComplexity: {
        poor: 4,
        low: 6,
        medium: 10,
        high: 18,
        ultra: 34
      }
    },
    //----------------------------------------------------------------------------
    // TEXT
    //----------------------------------------------------------------------------
    /**
     * Text mode options.
     *
     * @typedef TextModeOptions
     *
     * @property {string} template - Format string for building output text.
     * @property {string} horizontalAlign - Text alignment ('left', 'right', 'center').
     * @property {string} verticalAlign - Vertical text box alignment ('top', 'bottom', 'middle').
     * @property {number} dx - Text offset x in angstroms.
     * @property {number} dy - Text offset y in angstroms.
     * @property {number} dz - Text offset z in angstroms.
     * @property {string} fg - Color rule for foreground.
     * @property {string} bg - Color rule for background.
     * @property {boolean} showBg - Flag, that toggles background rendering.
     *
     */
    TX: {
      template: "{{Chain}}.{{Residue}}{{Sequence}}.{{Name}}",
      horizontalAlign: "center",
      verticalAlign: "middle",
      dx: 0,
      dy: 0,
      dz: 1,
      fg: "none",
      bg: "0x202020",
      showBg: true
    },
    //----------------------------------------------------------------------------
    // VOLUME DENSITY
    //----------------------------------------------------------------------------
    /**
     * Volume density mode options.
     *
     * @typedef VolumeDensityModeOptions
     *
     * @property {number} kSigma - Noise threshold coefficient.
     * @property {boolean} frame - flag, that turns on box frame painting.
     * @property {boolean} isoMode - flag, that turns on IsoSurface mode instead of Volume Rendering.
     * @property {PolyComplexity} polyComplexity - Polygonal complexity settings for different resolutions.
     */
    VD: {
      kSigma: 1,
      kSigmaMed: 2,
      kSigmaMax: 4,
      frame: true,
      isoMode: false,
      polyComplexity: {
        poor: 2,
        low: 3,
        medium: 4,
        high: 8,
        ultra: 10
      }
    }
  },
  /**
   * Default options for all available colorers.
   * Use {@link Colorer.id} as a dictionary key to access colorer options.
   *
   * Usually you don't need to override these settings. You may specify colorer options as a parameter during
   * {@link Colorer} construction.
   *
   * Not all colorers have options.
   *
   * @memberof SettingsObject#
   * @type {Object.<string, object>}
   *
   * @property {ElementColorerOptions} EL - Element colorer options.
   * @property {SequenceColorerOptions} SQ - Sequence colorer options.
   * @property {MoleculeColorerOptions} MO - Molecule colorer options.
   * @property {UniformColorerOptions} UN - Uniform colorer options.
   * @property {ConditionalColorerOptions} CO - Conditional colorer options.
   * @property {TemperatureColorerOptions} TM - Temperature colorer options.
   * @property {OccupancyColorerOptions} OC - Occupancy colorer options.
   * @property {HydrophobicityColorerOptions} HY - Hydrophobicity colorer options.
   */
  colorers: {
    /**
     * Element colorer options.
     *
     * @typedef ElementColorerOptions
     *
     * @property {number} carbon - Carbon color or -1 to use default.
     */
    EL: {
      carbon: -1
    },
    /**
     * Uniform colorer options.
     *
     * @typedef UniformColorerOptions
     *
     * @property {number} color - Single color to paint with.
     */
    UN: {
      color: 16777215
    },
    /**
     * Conditional colorer options.
     *
     * @typedef ConditionalColorerOptions
     *
     * @property {string} subset - Selector string.
     * @property {number} color - Color of selected atoms.
     * @property {number} baseColor - Color of other atoms.
     */
    CO: {
      subset: "charged",
      color: 16711680,
      baseColor: 16777215
    },
    /**
     * Carbon colorer options.
     *
     * @typedef CarbonColorerOptions
     *
     * @property {number} color - Single color to paint carbons
     * @property {number} factor - Color factor for not carbon atoms.
     */
    CB: {
      color: 9474192,
      factor: 0.6
    },
    /**
     * Sequence colorer options.
     *
     * @typedef SequenceColorerOptions
     *
     * @property {string} gradient - Name of gradient to use.
     */
    SQ: {
      gradient: "rainbow"
    },
    /**
     * Temperature colorer options.
     *
     * @typedef TemperatureColorerOptions
     *
     * @property {string} gradient - Name of gradient to use.
     * @property {number} min - Minimal temperature.
     * @property {number} max - Maximal temperature.
     */
    TM: {
      gradient: "temp",
      min: 5,
      max: 40
    },
    /**
     * Occupancy colorer options.
     *
     * @typedef OccupancyColorerOptions
     *
     * @property {string} gradient - Name of gradient to use.
     */
    OC: {
      gradient: "reds"
    },
    /**
     * Hydrophobicity colorer options.
     *
     * @typedef HydrophobicityColorerOptions
     *
     * @property {string} gradient - Name of gradient to use.
     */
    HY: {
      gradient: "blue-red"
    },
    /**
     * Molecule colorer options.
     *
     * @typedef MoleculeColorerOptions
     *
     * @property {string} gradient - Name of gradient to use.
     */
    MO: {
      gradient: "rainbow"
    }
  },
  /*
   * Use antialiasing in WebGL.
   * @type {boolean}
   */
  antialias: true,
  /*
   * Camera field of view in degrees.
   * @type {number}
   */
  camFov: 45,
  /*
   * Camera near plane distance.
   * @type {number}
   */
  camNear: 0.5,
  /*
   * Camera far plane distance.
   * @type {number}
   */
  camFar: 100,
  camDistance: 2.5,
  radiusToFit: 1,
  /**
   * @type {number}
   * @instance
   */
  fogNearFactor: 0.5,
  // [0, 1]
  /**
   * @type {number}
   * @instance
   */
  fogFarFactor: 1,
  // [0, 1]
  fogAlpha: 1,
  fogColor: 0,
  fogColorEnable: false,
  /**
   * Palette used for molecule coloring.
   * @type {string}
   */
  palette: "JM",
  /*
   * Geometry resolution.
   * @type {string}
   */
  resolution: "medium",
  autoResolution: false,
  autoPreset: true,
  preset: "default",
  // TODO: remove 'preset' from settings, implement autodetection
  presets: {
    // Default
    default: [{
      mode: "BS",
      colorer: "EL",
      selector: "all",
      material: "SF"
    }],
    empty: [],
    // Wireframe
    wire: [{
      mode: "LN",
      colorer: "EL",
      selector: "all",
      material: "SF"
    }],
    // Small molecules
    small: [{
      mode: "BS",
      colorer: "EL",
      selector: "all",
      material: "SF"
    }],
    // Proteins, nucleic acids etc.
    macro: [{
      mode: "CA",
      colorer: "SS",
      selector: "not hetatm",
      material: "SF"
    }, {
      mode: "BS",
      colorer: "EL",
      selector: "hetatm and not water",
      material: "SF"
    }]
  },
  objects: {
    line: {
      color: 4294967295,
      dashSize: 0.3,
      gapSize: 0.05
    }
  },
  //----------------------------------------------------------------------------
  bg: {
    color: 2105376,
    transparent: false
  },
  draft: {
    clipPlane: false,
    clipPlaneFactor: 0.5,
    clipPlaneSpeed: 3e-5
  },
  /*
     * Separate group for plugins.
     * Each plugin handles its field by itself.
     */
  plugins: {},
  /**
   * @type {boolean}
   * @instance
   */
  axes: true,
  /**
   * @type {boolean}
   * @instance
   */
  fog: true,
  /**
   * @type {boolean}
   * @instance
   */
  fps: true,
  /**
   * Switch using of z-sprites for sphere and cylinder geometry
   * @type {boolean}
   * @instance
   */
  zSprites: true,
  isoSurfaceFakeOpacity: true,
  /**
   * @type {boolean}
   * @instance
   */
  suspendRender: true,
  nowater: false,
  /**
   * @type {boolean}
   * @instance
   */
  autobuild: true,
  /**
   * Anti-aliasing.
   * @type {boolean}
   * @instance
   */
  fxaa: true,
  /**
   * Outline depths
   * @type {boolean}
   * @instance
   */
  outline: {
    on: false,
    color: 0,
    threshold: 0.1,
    thickness: 1
  },
  /**
   * Ambient Occlusion special effect.
   * @type {boolean}
   * @instance
   */
  ao: false,
  /**
   * Shadows options.
   *
   * @property {boolean} shadowMap - enable/disable.
   * @property {string} basic/percentage-closer filtering/non-uniform randomizing pcf.
   * @property {number} radius for percentage-closer filtering.
   */
  shadow: {
    on: false,
    type: "random",
    radius: 1
  },
  /**
   * Auto-rotation with constant speed.
   * @type {number}
   * @instance
   */
  autoRotation: 0,
  /**
   * Set maximum fps for animation.
   * @type {number}
   * @instance
   */
  maxfps: 30,
  /**
   * Set fbx output precision.
   * @type {number}
   * @instance
   */
  fbxprec: 4,
  /**
   * Auto-rotation axis.
   *
   * - true:  complex auto-rotation is about vertical axis
   * - false: rotation axis is defined by last user rotation
   *
   * @type {boolean}
   * @instance
   */
  autoRotationAxisFixed: true,
  /**
   * Enable zooming with mouse wheel or pinch gesture.
   * @type {boolean}
   * @instance
   */
  zooming: true,
  /**
   * Enable picking atoms & residues with left mouse button or touch.
   * @type {boolean}
   * @instance
   */
  picking: true,
  /**
   * Set picking mode ('atom', 'residue', 'chain', 'molecule').
   * @type {string}
   * @instance
   */
  pick: "atom",
  /**
   * Make "component" and "fragment" editing modes available.
   * @type {boolean}
   * @instance
   */
  editing: false,
  /**
   * Detect aromatic loops.
   * @type {boolean}
   * @instance
   */
  aromatic: false,
  /**
   * Load only one biological unit from all those described in PDB file.
   * @type {boolean}
   * @instance
   */
  singleUnit: true,
  /**
   * Set stereo mode ('NONE', 'SIMPLE', 'DISTORTED', 'ANAGLYPH', 'WEBVR').
   * @type {string}
   * @instance
   */
  stereo: "NONE",
  /**
   * Enable smooth transition between views
   * @type {boolean}
   * @instance
   */
  interpolateViews: true,
  /**
   * Set transparency mode ('standard', 'prepass').
   * @type {string}
   * @instance
   */
  transparency: "prepass",
  /**
   * Mouse translation speed.
   * @type {number}
   * @instance
   */
  translationSpeed: 2,
  debug: {
    example: 3.5,
    text: "hello!",
    good: true,
    ssaoKernelRadius: 0.7,
    ssaoFactor: 0.7,
    stereoBarrel: 0.25
  },
  use: {
    multiFile: false
  }
};
function Settings() {
  utils_EventDispatcher.call(this);
  this.old = null;
  this.now = {};
  this._changed = {};
  this.reset();
}
utils.deriveClass(Settings, utils_EventDispatcher, {
  defaults: settings_defaults,
  set(path, value) {
    if (external_module_lodash_commonjs_lodash_commonjs2_lodash_amd_lodash_root_namespaceObject["default"].isString(path)) {
      const oldValue = external_module_lodash_commonjs_lodash_commonjs2_lodash_amd_lodash_root_namespaceObject["default"].get(this.now, path);
      if (oldValue !== value) {
        external_module_lodash_commonjs_lodash_commonjs2_lodash_amd_lodash_root_namespaceObject["default"].set(this.now, path, value);
        this._notifyChange(path, value);
      }
    } else {
      const diff = utils.objectsDiff(path, this.now);
      if (!external_module_lodash_commonjs_lodash_commonjs2_lodash_amd_lodash_root_namespaceObject["default"].isEmpty(diff)) {
        external_module_lodash_commonjs_lodash_commonjs2_lodash_amd_lodash_root_namespaceObject["default"].merge(this.now, diff);
        this._notifyChanges(diff);
      }
    }
  },
  get(path, defaultValue) {
    return external_module_lodash_commonjs_lodash_commonjs2_lodash_amd_lodash_root_namespaceObject["default"].get(this.now, path, defaultValue);
  },
  reset() {
    const diff = utils.objectsDiff(settings_defaults, this.now);
    this.now = external_module_lodash_commonjs_lodash_commonjs2_lodash_amd_lodash_root_namespaceObject["default"].cloneDeep(settings_defaults);
    this.old = null;
    this._notifyChanges(diff);
    this._changed = {};
  },
  checkpoint() {
    this.old = external_module_lodash_commonjs_lodash_commonjs2_lodash_amd_lodash_root_namespaceObject["default"].cloneDeep(this.now);
    this._changed = {};
  },
  _notifyChange(path, value) {
    this._changed[path] = true;
    this.dispatchEvent({
      type: `change:${path}`,
      value
    });
  },
  _notifyChanges(diff) {
    utils.forInRecursive(diff, (deepValue, deepPath) => {
      this._notifyChange(deepPath, deepValue);
    });
  },
  changed() {
    if (!this.old) {
      return [];
    }
    const {
      old,
      now: now3
    } = this;
    const keys = external_module_lodash_commonjs_lodash_commonjs2_lodash_amd_lodash_root_namespaceObject["default"].filter(Object.keys(this._changed), (key) => external_module_lodash_commonjs_lodash_commonjs2_lodash_amd_lodash_root_namespaceObject["default"].get(old, key) !== external_module_lodash_commonjs_lodash_commonjs2_lodash_amd_lodash_root_namespaceObject["default"].get(now3, key));
    return keys;
  },
  applyDiffs(diffs) {
    if (diffs.hasOwnProperty("VERSION") && diffs.VERSION !== VERSION) {
      throw new Error("Settings version does not match!");
    }
    delete diffs.VERSION;
    this.reset();
    this.set(diffs);
  },
  getDiffs(versioned) {
    const diffs = utils.objectsDiff(this.now, settings_defaults);
    if (versioned) {
      diffs.VERSION = VERSION;
    }
    return diffs;
  },
  setPluginOpts(plugin, opts) {
    settings_defaults.plugins[plugin] = external_module_lodash_commonjs_lodash_commonjs2_lodash_amd_lodash_root_namespaceObject["default"].cloneDeep(opts);
    this.now.plugins[plugin] = external_module_lodash_commonjs_lodash_commonjs2_lodash_amd_lodash_root_namespaceObject["default"].cloneDeep(opts);
  }
});
var settings = new Settings();
var repIndex = 0;
function asBoolean(value) {
  return !(!value || value === "0" || external_module_lodash_commonjs_lodash_commonjs2_lodash_amd_lodash_root_namespaceObject["default"].isString(value) && value.toLowerCase() === "false");
}
var adapters = {
  string: String,
  number: Number,
  boolean: asBoolean
};
var cL1Ass = "=";
var cOptsSep = "!";
var cL2Ass = ":";
var cLSep = ",";
var cCommonIgnoreSymbols = "$;@/?";
function getLevel1ExcludedExpr() {
  const cLevel1Ignores = ":,";
  return utils.generateRegExp(cCommonIgnoreSymbols + cLevel1Ignores);
}
function getLevel2ExcludedExpr() {
  const cLevel2Ignores = " ";
  return utils.generateRegExp(cCommonIgnoreSymbols + cLevel2Ignores);
}
var cL1ExclExpr = getLevel1ExcludedExpr();
function encodeQueryComponentL1(value) {
  return utils.encodeQueryComponent(value, cL1ExclExpr);
}
var cL2ExclExpr = getLevel2ExcludedExpr();
function encodeQueryComponentL2(value) {
  return utils.encodeQueryComponent(value, cL2ExclExpr);
}
function ensureRepList(opts) {
  let {
    reps
  } = opts;
  if (!reps) {
    const {
      presets
    } = settings.now;
    let preset = opts.preset || settings.now.preset;
    reps = presets[preset];
    if (!reps) {
      logger.warn(`Unknown preset "${preset}"`);
      [preset] = Object.keys(presets);
      reps = presets[preset];
    }
    opts.preset = preset;
    opts.reps = utils.deriveDeep(reps, true);
  }
}
function ensureRepAssign(opts, prop, value) {
  ensureRepList(opts);
  const rep = opts.reps[repIndex];
  if (rep.hasOwnProperty(prop)) {
    repIndex = opts.reps.length;
    opts.reps[repIndex] = utils.deriveDeep(rep, true);
  }
  if (value !== void 0) {
    opts.reps[repIndex][prop] = value;
  }
}
function addObject(opts, params, options2) {
  if (opts._objects === void 0) {
    opts._objects = [];
  }
  const [type, newOpts] = options2;
  const newObj = {
    type,
    params
  };
  if (newOpts !== void 0) {
    newObj.opts = newOpts;
  }
  opts._objects[opts._objects.length] = newObj;
}
function parseParams(str, params) {
  const sep = str.indexOf(",");
  if (sep >= 0) {
    params.push(str.substr(sep + 1).split(","));
    return str.substr(0, sep);
  }
  return str;
}
function extractArgs(input, defaultsDict, params) {
  if (input) {
    const bang = input.indexOf(cOptsSep);
    const inputVal = parseParams(input.substr(0, bang >= 0 ? bang : void 0), params);
    if (bang >= 0) {
      const args = input.substr(bang + 1).split(cLSep);
      input = inputVal;
      if (defaultsDict) {
        const defaults2 = defaultsDict[input];
        const opts = utils.deriveDeep(defaults2, true);
        args.forEach((arg) => {
          const pair = arg.split(cL2Ass, 2);
          const key = decodeURIComponent(pair[0]);
          const value = decodeURIComponent(pair[1]);
          const adapter = adapters[typeof external_module_lodash_commonjs_lodash_commonjs2_lodash_amd_lodash_root_namespaceObject["default"].get(defaults2, key)];
          if (adapter) {
            external_module_lodash_commonjs_lodash_commonjs2_lodash_amd_lodash_root_namespaceObject["default"].set(opts, key, adapter(value));
          } else {
            logger.warn(`Unknown argument "${key}" for option "${input}"`);
          }
        });
        if (Object.keys(opts).length > 0) {
          input = [input, opts];
        }
      }
    } else {
      input = inputVal;
    }
  }
  return input;
}
var actions = {
  l: "load",
  load: String,
  t: "type",
  type: String,
  v: "view",
  view: String,
  u: "unit",
  unit: Number,
  menu: asBoolean,
  // Commands
  o: "object",
  object(value, opts) {
    const params = [];
    let options2 = extractArgs(value, settings.defaults.objects, params);
    if (!Array.isArray(options2)) {
      options2 = [options2];
    }
    addObject(opts, params[0], options2);
  },
  p: "preset",
  preset(value, opts) {
    opts.preset = value;
    opts.reps = null;
    ensureRepList(opts);
  },
  r: "rep",
  rep(value, opts) {
    ensureRepList(opts);
    repIndex = Number(value);
    repIndex = repIndex <= opts.reps.length ? repIndex < 0 ? 0 : repIndex : opts.reps.length;
    if (repIndex === opts.reps.length) {
      opts.reps[repIndex] = repIndex > 0 ? utils.deriveDeep(opts.reps[repIndex - 1], true) : utils.deriveDeep(settings.defaults.presets.default[0], true);
    }
  },
  s: "select",
  select(value, opts) {
    ensureRepAssign(opts, "selector", value);
  },
  m: "mode",
  mode(value, opts) {
    ensureRepAssign(opts, "mode", extractArgs(value, settings.defaults.modes));
  },
  c: "color",
  color(value, opts) {
    ensureRepAssign(opts, "colorer", extractArgs(value, settings.defaults.colorers));
  },
  mt: "material",
  material(value, opts) {
    ensureRepAssign(opts, "material", extractArgs(value, settings.defaults.materials));
  },
  dup(value, opts) {
    ensureRepList(opts);
    const {
      reps
    } = opts;
    const rep = reps[repIndex];
    repIndex = reps.length;
    reps[repIndex] = utils.deriveDeep(rep, true);
  },
  // Settings shortcuts
  ar: "autoResolution"
};
function _fromArray(entries) {
  repIndex = 0;
  const opts = {};
  for (let i2 = 0, n = entries.length; i2 < n; ++i2) {
    const entry = entries[i2];
    let key = entry[0];
    const value = entry[1];
    let action = actions[key];
    while (external_module_lodash_commonjs_lodash_commonjs2_lodash_amd_lodash_root_namespaceObject["default"].isString(action)) {
      key = action;
      action = actions[key];
    }
    if (!action) {
      const adapter = adapters[typeof external_module_lodash_commonjs_lodash_commonjs2_lodash_amd_lodash_root_namespaceObject["default"].get(settings.defaults, key)];
      if (adapter) {
        external_module_lodash_commonjs_lodash_commonjs2_lodash_amd_lodash_root_namespaceObject["default"].set(opts, `settings.${key}`, adapter(value));
      } else {
        logger.warn(`Unknown option "${key}"`);
      }
    } else if (external_module_lodash_commonjs_lodash_commonjs2_lodash_amd_lodash_root_namespaceObject["default"].isFunction(action)) {
      const result = action(value, opts);
      if (result !== void 0) {
        opts[key] = result;
      }
    }
  }
  return opts;
}
function fromAttr(attr) {
  return _fromArray(utils.getUrlParameters(`?${attr || ""}`));
}
function fromURL(url) {
  return _fromArray(utils.getUrlParameters(url));
}
function _processOptsForURL(opts) {
  const str = [];
  let i2 = 0;
  utils.forInRecursive(opts, (value, key) => {
    str[i2++] = encodeQueryComponentL2(key) + cL2Ass + encodeQueryComponentL2(value);
  });
  return str.join(cLSep);
}
function _processArgsForURL(args) {
  if (!external_module_lodash_commonjs_lodash_commonjs2_lodash_amd_lodash_root_namespaceObject["default"].isArray(args)) {
    return args;
  }
  if (args.length < 2) {
    return args[0];
  }
  return `${args[0]}${cOptsSep}${_processOptsForURL(args[1])}`;
}
function _processObjForURL(objOpts) {
  if (!objOpts || !objOpts.type) {
    return void 0;
  }
  let res = objOpts.type;
  if (external_module_lodash_commonjs_lodash_commonjs2_lodash_amd_lodash_root_namespaceObject["default"].isArray(objOpts.params) && objOpts.params.length > 0) {
    res += `,${objOpts.params.join(",")}`;
  }
  if (objOpts.opts) {
    res += cOptsSep + _processOptsForURL(objOpts.opts);
  }
  return res;
}
function toURL(opts) {
  const stringList = [];
  let idx = 0;
  function checkAndAdd(prefix, value) {
    if (value !== null && value !== void 0) {
      stringList[idx++] = encodeQueryComponentL1(prefix) + cL1Ass + encodeQueryComponentL1(value);
    }
  }
  function addReps(repList) {
    if (!repList) {
      return;
    }
    for (let i2 = 0, n = repList.length; i2 < n; ++i2) {
      if (external_module_lodash_commonjs_lodash_commonjs2_lodash_amd_lodash_root_namespaceObject["default"].isEmpty(repList[i2])) {
        continue;
      }
      checkAndAdd("r", i2);
      checkAndAdd("s", repList[i2].selector);
      checkAndAdd("m", _processArgsForURL(repList[i2].mode));
      checkAndAdd("c", _processArgsForURL(repList[i2].colorer));
      checkAndAdd("mt", _processArgsForURL(repList[i2].material));
    }
  }
  function addObjects(objList) {
    if (!objList) {
      return;
    }
    for (let i2 = 0, n = objList.length; i2 < n; ++i2) {
      checkAndAdd("o", _processObjForURL(objList[i2]));
    }
  }
  checkAndAdd("l", opts.load);
  checkAndAdd("u", opts.unit);
  checkAndAdd("p", opts.preset);
  addReps(opts.reps);
  addObjects(opts._objects);
  checkAndAdd("v", opts.view);
  utils.forInRecursive(opts.settings, (value, key) => {
    if (key === "preset") {
      return;
    }
    checkAndAdd(key, value);
  });
  let url = "";
  if (typeof window !== "undefined") {
    const {
      location
    } = window;
    url = `${location.protocol}//${location.host}${location.pathname}`;
  }
  if (stringList.length > 0) {
    url += `?${stringList.join("&")}`;
  }
  return url;
}
function _processOptsForScript(opts) {
  const str = [];
  let i2 = 0;
  utils.forInRecursive(opts, (value, key) => {
    str[i2++] = `${key}=${utils.enquoteString(value)}`;
  });
  return str.join(" ");
}
function _processArgsForScript(args) {
  if (!external_module_lodash_commonjs_lodash_commonjs2_lodash_amd_lodash_root_namespaceObject["default"].isArray(args)) {
    return args;
  }
  if (args.length < 2) {
    return args[0];
  }
  return `${args[0]} ${_processOptsForScript(args[1])}`;
}
function _processObjForScript(objOpts) {
  if (!objOpts || !objOpts.type) {
    return void 0;
  }
  let res = objOpts.type;
  if (external_module_lodash_commonjs_lodash_commonjs2_lodash_amd_lodash_root_namespaceObject["default"].isArray(objOpts.params) && objOpts.params.length > 0) {
    res += ` ${objOpts.params.map(utils.enquoteString).join(" ")}`;
  }
  if (objOpts.opts) {
    res += ` ${_processOptsForScript(objOpts.opts)}`;
  }
  return res;
}
function _processRepsForScript(rep, index) {
  const repString = [];
  let strIdx = 0;
  function localAdd(prefix, value) {
    if (value !== null && value !== void 0) {
      repString[strIdx++] = prefix + value;
    }
  }
  if (external_module_lodash_commonjs_lodash_commonjs2_lodash_amd_lodash_root_namespaceObject["default"].isEmpty(rep)) {
    return null;
  }
  localAdd("", index);
  localAdd("s=", utils.enquoteString(rep.selector));
  localAdd("m=", _processArgsForScript(rep.mode));
  localAdd("c=", _processArgsForScript(rep.colorer));
  localAdd("mt=", _processArgsForScript(rep.material));
  return repString.join(" ");
}
function toScript(opts) {
  const commandsList = [];
  let idx = 0;
  function checkAndAdd(command, value, saveQuotes) {
    if (value !== null && value !== void 0) {
      const quote = typeof value === "string" && saveQuotes ? '"' : "";
      commandsList[idx++] = `${command} ${quote}${value}${quote}`.trim();
    }
  }
  function addReps(repList) {
    if (!repList) {
      return;
    }
    for (let i2 = 0, n = repList.length; i2 < n; ++i2) {
      checkAndAdd("rep", _processRepsForScript(repList[i2], i2));
    }
  }
  function addObjects(objList) {
    if (!objList) {
      return;
    }
    for (let i2 = 0, n = objList.length; i2 < n; ++i2) {
      checkAndAdd("", _processObjForScript(objList[i2]));
    }
  }
  checkAndAdd("set", "autobuild false");
  checkAndAdd("load", opts.load, true);
  checkAndAdd("unit", opts.unit);
  checkAndAdd("preset", opts.preset);
  addReps(opts.reps);
  addObjects(opts._objects);
  utils.forInRecursive(opts.settings, (value, key) => {
    if (key === "preset") {
      return;
    }
    checkAndAdd(`set ${key}`, value, true);
  });
  checkAndAdd("view", opts.view);
  checkAndAdd("set", "autobuild true");
  return commandsList.join("\n");
}
var options = {
  fromURL,
  fromAttr,
  adapters,
  toURL,
  toScript
};
var _Atom = class _Atom {
  constructor(residue, name, type, position, role, het, serial, location, occupancy, temperature, charge) {
    this.index = -1;
    this.residue = residue;
    this.name = name;
    this.element = type;
    this.position = position;
    this.role = role;
    this.mask = 1 | 0;
    this.het = het;
    this.serial = serial;
    this.location = (location || " ").charCodeAt(0);
    this.occupancy = occupancy || 1;
    this.temperature = temperature;
    this.charge = charge;
    this.hydrogenCount = -1;
    this.radicalCount = 0;
    this.valence = -1;
    this.bonds = [];
    this.flags = 0;
    if (type.name === "H") {
      this.flags |= _Atom.Flags.HYDROGEN;
    } else if (type.name === "C") {
      this.flags |= _Atom.Flags.CARBON;
    }
  }
  isHet() {
    return this.het;
  }
  isHydrogen() {
    return this.element.number === 1;
  }
  getVisualName() {
    const {
      name
    } = this;
    if (name.length > 0) {
      return name;
    }
    return this.element.name.trim();
  }
  forEachBond(process) {
    const {
      bonds
    } = this;
    for (let i2 = 0, n = bonds.length; i2 < n; ++i2) {
      process(bonds[i2]);
    }
  }
  getFullName() {
    let name = "";
    if (this.residue !== null) {
      if (this.residue._chain !== null) {
        name += `${this.residue._chain.getName()}.`;
      }
      name += `${this.residue._sequence}.`;
    }
    name += this.name;
    return name;
  }
};
/**
 * Enumeration of atom flag values.
 *
 * @enum {number}
 * @readonly
 */
__publicField(_Atom, "Flags", {
  CARBON: 1,
  // OXYGEN: 0x0002,
  // NITROGEN: 0x0004,
  HYDROGEN: 8,
  /** Non-polar hydrogen (it is also a HYDROGEN) */
  NONPOLARH: 4104
});
var Atom = _Atom;
var chem_Atom = Atom;
var _Element = class _Element {
  constructor(number, name, fullName, weight, radius, radiusBonding, hValency) {
    this.number = number;
    this.name = name;
    this.fullName = fullName;
    this.weight = weight;
    this.radius = radius;
    this.radiusBonding = radiusBonding;
    this.hydrogenValency = hValency;
  }
};
__publicField(_Element, "Constants", {
  /* eslint-disable no-magic-numbers */
  U1: 1,
  Lead: 2,
  U2: 3,
  Wing: 4,
  U18: 18
  /* eslint-enable no-magic-numbers */
});
__publicField(_Element, "Role", (() => ({
  /* eslint-disable no-magic-numbers */
  N: _Element.Constants.U1,
  CA: _Element.Constants.Lead,
  C: _Element.Constants.U2,
  O: _Element.Constants.Wing,
  SG: _Element.Constants.U18
  /* eslint-enable no-magic-numbers */
}))());
// DO NOT EDIT MANUALLY! Autogenerated from atom_types.csv by atom_types.py.
__publicField(_Element, "ByAtomicNumber", (() => [
  /* eslint-disable no-magic-numbers */
  null,
  new _Element(1, "H", "Hydrogen", 1.008, 1.2, 0.23, [1]),
  new _Element(2, "HE", "Helium", 4.003, 1.4, 0.93, [0]),
  new _Element(3, "LI", "Lithium", 6.941, 1.82, 0.68, [1]),
  new _Element(4, "BE", "Beryllium", 9.012, 1.7, 0.35, [2]),
  new _Element(5, "B", "Boron", 10.81, 2.08, 0.83, [3]),
  new _Element(6, "C", "Carbon", 12.011, 1.95, 0.68, [4]),
  new _Element(7, "N", "Nitrogen", 14.007, 1.85, 0.68, [3, 5]),
  new _Element(8, "O", "Oxygen", 15.999, 1.7, 0.68, [2, 4]),
  new _Element(9, "F", "Fluorine", 18.998, 1.73, 0.64, [1]),
  new _Element(10, "NE", "Neon", 20.18, 1.54, 1.12, [0]),
  new _Element(11, "NA", "Sodium", 22.99, 2.27, 0.97, [1]),
  new _Element(12, "MG", "Magnesium", 24.305, 1.73, 1.1, [2]),
  new _Element(13, "AL", "Aluminum", 26.981, 2.05, 1.35, [3]),
  new _Element(14, "SI", "Silicon", 28.086, 2.1, 1.2, [4]),
  new _Element(15, "P", "Phosphorus", 30.974, 2.08, 0.75, [3, 5]),
  new _Element(16, "S", "Sulfur", 32.07, 2, 1.02, [2, 4, 6]),
  new _Element(17, "CL", "Chlorine", 35.453, 1.97, 0.99, [1, 3, 5, 7]),
  new _Element(18, "AR", "Argon", 39.948, 1.88, 1.57, [0]),
  new _Element(19, "K", "Potassium", 39.1, 2.75, 1.33, [1]),
  new _Element(20, "CA", "Calcium", 40.08, 1.973, 0.99, [2]),
  new _Element(21, "SC", "Scandium", 44.956, 1.7, 1.44, [0]),
  new _Element(22, "TI", "Titanium", 47.88, 1.7, 1.47, [0]),
  new _Element(23, "V", "Vanadium", 50.941, 1.7, 1.33, [0]),
  new _Element(24, "CR", "Chromium", 52, 1.7, 1.35, [0]),
  new _Element(25, "MN", "Manganese", 54.938, 1.7, 1.35, [0]),
  new _Element(26, "FE", "Iron", 55.847, 1.7, 1.34, [0]),
  new _Element(27, "CO", "Cobalt", 58.93, 1.7, 1.33, [0]),
  new _Element(28, "NI", "Nickel", 58.69, 1.63, 1.5, [0]),
  new _Element(29, "CU", "Copper", 63.55, 1.4, 1.52, [0]),
  new _Element(30, "ZN", "Zinc", 65.39, 1.39, 1.45, [0]),
  new _Element(31, "GA", "Gallium", 69.72, 1.87, 1.22, [3]),
  new _Element(32, "GE", "Germanium", 72.61, 1.7, 1.17, [4]),
  new _Element(33, "AS", "Arsenic", 74.92, 1.85, 1.21, [3, 5]),
  new _Element(34, "SE", "Selenium", 78.96, 1.9, 1.22, [2, 4, 6]),
  new _Element(35, "BR", "Bromine", 79.9, 2.1, 1.21, [1, 3, 5, 7]),
  new _Element(36, "KR", "Krypton", 83.8, 2.02, 1.91, [0]),
  new _Element(37, "RB", "Rubidium", 85.47, 1.7, 1.47, [1]),
  new _Element(38, "SR", "Strontium", 87.62, 1.7, 1.12, [2]),
  new _Element(39, "Y", "Yttrium", 88.91, 1.7, 1.78, [0]),
  new _Element(40, "ZR", "Zirconium", 91.22, 1.7, 1.56, [0]),
  new _Element(41, "NB", "Niobium", 92.91, 1.7, 1.48, [0]),
  new _Element(42, "MO", "Molybdenum", 95.94, 1.7, 1.47, [0]),
  new _Element(43, "TC", "Technetium", 98.91, 1.7, 1.35, [0]),
  new _Element(44, "RU", "Ruthenium", 101.07, 1.7, 1.4, [0]),
  new _Element(45, "RH", "Rhodium", 102.91, 1.7, 1.45, [0]),
  new _Element(46, "PD", "Palladium", 106.42, 1.63, 1.5, [0]),
  new _Element(47, "AG", "Silver", 107.87, 1.72, 1.59, [0]),
  new _Element(48, "CD", "Cadmium", 112.41, 1.58, 1.69, [0]),
  new _Element(49, "IN", "Indium", 114.82, 1.93, 1.63, [3]),
  new _Element(50, "SN", "Tin", 118.71, 2.17, 1.46, [2, 4]),
  new _Element(51, "SB", "Antimony", 121.75, 2.2, 1.46, [3, 5]),
  new _Element(52, "TE", "Tellurium", 127.6, 2.06, 1.47, [2, 4, 6]),
  new _Element(53, "I", "Iodine", 126.91, 2.15, 1.4, [1, 3, 5, 7]),
  new _Element(54, "XE", "Xenon", 131.29, 2.16, 1.98, [0]),
  new _Element(55, "CS", "Cesium", 132.91, 1.7, 1.67, [1]),
  new _Element(56, "BA", "Barium", 137.33, 1.7, 1.34, [2]),
  new _Element(57, "LA", "Lanthanum", 138.91, 1.7, 1.87, [0]),
  new _Element(58, "CE", "Cerium", 140.12, 1.7, 1.83, [0]),
  new _Element(59, "PR", "Praseodymium", 140.91, 1.7, 1.82, [0]),
  new _Element(60, "ND", "Neodymium", 144.24, 1.7, 1.81, [0]),
  new _Element(61, "PM", "Promethium", 144.9, 1.7, 1.8, [0]),
  new _Element(62, "SM", "Samarium", 150.36, 1.7, 1.8, [0]),
  new _Element(63, "EU", "Europium", 151.96, 1.7, 1.99, [0]),
  new _Element(64, "GD", "Gadolinium", 157.25, 1.7, 1.79, [0]),
  new _Element(65, "TB", "Terbium", 158.93, 1.7, 1.76, [0]),
  new _Element(66, "DY", "Dysprosium", 162.5, 1.7, 1.75, [0]),
  new _Element(67, "HO", "Holmium", 164.93, 1.7, 1.74, [0]),
  new _Element(68, "ER", "Erbium", 167.26, 1.7, 1.73, [0]),
  new _Element(69, "TM", "Thulium", 168.93, 1.7, 1.72, [0]),
  new _Element(70, "YB", "Ytterbium", 173.04, 1.7, 1.94, [0]),
  new _Element(71, "LU", "Lutetium", 174.97, 1.7, 1.72, [0]),
  new _Element(72, "HF", "Hafnium", 178.49, 1.7, 1.57, [0]),
  new _Element(73, "TA", "Tantalum", 180.95, 1.7, 1.43, [0]),
  new _Element(74, "W", "Tungsten", 183.85, 1.7, 1.37, [0]),
  new _Element(75, "RE", "Rhenium", 186.21, 1.7, 1.35, [0]),
  new _Element(76, "OS", "Osmium", 190.2, 1.7, 1.37, [0]),
  new _Element(77, "IR", "Iridium", 192.22, 1.7, 1.32, [0]),
  new _Element(78, "PT", "Platinum", 195.08, 1.72, 1.5, [0]),
  new _Element(79, "AU", "Gold", 196.97, 1.66, 1.5, [0]),
  new _Element(80, "HG", "Mercury", 200.59, 1.55, 1.7, [0]),
  new _Element(81, "TL", "Thallium", 204.38, 1.96, 1.55, [1, 3]),
  new _Element(82, "PB", "Lead", 207.2, 2.02, 1.54, [2, 4]),
  new _Element(83, "BI", "Bismuth", 208.98, 1.7, 1.54, [3, 5]),
  new _Element(84, "PO", "Polonium", 210, 1.7, 1.68, [2, 4, 6]),
  new _Element(85, "AT", "Astatine", 210, 1.7, 1.7, [1, 3, 5, 7]),
  new _Element(86, "RN", "Radon", 222, 1.7, 2.4, [0]),
  new _Element(87, "FR", "Francium", 223, 1.7, 2, [1]),
  new _Element(88, "RA", "Radium", 226.03, 1.7, 1.9, [2]),
  new _Element(89, "AC", "Actinium", 227.03, 1.7, 1.88, [0]),
  new _Element(90, "TH", "Thorium", 232.04, 1.7, 1.79, [0]),
  new _Element(91, "PA", "Protactinium", 231.04, 1.7, 1.61, [0]),
  new _Element(92, "U", "Uranium", 238.03, 1.86, 1.58, [0]),
  new _Element(93, "NP", "Neptunium", 237.05, 1.7, 1.55, [0]),
  new _Element(94, "PU", "Plutonium", 239.1, 1.7, 1.53, [0]),
  new _Element(95, "AM", "Americium", 243.1, 1.7, 1.51, [0]),
  new _Element(96, "CM", "Curium", 247.1, 1.7, 1.5, [0]),
  new _Element(97, "BK", "Berkelium", 247.1, 1.7, 1.5, [0]),
  new _Element(98, "CF", "Californium", 252.1, 1.7, 1.5, [0]),
  new _Element(99, "ES", "Einsteinium", 252.1, 1.7, 1.5, [0]),
  new _Element(100, "FM", "Fermium", 257.1, 1.7, 1.5, [0]),
  new _Element(101, "MD", "Mendelevium", 256.1, 1.7, 1.5, [0]),
  new _Element(102, "NO", "Nobelium", 259.1, 1.7, 1.5, [0]),
  new _Element(103, "LR", "Lawrencium", 260.1, 1.7, 1.5, [0]),
  new _Element(104, "RF", "Rutherfordium", 261, 1.7, 1.6, [0]),
  new _Element(105, "DB", "Dubnium", 262, 1.7, 1.6, [0]),
  new _Element(106, "SG", "Seaborgium", 263, 1.7, 1.6, [0]),
  new _Element(107, "BH", "Bohrium", 262, 1.7, 1.6, [0]),
  new _Element(108, "HS", "Hassium", 265, 1.7, 1.6, [0]),
  new _Element(109, "MT", "Meitnerium", 268, 1.7, 1.6, [0])
  /* eslint-enable no-magic-numbers */
])());
// DO NOT EDIT MANUALLY! Autogenerated from atom_types.csv by atom_types.py.
__publicField(_Element, "ByName", (() => ({
  // Duplicate atomic numbers (isotopes)
  /* eslint-disable no-magic-numbers */
  D: new _Element(1, "D", "Deuterium", 2.014, 1.2, 0.23, [1]),
  T: new _Element(1, "T", "Tritium", 3.016, 1.2, 0.23, [1])
  /* eslint-enable no-magic-numbers */
  // All regular elements will be added later, automatically
}))());
var Element = _Element;
(function() {
  const byAtomicNumber = Element.ByAtomicNumber;
  const byName = Element.ByName;
  for (let i2 = 0, n = byAtomicNumber.length; i2 < n; ++i2) {
    const element = byAtomicNumber[i2];
    if (element) {
      byName[element.name] = element;
    }
  }
})();
Element.getByName = function(element) {
  let type = Element.ByName[element];
  if (!type) {
    type = Element.ByName[element] = new Element(0, element, "Unknown", 0, 1, 0.01, [0]);
  }
  return type;
};
var chem_Element = Element;
var cBondTypes = {
  /** Was generated manually */
  UNKNOWN: 0,
  /** Simple covalent bond */
  COVALENT: 1,
  /** Aromatic bond */
  AROMATIC: 2
};
function getAtomPos(atom) {
  return atom.position;
}
var Bond = class {
  constructor(left, right, order, type, fixed) {
    this._left = left;
    this._right = right;
    this._fixed = fixed;
    this._index = -1;
    if (left > right) {
      throw new Error("In a bond atom indices must be in increasing order");
    }
    this._order = order;
    this._type = type;
  }
  getLeft() {
    return this._left;
  }
  getRight() {
    return this._right;
  }
  getOrder() {
    return this._order;
  }
  calcLength() {
    return this._left.position.distanceTo(this._right.position);
  }
  _forEachNeighbour(currAtom, process) {
    const {
      bonds
    } = currAtom;
    for (let i2 = 0, n = bonds.length; i2 < n; ++i2) {
      process(bonds[i2]._left !== currAtom ? bonds[i2]._left : bonds[i2]._right);
    }
  }
  forEachLevelOne(process) {
    const left = this._left;
    const right = this._right;
    this._forEachNeighbour(left, (atom) => {
      if (atom === right) {
        return;
      }
      process(atom);
    });
    this._forEachNeighbour(right, (atom) => {
      if (atom === left) {
        return;
      }
      process(atom);
    });
  }
  forEachLevelTwo(process) {
    const left = this._left;
    const right = this._right;
    const self2 = this;
    self2._forEachNeighbour(left, (atom) => {
      if (atom === right) {
        return;
      }
      self2._forEachNeighbour(atom, (l2Atom) => {
        if (l2Atom === left) {
          return;
        }
        process(l2Atom);
      });
    });
    self2._forEachNeighbour(right, (atom) => {
      if (atom === left) {
        return;
      }
      self2._forEachNeighbour(atom, (l2Atom) => {
        if (l2Atom === right) {
          return;
        }
        process(l2Atom);
      });
    });
  }
  _fixDir(refPoint, currDir, posGetter) {
    let rightCount = 0;
    let leftCount = 0;
    const tmpVec = refPoint.clone();
    function checkDir(atom) {
      tmpVec.copy(posGetter(atom));
      tmpVec.sub(refPoint);
      const dotProd = currDir.dot(tmpVec);
      if (dotProd > 0) {
        ++rightCount;
      } else {
        ++leftCount;
      }
    }
    function checkCarbon(atom) {
      if (atom.element.name === "C") {
        checkDir(atom);
      }
    }
    const stages = [[this.forEachLevelOne, checkCarbon], [this.forEachLevelOne, checkDir], [this.forEachLevelTwo, checkCarbon], [this.forEachLevelTwo, checkDir]];
    for (let stageId = 0; stageId < stages.length; ++stageId) {
      stages[stageId][0].call(this, stages[stageId][1]);
      if (leftCount > rightCount) {
        return currDir.multiplyScalar(-1);
      }
      if (leftCount < rightCount) {
        return currDir;
      }
    }
    return currDir;
  }
  calcNormalDir(posGetter) {
    const left = this._left;
    const right = this._right;
    let first = left;
    let second = right;
    posGetter = posGetter === void 0 ? getAtomPos : posGetter;
    if (left.bonds.length > right.bonds.length) {
      first = right;
      second = left;
    }
    let third = first;
    let maxNeibs = 0;
    const {
      bonds
    } = second;
    for (let i2 = 0, n = bonds.length; i2 < n; ++i2) {
      let another = bonds[i2]._left;
      if (bonds[i2]._left === second) {
        another = bonds[i2]._right;
      }
      if (another.bonds.length > maxNeibs && another !== first) {
        third = another;
        maxNeibs = another.bonds.length;
      }
    }
    const secondPos = posGetter(second);
    const firstV = posGetter(first).clone().sub(secondPos);
    const secondV = posGetter(third).clone().sub(secondPos);
    secondV.crossVectors(firstV, secondV);
    if (secondV.lengthSq() < 1e-4) {
      secondV.set(0, 1, 0);
    }
    firstV.normalize();
    secondV.normalize();
    firstV.crossVectors(secondV, firstV);
    if (firstV.lengthSq() < 1e-4) {
      firstV.set(0, 1, 0);
    }
    firstV.normalize();
    return this._fixDir(secondPos, firstV, posGetter);
  }
};
__publicField(Bond, "BondType", /* @__PURE__ */ (() => cBondTypes)());
Bond.prototype.BondType = cBondTypes;
var chem_Bond = Bond;
var cNucleicControlNames = ["C3'", "C3*", "P", "H5T", "H3T"];
var cNucleicWing1Names = ["OP1", "O1P"];
var cNucleicWing2Names = ["OP2", "O2P"];
var cCylinderSource = ["C3'", "C3*", "C1", "C1'", "C1*", "P"];
var cCylinderTarget = [{
  types: ["A", "DA", "G", "DG"],
  atoms: ["N1"]
}, {
  types: ["C", "DC"],
  atoms: ["N3"]
}, {
  types: ["T", "DT", "U", "DU"],
  atoms: ["O4"]
}];
var Residue = class {
  constructor(chain, type, sequence, icode) {
    this._chain = chain;
    this._component = null;
    this._type = type;
    this._sequence = sequence;
    this._icode = icode;
    this._mask = 1 | 0;
    this._index = -1;
    this._atoms = [];
    this._secondary = null;
    this._firstAtom = null;
    this._leadAtom = null;
    this._wingAtom = null;
    this._lastAtom = null;
    this._controlPoint = null;
    this._midPoint = null;
    this._wingVector = null;
    this._cylinders = null;
    this._isValid = true;
    this._het = false;
    this._molecule = null;
    this.temperature = null;
    this.occupancy = null;
  }
  // Getters and setters
  getChain() {
    return this._chain;
  }
  getMolecule() {
    return this._molecule;
  }
  getType() {
    return this._type;
  }
  getSequence() {
    return this._sequence;
  }
  getSecondary() {
    return this._secondary;
  }
  getICode() {
    return this._icode;
  }
  // Other methods
  addAtom(name, type, xyz, role, het, serial, altLoc, occupancy, tempFactor, charge) {
    const atom = new chem_Atom(this, name, type, xyz, role, het, serial, altLoc, occupancy, tempFactor, charge);
    const complex = this._chain.getComplex();
    complex.addAtom(atom);
    this._atoms.push(atom);
    this._het = this._het || het;
    return atom;
  }
  getAtomCount() {
    return this._atoms.length;
  }
  forEachAtom(process) {
    const atoms = this._atoms;
    for (let i2 = 0, n = atoms.length; i2 < n; ++i2) {
      if (process(atoms[i2])) {
        break;
      }
    }
  }
  _findAtomByName(name) {
    let res = null;
    this.forEachAtom((atom) => {
      if (atom.name === name) {
        res = atom;
        return true;
      }
      return false;
    });
    return res;
  }
  _findFirstAtomInList(names) {
    let res = null;
    for (let i2 = 0; i2 < names.length; ++i2) {
      res = this._findAtomByName(names[i2]);
      if (res !== null) {
        return res;
      }
    }
    return res;
  }
  collectMask() {
    let mask = 4294967295;
    const atoms = this._atoms;
    for (let i2 = 0, n = atoms.length; i2 < n; ++i2) {
      mask &= atoms[i2].mask;
    }
    this._mask = mask;
  }
  getCylinderTargetList() {
    const type = this._type._name;
    for (let i2 = 0, n = cCylinderTarget.length; i2 < n; ++i2) {
      for (let j = 0, m2 = cCylinderTarget[i2].types.length; j < m2; ++j) {
        if (type === cCylinderTarget[i2].types[j]) {
          return cCylinderTarget[i2].atoms;
        }
      }
    }
    return null;
  }
  _detectLeadWing(dst, next, getAtomPosition) {
    const leadAtom = this._findFirstAtomInList(cNucleicControlNames);
    let wingStart = this._findFirstAtomInList(cNucleicWing1Names);
    let wingEnd = this._findFirstAtomInList(cNucleicWing2Names);
    if (wingStart === null && next !== null) {
      wingStart = next._findFirstAtomInList(cNucleicWing1Names);
    }
    if (wingEnd === null && next !== null) {
      wingEnd = next._findFirstAtomInList(cNucleicWing2Names);
    }
    if (leadAtom === null || wingStart === null || wingEnd === null) {
      return;
    }
    dst._leadAtom = leadAtom;
    dst._controlPoint = getAtomPosition(leadAtom);
    dst._wingVector = getAtomPosition(wingEnd).clone().sub(getAtomPosition(wingStart));
    dst._isValid = true;
    const cylSource = this._findFirstAtomInList(cCylinderSource);
    const targetList = this.getCylinderTargetList();
    const cylTarget = targetList !== null ? this._findFirstAtomInList(targetList) : null;
    if (cylSource === null || cylTarget === null) {
      return;
    }
    dst._cylinders = [getAtomPosition(cylSource), getAtomPosition(cylTarget)];
  }
  calcWing(prevLeadPos, currLeadPos, prevWingPos, prevWing) {
    const vectorA = currLeadPos.clone().sub(prevLeadPos);
    const vectorB = prevLeadPos.clone().sub(prevWingPos);
    vectorB.crossVectors(vectorA, vectorB);
    vectorB.crossVectors(vectorA, vectorB).normalize();
    if (prevWing !== null && prevWing.length() > 1e-4) {
      const needToNegate = vectorB.length() > 1e-4 && Math.abs(prevWing.angleTo(vectorB)) > Math.PI / 2;
      if (needToNegate) {
        vectorB.negate();
      }
    }
    return vectorB;
  }
  _innerFinalize(prevRes, prev, nextRes, dst, chainAsNucleic, getAtomPosition) {
    const bFirstInChain = prev === null;
    const lp = getAtomPosition(this._leadAtom);
    const currLeadPos = new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Vector3(lp.x, lp.y, lp.z);
    if (chainAsNucleic) {
      this._detectLeadWing(dst, nextRes, getAtomPosition);
      return;
    }
    if (bFirstInChain) {
      dst._midPoint = getAtomPosition(this._firstAtom).clone();
    } else {
      const prevLeadPos = prev._controlPoint;
      dst._midPoint = prevLeadPos.clone().lerp(currLeadPos, 0.5);
      dst._wingVector = this.calcWing(prevLeadPos, currLeadPos, getAtomPosition(prevRes._wingAtom), prev._wingVector);
    }
    dst._controlPoint = currLeadPos;
  }
  _finalize2(prev, next, asNucleic) {
    this._innerFinalize(prev, prev, next, this, asNucleic, (atom) => atom.position);
  }
  isConnected(anotherResidue) {
    if (this._chain !== anotherResidue._chain) {
      return false;
    }
    if (this === anotherResidue) {
      return true;
    }
    let res = false;
    this.forEachAtom((atom) => {
      const {
        bonds
      } = atom;
      for (let i2 = 0, n = bonds.length; i2 < n; ++i2) {
        const bond = bonds[i2];
        if (bond._left.residue === anotherResidue || bond._right.residue === anotherResidue) {
          res = true;
          return true;
        }
      }
      return false;
    });
    return res;
  }
  _finalize() {
    const self2 = this;
    [this._firstAtom] = this._atoms;
    this._lastAtom = this._atoms[this._atoms.length - 1];
    this._leadAtom = null;
    this._wingAtom = null;
    let tempCount = 0;
    let temperature = 0;
    let occupCount = 0;
    let occupancy = 0;
    this.forEachAtom((a2) => {
      if (self2._leadAtom === null) {
        if (a2.role === chem_Element.Constants.Lead) {
          self2._leadAtom = a2;
        }
      }
      if (self2._wingAtom === null) {
        if (a2.role === chem_Element.Constants.Wing) {
          self2._wingAtom = a2;
        }
      }
      if (a2.temperature) {
        temperature += a2.temperature;
        tempCount++;
      }
      if (a2.occupancy) {
        occupancy += a2.occupancy;
        occupCount++;
      }
      return self2._leadAtom !== null && self2._wingAtom !== null;
    });
    if (tempCount > 0) {
      this.temperature = temperature / tempCount;
    }
    if (occupCount > 0) {
      this.occupancy = occupancy / occupCount;
    }
    if (this._leadAtom === null || this._wingAtom === null) {
      this._isValid = false;
    }
    if (this._leadAtom === null) {
      this._leadAtom = this._firstAtom;
    }
    if (this._wingAtom === null) {
      this._wingAtom = this._lastAtom;
    }
  }
};
var chem_Residue = Residue;
var _ResidueType = class _ResidueType {
  constructor(name, fullName, letterCode) {
    this._name = name;
    this._fullName = fullName;
    this.letterCode = letterCode;
    this.flags = 0;
  }
  getName() {
    return this._name;
  }
};
// DO NOT EDIT MANUALLY! Autogenerated from residue_types.csv by residue_types.py.
__publicField(_ResidueType, "StandardTypes", (() => ({
  /* eslint-disable no-magic-numbers */
  ALA: new _ResidueType("ALA", "Alanine", "A"),
  ARG: new _ResidueType("ARG", "Arginine", "R"),
  ASN: new _ResidueType("ASN", "Asparagine", "N"),
  ASP: new _ResidueType("ASP", "Aspartic Acid", "D"),
  CYS: new _ResidueType("CYS", "Cysteine", "C"),
  GLN: new _ResidueType("GLN", "Glutamine", "Q"),
  GLU: new _ResidueType("GLU", "Glutamic Acid", "E"),
  GLY: new _ResidueType("GLY", "Glycine", "G"),
  HIS: new _ResidueType("HIS", "Histidine", "H"),
  ILE: new _ResidueType("ILE", "Isoleucine", "I"),
  LEU: new _ResidueType("LEU", "Leucine", "L"),
  LYS: new _ResidueType("LYS", "Lysine", "K"),
  MET: new _ResidueType("MET", "Methionine", "M"),
  PHE: new _ResidueType("PHE", "Phenylalanine", "F"),
  PRO: new _ResidueType("PRO", "Proline", "P"),
  PYL: new _ResidueType("PYL", "Pyrrolysine", "O"),
  SEC: new _ResidueType("SEC", "Selenocysteine", "U"),
  SER: new _ResidueType("SER", "Serine", "S"),
  THR: new _ResidueType("THR", "Threonine", "T"),
  TRP: new _ResidueType("TRP", "Tryptophan", "W"),
  TYR: new _ResidueType("TYR", "Tyrosine", "Y"),
  VAL: new _ResidueType("VAL", "Valine", "V"),
  A: new _ResidueType("A", "Adenine", "A"),
  C: new _ResidueType("C", "Cytosine", "C"),
  G: new _ResidueType("G", "Guanine", "G"),
  I: new _ResidueType("I", "Inosine", "I"),
  T: new _ResidueType("T", "Thymine", "T"),
  U: new _ResidueType("U", "Uracil", "U"),
  DA: new _ResidueType("DA", "Adenine", "A"),
  DC: new _ResidueType("DC", "Cytosine", "C"),
  DG: new _ResidueType("DG", "Guanine", "G"),
  DI: new _ResidueType("DI", "Inosine", "I"),
  DT: new _ResidueType("DT", "Thymine", "T"),
  DU: new _ResidueType("DU", "Uracil", "U"),
  "+A": new _ResidueType("+A", "Adenine", "A"),
  "+C": new _ResidueType("+C", "Cytosine", "C"),
  "+G": new _ResidueType("+G", "Guanine", "G"),
  "+I": new _ResidueType("+I", "Inosine", "I"),
  "+T": new _ResidueType("+T", "Thymine", "T"),
  "+U": new _ResidueType("+U", "Uracil", "U"),
  WAT: new _ResidueType("WAT", "Water", ""),
  H2O: new _ResidueType("H2O", "Water", ""),
  HOH: new _ResidueType("HOH", "Water", ""),
  DOD: new _ResidueType("DOD", "Water", ""),
  UNK: new _ResidueType("UNK", "Unknown", ""),
  UNL: new _ResidueType("UNL", "Unknown Ligand", "")
  /* eslint-enable no-magic-numbers */
}))());
/**
 * Enumeration of residue flag values.
 *
 * @enum {number}
 * @readonly
 */
__publicField(_ResidueType, "Flags", {
  // Amino acids
  /** Amino acid residue */
  PROTEIN: 1,
  /** Basic amino acid residue */
  BASIC: 2,
  /** Acidic amino acid residue */
  ACIDIC: 4,
  /** Polar uncharged side chain amino acid residue */
  POLAR: 8,
  /** Non-polar hydrophobic side chain amino acid residue */
  NONPOLAR: 16,
  /** Aromatic amino acid residue */
  AROMATIC: 32,
  // Nucleic acids
  /** Nucleic residue */
  NUCLEIC: 256,
  /** Purine nucleic residue */
  PURINE: 512,
  /** Pyrimidine nucleic residue */
  PYRIMIDINE: 1024,
  /** DNA */
  DNA: 2048,
  /** RNA */
  RNA: 4096,
  /** Water */
  WATER: 65536
});
var ResidueType = _ResidueType;
function _addFlag(flag, list) {
  for (let i2 = 0, n = list.length; i2 < n; ++i2) {
    const res = ResidueType.StandardTypes[list[i2]];
    if (res) {
      res.flags |= flag;
    }
  }
}
var {
  Flags
} = ResidueType;
_addFlag(Flags.WATER, ["WAT", "H2O", "HOH", "DOD"]);
_addFlag(Flags.PROTEIN, ["ALA", "ARG", "ASN", "ASP", "CYS", "GLY", "GLU", "GLN", "HIS", "ILE", "LEU", "LYS", "MET", "PHE", "PRO", "PYL", "SEC", "SER", "THR", "TRP", "TYR", "VAL"]);
_addFlag(Flags.BASIC, ["ARG", "HIS", "LYS"]);
_addFlag(Flags.ACIDIC, ["ASP", "GLU"]);
_addFlag(Flags.POLAR, ["ASN", "CYS", "GLN", "SER", "THR", "TYR"]);
_addFlag(Flags.NONPOLAR, ["ALA", "ILE", "LEU", "MET", "PHE", "PRO", "TRP", "VAL", "GLY"]);
_addFlag(Flags.AROMATIC, ["PHE", "TRP", "TYR"]);
_addFlag(Flags.NUCLEIC, ["A", "G", "I", "DA", "DG", "DI", "+A", "+G", "+I", "C", "T", "U", "DC", "DT", "DU", "+C", "+T", "+U"]);
_addFlag(Flags.PURINE, ["A", "G", "I", "DA", "DG", "DI", "+A", "+G", "+I"]);
_addFlag(Flags.PYRIMIDINE, ["C", "T", "U", "DC", "DT", "DU", "+C", "+T", "+U"]);
_addFlag(Flags.DNA, ["DA", "DG", "DI", "DC", "DT", "DU"]);
_addFlag(Flags.RNA, ["A", "G", "I", "C", "T", "U"]);
var hydro = {
  ILE: 4.5,
  VAL: 4.2,
  LEU: 3.8,
  PHE: 2.8,
  CYS: 2.5,
  MET: 1.9,
  ALA: 1.8,
  GLY: -0.4,
  THR: -0.7,
  SER: -0.8,
  TRP: -0.9,
  TYR: -1.3,
  PRO: -1.6,
  HIS: -3.2,
  GLU: -3.5,
  GLN: -3.5,
  ASP: -3.5,
  ASN: -3.5,
  LYS: -3.9,
  ARG: -4.5
};
function _addParam(param, list) {
  const keys = Object.keys(list);
  for (let i2 = 0, n = keys.length; i2 < n; ++i2) {
    const key = keys[i2];
    const value = list[key];
    ResidueType.StandardTypes[key][param] = value;
  }
}
_addParam("hydrophobicity", hydro);
var chem_ResidueType = ResidueType;
var ChainType = {
  UNKNOWN: 0,
  PROTEIN: 1,
  NUCLEIC: 2
};
var Chain = class {
  constructor(complex, name) {
    this._complex = complex;
    this._name = name;
    this._mask = 1 | 0;
    this._index = -1;
    this._residues = [];
    this.minSequence = Number.POSITIVE_INFINITY;
    this.maxSequence = Number.NEGATIVE_INFINITY;
  }
  getComplex() {
    return this._complex;
  }
  getName() {
    return this._name;
  }
  getResidues() {
    return this._residues;
  }
  _determineType() {
    const residues = this._residues;
    const {
      PROTEIN,
      NUCLEIC
    } = chem_ResidueType.Flags;
    this.type = ChainType.UNKNOWN;
    for (let i2 = 0, n = residues.length; i2 < n; ++i2) {
      const {
        flags
      } = residues[i2]._type;
      if ((flags & NUCLEIC) !== 0) {
        this.type = ChainType.NUCLEIC;
        break;
      } else if ((flags & PROTEIN) !== 0) {
        this.type = ChainType.PROTEIN;
        break;
      }
    }
  }
  /**
   * Finds thre residue with specified sequence number and inserion code
   * @param {Number} seqNum sequence number
   * @param {string} iCode insertion code
   * @returns {*} Residue or null if not found
   */
  findResidue(seqNum, iCode) {
    const residues = this._residues;
    for (let i2 = 0, n = residues.length; i2 < n; ++i2) {
      const res = residues[i2];
      if (res._sequence === seqNum && res._icode === iCode) {
        return [res, i2];
      }
    }
    return null;
  }
  _finalize() {
    this._determineType();
    const residues = this._residues;
    let prev = null;
    for (let i2 = 0, n = residues.length; i2 < n; ++i2) {
      const next = i2 + 1 < n ? residues[i2 + 1] : null;
      const curr = residues[i2];
      if (true) {
        curr._finalize2(prev, next, this.type === ChainType.NUCLEIC);
        prev = curr;
      }
    }
    if (residues.length > 1 && residues[1]._wingVector) {
      const p2 = residues[1]._wingVector;
      residues[0]._wingVector = new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Vector3(p2.x, p2.y, p2.z);
    } else if (residues.length > 0) {
      residues[0]._wingVector = new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Vector3(1, 0, 0);
    }
  }
  updateToFrame(frameData) {
    const residues = this._residues;
    let prev = null;
    let prevData = null;
    const frameRes = frameData._residues;
    const n = residues.length;
    function getAtomPos2(atom) {
      return frameData.getAtomPos(atom.index);
    }
    for (let i2 = 0; i2 < n; ++i2) {
      const curr = residues[i2];
      const currData = frameRes[curr._index];
      const nextRes = i2 + 1 < n ? residues[i2 + 1] : null;
      curr._innerFinalize(prev, prevData, nextRes, currData, this.type === ChainType.NUCLEIC, getAtomPos2);
      prev = curr;
      prevData = currData;
    }
    frameRes[residues[0]._index]._wingVector = n > 1 ? frameRes[residues[1]._index]._wingVector : new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Vector3(1, 0, 0);
  }
  /**
   * Create a new residue.
   *
   * @param {string} name - Residue name.
   * @param {number} sequence - Residue sequence number.
   * @param {string} iCode - Insertion code.
   * @returns {Residue} - Newly created residue instance.
   */
  addResidue(name, sequence, iCode) {
    let type = this._complex.getResidueType(name);
    if (type === null) {
      type = this._complex.addResidueType(name);
    }
    const residue = new chem_Residue(this, type, sequence, iCode);
    this._complex.addResidue(residue);
    this._residues.push(residue);
    if (type.flags & (chem_ResidueType.Flags.NUCLEIC | chem_ResidueType.Flags.PROTEIN)) {
      if (this.maxSequence < sequence) {
        this.maxSequence = sequence;
      }
      if (this.minSequence > sequence) {
        this.minSequence = sequence;
      }
    }
    return residue;
  }
  getResidueCount() {
    return this._residues.length;
  }
  forEachResidue(process) {
    const residues = this._residues;
    for (let i2 = 0, n = residues.length; i2 < n; ++i2) {
      process(residues[i2]);
    }
  }
  collectMask() {
    let mask = 4294967295;
    const residues = this._residues;
    for (let i2 = 0, n = residues.length; i2 < n; ++i2) {
      mask &= residues[i2]._mask;
    }
    this._mask = mask;
  }
};
var chem_Chain = Chain;
var StructuralElement = class _StructuralElement {
  /**
   * Create a secondary structural element of the specified type.
   *
   * @param {StructuralElement.Type} type Secondary structure type.
   * @param {Residue} init Initial residue.
   * @param {Residue} term Terminal residue.
   */
  constructor(type, init, term) {
    this.type = type;
    this.generic = _StructuralElement.genericByType[this.type] || "loop";
    this.init = init;
    this.term = term;
  }
  /**
   * An internal method for making a final pass over the complex to set all required references.
   *
   * **NOTE:** I'm sorry. It's a legacy code waiting for refactoring.
   * Just copying it as-is right now and hoping for the best.
   *
   * @param {object} serialAtomMap A dictionary of atoms
   * @param {object} residueHash A dictionary of hashed residues to check.
   * @param {Complex} complex The molecular complex this element belongs to.
   */
  _finalize(serialAtomMap, residueHash, complex) {
    if (this.init instanceof chem_Residue && this.term instanceof chem_Residue) {
      return;
    }
    const start = complex.splitUnifiedSerial(this.init);
    const end = complex.splitUnifiedSerial(this.term);
    for (let chainId = start.chain; chainId <= end.chain; chainId++) {
      for (let serialId = start.serial; serialId <= end.serial; serialId++) {
        for (let {
          iCode
        } = start; iCode <= end.iCode; iCode++) {
          const hashCode = complex.getUnifiedSerial(chainId, serialId, iCode);
          if (residueHash[hashCode]) {
            residueHash[hashCode]._secondary = this;
          }
        }
      }
    }
    this.init = residueHash[this.init];
    this.term = residueHash[this.term];
  }
};
StructuralElement.Type = {
  /** A strand of a [beta-sheet](https://en.wikipedia.org/wiki/Beta_sheet). */
  STRAND: "E",
  /** An isolated beta-bridge (too small for a beta-sheet). */
  BRIDGE: "B",
  /** A [3/10 helix](https://en.wikipedia.org/wiki/310_helix) (hydrogen bonding is 3 residues apart). */
  HELIX_310: "G",
  /** An [alpha-helix](https://en.wikipedia.org/wiki/Alpha_helix) (hydrogen bonding is 4 residues apart). */
  HELIX_ALPHA: "H",
  /** A [pi-helix](https://en.wikipedia.org/wiki/Pi_helix) (hydrogen bonding is 5 residues apart). */
  HELIX_PI: "I",
  /** A generic helix of unspecified bonding distance. */
  HELIX: "X",
  /** An isolated 3/10-like helical turn. */
  TURN_310: "3",
  /** An isolated alpha-like helical turn. */
  TURN_ALPHA: "4",
  /** An isolated pi-like helical turn. */
  TURN_PI: "5",
  /** An isolated helical [turn](https://en.wikipedia.org/wiki/Turn_(biochemistry)) of unspecified bonding distance. */
  TURN: "T",
  /** A bend (a region of high curvature). */
  BEND: "S",
  /** Just a protein section with no particular conformation. */
  COIL: "C"
};
StructuralElement.Generic = {
  /** A strand of a sheet. */
  STRAND: "strand",
  /** A helix. */
  HELIX: "helix",
  /** Just a protein section with no particular conformation. */
  LOOP: "loop"
};
var StructuralElementType = StructuralElement.Type;
var StructuralElementGeneric = StructuralElement.Generic;
StructuralElement.genericByType = {
  [StructuralElementType.STRAND]: StructuralElementGeneric.STRAND,
  [StructuralElementType.HELIX_310]: StructuralElementGeneric.HELIX,
  [StructuralElementType.HELIX_ALPHA]: StructuralElementGeneric.HELIX,
  [StructuralElementType.HELIX_PI]: StructuralElementGeneric.HELIX,
  [StructuralElementType.HELIX]: StructuralElementGeneric.HELIX
};
var chem_StructuralElement = StructuralElement;
var Helix_StructuralElementType = chem_StructuralElement.Type;
var typeByPDBHelixClass = {
  1: Helix_StructuralElementType.HELIX_ALPHA,
  3: Helix_StructuralElementType.HELIX_PI,
  5: Helix_StructuralElementType.HELIX_310
};
var Helix = class extends chem_StructuralElement {
  /**
   * Create a helix.
   *
   * @param {number} helixClass A helix class according to the
   *   [PDB Format](http://www.wwpdb.org/documentation/file-format-content/format33/sect5.html#HELIX).
   * @param {Residue} init Initial residue.
   * @param {Residue} term Terminal residue.
   * @param {number} serial Serial number of the helix (see PDB Format).
   * @param {string} name Helix identifier (see PDB Format).
   * @param {string} comment Comment about this helix (see PDB Format).
   * @param {number} length Length of this helix, in residues (see PDB Format).
   */
  constructor(helixClass, init, term, serial, name, comment, length) {
    super(typeByPDBHelixClass[helixClass] || chem_StructuralElement.Type.HELIX, init, term);
    this.serial = serial;
    this.name = name;
    this.comment = comment;
    this.length = length;
  }
};
var chem_Helix = Helix;
var Strand = class extends chem_StructuralElement {
  /**
   * Create a strand.
   *
   * @param {Sheet} sheet Parent sheet this strand belongs to.
   * @param {Residue} init Initial residue.
   * @param {Residue} term Terminal residue.
   * @param {number} sense Sense of strand with respect to previous strand in the sheet.
   *   - 0 if the first strand,
   *   - 1 if parallel, and
   *   - -1 if anti-parallel.
   * @param {Atom} atomCur Atom in current strand (see PDB Format).
   * @param {Atom} atomPrev Atom in previous strand (see PDB Format).
   */
  constructor(sheet, init, term, sense, atomCur, atomPrev) {
    super(chem_StructuralElement.Type.STRAND, init, term);
    this.sheet = sheet;
    this.sense = sense;
    this.atomCur = atomCur;
    this.atomPrev = atomPrev;
  }
  /**
   * An internal method for making a final pass over the complex to set all required references.
   *
   * **NOTE:** I'm sorry. It's a legacy code waiting for refactoring.
   * Just copying it as-is right now and hoping for the best.
   *
   * @param {object} serialAtomMap A dictionary of atoms
   * @param {object} residueHash A dictionary of hashed residues to check.
   * @param {Complex} complex The molecular complex this element belongs to.
   *
   * @override
   */
  _finalize(serialAtomMap, residueHash, complex) {
    super._finalize(serialAtomMap, residueHash, complex);
    let as = this.atomCur;
    if (as !== null && !Number.isNaN(as)) {
      this.atomCur = serialAtomMap[as];
    }
    as = this.atomPrev;
    if (as !== null && !Number.isNaN(as)) {
      this.atomPrev = serialAtomMap[as];
    }
  }
};
var chem_Strand = Strand;
var Sheet = class {
  constructor(name, width) {
    this._name = name;
    this._width = width;
    this._strands = [];
  }
  // Getters and setters
  getName() {
    return this._name;
  }
  getWidth() {
    return this._width;
  }
  addStrand(strand) {
    this._strands.push(strand);
    this._width = this._strands.length;
  }
  addEmptyStrand() {
    this._strands.push(new chem_Strand(null, null, null, null, null, null));
  }
  _finalize(serialAtomMap, residueHash, complex) {
    const s2 = this._strands;
    for (let i2 = 0, n = s2.length; i2 < n; ++i2) {
      s2[i2]._finalize(serialAtomMap, residueHash, complex);
    }
    if (!this._width) {
      this._width = s2.length;
    }
    if (s2.length !== this._width) {
      throw new Error(`Sheet ${this._name} is inconsistent.`);
    }
  }
};
var chem_Sheet = Sheet;
var SGroup = class {
  constructor(id2, name, position, atoms, saveNode) {
    this._id = id2;
    this._name = name;
    this._position = position || new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Vector3();
    this._atoms = atoms || [];
    this._charge = 0;
    this._repeat = 1;
    this._center = null;
    this.xmlNodeRef = saveNode || null;
  }
  /**
   * Get atom full name.
   * @returns {string} Atom full name.
   */
  getName() {
    return this._name;
  }
  getPosition() {
    return this._position;
  }
  getCentralPoint() {
    return this._center;
  }
  _rebuildSGroupOnAtomChange() {
    const nLimon = 1e8;
    if (this._center === null) {
      return;
    }
    const bLow = new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Vector3(nLimon, nLimon, nLimon);
    const bHight = new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Vector3(-nLimon, -nLimon, -nLimon);
    for (let j = 0, n = this._atoms.length; j < n; j++) {
      const aPos = this._atoms[j].position;
      bLow.set(Math.min(bLow.x, aPos.x), Math.min(bLow.y, aPos.y), Math.min(bLow.z, aPos.z));
      bHight.set(Math.max(bHight.x, aPos.x), Math.max(bHight.y, aPos.y), Math.max(bHight.z, aPos.z));
    }
    this._center.addVectors(bLow, bHight);
    this._center.multiplyScalar(0.5);
  }
};
var chem_SGroup = SGroup;
var SelectionParser = __webpack_require__(99);
var Range = class {
  constructor(min, max) {
    this.min = min;
    this.max = typeof max === "undefined" ? min : max;
  }
  includes(value) {
    return this.min <= value && value <= this.max;
  }
  toString() {
    const {
      min,
      max
    } = this;
    return min === max ? String(min) : [min, max].join(":");
  }
  toJSON() {
    return [this.min, this.max];
  }
};
var List = class {
  constructor(arg) {
    if (arg instanceof this.constructor) {
      return arg;
    }
    if (arg instanceof Array) {
      this._values = arg.slice(0);
    } else if (arg) {
      this._values = [arg];
    } else {
      this._values = [];
    }
  }
  append(value) {
    const values = this._values;
    values[values.length] = value;
    return this;
  }
  remove(value) {
    const values = this._values;
    const index = values.indexOf(value);
    if (index >= 0) {
      values.splice(index, 1);
    }
    return this;
  }
  toString() {
    return this._values.join(",");
  }
  toJSON() {
    const values = this._values;
    const result = [];
    for (let i2 = 0, n = values.length; i2 < n; ++i2) {
      const value = values[i2];
      result[i2] = value.toJSON ? value.toJSON() : value;
    }
    return result;
  }
};
var RangeList = class extends List {
  includes(value) {
    const list = this._values;
    for (let i2 = 0, n = list.length; i2 < n; ++i2) {
      if (list[i2].includes(value)) {
        return true;
      }
    }
    return false;
  }
};
var valuesArray = [];
var ValueList = class extends List {
  constructor(arg, upperOnly) {
    const list = super(arg);
    if (upperOnly) {
      this.upperOnly = true;
      const values = list._values;
      for (let i2 = 0, n = values.length; i2 < n; ++i2) {
        const value = values[i2];
        if (typeof value === "string") {
          values[i2] = value.toUpperCase();
        }
      }
    } else {
      this.upperOnly = false;
    }
    return list;
  }
  includes(value) {
    return this._values.indexOf(value) !== -1;
  }
  toString() {
    const values = this._values;
    valuesArray.length = 0;
    for (let i2 = 0, n = values.length; i2 < n; ++i2) {
      valuesArray[i2] = utils.correctSelectorIdentifier(String(values[i2]));
    }
    return valuesArray.join(",");
  }
  _validate(value) {
    return this.upperOnly && typeof value === "string" ? value.toUpperCase() : value;
  }
  append(value) {
    super.append(this._validate(value));
    return this;
  }
  remove(value) {
    super.remove(this._validate(value));
    return this;
  }
};
var Selector = class {
  toString() {
    return this.keyword;
  }
  toJSON() {
    return [this.name];
  }
};
Selector.prototype.name = "Error";
Selector.prototype.keyword = "error";
var ListSelector = class extends Selector {
  constructor(list) {
    super();
    this.list = list;
  }
  toString() {
    return `${this.keyword} ${this.list}`;
  }
  toJSON() {
    return [this.name, this.list.toJSON()];
  }
};
var RangeListSelector = class extends ListSelector {
  constructor(arg) {
    super(new RangeList(arg));
  }
};
var ValueListSelector = class extends ListSelector {
  constructor(arg, caseSensitive) {
    super(new ValueList(arg, !caseSensitive));
  }
};
var NoneSelector = class extends Selector {
  includesAtom(_atom) {
    return false;
  }
};
NoneSelector.prototype.name = "None";
NoneSelector.prototype.keyword = "none";
var AllSelector = class extends Selector {
  includesAtom(_atom) {
    return true;
  }
};
AllSelector.prototype.name = "All";
AllSelector.prototype.keyword = "all";
var none = new NoneSelector();
var PrefixOperator = class extends Selector {
  constructor(rhs) {
    super();
    this.rhs = rhs || none;
  }
  toString() {
    const rhs = this.rhs.priority && this.rhs.priority > this.priority ? `(${this.rhs})` : this.rhs;
    return `${this.keyword} ${rhs}`;
  }
  toJSON() {
    return [this.name, this.rhs.toJSON()];
  }
};
PrefixOperator.prototype.priority = 1;
var InfixOperator = class extends Selector {
  constructor(lhs, rhs) {
    super();
    this.lhs = lhs || none;
    this.rhs = rhs || none;
  }
  toString() {
    const lhs = this.lhs.priority && this.lhs.priority > this.priority ? `(${this.lhs})` : this.lhs;
    const rhs = this.rhs.priority && this.rhs.priority > this.priority ? `(${this.rhs})` : this.rhs;
    return `${lhs} ${this.keyword} ${rhs}`;
  }
  toJSON() {
    return [this.name, this.lhs.toJSON(), this.rhs.toJSON()];
  }
};
InfixOperator.prototype.priority = 1e3;
var keywords = {};
function defineSelector(name, SelectorClass) {
  const keyword = name.toLowerCase();
  SelectorClass.prototype.keyword = keyword;
  SelectorClass.prototype.name = name;
  const factory = function() {
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    return new SelectorClass(...args);
  };
  factory.SelectorClass = SelectorClass;
  keywords[keyword] = factory;
  return SelectorClass;
}
defineSelector("Serial", class SerialSelector extends RangeListSelector {
  includesAtom(atom) {
    return this.list.includes(atom.serial);
  }
});
defineSelector("Name", class NameSelector extends ValueListSelector {
  includesAtom(atom) {
    return this.list.includes(atom.name);
  }
});
defineSelector("AltLoc", class AltLocSelector extends ValueListSelector {
  includesAtom(atom) {
    return this.list.includes(String.fromCharCode(atom.location));
  }
});
defineSelector("Elem", class ElemSelector extends ValueListSelector {
  includesAtom(atom) {
    return this.list.includes(atom.element.name);
  }
});
defineSelector("Residue", class ResidueSelector extends ValueListSelector {
  includesAtom(atom) {
    return this.list.includes(atom.residue._type._name);
  }
});
defineSelector("Sequence", class SequenceSelector extends RangeListSelector {
  includesAtom(atom) {
    return this.list.includes(atom.residue._sequence);
  }
});
defineSelector("ICode", class ICodeSelector extends ValueListSelector {
  constructor(arg) {
    super(arg, true);
  }
  includesAtom(atom) {
    return this.list.includes(atom.residue._icode);
  }
});
defineSelector("ResIdx", class ResIdxSelector extends RangeListSelector {
  includesAtom(atom) {
    return this.list.includes(atom.residue._index);
  }
});
defineSelector("Chain", class ChainSelector extends ValueListSelector {
  constructor(arg) {
    super(arg, true);
  }
  includesAtom(atom) {
    return this.list.includes(atom.residue._chain._name);
  }
});
defineSelector("Hetatm", class HetatmSelector extends Selector {
  includesAtom(atom) {
    return atom.het;
  }
});
defineSelector("PolarH", class PolarHSelector extends Selector {
  includesAtom(atom) {
    return (atom.flags & chem_Atom.Flags.NONPOLARH) === chem_Atom.Flags.HYDROGEN;
  }
});
defineSelector("NonPolarH", class NonPolarHSelector extends Selector {
  includesAtom(atom) {
    return (atom.flags & chem_Atom.Flags.NONPOLARH) === chem_Atom.Flags.NONPOLARH;
  }
});
defineSelector("All", AllSelector);
defineSelector("None", NoneSelector);
var NULL_SELECTOR = keywords.none();
function defineOperator(name, priority, OperatorClass) {
  OperatorClass.prototype.priority = priority;
  return defineSelector(name, OperatorClass);
}
defineOperator("Not", 1, class NotOperator extends PrefixOperator {
  includesAtom(atom) {
    return !this.rhs.includesAtom(atom);
  }
});
defineOperator("And", 2, class AndOperator extends InfixOperator {
  includesAtom(atom) {
    return this.lhs.includesAtom(atom) && this.rhs.includesAtom(atom);
  }
});
defineOperator("Or", 3, class OrOperator extends InfixOperator {
  includesAtom(atom) {
    return this.lhs.includesAtom(atom) || this.rhs.includesAtom(atom);
  }
});
function byResidueTypeFlag(flag, name) {
  return defineSelector(name, class extends Selector {
    includesAtom(atom) {
      return (atom.residue._type.flags & flag) !== 0;
    }
  });
}
byResidueTypeFlag(chem_ResidueType.Flags.PROTEIN, "Protein");
byResidueTypeFlag(chem_ResidueType.Flags.BASIC, "Basic");
byResidueTypeFlag(chem_ResidueType.Flags.ACIDIC, "Acidic");
byResidueTypeFlag(chem_ResidueType.Flags.BASIC | chem_ResidueType.Flags.ACIDIC, "Charged");
byResidueTypeFlag(chem_ResidueType.Flags.POLAR, "Polar");
byResidueTypeFlag(chem_ResidueType.Flags.NONPOLAR, "NonPolar");
byResidueTypeFlag(chem_ResidueType.Flags.AROMATIC, "Aromatic");
byResidueTypeFlag(chem_ResidueType.Flags.NUCLEIC, "Nucleic");
byResidueTypeFlag(chem_ResidueType.Flags.PURINE, "Purine");
byResidueTypeFlag(chem_ResidueType.Flags.PYRIMIDINE, "Pyrimidine");
byResidueTypeFlag(chem_ResidueType.Flags.WATER, "Water");
var selectors = Object.create(keywords);
selectors.Selector = Selector;
selectors.RangeListSelector = RangeListSelector;
selectors.ValueListSelector = ValueListSelector;
selectors.Range = Range;
selectors.RangeList = RangeList;
selectors.ValueList = ValueList;
selectors.PrefixOperator = PrefixOperator;
selectors.InfixOperator = InfixOperator;
selectors.Context = /* @__PURE__ */ Object.create({});
selectors.GetSelector = function(key) {
  if (!selectors.Context.hasOwnProperty(key)) {
    const exc = {
      message: `selector ${key} is not registered`
    };
    throw exc;
  }
  return selectors.Context[key] || NULL_SELECTOR;
};
selectors.ClearContext = function() {
  Object.keys(selectors.Context).forEach((k2) => {
    delete selectors.Context[k2];
  });
};
selectors.keyword = function(key) {
  return keywords[key.toLowerCase()] || keywords.none;
};
selectors.parse = function(str) {
  const res = {};
  try {
    res.selector = SelectionParser.parser.parse(str);
  } catch (e2) {
    res.selector = NULL_SELECTOR;
    res.error = e2.message;
  }
  return res;
};
SelectionParser.parser.yy = selectors;
SelectionParser.parser.yy.parseError = SelectionParser.parser.parseError;
var chem_selectors = selectors;
var BiologicalUnit = class {
  constructor(complex) {
    this._complex = complex;
    this._selector = chem_selectors.keyword("All")();
    this._boundaries = {
      boundingBox: new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Box3(),
      boundingSphere: new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Sphere()
    };
  }
  computeBoundaries() {
    const atoms = this._complex._atoms;
    const n = atoms.length;
    const selector = this._selector;
    const {
      boundingBox
    } = this._boundaries;
    boundingBox.makeEmpty();
    if (n === 1) {
      boundingBox.expandByPoint(atoms[0].position);
      const bbc = new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Vector3();
      boundingBox.getCenter(bbc);
      const s2 = 2 * atoms[0].element.radius;
      boundingBox.setFromCenterAndSize(bbc, new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Vector3(s2, s2, s2));
    } else {
      for (let i2 = 0; i2 < n; ++i2) {
        if (selector.includesAtom(atoms[i2])) {
          boundingBox.expandByPoint(atoms[i2].position);
        }
      }
    }
    let radiusSquared = 0;
    const center = new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Vector3();
    boundingBox.getCenter(center);
    if (n === 1) {
      this._boundaries.boundingSphere.set(center, atoms[0].element.radius);
    } else {
      for (let i2 = 0; i2 < n; ++i2) {
        if (!selector.includesAtom(atoms[i2])) {
          continue;
        }
        const pos = atoms[i2].position;
        const lengthSquared = center.distanceToSquared(pos);
        if (radiusSquared < lengthSquared) {
          radiusSquared = lengthSquared;
        }
      }
      this._boundaries.boundingSphere.set(center, Math.sqrt(radiusSquared));
    }
  }
  getTransforms() {
    return [];
  }
  getSelector() {
    return this._selector;
  }
  getBoundaries() {
    return this._boundaries;
  }
  finalize() {
  }
};
var chem_BiologicalUnit = BiologicalUnit;
var Assembly = class extends chem_BiologicalUnit {
  constructor(complex) {
    super(complex);
    this.chains = [];
    this.matrices = [];
  }
  computeBoundaries() {
    super.computeBoundaries();
    const {
      matrices
    } = this;
    const oldCenter = this._boundaries.boundingSphere.center;
    const oldRad = this._boundaries.boundingSphere.radius;
    const boundingBox = this._boundaries.boundingBox = new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Box3();
    boundingBox.makeEmpty();
    for (let i2 = 0, n = matrices.length; i2 < n; ++i2) {
      boundingBox.expandByPoint(oldCenter.clone().applyMatrix4(matrices[i2]));
    }
    const newRad = boundingBox.max.distanceTo(boundingBox.min) / 2 + oldRad;
    const center = new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Vector3();
    boundingBox.getCenter(center);
    this._boundaries.boundingSphere = new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Sphere().set(center, newRad);
    boundingBox.max.addScalar(oldRad);
    boundingBox.min.subScalar(oldRad);
  }
  /**
   * Mark a chain as belonging to this biological assembly.
   * @param {string} chain - chain identifier, usually a single letter
   */
  addChain(chain) {
    this.chains[this.chains.length] = chain;
  }
  /**
   * Add a transformation matrix.
   * @param {THREE.Matrix4} matrix - transformation matrix
   */
  addMatrix(matrix) {
    this.matrices[this.matrices.length] = matrix;
  }
  getTransforms() {
    return this.matrices;
  }
  finalize() {
    if (this.chains.length > 0) {
      this._selector = chem_selectors.keyword("Chain")(this.chains);
    } else {
      this._selector = chem_selectors.keyword("None")();
    }
  }
};
var chem_Assembly = Assembly;
var Component = class {
  constructor(complex) {
    this._complex = complex;
    this._index = -1;
    this._residueIndices = [];
    this._cycles = [];
    this._subDivs = [];
    this._residueCount = 0;
  }
  getResidues() {
    return this._complex._residues;
  }
  getResidueCount() {
    return this._residueCount;
  }
  forEachResidue(process) {
    const residues = this._complex._residues;
    const resIdc = this._residueIndices;
    for (let idIdc = 0, idCount = resIdc.length; idIdc < idCount; ++idIdc) {
      for (let idx = resIdc[idIdc].start, last = resIdc[idIdc].end; idx <= last; ++idx) {
        process(residues[idx]);
      }
    }
  }
  setSubDivs(subDivs) {
    this._subDivs = subDivs;
    let curr = 0;
    const resIdc = [];
    let resCnt = 0;
    for (let i2 = 0, n = subDivs.length; i2 < n; ++i2) {
      if (i2 === n - 1 || subDivs[i2].end + 1 !== subDivs[i2 + 1].start) {
        const {
          start
        } = subDivs[curr];
        const {
          end
        } = subDivs[i2];
        resIdc[resIdc.length] = {
          start,
          end
        };
        resCnt += end - start + 1;
        curr = i2 + 1;
      }
    }
    this._residueIndices = resIdc;
    this._residueCount = resCnt;
  }
  getComplex() {
    return this._complex;
  }
  forEachBond(process) {
    const bonds = this._complex._bonds;
    for (let i2 = 0, n = bonds.length; i2 < n; ++i2) {
      const bond = bonds[i2];
      if (bond._left.residue._component === this) {
        process(bond);
      }
    }
  }
  update() {
    this.forEachCycle((cycle) => {
      cycle.update();
    });
  }
  forEachAtom(process) {
    this.forEachResidue((residue) => {
      residue.forEachAtom(process);
    });
  }
  addCycle(cycle) {
    this._cycles.push(cycle);
  }
  forEachCycle(process) {
    const cycles = this._cycles;
    for (let i2 = 0, n = cycles.length; i2 < n; ++i2) {
      process(cycles[i2]);
    }
  }
  markResidues() {
    const self2 = this;
    self2.forEachResidue((residue) => {
      residue._component = self2;
    });
  }
  _forEachSubChain(mask, process) {
    const residues = this._complex._residues;
    const subs = this._subDivs;
    for (let i2 = 0, n = subs.length; i2 < n; ++i2) {
      for (let idx = subs[i2].start, last = subs[i2].end; idx <= last; ++idx) {
        const currRes = residues[idx];
        if (mask & currRes._mask && currRes._isValid) {
          let end = idx + 1;
          for (; end <= last; ++end) {
            const endRes = residues[end];
            if (!(mask & endRes._mask && endRes._isValid)) {
              break;
            }
          }
          process(i2, idx, end - 1);
          idx = end;
        }
      }
    }
  }
  getMaskedSequences(mask) {
    const subs = [];
    let idx = 0;
    this._forEachSubChain(mask, (_subIdx, start, end) => {
      subs[idx++] = {
        start,
        end
      };
    });
    return subs;
  }
  getMaskedSubdivSequences(mask) {
    const subs = [];
    let currIdx = -1;
    let lastSubIdx = -1;
    const subDivs = this._subDivs;
    this._forEachSubChain(mask, (subIdx, start, end) => {
      if (lastSubIdx !== subIdx) {
        ++currIdx;
        subs[currIdx] = {
          arr: [],
          boundaries: subDivs[subIdx]
        };
        lastSubIdx = subIdx;
      }
      subs[currIdx].arr[subs[currIdx].arr.length] = {
        start,
        end
      };
    });
    return subs;
  }
};
var chem_Component = Component;
var cMaxPairsForHashCode = 32;
var cHashTableSize = 1024 * 1024;
var cNumbersPerPair = 4;
var cMaxNeighbours = 14;
var cInvalidVal = -1;
var cBigPrime = 89237;
var AtomPairs = class {
  constructor(maxPairsEstimate) {
    this.numPairs = 0;
    this.numMaxPairs = maxPairsEstimate;
    this.intBuffer = utils.allocateTyped(Int32Array, maxPairsEstimate * cNumbersPerPair);
    for (let i2 = 0; i2 < maxPairsEstimate * cNumbersPerPair; i2++) {
      this.intBuffer[i2] = cInvalidVal;
    }
    this.hashBuffer = utils.allocateTyped(Int32Array, cHashTableSize * cMaxPairsForHashCode);
    for (let i2 = 0; i2 < cHashTableSize * cMaxPairsForHashCode; i2++) {
      this.hashBuffer[i2] = cInvalidVal;
    }
  }
  /**
   * Destroy all pairs memory
   */
  destroy() {
    this.intBuffer = null;
    this.hashBuffer = null;
  }
  /**
   * Add pair of atoms to collection
   * @param {number} indexA - Index of the 1st vertex.
   * @param {number} indexB - Index of the 2nd vertex.
   */
  addPair(indexA, indexB) {
    const ia = indexA < indexB ? indexA : indexB;
    const ib = indexA > indexB ? indexA : indexB;
    const codeToAdd = ia + (ib << cMaxNeighbours);
    const hashCode = ia + ib * cBigPrime & cHashTableSize - 1;
    let j = hashCode * cMaxPairsForHashCode;
    let apI = 0;
    for (; apI < cMaxPairsForHashCode; apI++) {
      const code = this.hashBuffer[j + apI];
      if (code === cInvalidVal) {
        break;
      }
      if (code === codeToAdd) {
        return false;
      }
    }
    if (apI >= cMaxPairsForHashCode) {
      throw new Error("addPair: increase cMaxPairsForHashCode");
    }
    this.hashBuffer[j + apI] = codeToAdd;
    if (this.numPairs >= this.numMaxPairs) {
      throw new Error("addPair: increase num pairs");
    }
    j = this.numPairs * cNumbersPerPair;
    this.intBuffer[j] = ia;
    this.intBuffer[j + 1] = ib;
    this.intBuffer[j + 2] = codeToAdd;
    this.numPairs++;
    return true;
  }
};
var chem_AtomPairs = AtomPairs;
var cProfileBondBuilder = false;
var cEstBondsMultiplier = 4;
var cSpaceCode = 32;
var cBondTolerance = 0.45;
var cVMDTolerance = 0.6;
var cBondRadInJMOL = true;
var cEpsilon = 1e-3;
function _getBondingRadius(atom) {
  const {
    element
  } = atom;
  if (element) {
    return element.radiusBonding;
  }
  throw new Error("_getBondingRadius: Logic error.");
}
function _isAtomEligible(atom) {
  return !atom.isHet() || atom.bonds && atom.bonds.length === 0;
}
var AutoBond = class {
  constructor(complex) {
    this._complex = complex;
    this._maxRad = 1.8;
    const bBox = this._complex.getDefaultBoundaries().boundingBox;
    this._vBoxMin = bBox.min.clone();
    this._vBoxMax = bBox.max.clone();
    this._pairCollection = null;
  }
  /**
   * Add existing pairs of connectors (from pdb file after its reading)
   * @returns {number} 0
   */
  _addExistingPairs() {
    const atoms = this._complex.getAtoms();
    const numAtoms = atoms.length;
    let aInd = 0;
    const collection = this._pairCollection;
    for (; aInd < numAtoms; aInd++) {
      const {
        bonds
      } = atoms[aInd];
      const numBondsForAtom = bonds.length;
      for (let bInd = 0; bInd < numBondsForAtom; bInd++) {
        const bond = bonds[bInd];
        const indTo = bond._left.index;
        if (indTo === aInd) {
          collection.addPair(aInd, bond._right.index);
        }
      }
    }
    return 0;
  }
  _findPairs() {
    const vw = this._complex.getVoxelWorld();
    if (vw === null) {
      return;
    }
    const atoms = this._complex._atoms;
    const atomsNum = atoms.length;
    const self2 = this;
    let rA;
    let isHydrogenA;
    let posA;
    let locationA;
    let atomA;
    const processAtom = function(atomB) {
      if (isHydrogenA && atomB.isHydrogen()) {
        return;
      }
      const locationB = atomB.location;
      if (locationA !== cSpaceCode && locationB !== cSpaceCode && locationA !== locationB) {
        return;
      }
      const dist2 = posA.distanceToSquared(atomB.position);
      const rB = atomB.element.radiusBonding;
      const maxAcceptable = cBondRadInJMOL ? rA + rB + cBondTolerance : cVMDTolerance * (rA + rB);
      if (dist2 > maxAcceptable * maxAcceptable) {
        return;
      }
      if (dist2 < cEpsilon) {
        return;
      }
      self2._pairCollection.addPair(atomA.index, atomB.index);
    };
    for (let i2 = 0; i2 < atomsNum; ++i2) {
      atomA = atoms[i2];
      if (!_isAtomEligible(atomA)) {
        continue;
      }
      rA = atomA.element.radiusBonding;
      isHydrogenA = atomA.isHydrogen();
      posA = atomA.position;
      locationA = atomA.location;
      vw.forEachAtomWithinRadius(posA, 2 * this._maxRad + cBondTolerance, processAtom);
    }
  }
  _addPairs() {
    const atoms = this._complex._atoms;
    for (let i2 = 0, k2 = 0; i2 < this._pairCollection.numPairs; i2++, k2 += 4) {
      const iA = this._pairCollection.intBuffer[k2];
      const iB = this._pairCollection.intBuffer[k2 + 1];
      this._addPair(atoms[iA], atoms[iB]);
    }
  }
  _addPair(atomA, atomB) {
    const bondsA = atomA.bonds;
    const indexA = atomA.index;
    const indexB = atomB.index;
    for (let j = 0, numBonds = bondsA.length; j < numBonds; ++j) {
      const bond = bondsA[j];
      if (bond._left.index === indexB || bond._right.index === indexB) {
        return;
      }
    }
    const left = indexA < indexB ? atomA : atomB;
    const right = indexA < indexB ? atomB : atomA;
    const newBond = this._complex.addBond(left, right, 0, chem_Bond.BondType.UNKNOWN, false);
    bondsA.push(newBond);
    atomB.bonds.push(newBond);
  }
  build() {
    if (cProfileBondBuilder) {
      console.time("Bonds Builder");
    }
    this._buildInner();
    if (cProfileBondBuilder) {
      console.timeEnd("Bonds Builder");
    }
  }
  _buildInner() {
    const atoms = this._complex._atoms;
    if (atoms.length < 2) {
      return;
    }
    if (atoms[0].index < 0) {
      throw new Error("AutoBond: Atoms in complex were not indexed.");
    }
    this._calcBoundingBox();
    this._pairCollection = new chem_AtomPairs(atoms.length * cEstBondsMultiplier);
    this._addExistingPairs();
    this._findPairs();
    this._addPairs();
  }
  _calcBoundingBox() {
    const atoms = this._complex._atoms;
    const nAtoms = atoms.length;
    let maxRad = _getBondingRadius(atoms[0]);
    for (let i2 = 1; i2 < nAtoms; ++i2) {
      maxRad = Math.max(maxRad, _getBondingRadius(atoms[i2]));
    }
    this._vBoxMax.addScalar(maxRad);
    this._vBoxMin.addScalar(-maxRad);
    this._maxRad = maxRad * 1.2;
  }
  destroy() {
    if (this._pairCollection) {
      this._pairCollection.destroy();
    }
  }
};
var chem_AutoBond = AutoBond;
var cCrossThresh = 0.1;
var cAromaticType = chem_Bond.BondType.AROMATIC;
var cAromaticAtoms = [
  chem_Element.ByName.C.number,
  chem_Element.ByName.N.number
  // Element.ByName.O.number,
  // Element.ByName.S.number,
];
var _coDirVectors = function() {
  const v1Tmp = new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Vector3();
  const v2Tmp = new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Vector3();
  const cp = new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Vector3();
  return function(v1, v2) {
    v1Tmp.copy(v1).normalize();
    v2Tmp.copy(v2).normalize();
    cp.crossVectors(v1Tmp, v2Tmp);
    if (cp.length() > cCrossThresh) {
      return false;
    }
    return v1Tmp.dot(v2Tmp) >= 0;
  };
}();
function _insertAscending(arr, val) {
  let idx = 0;
  while (idx < arr.length && arr[idx] < val) {
    ++idx;
  }
  arr.splice(idx, 0, val);
}
function _anotherAtom(bond, currAtom) {
  return bond._left === currAtom ? bond._right : bond._left;
}
function _cosBetween(v1, v2) {
  const theta = v1.dot(v2) / Math.sqrt(v1.lengthSq() * v2.lengthSq());
  return external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.MathUtils.clamp(theta, -1, 1);
}
function _markAromatic(bond) {
  bond._type = cAromaticType;
}
var Cycle = class {
  constructor(atomsList) {
    this.atoms = atomsList;
    this.update();
  }
  update() {
    const {
      atoms
    } = this;
    const center = new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Vector3();
    const nA = atoms.length;
    for (let j = 0; j < nA; ++j) {
      center.add(atoms[j].position);
    }
    center.multiplyScalar(1 / nA);
    this.center = center;
    this.radius = center.distanceTo(atoms[0].position.clone().lerp(atoms[1].position, 0.5));
  }
  forEachBond(process) {
    const {
      atoms
    } = this;
    const nA = atoms.length;
    let currAtom = atoms[0];
    let nextAtom;
    function checkBond(bond) {
      if (bond._left === nextAtom || bond._right === nextAtom) {
        process(bond);
      }
    }
    for (let i2 = 0; i2 < nA; ++i2) {
      nextAtom = atoms[(i2 + 1) % nA];
      currAtom.forEachBond(checkBond);
      currAtom = nextAtom;
    }
  }
};
function _isAromatic(bond) {
  return bond._type === cAromaticType;
}
function _isPossibleAromatic(bond) {
  if (bond.type === cAromaticType) {
    return true;
  }
  const rightIdx = cAromaticAtoms.indexOf(bond._right.element.number);
  const leftIdx = cAromaticAtoms.indexOf(bond._left.element.number);
  return rightIdx !== -1 && leftIdx !== -1;
}
function _checkCycleSimple(cycle) {
  return cycle.length > 3;
}
function _checkCycleComplex(cycle) {
  console.assert(cycle.length > 2);
  return true;
}
var AromaticLoopsMarker = class {
  constructor(complex) {
    this._complex = complex;
    const bondsData = new Array(complex._bonds.length);
    const bondMarks = new Array(complex._bonds.length);
    for (let i2 = 0, n = bondsData.length; i2 < n; ++i2) {
      bondsData[i2] = [];
      bondMarks[i2] = false;
    }
    this._bondsData = bondsData;
    this._bondMarks = bondMarks;
    this._resetCycles();
  }
  _resetCycles() {
    this._cycles = [];
    this._currIdx = -1;
  }
  _haveSameCycle(bondsData, bond1, bond2) {
    const arr1 = bondsData[bond1._index];
    const arr2 = bondsData[bond2._index];
    const n1 = arr1.length;
    const n2 = arr2.length;
    let i1 = 0;
    let i2 = 0;
    while (i1 < n1 && i2 < n2) {
      if (arr1[i1] === arr2[i2]) {
        return true;
      }
      if (arr1[i1] > arr2[i2]) {
        ++i2;
      } else {
        ++i1;
      }
    }
    return false;
  }
  _tryBond(prevBond, currRight, currDir) {
    const bondsOrder = [];
    const bondsData = this._bondsData;
    const currLeft = _anotherAtom(prevBond, currRight);
    const currVec = currRight.position.clone().sub(currLeft.position);
    const startAtomRef = this._currStart;
    const self2 = this;
    const bondMarks = this._bondMarks;
    let checkAromatic = this._checkBond;
    bondMarks[prevBond._index] = true;
    checkAromatic = checkAromatic === void 0 ? _isAromatic : checkAromatic;
    currRight.forEachBond((newBond) => {
      if (!checkAromatic(newBond) || newBond === prevBond || bondMarks[newBond._index] || self2._haveSameCycle(bondsData, prevBond, newBond)) {
        return;
      }
      const anotherAtom = _anotherAtom(newBond, currRight);
      const anotherVec = anotherAtom.position.clone().sub(currRight.position);
      const val = anotherAtom === startAtomRef ? -2 : 1 - _cosBetween(currVec, anotherVec);
      const newDir = anotherVec.cross(currVec);
      if (!_coDirVectors(newDir, currDir)) {
        return;
      }
      let idx = 0;
      while (idx < bondsOrder.length && bondsOrder[idx].val < val) {
        ++idx;
      }
      bondsOrder.splice(idx, 0, {
        bond: newBond,
        val,
        dir: newDir
      });
    });
    for (let i2 = 0, n = bondsOrder.length; i2 < n; ++i2) {
      const {
        bond
      } = bondsOrder[i2];
      const newRight = bond._left === currRight ? bond._right : bond._left;
      if (newRight === startAtomRef) {
        ++this._currIdx;
        this._cycles.push([currRight]);
        bondMarks[prevBond._index] = false;
        return true;
      }
      if (this._tryBond(bond, newRight, bondsOrder[i2].dir)) {
        _insertAscending(bondsData[bond._index], this._currIdx);
        this._cycles[this._currIdx].push(currRight);
        bondMarks[prevBond._index] = false;
        return true;
      }
    }
    bondMarks[prevBond._index] = false;
    return false;
  }
  _startCycle(bond) {
    this._currStart = bond._left;
    if (this._tryBond(bond, bond._right, new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Vector3())) {
      _insertAscending(this._bondsData[bond._index], this._currIdx);
      this._cycles[this._currIdx].push(bond._left);
    }
  }
  _findLoops(checkBond, checkCycle) {
    this._checkBond = checkBond;
    const complex = this._complex;
    const self2 = this;
    complex.forEachComponent((component) => {
      self2._resetCycles();
      component.forEachBond((bond) => {
        if (checkBond(bond)) {
          self2._startCycle(bond);
        }
      });
      const cycles = self2._cycles;
      for (let i2 = 0, n = cycles.length; i2 < n; ++i2) {
        const cycle = cycles[i2];
        if (!checkCycle(cycle)) {
          continue;
        }
        const newCycle = new Cycle(cycle);
        newCycle.forEachBond(_markAromatic);
        component.addCycle(newCycle);
      }
    });
  }
  markCycles() {
    this._findLoops(_isAromatic, _checkCycleSimple);
  }
  detectCycles() {
    this._findLoops(_isPossibleAromatic, _checkCycleComplex);
  }
};
var chem_AromaticLoopsMarker = AromaticLoopsMarker;
function _getSphereSliceRadiusRange(center, radius, zMin, zMax) {
  const dzMin = zMin - center.z;
  const dzMax = zMax - center.z;
  const rzMin = Math.sqrt(Math.max(radius * radius - dzMin * dzMin, 0));
  const rzMax = Math.sqrt(Math.max(radius * radius - dzMax * dzMax, 0));
  const rMin = Math.min(rzMin, rzMax);
  let rMax;
  if (zMin <= center.z && zMax >= center.z) {
    rMax = radius;
  } else {
    rMax = Math.max(rzMin, rzMax);
  }
  return [rMin, rMax];
}
function _getCircleSliceRadiusRange(center, radius, yMin, yMax) {
  const dyMin = yMin - center.y;
  const dyMax = yMax - center.y;
  const ryMin = Math.sqrt(Math.max(radius * radius - dyMin * dyMin, 0));
  const ryMax = Math.sqrt(Math.max(radius * radius - dyMax * dyMax, 0));
  const rMin = Math.min(ryMin, ryMax);
  let rMax;
  if (yMin <= center.y && yMax >= center.y) {
    rMax = radius;
  } else {
    rMax = Math.max(ryMin, ryMax);
  }
  return [rMin, rMax];
}
var _VoxelWorld = class _VoxelWorld {
  constructor(box, vCellSizeHint) {
    this._box = box.clone();
    const size = new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Vector3();
    box.getSize(size);
    this._count = size.clone().divide(vCellSizeHint).floor().max(new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Vector3(1, 1, 1));
    this._last = this._count.clone().subScalar(1);
    this._cellSize = size.clone().divide(this._count);
    this._cellInnerR = 0.5 * Math.min(Math.min(this._cellSize.x, this._cellSize.y), this._cellSize.z);
    this._cellOuterR = 0.5 * Math.sqrt(this._cellSize.dot(this._cellSize));
    const numVoxels = this._count.x * this._count.y * this._count.z;
    this._voxels = utils.allocateTyped(Int32Array, numVoxels);
    for (let i2 = 0; i2 < numVoxels; ++i2) {
      this._voxels[i2] = -1;
    }
    this._atoms = [];
  }
  /**
   * Add all atoms from a complex to voxel world
   *
   * @param {Complex} complex - complex
   */
  addAtoms(complex) {
    const self2 = this;
    let idx = this._atoms.length;
    this._atoms.length += 2 * complex.getAtomCount();
    complex.forEachAtom((atom) => {
      const voxelIdx = self2._findVoxel(atom.position);
      self2._atoms[idx] = atom;
      self2._atoms[idx + 1] = self2._voxels[voxelIdx];
      self2._voxels[voxelIdx] = idx;
      idx += 2;
    });
  }
  _findVoxel(point) {
    const zero = _VoxelWorld._zero;
    const voxel = _VoxelWorld._voxel;
    voxel.copy(point).sub(this._box.min).divide(this._cellSize).floor().clamp(zero, this._last);
    return voxel.x + this._count.x * (voxel.y + this._count.y * voxel.z);
  }
  /**
   * Call a function for each atom in voxel
   *
   * @param {number} voxel - index of voxel
   * @param {function(Atom)} process - function to call
   */
  _forEachAtomInVoxel(voxel, process) {
    for (let i2 = this._voxels[voxel]; i2 >= 0; i2 = this._atoms[i2 + 1]) {
      process(this._atoms[i2]);
    }
  }
  _forEachVoxelWithinRadius(center, radius, process) {
    const xRange = _VoxelWorld._xRange;
    const yRange = _VoxelWorld._yRange;
    const zRange = _VoxelWorld._zRange;
    if (radius / this._cellInnerR < 10) {
      this._forEachVoxelWithinRadiusSimple(center, radius, process);
      return;
    }
    let rRangeXY;
    let rRangeX;
    let xVal;
    let yVal;
    let zVal;
    let isInsideX;
    let isInsideY;
    let isInsideZ;
    zRange.set(center.z - radius, center.z + radius);
    zRange.subScalar(this._box.min.z).divideScalar(this._cellSize.z).floor().clampScalar(0, this._count.z - 1);
    for (let z = zRange.x; z <= zRange.y; ++z) {
      zVal = [this._box.min.z + z * this._cellSize.z, this._box.min.z + (z + 1) * this._cellSize.z];
      isInsideZ = center.z - radius <= zVal[0] && zVal[1] <= center.z + radius;
      rRangeXY = _getSphereSliceRadiusRange(center, radius, zVal[0], zVal[1]);
      yRange.set(center.y - rRangeXY[1], center.y + rRangeXY[1]);
      yRange.subScalar(this._box.min.y).divideScalar(this._cellSize.y).floor().clampScalar(0, this._count.y - 1);
      for (let y2 = yRange.x; y2 <= yRange.y; ++y2) {
        yVal = [this._box.min.y + y2 * this._cellSize.y, this._box.min.y + (y2 + 1) * this._cellSize.y];
        isInsideY = center.y - rRangeXY[0] <= yVal[0] && yVal[1] <= center.y + rRangeXY[0];
        rRangeX = _getCircleSliceRadiusRange(center, rRangeXY[1], yVal[0], yVal[1]);
        xRange.set(center.x - rRangeX[1], center.x + rRangeX[1]);
        xRange.subScalar(this._box.min.x).divideScalar(this._cellSize.x).floor().clampScalar(0, this._count.x - 1);
        for (let {
          x: x3
        } = xRange; x3 <= xRange.y; ++x3) {
          xVal = [this._box.min.x + x3 * this._cellSize.x, this._box.min.x + (x3 + 1) * this._cellSize.x];
          isInsideX = center.x - rRangeX[0] <= xVal[0] && xVal[1] <= center.x + rRangeX[0];
          process(x3 + this._count.x * (y2 + this._count.y * z), isInsideX && isInsideY && isInsideZ);
        }
      }
    }
  }
  _forEachVoxelWithinRadiusSimple(center, radius, process) {
    const xRange = _VoxelWorld._xRange;
    const yRange = _VoxelWorld._yRange;
    const zRange = _VoxelWorld._zRange;
    const vCenter = _VoxelWorld._vCenter;
    const distTouch2 = (radius + this._cellOuterR) * (radius + this._cellOuterR);
    let distInside2 = -1;
    if (radius > this._cellOuterR) {
      distInside2 = (radius - this._cellOuterR) * (radius - this._cellOuterR);
    }
    xRange.set(center.x - radius, center.x + radius);
    xRange.subScalar(this._box.min.x).divideScalar(this._cellSize.x).floor();
    xRange.x = Math.min(Math.max(xRange.x, 0), this._count.x - 1);
    xRange.y = Math.min(Math.max(xRange.y, 0), this._count.x - 1);
    yRange.set(center.y - radius, center.y + radius);
    yRange.subScalar(this._box.min.y).divideScalar(this._cellSize.y).floor();
    yRange.x = Math.min(Math.max(yRange.x, 0), this._count.y - 1);
    yRange.y = Math.min(Math.max(yRange.y, 0), this._count.y - 1);
    zRange.set(center.z - radius, center.z + radius);
    zRange.subScalar(this._box.min.z).divideScalar(this._cellSize.z).floor();
    zRange.x = Math.min(Math.max(zRange.x, 0), this._count.z - 1);
    zRange.y = Math.min(Math.max(zRange.y, 0), this._count.z - 1);
    for (let z = zRange.x; z <= zRange.y; ++z) {
      const zVal = [this._box.min.z + z * this._cellSize.z, this._box.min.z + (z + 1) * this._cellSize.z];
      vCenter.z = 0.5 * (zVal[0] + zVal[1]);
      for (let y2 = yRange.x; y2 <= yRange.y; ++y2) {
        const yVal = [this._box.min.y + y2 * this._cellSize.y, this._box.min.y + (y2 + 1) * this._cellSize.y];
        vCenter.y = 0.5 * (yVal[0] + yVal[1]);
        for (let {
          x: x3
        } = xRange; x3 <= xRange.y; ++x3) {
          const xVal = [this._box.min.x + x3 * this._cellSize.x, this._box.min.x + (x3 + 1) * this._cellSize.x];
          vCenter.x = 0.5 * (xVal[0] + xVal[1]);
          const d2 = center.distanceToSquared(vCenter);
          if (d2 <= distTouch2) {
            process(x3 + this._count.x * (y2 + this._count.y * z), d2 <= distInside2);
          }
        }
      }
    }
  }
  /**
   * Call a function for each atom within given sphere
   *
   * @param {Vector3} center - center of the sphere
   * @param {number} radius  - sphere radius
   * @param {function(Atom)} process - function to call
   */
  forEachAtomWithinRadius(center, radius, process) {
    const self2 = this;
    const r2 = radius * radius;
    self2._forEachVoxelWithinRadius(center, radius, (voxel, isInside) => {
      if (isInside) {
        self2._forEachAtomInVoxel(voxel, process);
      } else {
        self2._forEachAtomInVoxel(voxel, (atom) => {
          if (center.distanceToSquared(atom.position) <= r2) {
            process(atom);
          }
        });
      }
    });
  }
  /**
   * Call a function for each atom of given complex within given distance from group of atoms defined by mask
   *
   * @param {Complex} complex - complex
   * @param {number} mask - bit mask
   * @param {number} dist - distance
   * @param {function(Atom)} process - function to call
   */
  forEachAtomWithinDistFromMasked(complex, mask, dist, process) {
    this._forEachAtomWithinDistFromGroup((atomProc) => {
      complex.forEachAtom((atom) => {
        if ((atom.mask & mask) !== 0) {
          atomProc(atom);
        }
      });
    }, dist, process);
  }
  /**
   * Call a function for each atom of given complex within given distance from group of atoms defined by selector
   *
   * @param {Complex} complex - complex
   * @param {number} selector - selector
   * @param {number} dist - distance
   * @param {function(Atom)} process - function to call
   */
  forEachAtomWithinDistFromSelected(complex, selector, dist, process) {
    this._forEachAtomWithinDistFromGroup((atomProc) => {
      complex.forEachAtom((atom) => {
        if (selector.includesAtom(atom)) {
          atomProc(atom);
        }
      });
    }, dist, process);
  }
  /**
   * Call a function for each atom of given complex within given distance from group of atoms
   *
   * @param {function} forEachAtom - enumerator of atoms in the group
   * @param {number} dist - distance
   * @param {function(Atom)} process - function to call
   */
  _forEachAtomWithinDistFromGroup(forEachAtom, dist, process) {
    const self2 = this;
    const r2 = dist * dist;
    const voxels = [];
    const atoms = [];
    let idx = 0;
    forEachAtom((atom) => {
      self2._forEachVoxelWithinRadius(atom.position, dist, (voxel2, isInside) => {
        if (isInside) {
          voxels[voxel2] = -1;
        } else if (typeof voxels[voxel2] === "undefined") {
          atoms.push(atom);
          atoms.push(-1);
          voxels[voxel2] = idx;
          idx += 2;
        } else if (voxels[voxel2] !== -1) {
          atoms.push(atom);
          atoms.push(voxels[voxel2]);
          voxels[voxel2] = idx;
          idx += 2;
        }
      });
    });
    let voxel;
    const processIfWithin = function(atom) {
      if (typeof voxels[voxel] === "undefined") {
        return;
      }
      idx = voxels[voxel];
      if (idx === -1) {
        process(atom);
        return;
      }
      for (; idx >= 0; idx = atoms[idx + 1]) {
        if (atom.position.distanceToSquared(atoms[idx].position) < r2) {
          process(atom);
          break;
        }
      }
    };
    for (voxel in voxels) {
      if (voxels.hasOwnProperty(voxel)) {
        self2._forEachAtomInVoxel(voxel, processIfWithin);
      }
    }
  }
};
/**
 * Get voxel that contains specified 3D point (we use clamp at the edges)
 *
 * @param {Vector3} point - a point in 3D
 * @returns {number} - index of voxel
 */
__publicField(_VoxelWorld, "_zero", (() => new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Vector3(0, 0, 0))());
__publicField(_VoxelWorld, "_voxel", (() => new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Vector3())());
/**
 * Call a function for each voxel that is touched by given sphere. Callback also takes flag
 * isInside specifying whether voxel lies inside the sphere entirely.
 *
 * @param {Vector3} center - center of the sphere
 * @param {number} radius  - sphere radius
 * @param {function(number,bool)} process - function to call that takes voxel index and boolean isInside
 */
__publicField(_VoxelWorld, "_xRange", (() => new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Vector2())());
__publicField(_VoxelWorld, "_yRange", (() => new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Vector2())());
__publicField(_VoxelWorld, "_zRange", (() => new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Vector2())());
/**
 * Call a function for each voxel that is touched by given sphere. Callback also takes flag
 * isInside specifying whether voxel lies inside the sphere entirely.
 * This is a version of method that doesn't try to "calculate" what voxels fall inside radius
 * but instead just checks all voxels inside sphere's bounding box. This should be faster
 * unless cell size is much smaller than sphere radius.
 *
 * @param {Vector3} center - center of the sphere
 * @param {number} radius  - sphere radius
 * @param {function(number,bool)} process - function to call that takes voxel index and boolean isInside
 */
__publicField(_VoxelWorld, "_vCenter", (() => new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Vector3())());
var VoxelWorld = _VoxelWorld;
var chem_VoxelWorld = VoxelWorld;
var MINIMAL_DISTANCE = 0.5;
var MIN_HBOND_ENERGY = -9.9;
var MAX_HBOND_ENERGY = -0.5;
var COUPLING_CONSTANT = -27.888;
var MAX_COUPLING_DISTANCE = 5;
var MAX_RESIDUES_THRESHOLD = 1e3;
var HBondInfo = class {
  constructor(complex) {
    this._complex = complex;
    this._hbonds = [];
    if (this._complex._residues.length > MAX_RESIDUES_THRESHOLD) {
      this._buildVW();
    } else {
      this._build();
    }
  }
  isBond(from, to) {
    if (this._hbonds[from]) {
      const [acc0, acc1] = this._hbonds[from].acceptor;
      if (acc0 && acc0.residue === to && acc0.energy < MAX_HBOND_ENERGY) {
        return true;
      }
      if (acc1 && acc1.residue === to && acc1.energy < MAX_HBOND_ENERGY) {
        return true;
      }
    }
    return false;
  }
  _build() {
    const self2 = this;
    for (let i2 = 0; i2 < this._complex._residues.length - 1; ++i2) {
      const ri = this._complex._residues[i2];
      if ((ri.getType().flags & chem_ResidueType.Flags.PROTEIN) === 0) {
        continue;
      }
      let preri = null;
      if (i2 > 0 && this._complex._residues[i2 - 1].getType().flags & chem_ResidueType.Flags.PROTEIN && ri._sequence === this._complex._residues[i2 - 1]._sequence + 1) {
        preri = this._complex._residues[i2 - 1];
      }
      for (let j = i2 + 1; j < this._complex._residues.length; ++j) {
        const rj = this._complex._residues[j];
        if ((rj.getType().flags & chem_ResidueType.Flags.PROTEIN) === 0) {
          continue;
        }
        let prerj = null;
        if (this._complex._residues[j - 1].getType().flags & chem_ResidueType.Flags.PROTEIN && rj._sequence === this._complex._residues[j - 1]._sequence + 1) {
          prerj = this._complex._residues[j - 1];
        }
        self2._calcHBondEnergy(preri, ri, rj);
        if (j !== i2 + 1) {
          self2._calcHBondEnergy(prerj, rj, ri);
        }
      }
    }
  }
  _buildVW() {
    const self2 = this;
    const residues = this._complex._residues;
    let ri;
    let preri;
    const vw = this._complex.getVoxelWorld();
    if (vw === null) {
      return;
    }
    const pairs = new chem_AtomPairs(this._complex._residues.length * this._complex._residues.length / 2);
    function processAtom(atom) {
      const rj = atom.residue;
      if (rj._index === ri._index) {
        return;
      }
      if ((rj.getType().flags & chem_ResidueType.Flags.PROTEIN) === 0) {
        return;
      }
      if (!pairs.addPair(ri._index, rj._index)) {
        return;
      }
      let prerj = rj._index > 0 ? residues[rj._index - 1] : null;
      if (prerj && ((prerj.getType().flags & chem_ResidueType.Flags.PROTEIN) === 0 || rj._sequence !== prerj._sequence + 1)) {
        prerj = null;
      }
      self2._calcHBondEnergy(preri, ri, rj);
      if (rj._index !== ri._index + 1) {
        self2._calcHBondEnergy(prerj, rj, ri);
      }
    }
    for (let i2 = 0; i2 < residues.length - 1; ++i2) {
      ri = residues[i2];
      if ((ri.getType().flags & chem_ResidueType.Flags.PROTEIN) === 0) {
        continue;
      }
      preri = i2 > 0 ? residues[i2 - 1] : null;
      if (preri && ((preri.getType().flags & chem_ResidueType.Flags.PROTEIN) === 0 || ri._sequence !== preri._sequence + 1)) {
        preri = null;
      }
      vw.forEachAtomWithinRadius(this._residueGetCAlpha(ri), MAX_COUPLING_DISTANCE, processAtom);
    }
  }
  _residueGetCAlpha(res) {
    for (let i2 = 0; i2 < res._atoms.length; ++i2) {
      const {
        name
      } = res._atoms[i2];
      if (name === "CA" || name === "C1") {
        return res._atoms[i2].position;
      }
    }
    return null;
  }
  _residueGetCO(res) {
    let c2 = null;
    let o2 = null;
    res.forEachAtom((a2) => {
      if (a2.name === "C") {
        c2 = a2.position;
      } else if (a2.name === "O") {
        o2 = a2.position;
      }
    });
    return [c2, o2];
  }
  // TODO Support hydrogen defined in complex
  _residueGetNH(prev, res) {
    const [c2, o2] = this._residueGetCO(prev);
    let n;
    res.forEachAtom((a2) => {
      if (a2.name === "N") {
        n = a2.position;
      }
    });
    if (c2 && o2 && n) {
      const h2 = c2.clone();
      h2.sub(o2);
      h2.multiplyScalar(1 / h2.length());
      h2.add(n);
      return [n, h2];
    }
    return [null, null];
  }
  _calcHBondEnergy(predonor, donor, acceptor) {
    let result = 0;
    if (predonor === null) {
      return result;
    }
    if (donor.getType().getName() !== "PRO") {
      const [n, h2] = this._residueGetNH(predonor, donor);
      const [c2, o2] = this._residueGetCO(acceptor);
      if (n === null || h2 === null || c2 === null || o2 === null) {
        return result;
      }
      const distanceHO = h2.distanceTo(o2);
      const distanceHC = h2.distanceTo(c2);
      const distanceNC = n.distanceTo(c2);
      const distanceNO = n.distanceTo(o2);
      if (distanceHO < MINIMAL_DISTANCE || distanceHC < MINIMAL_DISTANCE || distanceNC < MINIMAL_DISTANCE || distanceNO < MINIMAL_DISTANCE) {
        result = MIN_HBOND_ENERGY;
      } else {
        result = COUPLING_CONSTANT / distanceHO - COUPLING_CONSTANT / distanceHC + COUPLING_CONSTANT / distanceNC - COUPLING_CONSTANT / distanceNO;
      }
      result = Math.round(result * 1e3) / 1e3;
      if (result < MIN_HBOND_ENERGY) {
        result = MIN_HBOND_ENERGY;
      }
    }
    if (typeof this._hbonds[donor._index] === "undefined") {
      this._hbonds[donor._index] = {
        donor: [],
        acceptor: []
      };
    }
    const donorInfo = this._hbonds[donor._index];
    if (donorInfo.acceptor.length < 2) {
      donorInfo.acceptor.push({
        residue: acceptor._index,
        energy: result
      });
    }
    if (donorInfo.acceptor.length > 1) {
      if (result < donorInfo.acceptor[0].energy) {
        donorInfo.acceptor[1].residue = donorInfo.acceptor[0].residue;
        donorInfo.acceptor[1].energy = donorInfo.acceptor[0].energy;
        donorInfo.acceptor[0].residue = acceptor._index;
        donorInfo.acceptor[0].energy = result;
      } else if (result < donorInfo.acceptor[1].energy) {
        donorInfo.acceptor[1].residue = acceptor._index;
        donorInfo.acceptor[1].energy = result;
      }
    }
    if (typeof this._hbonds[acceptor._index] === "undefined") {
      this._hbonds[acceptor._index] = {
        donor: [],
        acceptor: []
      };
    }
    const accInfo = this._hbonds[acceptor._index];
    if (accInfo.donor.length < 2) {
      accInfo.donor.push({
        residue: donor._index,
        energy: result
      });
    }
    if (accInfo.donor.length > 1) {
      if (result < accInfo.donor[0].energy) {
        accInfo.donor[1].residue = accInfo.donor[0].residue;
        accInfo.donor[1].energy = accInfo.donor[0].energy;
        accInfo.donor[0].residue = donor._index;
        accInfo.donor[0].energy = result;
      } else if (result < accInfo.donor[1].energy) {
        accInfo.donor[1].residue = donor._index;
        accInfo.donor[1].energy = result;
      }
    }
    return result;
  }
};
var BridgeType = Object.freeze({
  NO_BRIDGE: 0,
  PARALLEL: 1,
  ANTI_PARALLEL: 2
});
var HelixFlag = Object.freeze({
  START: 1,
  MIDDLE: 2,
  END: 3,
  START_AND_END: 4
});
var StructureType = Object.freeze({
  STRAND: "E",
  BRIDGE: "B",
  HELIX_310: "G",
  HELIX_ALPHA: "H",
  HELIX_PI: "I",
  TURN: "T",
  BEND: "S",
  LOOP: " "
});
var SecondaryStructureMap = class {
  constructor(complex) {
    this._complex = complex;
    this._build();
  }
  _build() {
    const self2 = this;
    this._hbonds = new HBondInfo(this._complex);
    this._ss = [];
    this._sheet = [];
    this._betaPartners = [];
    this._bend = [];
    for (let i2 = 0; i2 < this._complex.getResidues().length; ++i2) {
      this._betaPartners[i2] = [];
    }
    this._helixFlags = [];
    this._helixFlags[3] = [];
    this._helixFlags[4] = [];
    this._helixFlags[5] = [];
    this._chainLengths = [];
    for (let i2 = 0; i2 < this._complex._chains.length; ++i2) {
      const chain = this._complex._chains[i2].getResidues();
      let len = 0;
      for (; len < chain.length; ++len) {
        if ((chain[len].getType().flags & chem_ResidueType.Flags.PROTEIN) === 0) {
          break;
        }
      }
      this._chainLengths[i2] = len;
    }
    this._buildBetaSheets();
    for (let i2 = 0; i2 < this._complex._chains.length; ++i2) {
      self2._buildAlphaHelices(this._complex._chains[i2].getResidues(), this._chainLengths[i2], false);
    }
  }
  _buildAlphaHelices(inResidues, chainLength, inPreferPiHelices) {
    for (let stride = 3; stride <= 5; ++stride) {
      if (inResidues.length < stride) {
        break;
      }
      for (let i2 = 0; i2 + stride < chainLength; ++i2) {
        if (this._hbonds.isBond(inResidues[i2 + stride]._index, inResidues[i2]._index)) {
          this._helixFlags[stride][inResidues[i2 + stride]._index] = HelixFlag.END;
          for (let j = i2 + 1; j < i2 + stride; ++j) {
            if (typeof this._helixFlags[stride][inResidues[j]._index] === "undefined") {
              this._helixFlags[stride][inResidues[j]._index] = HelixFlag.MIDDLE;
            }
          }
          if (this._helixFlags[stride][inResidues[i2]._index] === HelixFlag.END) {
            this._helixFlags[stride][inResidues[i2]._index] = HelixFlag.START_AND_END;
          } else {
            this._helixFlags[stride][inResidues[i2]._index] = HelixFlag.START;
          }
        }
      }
    }
    for (let i2 = 2; i2 < chainLength - 2; ++i2) {
      const kappa = this._kappa(inResidues[i2 - 2], inResidues[i2], inResidues[i2 + 2]);
      this._bend[inResidues[i2]._index] = kappa !== 360 && kappa > 70;
    }
    for (let i2 = 1; i2 + 4 < chainLength; ++i2) {
      if (this._isHelixStart(inResidues[i2]._index, 4) && this._isHelixStart(inResidues[i2 - 1]._index, 4)) {
        for (let j = i2; j <= i2 + 3; ++j) {
          this._ss[inResidues[j]._index] = StructureType.HELIX_ALPHA;
        }
      }
    }
    for (let i2 = 1; i2 + 3 < chainLength; ++i2) {
      if (this._isHelixStart(inResidues[i2]._index, 3) && this._isHelixStart(inResidues[i2 - 1]._index, 3)) {
        let empty = true;
        for (let j = i2; empty && j <= i2 + 2; ++j) {
          empty = typeof this._ss[inResidues[j]._index] === "undefined" || this._ss[inResidues[j]._index] === StructureType.HELIX_310;
        }
        if (empty) {
          for (let j = i2; j <= i2 + 2; ++j) {
            this._ss[inResidues[j]._index] = StructureType.HELIX_310;
          }
        }
      }
    }
    for (let i2 = 1; i2 + 5 < chainLength; ++i2) {
      if (this._isHelixStart(inResidues[i2]._index, 5) && this._isHelixStart(inResidues[i2 - 1]._index, 5)) {
        let empty = true;
        for (let j = i2; empty && j <= i2 + 4; ++j) {
          empty = typeof this._ss[inResidues[j]._index] === "undefined" || this._ss[inResidues[j]._index] === StructureType.HELIX_PI || inPreferPiHelices && this._ss[inResidues[j]._index] === StructureType.HELIX_ALPHA;
        }
        if (empty) {
          for (let j = i2; j <= i2 + 4; ++j) {
            this._ss[inResidues[j]._index] = StructureType.HELIX_PI;
          }
        }
      }
    }
    for (let i2 = 1; i2 + 1 < chainLength; ++i2) {
      if (typeof this._ss[inResidues[i2]._index] === "undefined") {
        let isTurn = false;
        for (let stride = 3; stride <= 5 && !isTurn; ++stride) {
          for (let k2 = 1; k2 < stride && !isTurn; ++k2) {
            isTurn = i2 >= k2 && this._isHelixStart(inResidues[i2 - k2]._index, stride);
          }
        }
        if (isTurn) {
          this._ss[inResidues[i2]._index] = StructureType.TURN;
        } else if (this._bend[inResidues[i2]._index]) {
          this._ss[inResidues[i2]._index] = StructureType.BEND;
        }
      }
    }
  }
  _residueGetCAlpha(res) {
    for (let i2 = 0; i2 < res._atoms.length; ++i2) {
      const {
        name
      } = res._atoms[i2];
      if (name === "CA" || name === "C1") {
        return res._atoms[i2].position;
      }
    }
    return null;
  }
  _cosinusAngle(p1, p2, p3, p4) {
    const v12 = p1.clone().sub(p2);
    const v34 = p3.clone().sub(p4);
    let result = 0;
    const x3 = v12.dot(v12) * v34.dot(v34);
    if (x3 > 0) {
      result = v12.dot(v34) / Math.sqrt(x3);
    }
    return result;
  }
  _kappa(prevPrev, res, nextNext) {
    const curCA = this._residueGetCAlpha(res);
    const ppCA = this._residueGetCAlpha(prevPrev);
    const nnCA = this._residueGetCAlpha(nextNext);
    if (curCA === null || ppCA === null || nnCA === null) {
      return 180;
    }
    const ckap = this._cosinusAngle(curCA, ppCA, nnCA, curCA);
    const skap = Math.sqrt(1 - ckap * ckap);
    return Math.atan2(skap, ckap) * 180 / Math.PI;
  }
  _isHelixStart(res, stride) {
    return this._helixFlags[stride][res] === HelixFlag.START || this._helixFlags[stride][res] === HelixFlag.START_AND_END;
  }
  _buildBetaSheets() {
    const bridges = [];
    for (let a2 = 0; a2 < this._complex._chains.length; ++a2) {
      const lenA = this._chainLengths[a2];
      if (lenA <= 4) {
        continue;
      }
      const chainA = this._complex._chains[a2].getResidues();
      for (let b2 = a2; b2 < this._complex._chains.length; ++b2) {
        const lenB = this._chainLengths[b2];
        if (lenB <= 4) {
          continue;
        }
        const chainB = this._complex._chains[b2].getResidues();
        for (let i2 = 1; i2 + 1 < lenA; ++i2) {
          const ri = chainA[i2];
          let j = 1;
          if (b2 === a2) {
            j = i2 + 3;
          }
          for (; j + 1 < lenB; ++j) {
            const rj = chainB[j];
            const type = this._testBridge(chainA, i2, chainB, j);
            if (type === BridgeType.NO_BRIDGE) {
              continue;
            }
            let found = false;
            for (const bridge of bridges) {
              if (type !== bridge.type || ri._index !== bridge.i[bridge.i.length - 1] + 1) {
                continue;
              }
              if (type === BridgeType.PARALLEL && bridge.j[bridge.j.length - 1] + 1 === rj._index) {
                bridge.i.push(ri._index);
                bridge.j.push(rj._index);
                found = true;
                break;
              }
              if (type === BridgeType.ANTI_PARALLEL && bridge.j[0] - 1 === rj._index) {
                bridge.i.push(ri._index);
                bridge.j.unshift(rj._index);
                found = true;
                break;
              }
            }
            if (!found) {
              bridges.push({
                type,
                i: [ri._index],
                chainI: ri.getChain()._index,
                j: [rj._index],
                chainJ: rj.getChain()._index
              });
            }
          }
        }
      }
    }
    bridges.sort((a2, b2) => {
      if (a2.chainI < b2.chainI || a2.chainI === b2.chainI && a2.i[0] < b2.i[0]) {
        return -1;
      }
      return 1;
    });
    for (let i2 = 0; i2 < bridges.length; ++i2) {
      for (let j = i2 + 1; j < bridges.length; ++j) {
        const ibi = bridges[i2].i[0];
        const iei = bridges[i2].i[bridges[i2].i.length - 1];
        const jbi = bridges[i2].j[0];
        const jei = bridges[i2].j[bridges[i2].j.length - 1];
        const ibj = bridges[j].i[0];
        const iej = bridges[j].i[bridges[j].i.length - 1];
        const jbj = bridges[j].j[0];
        const jej = bridges[j].j[bridges[j].j.length - 1];
        if (bridges[i2].type !== bridges[j].type || this._hasChainBreak(Math.min(ibi, ibj), Math.max(iei, iej)) || this._hasChainBreak(Math.min(jbi, jbj), Math.max(jei, jej)) || ibj - iei >= 6 || iei >= ibj && ibi <= iej) {
          continue;
        }
        let bulge = false;
        if (bridges[i2].type === BridgeType.PARALLEL) {
          bulge = jbj - jei < 6 && ibj - iei < 3 || jbj - jei < 3;
        } else {
          bulge = jbi - jej < 6 && ibj - iei < 3 || jbi - jej < 3;
        }
        if (bulge) {
          bridges[i2].i = bridges[i2].i.concat(bridges[j].i);
          if (bridges[i2].type === BridgeType.PARALLEL) {
            bridges[i2].j = bridges[i2].j.concat(bridges[j].j);
          } else {
            bridges[i2].j = bridges[j].j.concat(bridges[i2].j);
          }
          bridges.splice(j--, 1);
        }
      }
    }
    const ladderset = /* @__PURE__ */ new Set();
    for (let i2 = 0; i2 < bridges.length; ++i2) {
      ladderset.add(bridges[i2]);
    }
    let sheet = 1;
    let ladder = 0;
    while (ladderset.size > 0) {
      let bridge = ladderset.values().next().value;
      ladderset.delete(bridge);
      const sheetset = /* @__PURE__ */ new Set();
      sheetset.add(bridge);
      let toMove;
      do {
        toMove = /* @__PURE__ */ new Set();
        for (const a2 of sheetset.values()) {
          for (const b2 of ladderset.values()) {
            if (this._areBridgesLinked(a2, b2)) {
              toMove.add(b2);
            }
          }
        }
        for (bridge of toMove.values()) {
          sheetset.add(bridge);
          ladderset.delete(bridge);
        }
      } while (toMove.size > 0);
      for (bridge of sheetset.values()) {
        bridge.ladder = ladder;
        bridge.sheet = sheet;
        bridge.link = sheetset;
        ++ladder;
      }
      ++sheet;
    }
    for (let i2 = 0; i2 < bridges.length; ++i2) {
      const bridge = bridges[i2];
      let betai = 0;
      let betaj = 0;
      for (let l2 = 0; l2 < bridge.i.length; ++l2) {
        if (this._betaPartners[bridge.i[l2]][0]) {
          betai = 1;
          break;
        }
      }
      for (let l2 = 0; l2 < bridge.j.length; ++l2) {
        if (this._betaPartners[bridge.j[l2]][0]) {
          betaj = 1;
          break;
        }
      }
      let ss = StructureType.BRIDGE;
      if (bridge.i.length > 1) {
        ss = StructureType.STRAND;
      }
      if (bridge.type === BridgeType.PARALLEL) {
        let j = 0;
        for (let k2 = 0; k2 < bridge.i.length; ++k2) {
          this._betaPartners[bridge.i[k2]][betai] = {
            residue: bridge.j[j++],
            ladder: bridge.ladder,
            parallel: true
          };
        }
        j = 0;
        for (let k2 = 0; k2 < bridge.j.length; ++k2) {
          this._betaPartners[bridge.j[k2]][betaj] = {
            residue: bridge.i[j++],
            ladder: bridge.ladder,
            parallel: true
          };
        }
      } else {
        let j = bridge.j.length - 1;
        for (let k2 = 0; k2 < bridge.i.length; ++k2) {
          this._betaPartners[bridge.i[k2]][betai] = {
            residue: bridge.j[j--],
            ladder: bridge.ladder,
            parallel: false
          };
        }
        j = bridge.i.length - 1;
        for (let k2 = 0; k2 < bridge.j.length; ++k2) {
          this._betaPartners[bridge.j[k2]][betaj] = {
            residue: bridge.i[j--],
            ladder: bridge.ladder,
            parallel: false
          };
        }
      }
      for (let k2 = bridge.i[0]; k2 <= bridge.i[bridge.i.length - 1]; ++k2) {
        if (this._ss[k2] !== StructureType.STRAND) {
          this._ss[k2] = ss;
          this._sheet[k2] = bridge.sheet;
        }
      }
      for (let k2 = bridge.j[0]; k2 <= bridge.j[bridge.j.length - 1]; ++k2) {
        if (this._ss[k2] !== StructureType.STRAND) {
          this._ss[k2] = ss;
          this._sheet[k2] = bridge.sheet;
        }
      }
    }
  }
  _testBridge(chainA, from, chainB, to) {
    let result = BridgeType.NO_BRIDGE;
    const a2 = chainA[from - 1]._index;
    const b2 = chainA[from]._index;
    const c2 = chainA[from + 1]._index;
    const d2 = chainB[to - 1]._index;
    const e2 = chainB[to]._index;
    const f2 = chainB[to + 1]._index;
    const isBond = this._hbonds.isBond.bind(this._hbonds);
    if (isBond(c2, e2) && isBond(e2, a2) || isBond(f2, b2) && isBond(b2, d2)) {
      result = BridgeType.PARALLEL;
    } else if (isBond(c2, d2) && isBond(f2, a2) || isBond(e2, b2) && isBond(b2, e2)) {
      result = BridgeType.ANTI_PARALLEL;
    }
    return result;
  }
  // return true if any of the residues in bridge a is identical to any of the residues in bridge b
  _areBridgesLinked(a2, b2) {
    const ai = new Set(a2.i);
    const aj = new Set(a2.j);
    for (const i2 of b2.i) {
      if (ai.has(i2) || aj.has(i2)) {
        return true;
      }
    }
    for (const i2 of b2.j) {
      if (ai.has(i2) || aj.has(i2)) {
        return true;
      }
    }
    return false;
  }
  _hasChainBreak(from, to) {
    for (let i2 = from + 1; i2 <= to; ++i2) {
      if (this._complex._residues[i2]._sequence !== this._complex._residues[i2 - 1]._sequence + 1) {
        return true;
      }
    }
    return false;
  }
};
SecondaryStructureMap.StructureType = StructureType;
var VOXEL_SIZE = 5;
var {
  StructureType: Complex_StructureType
} = SecondaryStructureMap;
var Complex_StructuralElementType = chem_StructuralElement.Type;
var helixClassMap = {
  [Complex_StructureType.HELIX_ALPHA]: 1,
  [Complex_StructureType.HELIX_PI]: 3,
  [Complex_StructureType.HELIX_310]: 5
};
var loopMap = {
  [Complex_StructureType.BRIDGE]: Complex_StructuralElementType.BRIDGE,
  [Complex_StructureType.TURN]: Complex_StructuralElementType.TURN,
  [Complex_StructureType.BEND]: Complex_StructuralElementType.BEND,
  [Complex_StructureType.LOOP]: Complex_StructuralElementType.COIL
};
var Complex = class {
  constructor() {
    this._chains = [];
    this._components = [];
    this._helices = [];
    this._sheets = [];
    this.structures = [];
    this._residueTypes = Object.create(chem_ResidueType.StandardTypes);
    this._atoms = [];
    this._residues = [];
    this._bonds = [];
    this._sgroups = [];
    this._molecules = [];
    this._maskNeedsUpdate = false;
    this.metadata = {};
    this.symmetry = [];
    this.units = [new chem_BiologicalUnit(this)];
    this._currentUnit = 0;
  }
  addAtom(atom) {
    const index = this._atoms.length;
    this._atoms.push(atom);
    return index;
  }
  addSheet(sheet) {
    const index = this._sheets.length;
    this._sheets.push(sheet);
    return index;
  }
  addHelix(helix) {
    const index = this._helices.length;
    this._helices.push(helix);
    return index;
  }
  getAtoms() {
    return this._atoms;
  }
  getBonds() {
    return this._bonds;
  }
  getAtomCount() {
    return this._atoms.length;
  }
  addResidue(residue) {
    const index = this._residues.length;
    this._residues.push(residue);
    return index;
  }
  updateToFrame(frameData) {
    this.forEachChain((chain) => {
      chain.updateToFrame(frameData);
    });
  }
  addResidueType(resName) {
    const rt = this._residueTypes[resName] = new chem_ResidueType(resName, "Unknown", "");
    return rt;
  }
  getResidueCount() {
    return this._residues.length;
  }
  getResidues() {
    return this._residues;
  }
  getSGroupCount() {
    return this._sgroups.length;
  }
  getSGroups() {
    return this._sgroups;
  }
  /*
     Extract atom by its fullname: #chainName#.#residueId#.#atomName#
     */
  getAtomByFullname(fullName) {
    const parts = fullName.split(".");
    if (parts.length !== 3) {
      return null;
    }
    const chainName = parts[0];
    const resId = parseInt(parts[1], 10);
    if (Number.isNaN(resId)) {
      return null;
    }
    const atomName = parts[2].toUpperCase();
    let currAtom = null;
    this.forEachChain((chain) => {
      if (currAtom) {
        return;
      }
      if (chain._name.localeCompare(chainName) === 0) {
        chain.forEachResidue((residue) => {
          if (currAtom) {
            return;
          }
          if (residue._sequence === resId) {
            residue.forEachAtom((atom) => {
              if (currAtom) {
                return;
              }
              if (atomName.localeCompare(atom.name) === 0) {
                currAtom = atom;
              }
            });
          }
        });
      }
    });
    return currAtom;
  }
  /**
   * Create a new chain.
   *
   * @param {string} name - Chain name.
   * @returns {Chain} - Newly created chain.
   */
  addChain(name) {
    const result = new chem_Chain(this, name);
    this._chains.push(result);
    return result;
  }
  getChain(name) {
    for (let i2 = 0, n = this._chains.length; i2 < n; ++i2) {
      const chain = this._chains[i2];
      if (chain.getName() === name) {
        return chain;
      }
    }
    return null;
  }
  getChainCount() {
    return this._chains.length;
  }
  getMolecules() {
    return this._molecules;
  }
  getMoleculeCount() {
    return this._molecules.length;
  }
  forEachAtom(process) {
    const atoms = this._atoms;
    for (let i2 = 0, n = atoms.length; i2 < n; ++i2) {
      process(atoms[i2]);
    }
  }
  forEachBond(process) {
    const bonds = this._bonds;
    for (let i2 = 0, n = bonds.length; i2 < n; ++i2) {
      process(bonds[i2]);
    }
  }
  forEachResidue(process) {
    const residues = this._residues;
    for (let i2 = 0, n = residues.length; i2 < n; ++i2) {
      process(residues[i2]);
    }
  }
  forEachChain(process) {
    const chains = this._chains;
    for (let i2 = 0, n = chains.length; i2 < n; ++i2) {
      process(chains[i2]);
    }
  }
  forEachMolecule(process) {
    const molecules = this._molecules;
    const n = molecules.length;
    for (let i2 = 0; i2 < n; ++i2) {
      process(molecules[i2]);
    }
  }
  forEachSGroup(process) {
    const groups2 = this._sgroups;
    for (let i2 = 0, n = groups2.length; i2 < n; ++i2) {
      process(groups2[i2]);
    }
  }
  forEachComponent(process) {
    const components = this._components;
    for (let i2 = 0, n = components.length; i2 < n; ++i2) {
      process(components[i2]);
    }
  }
  forEachVisibleComponent(process) {
    const components = this._components;
    for (let i2 = 0, n = components.length; i2 < n; ++i2) {
      process(components[i2]);
    }
  }
  addBond(left, right, order, type, fixed) {
    const bond = new chem_Bond(left, right, order, type, fixed);
    this._bonds.push(bond);
    return bond;
  }
  getBondCount() {
    return this._bonds.length;
  }
  getResidueType(name) {
    return this._residueTypes[name] || null;
  }
  getUnifiedSerial(chain, serial, iCode) {
    const maxSerial = 65536;
    const chainShift = maxSerial * 256;
    return serial + iCode * maxSerial + chain * chainShift;
  }
  splitUnifiedSerial(uniSerial) {
    const maxSerial = 65536;
    const chainShift = maxSerial * 256;
    const chainId = Math.floor(uniSerial / chainShift);
    const remnant = uniSerial - chainId * chainShift;
    const insCode = Math.floor(remnant / maxSerial);
    const ser = remnant - insCode * maxSerial;
    return {
      chain: chainId,
      serial: ser,
      iCode: insCode
    };
  }
  _fillCmpEdit() {
    const self2 = this;
    const components = this._components;
    function addComp() {
      const comp = new chem_Component(self2);
      comp._index = components.length;
      components[comp._index] = comp;
      return comp;
    }
    this.forEachChain((chain) => {
      const residues = chain._residues;
      const resCount = residues.length;
      if (resCount < 1) {
        return;
      }
      let comp = addComp();
      let currStart = residues[0]._index;
      for (let i2 = 0; i2 < resCount; ++i2) {
        const currRes = residues[i2];
        currRes._component = comp;
        const nextRes = i2 === resCount - 1 ? null : residues[i2 + 1];
        if (!nextRes || !currRes.isConnected(nextRes) || currRes._index !== nextRes._index - 1) {
          comp.setSubDivs([{
            start: currStart,
            end: currRes._index
          }]);
          if (nextRes) {
            currStart = nextRes._index;
            comp = addComp();
          }
        }
      }
    });
  }
  // This function was added in the moment of despair
  // It was the dark times for miew
  _fillCmpNoedit() {
    const comp = new chem_Component(this);
    comp._index = 0;
    const residues = this._residues;
    const resCount = residues.length;
    if (resCount === 0) {
      return;
    }
    const currSubDivs = [];
    let currStart = 0;
    for (let i2 = 0; i2 < resCount; ++i2) {
      const currRes = residues[i2];
      currRes._component = comp;
      const nextRes = i2 === resCount - 1 ? null : residues[i2 + 1];
      if (!nextRes || !currRes.isConnected(nextRes)) {
        currSubDivs[currSubDivs.length] = {
          start: currStart,
          end: i2
        };
        if (nextRes) {
          currStart = i2 + 1;
        }
      }
    }
    comp.setSubDivs(currSubDivs);
    this._components[comp._index] = comp;
  }
  /**
   * Fill components information.
   * @param {boolean} enableEditing - Restructure Complex to enable per-component editing.
   */
  _fillComponents(enableEditing) {
    if (enableEditing) {
      this._fillCmpEdit();
    } else {
      this._fillCmpNoedit();
    }
  }
  getCurrentUnit() {
    return this._currentUnit;
  }
  getDefaultBoundaries() {
    return this.units[0].getBoundaries();
  }
  getBoundaries() {
    return this.units[this._currentUnit].getBoundaries();
  }
  getTransforms() {
    return this.units[this._currentUnit].getTransforms();
  }
  getSelector() {
    return this.units[this._currentUnit].getSelector();
  }
  resetCurrentUnit() {
    this._currentUnit = 0;
    this.setCurrentUnit(1);
  }
  setCurrentUnit(newUnit) {
    if (newUnit !== null && newUnit !== void 0 && newUnit !== this._currentUnit && newUnit >= 0 && newUnit < this.units.length) {
      this._currentUnit = newUnit;
      return true;
    }
    return false;
  }
  _computeBounds() {
    const {
      units
    } = this;
    for (let i2 = 0, n = units.length; i2 < n; ++i2) {
      units[i2].computeBoundaries();
    }
  }
  onAtomPositionChanged() {
    this.forEachChain((a2) => {
      a2._finalize();
    });
    this.forEachComponent((c2) => {
      c2.update();
    });
    this._computeBounds();
    this._finalizeBonds();
    this.forEachSGroup((s2) => {
      s2._rebuildSGroupOnAtomChange();
    });
  }
  update() {
    if (this._maskNeedsUpdate) {
      this.updateStructuresMask();
      this._maskNeedsUpdate = false;
    }
  }
  _finalizeBonds() {
    const bonds = this.getBonds();
    const n = bonds.length;
    for (let i2 = 0; i2 < n; ++i2) {
      bonds[i2]._index = i2;
    }
  }
  /**
   * Finalizes complex's inner data(i.e. after parsing).
   * @param {objects} opts - Build bonds automatically.
   * @param {boolean} opts.needAutoBonding     - Build bonds automatically.
   * @param {boolean} opts.detectAromaticLoops - Find/mark aromatic loops.
   * @param {boolean} opts.enableEditing       - Restructure Complex to enable per-component editing.
   * @param {Array<Atom>} [opts.serialAtomMap] - Array of atoms ordered by their serials.
   */
  finalize(opts) {
    opts = opts || {};
    const bonds = this._bonds;
    let i2;
    let n;
    for (i2 = bonds.length - 1; i2 >= 0; i2--) {
      const bond = bonds[i2];
      if (bond._left === null || bond._right === null) {
        bonds.splice(i2, 1);
      } else {
        bond._left.bonds.push(bond);
        bond._right.bonds.push(bond);
      }
    }
    const residues = this._residues;
    for (i2 = 0, n = residues.length; i2 < n; ++i2) {
      residues[i2]._finalize();
    }
    this.forEachChain((a2) => {
      a2._finalize();
    });
    const {
      units
    } = this;
    for (i2 = 0, n = units.length; i2 < n; ++i2) {
      units[i2].finalize();
    }
    this.setCurrentUnit(1);
    const residueHash = {};
    for (i2 = 0, n = residues.length; i2 < n; ++i2) {
      const res = residues[i2];
      residueHash[this.getUnifiedSerial(res.getChain().getName().charCodeAt(0), res.getSequence(), res.getICode().charCodeAt(0))] = res;
    }
    const {
      structures
    } = this;
    for (i2 = 0, n = structures.length; i2 < n; ++i2) {
      structures[i2]._finalize(opts.serialAtomMap, residueHash, this);
    }
    const helices = this._helices;
    for (i2 = 0, n = helices.length; i2 < n; ++i2) {
      helices[i2]._finalize(opts.serialAtomMap, residueHash, this);
    }
    const sheets = this._sheets;
    for (i2 = 0, n = sheets.length; i2 < n; ++i2) {
      sheets[i2]._finalize(opts.serialAtomMap, residueHash, this);
    }
    this._computeBounds();
    const atoms = this._atoms;
    for (i2 = 0, n = atoms.length; i2 < n; ++i2) {
      const currAtom = atoms[i2];
      currAtom.index = i2;
    }
    if (opts.needAutoBonding) {
      try {
        const autoConnector = new chem_AutoBond(this);
        autoConnector.build();
        autoConnector.destroy();
      } catch (e2) {
        console.warn("Autobonding failed:", e2);
      }
    }
    const chains = this._chains;
    for (i2 = 0, n = chains.length; i2 < n; ++i2) {
      chains[i2]._index = i2;
    }
    for (i2 = 0, n = residues.length; i2 < n; ++i2) {
      residues[i2]._index = i2;
    }
    for (i2 = 0, n = atoms.length; i2 < n; ++i2) {
      const atom = atoms[i2];
      if (atom.flags & chem_Atom.Flags.HYDROGEN && atom.bonds.length === 1) {
        const bond = atom.bonds[0];
        const other = bond._left !== atom && bond._left || bond._right;
        if (other.flags & chem_Atom.Flags.CARBON) {
          atom.flags |= chem_Atom.Flags.NONPOLARH;
        }
      }
    }
    this._finalizeBonds();
    this._fillComponents(opts.enableEditing);
    const marker = new chem_AromaticLoopsMarker(this);
    marker.markCycles();
    if (opts.detectAromaticLoops) {
      marker.detectCycles();
    }
    this._finalizeMolecules();
  }
  _finalizeMolecules() {
    for (let i2 = 0; i2 < this._molecules.length; i2++) {
      const molecule = this._molecules[i2];
      const count = molecule.residues.length;
      for (let j = 0; j < count; j++) {
        const residue = molecule.residues[j];
        residue._molecule = molecule;
      }
    }
  }
  updateStructuresMask() {
    const updater = (structure) => structure.collectMask();
    this.forEachResidue(updater);
    this.forEachChain(updater);
    this.forEachMolecule(updater);
  }
  countAtomsByMask(mask) {
    let count = 0;
    this.forEachAtom((atom) => {
      if ((atom.mask & mask) !== 0) {
        count++;
      }
    });
    return count;
  }
  getNumAtomsBySelector(selector) {
    let count = 0;
    this.forEachAtom((atom) => {
      if (selector.includesAtom(atom)) {
        count++;
      }
    });
    return count;
  }
  resetAtomMask(mask) {
    this.forEachAtom((atom) => {
      atom.mask = mask;
    });
  }
  markAtoms(selector, mask) {
    const setMask = mask;
    const clearMask = ~setMask;
    let count = 0;
    const totalSelector = chem_selectors.keyword("And")(selector, this.getSelector());
    this.forEachAtom((atom) => {
      if (totalSelector.includesAtom(atom)) {
        atom.mask |= setMask;
        count++;
      } else {
        atom.mask &= clearMask;
      }
    });
    this._maskNeedsUpdate = true;
    return count;
  }
  markAtomsAdditionally(selector, mask) {
    const setMask = mask;
    let count = 0;
    this.forEachAtom((atom) => {
      if (selector.includesAtom(atom) && (atom.mask & mask) !== mask) {
        atom.mask |= setMask;
        count++;
      }
    });
    return count;
  }
  clearAtomBits(mask) {
    const clearMask = ~mask;
    this.forEachAtom((atom) => {
      atom.mask &= clearMask;
    });
    const reseter = (a2) => {
      a2._mask &= clearMask;
    };
    this.forEachAtom(reseter);
    this.forEachResidue(reseter);
    this.forEachChain(reseter);
    this.forEachMolecule(reseter);
  }
  getAtomNames() {
    if (this.hasOwnProperty("_atomNames")) {
      return this._atomNames;
    }
    const dict = {};
    this.forEachAtom((atom) => {
      dict[atom.name] = 1;
    });
    this._atomNames = Object.keys(dict);
    return this._atomNames;
  }
  getElements() {
    if (this.hasOwnProperty("_elements")) {
      return this._elements;
    }
    const dict = {};
    this.forEachAtom((atom) => {
      dict[atom.element.name] = 1;
    });
    this._elements = Object.keys(dict);
    return this._elements;
  }
  getResidueNames() {
    if (this.hasOwnProperty("_residueNames")) {
      return this._residueNames;
    }
    const dict = {};
    this.forEachResidue((res) => {
      dict[res._type._name] = 1;
    });
    this._residueNames = Object.keys(dict);
    return this._residueNames;
  }
  getChainNames() {
    if (this.hasOwnProperty("_chainNames")) {
      return this._chainNames;
    }
    const dict = {};
    this.forEachChain((chain) => {
      dict[chain._name] = 1;
    });
    this._chainNames = Object.keys(dict);
    return this._chainNames;
  }
  getAltLocNames() {
    if (this.hasOwnProperty("_altlocNames")) {
      return this._altlocNames;
    }
    const dict = {};
    this.forEachAtom((atom) => {
      dict[String.fromCharCode(atom.location)] = 1;
    });
    this._altlocNames = Object.keys(dict);
    return this._altlocNames;
  }
  getVoxelWorld() {
    if (!this.hasOwnProperty("_voxelWorld")) {
      try {
        this._voxelWorld = new chem_VoxelWorld(this.getDefaultBoundaries().boundingBox, new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Vector3(VOXEL_SIZE, VOXEL_SIZE, VOXEL_SIZE));
        this._voxelWorld.addAtoms(this);
      } catch (e2) {
        logger.warn("Unable to create voxel world");
        this._voxelWorld = null;
      }
    }
    return this._voxelWorld;
  }
  /**
   * Simple function to make unified routine procedure without code duplication.
   * @param {Array} srcArray   - Source chemical structure array (will be part of resulting chemical structure array).
   * @param {Array} dstArray   - Resulting chemical structure array.
   * @param {number} param     - Parameter for processor.
   * @param {function} functor - Processor for every element in array.
   */
  addElement(srcArray, dstArray, param, functor) {
    const {
      length
    } = srcArray;
    for (let i2 = 0; i2 < length; ++i2) {
      const elem = srcArray[i2];
      functor(elem, param);
      dstArray.push(elem);
    }
  }
  // this function joins multiple complexes into one (this)
  // atom, bond, ... objects are reused -- so input complexes are no longer valid
  joinComplexes(complexes) {
    this._chains = [];
    this._components = [];
    this._helices = [];
    this._sheets = [];
    this.structures = [];
    this._atoms = [];
    this._residues = [];
    this._bonds = [];
    this._sgroups = [];
    const self2 = this;
    let atomBias = 0;
    let bondBias = 0;
    let residueBias = 0;
    let chainBias = 0;
    let componentBias = 0;
    function processAtom(atom, bias) {
      atom.serial += bias;
      atom.index += bias;
    }
    function processBond(bond, bias) {
      bond._index += bias;
    }
    function processResidue(residue, bias) {
      residue._index += bias;
    }
    function processChain(chain, bias) {
      chain._complex = self2;
      chain._index += bias;
    }
    function processComponent(component, bias) {
      component._complex = self2;
      component._index += bias;
    }
    function doNothing() {
    }
    for (let i2 = 0; i2 < complexes.length; ++i2) {
      const c2 = complexes[i2];
      this.addElement(c2._atoms, this._atoms, atomBias, processAtom);
      this.addElement(c2._bonds, this._bonds, bondBias, processBond);
      this.addElement(c2._residues, this._residues, residueBias, processResidue);
      this.addElement(c2._chains, this._chains, chainBias, processChain);
      this.addElement(c2._sheets, this._sheets, 0, doNothing);
      this.addElement(c2._helices, this._helices, 0, doNothing);
      this.addElement(c2._sgroups, this._sgroups, 0, doNothing);
      this.addElement(c2._components, this._components, componentBias, processComponent);
      this.addElement(c2.structures, this.structures, 0, doNothing);
      for (const rt in c2._residueTypes) {
        if (c2._residueTypes.hasOwnProperty(rt)) {
          this._residueTypes[rt] = c2._residueTypes[rt];
        }
      }
      atomBias += c2._atoms.length;
      bondBias += c2._bonds.length;
      residueBias += c2._residues.length;
      chainBias += c2._chains.length;
      componentBias += c2._components.length;
    }
    this._computeBounds();
  }
  /**
   * Replace secondary structure with calculated one.
   *
   * DSSP algorithm implementation is used.
   *
   * Kabsch W, Sander C. 1983. Dictionary of protein secondary structure: pattern recognition of hydrogen-bonded and
   * geometrical features. Biopolymers. 22(12):2577-2637. doi:10.1002/bip.360221211.
   */
  dssp() {
    const ssMap = new SecondaryStructureMap(this);
    const structures = this.structures = [];
    const helices = this._helices = [];
    const sheets = this._sheets = [];
    const getSheet = (index) => {
      let item = sheets[index];
      if (!item) {
        item = sheets[index] = new chem_Sheet(String(index), 0);
      }
      return item;
    };
    let lastCode;
    let lastSheetIndex;
    let lastHelixIndex = 0;
    let curStructure = null;
    for (let i2 = 0, n = this._residues.length; i2 < n; ++i2) {
      const curCode = ssMap._ss[i2];
      const curResidue = this._residues[i2];
      const curSheetIndex = ssMap._sheet[i2];
      if (curCode === lastCode && curSheetIndex === lastSheetIndex) {
        curResidue._secondary = curStructure;
        if (curStructure) {
          curStructure.term = curResidue;
        }
        if (curStructure instanceof chem_Helix) {
          curStructure.length++;
        }
        continue;
      }
      const helixClass = helixClassMap[curCode];
      const loopType = loopMap[curCode];
      if (curCode === Complex_StructureType.STRAND) {
        const curSheet = getSheet(curSheetIndex);
        curStructure = new chem_Strand(curSheet, curResidue, curResidue, 0, null, null);
        curSheet.addStrand(curStructure);
      } else if (helixClass !== void 0) {
        lastHelixIndex++;
        curStructure = new chem_Helix(helixClass, curResidue, curResidue, lastHelixIndex, String(lastHelixIndex), "", 1);
        helices.push(curStructure);
      } else if (loopType !== void 0) {
        curStructure = new chem_StructuralElement(loopType, curResidue, curResidue);
      } else {
        curStructure = null;
      }
      if (curStructure) {
        structures.push(curStructure);
      }
      curResidue._secondary = curStructure;
      lastCode = curCode;
      lastSheetIndex = curSheetIndex;
    }
    this._sheets = sheets.filter((_sheet) => true);
  }
};
Complex.prototype.id = "Complex";
Complex.prototype.name = "";
var chem_Complex = Complex;
function pow2ceil(v2) {
  let p2 = 2;
  v2 = v2 - 1 >> 1;
  while (v2) {
    p2 <<= 1;
    v2 >>= 1;
  }
  return p2;
}
var Volume = class _Volume {
  constructor(type, dimensions, box, vecSize, data, volumeInfo) {
    this._box = box.clone();
    this._dimVec = Math.max(Math.floor(vecSize || 1), 1);
    this._volumeInfo = volumeInfo;
    if (dimensions instanceof Array) {
      [this._dimX, this._dimY, this._dimZ] = dimensions;
    } else {
      this._dimX = dimensions.x;
      this._dimY = dimensions.y;
      this._dimZ = dimensions.z;
    }
    this._dimX = Math.max(Math.floor(this._dimX), 1);
    this._dimY = Math.max(Math.floor(this._dimY), 1);
    this._dimZ = Math.max(Math.floor(this._dimZ), 1);
    this._rowElements = this._dimVec * this._dimX;
    this._planeElements = this._rowElements * this._dimY;
    this._totalElements = this._planeElements * this._dimZ;
    this._data = data || utils.allocateTyped(type, this._totalElements);
    switch (this._dimVec) {
      case 1:
        break;
      case 2:
        this.getValue = function(x3, y2, z) {
          const idx = x3 * this._dimVec + y2 * this._rowElements + z * this._planeElements;
          return [this._data[idx], this._data[idx + 1]];
        };
        this.setValue = function(x3, y2, z, a2, b2) {
          const idx = x3 * this._dimVec + y2 * this._rowElements + z * this._planeElements;
          this._data[idx] = a2;
          this._data[idx + 1] = b2;
        };
        this.addValue = function(x3, y2, z, a2, b2) {
          const idx = x3 * this._dimVec + y2 * this._rowElements + z * this._planeElements;
          this._data[idx] += a2;
          this._data[idx + 1] += b2;
        };
        break;
      case 3:
        this.getValue = function(x3, y2, z) {
          const idx = x3 * this._dimVec + y2 * this._rowElements + z * this._planeElements;
          return [this._data[idx], this._data[idx + 1], this._data[idx + 2]];
        };
        this.setValue = function(x3, y2, z, a2, b2, c2) {
          const idx = x3 * this._dimVec + y2 * this._rowElements + z * this._planeElements;
          this._data[idx] = a2;
          this._data[idx + 1] = b2;
          this._data[idx + 2] = c2;
        };
        this.addValue = function(x3, y2, z, a2, b2, c2) {
          const idx = x3 * this._dimVec + y2 * this._rowElements + z * this._planeElements;
          this._data[idx] += a2;
          this._data[idx + 1] += b2;
          this._data[idx + 2] += c2;
        };
        break;
      default:
        throw new Error("Volume: invalid vector dimension");
    }
  }
  // default getter assumes it's a scalar field
  getValue(x3, y2, z) {
    return this._data[x3 + y2 * this._rowElements + z * this._planeElements];
  }
  // default setter assumes it's a scalar field
  setValue(x3, y2, z, val) {
    this._data[x3 + y2 * this._rowElements + z * this._planeElements] = val;
  }
  // default adder assumes it's a scalar field
  addValue(x3, y2, z, val) {
    this._data[x3 + y2 * this._rowElements + z * this._planeElements] += val;
  }
  getDimensions() {
    return [this._dimX, this._dimY, this._dimZ];
  }
  getBox() {
    return this._box;
  }
  getVolumeInfo() {
    return this._volumeInfo;
  }
  getCellSize() {
    const boxSize = new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Vector3();
    this._box.getSize(boxSize);
    const res = new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Vector3();
    res.x = this._dimX > 1 ? boxSize.x / (this._dimX - 1) : 0;
    res.y = this._dimY > 1 ? boxSize.y / (this._dimY - 1) : 0;
    res.z = this._dimZ > 1 ? boxSize.z / (this._dimZ - 1) : 0;
    return res;
  }
  computeGradient() {
    if (this._dimVec !== 1) {
      return null;
    }
    const gradient = new _Volume(Float32Array, [this._dimX, this._dimY, this._dimZ], this._box, 3);
    const vl = this.getCellSize();
    const vs = new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Vector3(-0.5 / vl.x, -0.5 / vl.y, -0.5 / vl.z);
    function clamp3(val, min, max) {
      return Math.min(max, Math.max(min, val));
    }
    const xSize = this._dimX;
    const ySize = this._dimY;
    const zSize = this._dimZ;
    const volMap = this._data;
    function _voxelValue(x3, y2, z) {
      return volMap[z * xSize * ySize + y2 * xSize + x3];
    }
    for (let zi = 0; zi < zSize; ++zi) {
      const zm = clamp3(zi - 1, 0, zSize - 1);
      const zp = clamp3(zi + 1, 0, zSize - 1);
      for (let yi = 0; yi < ySize; ++yi) {
        const ym = clamp3(yi - 1, 0, ySize - 1);
        const yp = clamp3(yi + 1, 0, ySize - 1);
        for (let xi = 0; xi < xSize; ++xi) {
          const xm = clamp3(xi - 1, 0, xSize - 1);
          const xp = clamp3(xi + 1, 0, xSize - 1);
          gradient.setValue(xi, yi, zi, (_voxelValue(xp, yi, zi) - _voxelValue(xm, yi, zi)) * vs.x, (_voxelValue(xi, yp, zi) - _voxelValue(xi, ym, zi)) * vs.y, (_voxelValue(xi, yi, zp) - _voxelValue(xi, yi, zm)) * vs.z);
        }
      }
    }
    return gradient;
  }
  normalize() {
    const data = this._data;
    let min = data[0];
    let max = data[0];
    for (let i2 = 1; i2 < data.length; ++i2) {
      min = Math.min(min, data[i2]);
      max = Math.max(max, data[i2]);
    }
    const d2 = 1 / (max - min);
    if (d2 === 0) {
      return;
    }
    for (let i2 = 0; i2 < data.length; ++i2) {
      data[i2] = d2 * (data[i2] - min);
    }
  }
  getTiledTextureStride() {
    return [this._dimX + 2, this._dimY + 2];
  }
  buildTiledTexture() {
    let tilesX = Math.ceil(Math.sqrt(this._dimZ * this._dimY / this._dimX));
    let width = tilesX * (this._dimX + 2) - 1;
    width = pow2ceil(width);
    tilesX = Math.floor(width / (this._dimX + 2));
    const tilesY = Math.ceil(this._dimZ / tilesX);
    let height = tilesY * (this._dimY + 2) - 1;
    height = pow2ceil(height);
    const data = new Uint8Array(width * height);
    let src2;
    let dst;
    for (let tileRow = 0; tileRow < tilesY; ++tileRow) {
      for (let row = 0; row < this._dimY; ++row) {
        src2 = tileRow * tilesX * this._planeElements + row * this._rowElements;
        dst = width * (tileRow * (this._dimY + 2) + row);
        for (let t2 = 0; t2 < tilesX; ++t2) {
          for (let x3 = 0; x3 < this._dimX; ++x3) {
            data[dst++] = 255 * this._data[src2++];
          }
          data[dst++] = 255 * this._data[src2 - 1];
          if (t2 < tilesX - 1) {
            src2 += this._planeElements - this._rowElements;
            data[dst++] = 255 * this._data[src2];
          }
        }
      }
    }
    for (let tileRow = 0; tileRow < tilesY; ++tileRow) {
      src2 = width * (tileRow * (this._dimY + 2) + this._dimY - 1);
      dst = src2 + width;
      for (let x3 = 0; x3 < width; ++x3) {
        data[dst++] = data[src2++];
      }
      if (tileRow < tilesY - 1) {
        src2 = width * (tileRow + 1) * (this._dimY + 2);
        dst = src2 - width;
        for (let x3 = 0; x3 < width; ++x3) {
          data[dst++] = data[src2++];
        }
      }
    }
    const texture = new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.DataTexture(data, width, height, external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.LuminanceFormat, external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.UnsignedByteType, external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.UVMapping, external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.ClampToEdgeWrapping, external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.ClampToEdgeWrapping, external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.LinearFilter, external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.LinearFilter);
    texture.needsUpdate = true;
    return texture;
  }
  /* ********************************************************************************
   *
   * Methods that provide direct access to internal array (for better performance)
   *
   ******************************************************************************** */
  getData() {
    return this._data;
  }
  getDirectIdx(x3, y2, z) {
    return x3 * this._dimVec + y2 * this._rowElements + z * this._planeElements;
  }
  getStrideX() {
    return this._dimVec;
  }
  getStrideY() {
    return this._rowElements;
  }
  getStrideZ() {
    return this._planeElements;
  }
};
Volume.prototype.id = "Volume";
var chem_Volume = Volume;
var Molecule = class {
  constructor(complex, name, index) {
    this.complex = complex;
    this.name = name || "";
    this.residues = [];
    this.mask = 1 | 0;
    this.index = index || -1;
  }
  forEachResidue(process) {
    const {
      residues
    } = this;
    for (let i2 = 0, n = residues.length; i2 < n; ++i2) {
      process(residues[i2]);
    }
  }
  collectMask() {
    let mask = 4294967295;
    const {
      residues
    } = this;
    for (let i2 = 0, n = residues.length; i2 < n; ++i2) {
      mask &= residues[i2]._mask;
    }
    this.mask = mask;
  }
};
var chem_Molecule = Molecule;
var chem = {
  Atom: chem_Atom,
  Element: chem_Element,
  Bond: chem_Bond,
  Residue: chem_Residue,
  ResidueType: chem_ResidueType,
  Chain: chem_Chain,
  Helix: chem_Helix,
  Strand: chem_Strand,
  Sheet: chem_Sheet,
  SGroup: chem_SGroup,
  Assembly: chem_Assembly,
  Complex: chem_Complex,
  Volume: chem_Volume,
  VoxelWorld: chem_VoxelWorld,
  selectors: chem_selectors,
  Molecule: chem_Molecule
};
var CSS2DObject = class _CSS2DObject extends external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Object3D {
  constructor(element) {
    super();
    const self2 = this;
    this._element = element;
    this._element.style.position = "absolute";
    this.addEventListener("removed", () => {
      if (self2._element.parentNode !== null) {
        self2._element.parentNode.removeChild(self2._element);
      }
    });
  }
  getElement() {
    return this._element;
  }
  /**
   * Sets label transparency.
   *
   * @param {number} transp    - in [0; 1] 1 means fully transparent
   */
  setTransparency(transp) {
    const el = this.getElement();
    if (el === null) {
      return;
    }
    if (transp === 1) {
      el.style.display = "none";
      return;
    }
    el.style.display = "inline";
    const op = 1 - transp;
    const top = op.toString();
    const op100 = op * 100;
    el.style.opacity = top;
    el.style.filter = `alpha(opacity=${op100})`;
  }
  clone() {
    const obj = new _CSS2DObject(this._element);
    obj.copy(this);
    return obj;
  }
};
var gfx_CSS2DObject = CSS2DObject;
var RCGroup = class extends external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Group {
  raycast(raycaster, intersects2) {
    if (!this.visible) {
      return;
    }
    const {
      children
    } = this;
    for (let i2 = 0, n = children.length; i2 < n; ++i2) {
      children[i2].raycast(raycaster, intersects2);
    }
  }
  enableSubset(mask, innerOnly) {
    const {
      children
    } = this;
    for (let i2 = 0, n = children.length; i2 < n; ++i2) {
      if (children[i2].enableSubset) {
        children[i2].enableSubset(mask, innerOnly);
      }
    }
  }
  disableSubset(mask, innerOnly) {
    const {
      children
    } = this;
    for (let i2 = 0, n = children.length; i2 < n; ++i2) {
      if (children[i2].disableSubset) {
        children[i2].disableSubset(mask, innerOnly);
      }
    }
  }
  isEmpty() {
    return this.children.length === 0;
  }
  updateToFrame(frameData) {
    const {
      children
    } = this;
    for (let i2 = 0, n = children.length; i2 < n; ++i2) {
      if (children[i2].updateToFrame) {
        children[i2].updateToFrame(frameData);
      }
    }
  }
  getSubset(mask, innerOnly) {
    const totalSubset = [];
    const {
      children
    } = this;
    for (let i2 = 0, n = children.length; i2 < n; ++i2) {
      if (children[i2].getSubset) {
        Array.prototype.push.apply(totalSubset, children[i2].getSubset(mask, innerOnly));
      }
    }
    return totalSubset;
  }
};
var gfx_RCGroup = RCGroup;
var ScreenQuad_namespaceObject = "uniform mat4 projectionMatrix;\r\nuniform mat4 modelViewMatrix;\r\n\r\nattribute vec2 uv;\r\nattribute vec3 position;\r\n\r\nvarying vec2 vUv;\r\n\r\nvoid main() {\r\n  vUv = uv;\r\n  gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\r\n}\r\n";
var ScreenQuadFromTex_namespaceObject = "precision highp float;\r\n\r\nvarying vec2 vUv;\r\nuniform sampler2D srcTex;\r\nuniform float opacity;\r\n\r\nvoid main() {\r\n  vec4 color = texture2D(srcTex, vUv);\r\n  gl_FragColor = vec4(color.xyz, color.a * opacity);\r\n}\r\n";
var ScreenQuadFromTexWithDistortion_namespaceObject = "precision highp float;\r\n\r\nvarying vec2 vUv;\r\nuniform sampler2D srcTex;\r\nuniform float coef;\r\n\r\nvoid main() {\r\n  vec2 uv = vUv * 2.0 - 1.0;\r\n  float r2 = dot(uv, uv);\r\n  vec2 tc = uv * (1.0 + coef * r2);\r\n  if (!all(lessThan(abs(tc), vec2(1.0))))\r\n    discard;\r\n  tc = 0.5 * (tc + 1.0);\r\n  gl_FragColor = texture2D(srcTex, tc);\r\n}\r\n";
var LAYERS = {
  DEFAULT: 0,
  VOLUME: 1,
  TRANSPARENT: 2,
  PREPASS_TRANSPARENT: 3,
  VOLUME_BFPLANE: 4,
  COLOR_FROM_POSITION: 5,
  SHADOWMAP: 6
};
var SELECTION_LAYERS = [
  // These layers, that are used in the selection by ray casting
  LAYERS.DEFAULT,
  LAYERS.TRANSPARENT
];
external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Object3D.prototype.resetTransform = function() {
  this.position.set(0, 0, 0);
  this.quaternion.set(0, 0, 0, 1);
  this.scale.set(1, 1, 1);
};
external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Object3D.prototype.updateMatrixWorldRecursive = function() {
  if (this.parent != null) {
    this.parent.updateMatrixWorldRecursive();
  }
  this.updateMatrixWorld();
};
external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Object3D.prototype.addSavingWorldTransform = function() {
  const _worldMatrixInverse = new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Matrix4();
  return function(object) {
    if (object instanceof external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Object3D) {
      _worldMatrixInverse.copy(this.matrixWorld).invert();
      _worldMatrixInverse.multiply(object.matrixWorld);
      object.matrix.copy(_worldMatrixInverse);
      object.matrix.decompose(object.position, object.quaternion, object.scale);
      this.add(object);
    }
  };
}();
external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.WebGLRenderer.prototype.renderDummyQuad = function() {
  const _material = new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.MeshBasicMaterial({
    transparent: true,
    opacity: 0,
    depthWrite: false
  });
  const _scene = new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Scene();
  const _quad = new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Mesh(new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.PlaneGeometry(0.01, 0.01), _material);
  _scene.add(_quad);
  const _camera2 = new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.OrthographicCamera(-0.5, 0.5, 0.5, -0.5, -1e4, 1e4);
  _camera2.position.z = 100;
  return function() {
    this.render(_scene, _camera2);
  };
}();
external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.WebGLRenderer.prototype.renderScreenQuad = function() {
  const _scene = new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Scene();
  const _quad = new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Mesh(new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.PlaneGeometry(1, 1));
  _scene.add(_quad);
  const _camera2 = new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.OrthographicCamera(-0.5, 0.5, 0.5, -0.5, -1e4, 1e4);
  _camera2.position.z = 100;
  return function(material) {
    _quad.material = material;
    this.render(_scene, _camera2);
  };
}();
external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Matrix4.prototype.isIdentity = function() {
  const identity = new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Matrix4();
  return function() {
    return identity.equals(this);
  };
}();
external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Matrix4.prototype.applyToPointsArray = function(array, stride, w2) {
  if (!array || !stride || stride < 3) {
    return array;
  }
  w2 = w2 || 0;
  const e2 = this.elements;
  for (let i2 = 0; i2 < array.length; i2 += stride) {
    const x3 = array[i2];
    const y2 = array[i2 + 1];
    const z = array[i2 + 2];
    const persp = 1 / (e2[3] * x3 + e2[7] * y2 + e2[11] * z + e2[15]);
    array[i2] = (e2[0] * x3 + e2[4] * y2 + e2[8] * z + e2[12] * w2) * persp;
    array[i2 + 1] = (e2[1] * x3 + e2[5] * y2 + e2[9] * z + e2[13] * w2) * persp;
    array[i2 + 2] = (e2[2] * x3 + e2[6] * y2 + e2[10] * z + e2[14] * w2) * persp;
  }
  return array;
};
var ScreenQuadMaterial = class extends external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.RawShaderMaterial {
  constructor(params) {
    if (params.uniforms === void 0) {
      params.uniforms = {};
    }
    params.uniforms.srcTex = {
      type: "t",
      value: null
    };
    params.vertexShader = ScreenQuad_namespaceObject;
    params.transparent = false;
    params.depthTest = false;
    params.depthWrite = false;
    super(params);
  }
};
external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.WebGLRenderer.prototype.renderScreenQuadFromTex = function() {
  const _material = new ScreenQuadMaterial({
    uniforms: {
      opacity: {
        type: "f",
        value: 1
      }
    },
    fragmentShader: ScreenQuadFromTex_namespaceObject,
    transparent: true
  });
  return function(srcTex, opacity) {
    _material.uniforms.srcTex.value = srcTex;
    _material.transparent = opacity < 1;
    _material.uniforms.opacity.value = opacity;
    this.renderScreenQuad(_material);
  };
}();
external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.WebGLRenderer.prototype.renderScreenQuadFromTexWithDistortion = function() {
  const _material = new ScreenQuadMaterial({
    uniforms: {
      coef: {
        type: "f",
        value: 1
      }
    },
    fragmentShader: ScreenQuadFromTexWithDistortion_namespaceObject
  });
  return function(srcTex, coef) {
    _material.uniforms.srcTex.value = srcTex;
    _material.uniforms.coef.value = coef;
    this.renderScreenQuad(_material);
  };
}();
external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.PerspectiveCamera.prototype.setMinimalFov = function(angle) {
  if (this.aspect >= 1) {
    this.fov = angle;
  } else {
    this.fov = external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.MathUtils.radToDeg(2 * Math.atan(Math.tan(external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.MathUtils.degToRad(angle) * 0.5) / this.aspect));
  }
};
external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.StereoCamera.prototype.updateHalfSized = function(camera, angle) {
  const originalAspect = camera.aspect;
  const originalFov = camera.fov;
  camera.aspect = originalAspect / 2;
  camera.setMinimalFov(angle);
  camera.updateProjectionMatrix();
  this.update(camera);
  camera.aspect = originalAspect;
  camera.fov = originalFov;
  camera.updateProjectionMatrix();
};
external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.PerspectiveCamera.prototype.setDistanceToFit = function(radius, angle) {
  this.position.z = radius / Math.sin(0.5 * external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.MathUtils.degToRad(angle));
};
external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Raycaster.prototype.intersectVisibleObject = function(gfxObj, camera, clipPlane, fogFarPlane) {
  const intersects2 = this.intersectObject(gfxObj, false);
  if (intersects2.length === 0) {
    return null;
  }
  const nearPlane = Math.min(camera.near, clipPlane);
  let i2;
  let p2 = intersects2[0];
  const v2 = new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Vector3();
  for (i2 = 0; i2 < intersects2.length; ++i2) {
    p2 = intersects2[i2];
    v2.copy(p2.point);
    v2.applyMatrix4(camera.matrixWorldInverse);
    if (v2.z <= -nearPlane) {
      break;
    }
  }
  if (i2 === intersects2.length) {
    return null;
  }
  const farPlane = Math.min(camera.far, fogFarPlane);
  v2.copy(p2.point);
  v2.applyMatrix4(camera.matrixWorldInverse);
  if (v2.z <= -farPlane) {
    return null;
  }
  return p2;
};
external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Matrix4.prototype.extractScale = function() {
  const _v = new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Vector3();
  return function(scale) {
    if (scale === void 0) {
      logger.debug("extractScale(): new is too expensive operation to do it on-the-fly");
      scale = _v.clone();
    }
    const te = this.elements;
    scale.x = _v.set(te[0], te[1], te[2]).length();
    scale.y = _v.set(te[4], te[5], te[6]).length();
    scale.z = _v.set(te[8], te[9], te[10]).length();
    const det = this.determinant();
    if (det < 0) {
      scale.x = -scale.x;
    }
    return scale;
  };
}();
function _calcCylinderMatrix(posBegin, posEnd, radius) {
  const posCenter = posBegin.clone().lerp(posEnd, 0.5);
  const matScale = new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Matrix4();
  matScale.makeScale(radius, posBegin.distanceTo(posEnd), radius);
  const matRotHalf = new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Matrix4();
  matRotHalf.makeRotationX(Math.PI / 2);
  const matRotLook = new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Matrix4();
  const vUp = new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Vector3(0, 1, 0);
  matRotLook.lookAt(posCenter, posEnd, vUp);
  matRotLook.multiply(matRotHalf);
  matRotLook.multiply(matScale);
  matRotLook.setPosition(posCenter);
  return matRotLook;
}
function _calcChunkMatrix(eye, target, up, rad) {
  const matScale = new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Matrix4();
  matScale.makeScale(rad.x, rad.y, 0);
  const matRotLook = new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Matrix4();
  matRotLook.lookAt(eye, target, up);
  matRotLook.multiply(matScale);
  matRotLook.setPosition(eye);
  return matRotLook;
}
function _groupHasGeometryToRender(group) {
  let hasGeoms = false;
  group.traverse((node) => {
    if (node.hasOwnProperty("geometry") || node instanceof gfx_CSS2DObject) {
      hasGeoms = true;
    }
  });
  return hasGeoms;
}
function _buildDistorionMesh(widthSegments, heightSegements, coef) {
  function calcInverseBarrel(r2) {
    const epsilon = 1e-5;
    let prevR2 = 0;
    let curR2 = r2;
    let dr = 1;
    while (Math.abs(curR2 - prevR2) > epsilon) {
      dr = 1 + coef * curR2;
      prevR2 = curR2;
      curR2 = r2 / (dr * dr);
    }
    return 1 / dr;
  }
  const geo = new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.PlaneGeometry(2, 2, widthSegments, heightSegements);
  const pos = geo.getAttribute("position");
  for (let i2 = 0; i2 < pos.count; ++i2) {
    const x3 = pos.array[3 * i2];
    const y2 = pos.array[3 * i2 + 1];
    const c2 = calcInverseBarrel(x3 * x3 + y2 * y2);
    pos.setXY(i2, c2 * x3, c2 * y2);
  }
  return geo;
}
external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.BufferAttribute.prototype.copyAtList = function(attribute, indexList) {
  console.assert(this.itemSize === attribute.itemSize, "DEBUG: BufferAttribute.copyAtList buffers have different item size.");
  const {
    itemSize
  } = this;
  for (let i2 = 0, n = indexList.length; i2 < n; ++i2) {
    for (let j = 0; j < itemSize; ++j) {
      this.array[i2 * itemSize + j] = attribute.array[indexList[i2] * itemSize + j];
    }
  }
  return this;
};
function fillArray(array, value, startIndex, endIndex) {
  startIndex = typeof startIndex !== "undefined" ? startIndex : 0;
  endIndex = typeof endIndex !== "undefined" ? endIndex : array.length;
  for (let i2 = startIndex; i2 < endIndex; ++i2) {
    array[i2] = value;
  }
}
function removeChildren(object) {
  const {
    children
  } = object;
  for (let i2 = 0, n = children.length; i2 < n; ++i2) {
    const child = children[i2];
    child.parent = null;
    child.dispatchEvent({
      type: "removed"
    });
  }
  object.children = [];
}
function clearTree(object) {
  object.traverse((obj) => {
    if (obj instanceof external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Mesh || obj instanceof external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.LineSegments || obj instanceof external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Line) {
      obj.geometry.dispose();
    }
  });
  removeChildren(object);
}
function destroyObject(object) {
  clearTree(object);
  if (object.parent) {
    object.parent.remove(object);
  } else {
    object.dispatchEvent({
      type: "removed"
    });
  }
}
function belongToSelectLayers(object) {
  for (let i2 = 0; i2 < SELECTION_LAYERS.length; i2++) {
    if ((object.layers.mask >> SELECTION_LAYERS[i2] & 1) === 1) {
      return true;
    }
  }
  return false;
}
function processObjRenderOrder(root, idMaterial) {
  const renderOrder = +(idMaterial !== "BA");
  root.traverse((object) => {
    if (object.isGroup) {
      object.renderOrder = renderOrder;
    }
  });
}
function applySelectionMaterial(geo) {
  geo.traverse((node) => {
    if ("material" in node) {
      node.material = node.material.clone(true);
      node.material.setValues({
        depthFunc: external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.LessEqualDepth,
        overrideColor: true,
        fog: false,
        lights: false,
        shadowmap: false
      });
      node.material.setUberOptions({
        fixedColor: new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Color(16776960),
        zOffset: -1e-6
      });
    }
  });
}
function getMiddlePoint(point1, point2, optionalTarget) {
  const result = optionalTarget || new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Vector3();
  result.set(0, 0, 0);
  result.addScaledVector(point1, 0.5);
  result.addScaledVector(point2, 0.5);
  return result;
}
var _oldInstancedBufferGeometryCopy = external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.InstancedBufferGeometry.prototype.copy;
external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.InstancedBufferGeometry.prototype.copy = function(source) {
  _oldInstancedBufferGeometryCopy.call(this, source);
  if (this.instanceCount === void 0) {
    this.instanceCount = Infinity;
  }
};
var gfxutils = {
  calcCylinderMatrix: _calcCylinderMatrix,
  calcChunkMatrix: _calcChunkMatrix,
  groupHasGeometryToRender: _groupHasGeometryToRender,
  buildDistorionMesh: _buildDistorionMesh,
  RCGroup: gfx_RCGroup,
  fillArray,
  clearTree,
  destroyObject,
  belongToSelectLayers,
  processObjRenderOrder,
  applySelectionMaterial,
  getMiddlePoint,
  LAYERS
};
var _defaultBoundaries = {
  boundingBox: new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Box3(new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Vector3(-1, -1, -1), new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Vector3(1, 1, 1)),
  boundingSphere: new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Sphere(new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Vector3(0, 0, 0), 1)
};
var Visual = class extends gfxutils.RCGroup {
  constructor(name, dataSource) {
    super(name, dataSource);
    this.name = name;
    this._dataSource = dataSource;
  }
  release() {
    if (this.parent) {
      this.parent.remove(this);
    }
  }
  getDataSource() {
    return this._dataSource;
  }
  getBoundaries() {
    return _defaultBoundaries;
  }
};
var src_Visual = Visual;
function _ensureArray(x3) {
  if (x3 === null || x3 === void 0 || Array.isArray(x3)) {
    return x3;
  }
  return [x3];
}
var EntityList = class _EntityList {
  /**
   * Create a list of objects.
   * The objects can be indexed by one or more properties for the later retrieval.
   *
   * @param {!Array<Object>=} entities A list of objects to automatically register at creation time.
   * @param {!Array<string>=} indices A list of property names to use for case-insensitive indexing.
   *   By default, a single `.id` property is used.
   * @see EntityList#register
   */
  constructor() {
    let entities = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
    let indices = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : ["id"];
    this._list = [];
    this._dict = {};
    this._indices = [...indices];
    this._indices.forEach((index) => {
      this._dict[index] = {};
    });
    entities.forEach((entity) => this.register(entity));
  }
  /**
   * Add a value to the end of a list.
   * The list will contain only one copy of the value.
   *
   * @param {!Array} list An array.
   * @param {*} value A value to add.
   * @see EntityList.unregisterFromList
   * @see EntityList.registerInDict
   */
  static registerInList(list, value) {
    if (!list.includes(value)) {
      list.push(value);
    }
  }
  /**
   * Remove a value from a list if it is there.
   *
   * @param {!Array} list An array.
   * @param {*} value A value to remove.
   * @see EntityList.registerInList
   */
  static unregisterFromList(list, value) {
    const pos = list.indexOf(value);
    if (pos !== -1) {
      list.splice(pos, 1);
    }
  }
  /**
   * Add a value to a dictionary.
   * The value may be stored under multiple different keys (aliases).
   * There might be multiples values stored under the same key.
   *
   * @param {!Object<string,*>} dict A dictionary.
   * @param {!Array<string>} keys An array of keys.
   * @param {*} value A value to add.
   * @see EntityList.unregisterFromDict
   * @see EntityList.registerInList
   */
  static registerInDict(dict, keys, value) {
    keys.forEach((key) => {
      key = key.toLowerCase();
      const list = dict[key] = dict[key] || [];
      if (!list.includes(value)) {
        list.push(value);
      }
    });
  }
  /**
   * Remove a value from a dictionary.
   * The value may be stored under multiple different keys (aliases).
   * There might be multiples values stored under the same key.
   *
   * @param {!Object<string,*>} dict A dictionary.
   * @param {!Array<string>} keys An array of keys.
   * @param {*} value A value to add.
   * @see EntityList.registerInDict
   */
  static unregisterFromDict(dict, keys, value) {
    keys.forEach((key) => {
      key = key.toLowerCase();
      const list = dict[key];
      if (list) {
        const pos = list.indexOf(value);
        if (pos !== -1) {
          list.splice(pos, 1);
        }
        if (list.length === 0) {
          delete dict[key];
        }
      }
    });
  }
  /**
   * Add an entity to this list.
   *
   * @param {!Object} entity An object or a class to register. The object must include all
   *   properties specified as indices on construction.
   * @see EntityList#unregister
   */
  register(entity) {
    _EntityList.registerInList(this._list, entity);
    this._indices.forEach((index) => {
      _EntityList.registerInDict(this._dict[index], _ensureArray(entity[index]), entity);
    });
  }
  /**
   * Remove an entity from this list.
   *
   * @param {!Object} entity An object or a class to unregister. The object may be
   *   missing from the list but it must include all properties specified as indices
   *   on construction.
   * @see EntityList#register
   */
  unregister(entity) {
    _EntityList.unregisterFromList(this._list, entity);
    this._indices.forEach((index) => {
      _EntityList.unregisterFromDict(this._dict[index], _ensureArray(entity[index]), entity);
    });
  }
  /**
   * An ordered list of all registered entities.
   * It is a read-only copy, use {@link EntityList#register} and {@link EntityList#unregister}
   * to modify it.
   *
   * @type {!Array<Object>}
   */
  get all() {
    return [...this._list];
  }
  /**
   * The first registered entity.
   * Use it if you do not care which entity you are referring to.
   *
   * @type {Object=}
   */
  get first() {
    return this._list[0];
  }
  /**
   * Retrieve a list of keys for the index.
   *
   * @param {string=} index One of the indices specified during the list construction. If omitted,
   *   the first of the indices is used.
   * @returns {!Array<string>} An unordered list of keys in the index, i.e. particular property
   *   values for all registered entities.
   */
  keys(index) {
    return Object.keys(this._dict[index || this._indices[0]]);
  }
  /**
   * Retrieve an entity by its key.
   *
   * @param {string} key A case-insensitive property value to look-up.
   * @param {string=} index One of the indices specified during the list construction. If omitted,
   *   the first of the indices is used.
   * @returns {Object=} An object registered in the index under the key. If there are multiple
   *   objects under the same key, the first one is returned.
   */
  get(key, index) {
    const dict = this._dict[index || this._indices[0]];
    if (dict) {
      const values = dict[key && key.toLowerCase()];
      return values && values.length > 0 ? values[0] : void 0;
    }
    return void 0;
  }
};
var utils_EntityList = EntityList;
function makeContextDependent(prototype) {
  Object.defineProperties(prototype, {
    logger: {
      get() {
        return this.context && this.context.logger ? this.context.logger : logger;
      }
    },
    settings: {
      get() {
        return this.context && this.context.settings ? this.context.settings : settings;
      }
    }
  });
}
var utils_makeContextDependent = makeContextDependent;
var _CollisionSphere = class _CollisionSphere {
  constructor(position, radius) {
    this._position = position;
    this._radius = radius;
  }
  raycast(raycaster) {
    const sphere = _CollisionSphere._sphere;
    sphere.set(this._position, this._radius);
    const p2 = new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Vector3();
    if (raycaster.ray.intersectSphere(sphere, p2)) {
      return {
        distance: raycaster.ray.origin.distanceTo(p2),
        point: p2
      };
    }
    return null;
  }
};
__publicField(_CollisionSphere, "_sphere", (() => new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Sphere())());
var CollisionSphere = _CollisionSphere;
var SphereCollisionGeo = (base) => class extends base {
  constructor(count) {
    for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      args[_key - 1] = arguments[_key];
    }
    super(...args);
    this._objects = new Array(count);
    this.boundingSphere = null;
    this.boundingBox = null;
  }
  setSphere(idx, position, radius) {
    this._objects[idx] = new CollisionSphere(position, radius);
  }
  raycast(raycaster, intersects2) {
    for (let i2 = 0, n = this._objects.length; i2 < n; ++i2) {
      const inters = this._objects[i2].raycast(raycaster);
      if (inters) {
        inters.chunkIdx = i2;
        intersects2.push(inters);
      }
    }
  }
  computeBoundingBox() {
    const objects = this._objects;
    let {
      boundingBox
    } = this;
    if (boundingBox === null) {
      this.boundingBox = boundingBox = new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Box3();
    }
    boundingBox.makeEmpty();
    for (let i2 = 0, n = objects.length; i2 < n; ++i2) {
      boundingBox.expandByPoint(objects[i2]._position);
    }
  }
  computeBoundingSphere() {
    this.computeBoundingBox();
    const objects = this._objects;
    const {
      boundingBox
    } = this;
    let radiusSquared = 0;
    const center = new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Vector3();
    boundingBox.getCenter(center);
    for (let i2 = 0, n = objects.length; i2 < n; ++i2) {
      const pos = objects[i2]._position;
      const lengthSquared = center.distanceToSquared(pos);
      if (radiusSquared < lengthSquared) {
        radiusSquared = lengthSquared;
      }
    }
    if (this.boundingSphere === null) {
      this.boundingSphere = new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Sphere();
    }
    this.boundingSphere.set(center, Math.sqrt(radiusSquared));
  }
};
var geometries_SphereCollisionGeo = SphereCollisionGeo;
var tmpColor = new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Color();
var OFFSET_SIZE = 4;
var COLOR_SIZE = 3;
var {
  copySubArrays: InstancedSpheresGeometry_copySubArrays
} = utils;
function setArrayXYZ(arr, idx, x3, y2, z) {
  arr[idx] = x3;
  arr[idx + 1] = y2;
  arr[idx + 2] = z;
}
function setArrayXYZW(arr, idx, x3, y2, z, w2) {
  arr[idx] = x3;
  arr[idx + 1] = y2;
  arr[idx + 2] = z;
  arr[idx + 3] = w2;
}
var InstancedSpheresGeometry = class extends geometries_SphereCollisionGeo(external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.InstancedBufferGeometry) {
  constructor(spheresCount, sphereComplexity, useZSprites) {
    super(spheresCount);
    this._sphGeometry = useZSprites ? new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.PlaneGeometry(2, 2, 1, 1) : new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.SphereBufferGeometry(1, sphereComplexity * 2, sphereComplexity, 0, Math.PI * 2, 0, Math.PI);
    this._init(spheresCount, this._sphGeometry);
  }
  setItem(itemIdx, itemPos, itemRad) {
    setArrayXYZW(this._offsets, itemIdx * OFFSET_SIZE, itemPos.x, itemPos.y, itemPos.z, itemRad);
    this.setSphere(itemIdx, itemPos, itemRad);
  }
  setColor(itemIdx, colorVal) {
    tmpColor.set(colorVal);
    setArrayXYZ(this._colors, itemIdx * COLOR_SIZE, tmpColor.r, tmpColor.g, tmpColor.b);
  }
  startUpdate() {
    return true;
  }
  finishUpdate() {
    this.getAttribute("offset").needsUpdate = true;
    this.getAttribute("color").needsUpdate = true;
  }
  finalize() {
    this.finishUpdate();
    this.computeBoundingSphere();
  }
  setOpacity(chunkIndices, value) {
    const alphaArr = this._alpha;
    for (let i2 = 0, n = chunkIndices.length; i2 < n; ++i2) {
      alphaArr[chunkIndices[i2]] = value;
    }
    this.getAttribute("alphaColor").needsUpdate = true;
  }
  getSubset(chunkIndices) {
    const instanceCount = chunkIndices.length;
    const geom = new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.InstancedBufferGeometry();
    this._init.call(geom, instanceCount, this._sphGeometry);
    InstancedSpheresGeometry_copySubArrays(this._offsets, geom._offsets, chunkIndices, OFFSET_SIZE);
    InstancedSpheresGeometry_copySubArrays(this._colors, geom._colors, chunkIndices, COLOR_SIZE);
    geom.boundingSphere = this.boundingSphere;
    geom.boundingBox = this.boundingBox;
    return [geom];
  }
  _init(spheresCount, sphereGeo) {
    this.copy(sphereGeo);
    this._offsets = utils.allocateTyped(Float32Array, spheresCount * OFFSET_SIZE);
    this._colors = utils.allocateTyped(Float32Array, spheresCount * COLOR_SIZE);
    const alpha = this._alpha = utils.allocateTyped(Float32Array, spheresCount);
    external_module_lodash_commonjs_lodash_commonjs2_lodash_amd_lodash_root_namespaceObject["default"].fill(alpha, 1);
    this.setAttribute("offset", new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.InstancedBufferAttribute(this._offsets, OFFSET_SIZE, false, 1));
    this.setAttribute("color", new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.InstancedBufferAttribute(this._colors, COLOR_SIZE, false, 1));
    this.setAttribute("alphaColor", new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.InstancedBufferAttribute(alpha, 1, false, 1));
  }
};
var geometries_InstancedSpheresGeometry = InstancedSpheresGeometry;
var MAX_IDC_16BIT = 65535;
var VEC_SIZE = 3;
var ChunkedObjectsGeometry_tmpColor = new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Color();
var ChunkedObjectsGeometry = class _ChunkedObjectsGeometry extends external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.BufferGeometry {
  constructor(chunkGeo, chunksCount) {
    super();
    if (this.constructor === _ChunkedObjectsGeometry) {
      throw new Error("Can not instantiate abstract class!");
    }
    this._chunkGeo = chunkGeo;
    this._init(chunkGeo, chunksCount);
  }
  startUpdate() {
    return true;
  }
  finishUpdate() {
    this.getAttribute("position").needsUpdate = true;
    this.getAttribute("normal").needsUpdate = true;
    this.getAttribute("color").needsUpdate = true;
  }
  setColor(chunkIdx, colorVal) {
    ChunkedObjectsGeometry_tmpColor.set(colorVal);
    const colors = this._colors;
    const chunkSize = this._chunkSize;
    for (let i2 = chunkIdx * chunkSize, end = i2 + chunkSize; i2 < end; ++i2) {
      const idx = i2 * VEC_SIZE;
      colors[idx] = ChunkedObjectsGeometry_tmpColor.r;
      colors[idx + 1] = ChunkedObjectsGeometry_tmpColor.g;
      colors[idx + 2] = ChunkedObjectsGeometry_tmpColor.b;
    }
  }
  finalize() {
    this.finishUpdate();
    this.computeBoundingSphere();
  }
  setOpacity(chunkIndices, value) {
    const alphaArr = this._alpha;
    const chunkSize = this._chunkSize;
    for (let i2 = 0, n = chunkIndices.length; i2 < n; ++i2) {
      const left = chunkIndices[i2] * chunkSize;
      external_module_lodash_commonjs_lodash_commonjs2_lodash_amd_lodash_root_namespaceObject["default"].fill(alphaArr, value, left, left + chunkSize);
    }
    this.getAttribute("alphaColor").needsUpdate = true;
  }
  raycast(raycaster, intersects2) {
    const inters = [];
    const mesh = new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Mesh();
    mesh.geometry = this;
    mesh.raycast(raycaster, inters);
    const facesPerChunk = this._chunkGeo.index.count / 3;
    for (let i2 = 0, n = inters.length; i2 < n; ++i2) {
      if (!inters[i2].hasOwnProperty("faceIndex")) {
        continue;
      }
      inters[i2].chunkIdx = Math.floor(inters[i2].faceIndex / facesPerChunk);
      intersects2.push(inters[i2]);
    }
  }
  getSubset(chunkIndices) {
    const instanceCount = chunkIndices.length;
    const geom = new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.BufferGeometry();
    this._init.call(geom, this._chunkGeo, instanceCount);
    const srcPos = this._positions;
    const srcNorm = this._normals;
    const srcColor = this._colors;
    const dstPos = geom._positions;
    const dstNorm = geom._normals;
    const dstColor = geom._colors;
    const chunkSize = this._chunkSize * VEC_SIZE;
    for (let i2 = 0, n = chunkIndices.length; i2 < n; ++i2) {
      const dstPtOffset = i2 * chunkSize;
      const ptIdxBegin = chunkIndices[i2] * chunkSize;
      const ptIdxEnd = ptIdxBegin + chunkSize;
      dstPos.set(srcPos.subarray(ptIdxBegin, ptIdxEnd), dstPtOffset);
      dstNorm.set(srcNorm.subarray(ptIdxBegin, ptIdxEnd), dstPtOffset);
      dstColor.set(srcColor.subarray(ptIdxBegin, ptIdxEnd), dstPtOffset);
    }
    geom.boundingSphere = this.boundingSphere;
    geom.boundingBox = this.boundingBox;
    return [geom];
  }
  _init(chunkGeo, chunksCount) {
    const chunkSize = this._chunkSize = chunkGeo.attributes.position.count;
    const chunkIndex = chunkGeo.index.array;
    const chunkIndexSize = chunkIndex.length;
    const pointsCount = this._chunkSize * chunksCount;
    const use32bitIndex = pointsCount > MAX_IDC_16BIT;
    const indexSize = chunkIndexSize * chunksCount;
    const index = this._index = utils.allocateTyped(use32bitIndex ? Uint32Array : Uint16Array, indexSize);
    this._positions = utils.allocateTyped(Float32Array, pointsCount * VEC_SIZE);
    this._normals = utils.allocateTyped(Float32Array, pointsCount * VEC_SIZE);
    this._colors = utils.allocateTyped(Float32Array, pointsCount * VEC_SIZE);
    const alpha = this._alpha = utils.allocateTyped(Float32Array, pointsCount);
    external_module_lodash_commonjs_lodash_commonjs2_lodash_amd_lodash_root_namespaceObject["default"].fill(alpha, 1);
    for (let i2 = 0; i2 < chunksCount; ++i2) {
      const offset = i2 * chunkIndexSize;
      const posOffset = i2 * chunkSize;
      index.set(chunkIndex, offset);
      for (let j = 0; j < chunkIndexSize; ++j) {
        index[offset + j] += posOffset;
      }
    }
    this.setIndex(new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.BufferAttribute(this._index, 1));
    this.setAttribute("position", new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.BufferAttribute(this._positions, VEC_SIZE));
    this.setAttribute("normal", new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.BufferAttribute(this._normals, VEC_SIZE));
    this.setAttribute("color", new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.BufferAttribute(this._colors, VEC_SIZE));
    this.setAttribute("alphaColor", new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.BufferAttribute(alpha, 1));
  }
};
var geometries_ChunkedObjectsGeometry = ChunkedObjectsGeometry;
var SimpleSpheresGeometry_VEC_SIZE = 3;
var SimpleSpheresGeometry = class extends geometries_SphereCollisionGeo(geometries_ChunkedObjectsGeometry) {
  constructor(spheresCount, sphereComplexity) {
    const sphGeometry = new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.SphereBufferGeometry(1, sphereComplexity * 2, sphereComplexity, 0, Math.PI * 2, 0, Math.PI);
    super(spheresCount, sphGeometry, spheresCount);
    const normals = this._normals;
    const geoNormals = sphGeometry.attributes.normal.array;
    const chunkSize = this._chunkSize;
    this._chunkPos = this._chunkGeo.attributes.position.array;
    this._tmpPositions = utils.allocateTyped(Float32Array, chunkSize * SimpleSpheresGeometry_VEC_SIZE);
    for (let i2 = 0; i2 < spheresCount; ++i2) {
      normals.set(geoNormals, chunkSize * SimpleSpheresGeometry_VEC_SIZE * i2);
    }
  }
  setItem(itemIdx, itemPos, itemRad) {
    const tmpPos = this._tmpPositions;
    const chunkSize = this._chunkSize;
    const geoPos = this._chunkPos;
    for (let i2 = 0; i2 < chunkSize; ++i2) {
      const idx = i2 * 3;
      tmpPos[idx] = itemPos.x + geoPos[idx] * itemRad;
      tmpPos[idx + 1] = itemPos.y + geoPos[idx + 1] * itemRad;
      tmpPos[idx + 2] = itemPos.z + geoPos[idx + 2] * itemRad;
    }
    this._positions.set(tmpPos, chunkSize * itemIdx * SimpleSpheresGeometry_VEC_SIZE);
    this.setSphere(itemIdx, itemPos, itemRad);
  }
};
var geometries_SimpleSpheresGeometry = SimpleSpheresGeometry;
var Simple2CCylindersGeometry_VEC_SIZE = 3;
var centerPos = new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Vector3();
var tmpVector = new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Vector3();
var normMtx = new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Matrix3();
var Simple2CCylindersGeometry = class extends geometries_ChunkedObjectsGeometry {
  constructor(instanceCount, polyComplexity) {
    const cylGeometry = new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.CylinderGeometry(1, 1, 1, Math.max(3, polyComplexity), 2, true);
    super(cylGeometry, 2 * instanceCount);
    const chunkSize = this._chunkSize;
    this._chunkPos = this._chunkGeo.attributes.position.array;
    this._chunkNorms = this._chunkGeo.attributes.normal.array;
    this._tmpVector = utils.allocateTyped(Float32Array, chunkSize * Simple2CCylindersGeometry_VEC_SIZE);
  }
  setItem(itemIdx, botPos, topPos, itemRad) {
    const chunkSize = this._chunkSize;
    const firstOffset = chunkSize * 2 * itemIdx * Simple2CCylindersGeometry_VEC_SIZE;
    const secondOffset = firstOffset + chunkSize * Simple2CCylindersGeometry_VEC_SIZE;
    const tmpArray = this._tmpVector;
    const geoPos = this._chunkPos;
    const geoNorm = this._chunkNorms;
    centerPos.lerpVectors(botPos, topPos, 0.5);
    const mtx1 = gfxutils.calcCylinderMatrix(botPos, centerPos, itemRad);
    normMtx.getNormalMatrix(mtx1);
    let idx;
    for (let i2 = 0; i2 < chunkSize; ++i2) {
      idx = i2 * Simple2CCylindersGeometry_VEC_SIZE;
      tmpVector.fromArray(geoPos, idx);
      tmpVector.applyMatrix4(mtx1);
      tmpVector.toArray(tmpArray, idx);
    }
    this._positions.set(tmpArray, firstOffset);
    centerPos.sub(botPos);
    for (let i2 = 0; i2 < chunkSize; ++i2) {
      idx = i2 * Simple2CCylindersGeometry_VEC_SIZE;
      tmpArray[idx] += centerPos.x;
      tmpArray[idx + 1] += centerPos.y;
      tmpArray[idx + 2] += centerPos.z;
    }
    this._positions.set(tmpArray, secondOffset);
    for (let i2 = 0; i2 < chunkSize; ++i2) {
      idx = i2 * Simple2CCylindersGeometry_VEC_SIZE;
      tmpVector.fromArray(geoNorm, idx);
      tmpVector.applyMatrix3(normMtx);
      tmpVector.toArray(tmpArray, idx);
    }
    this._normals.set(tmpArray, firstOffset);
    this._normals.set(tmpArray, secondOffset);
  }
  setColor(itemIdx, colorVal1, colorVal2) {
    const first = 2 * itemIdx;
    super.setColor(first, colorVal1);
    const second = first + 1;
    super.setColor(second, colorVal2);
  }
};
var geometries_Simple2CCylindersGeometry = Simple2CCylindersGeometry;
var MAX_POINTS_COUNT_16BIT = 65536;
var PTS_PER_TRIANGLE = 3;
var CylinderBufferGeometry2 = class _CylinderBufferGeometry extends external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.BufferGeometry {
  constructor(radiusTop, radiusBottom, height, radialSegments, heightSegments, openEnded) {
    super();
    const thetaStart = 0;
    const thetaLength = 2 * Math.PI;
    this.type = "CylinderBufferGeometry";
    this.parameters = {
      radiusTop,
      radiusBottom,
      height,
      radialSegments,
      heightSegments,
      openEnded
    };
    const hasTop = openEnded === false && radiusTop > 0;
    const hasBottom = openEnded === false && radiusBottom > 0;
    const vertexCount = (heightSegments + 1) * radialSegments + hasTop * (radialSegments + 1) + hasBottom * (radialSegments + 1);
    const facesCount = (2 * heightSegments + hasTop + hasBottom) * radialSegments;
    const heightHalf = height / 2;
    const positions = new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.BufferAttribute(utils.allocateTyped(Float32Array, vertexCount * 3), 3);
    const normals = new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.BufferAttribute(utils.allocateTyped(Float32Array, vertexCount * 3), 3);
    const indices = new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Uint16BufferAttribute(utils.allocateTyped(Uint16Array, facesCount * PTS_PER_TRIANGLE), 1);
    const uvs = new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.BufferAttribute(utils.allocateTyped(Float32Array, vertexCount * 2), 2);
    console.assert(vertexCount < MAX_POINTS_COUNT_16BIT, "DEBUG: Cylinder Geometry has too many vertices (65536 max).");
    let currVtxIdx = 0;
    let currFaceIdx = 0;
    const tanTheta = -(radiusBottom - radiusTop) / height;
    for (let y2 = 0; y2 <= heightSegments; y2++) {
      if (y2 !== heightSegments) {
        for (let i2 = 0; i2 < radialSegments; i2++) {
          const v1 = currVtxIdx + i2;
          const v22 = currVtxIdx + radialSegments + i2;
          const v3 = currVtxIdx + radialSegments + (i2 + 1) % radialSegments;
          const v4 = currVtxIdx + (i2 + 1) % radialSegments;
          indices.setXYZ(currFaceIdx * PTS_PER_TRIANGLE, v1, v4, v22);
          currFaceIdx++;
          indices.setXYZ(currFaceIdx * PTS_PER_TRIANGLE, v22, v4, v3);
          currFaceIdx++;
        }
      }
      const v2 = y2 / heightSegments;
      const radius = v2 * (radiusBottom - radiusTop) + radiusTop;
      for (let x3 = 0; x3 < radialSegments; x3++) {
        const u2 = x3 / radialSegments;
        const vx = radius * Math.sin(u2 * thetaLength + thetaStart);
        const vy = v2 * height - heightHalf;
        const vz = radius * Math.cos(u2 * thetaLength + thetaStart);
        const normal = new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Vector3(vx, Math.sqrt(vx * vx + vz * vz) * tanTheta, vz).normalize();
        positions.setXYZ(currVtxIdx, vx, vy, vz);
        normals.setXYZ(currVtxIdx, normal.x, normal.y, normal.z);
        uvs.setXY(currVtxIdx, u2, v2);
        ++currVtxIdx;
      }
    }
    if (hasTop) {
      const startTIdx = currVtxIdx;
      const lastIdx = currVtxIdx + radialSegments;
      for (let fTIdx = 0; fTIdx < radialSegments; ++fTIdx) {
        const currSrcIdx = currVtxIdx - radialSegments;
        positions.setXYZ(currVtxIdx, positions.getX(currSrcIdx), positions.getY(currSrcIdx), positions.getZ(currSrcIdx));
        normals.setXYZ(currVtxIdx, 0, 1, 0);
        uvs.setXY(currVtxIdx, 1, 1);
        const nextTVtx = startTIdx + (fTIdx + 1) % radialSegments;
        indices.setXYZ(currFaceIdx * PTS_PER_TRIANGLE, currVtxIdx, nextTVtx, lastIdx);
        currFaceIdx++;
        currVtxIdx++;
      }
      positions.setXYZ(currVtxIdx, 0, heightHalf, 0);
      normals.setXYZ(currVtxIdx, 0, 1, 0);
      uvs.setXY(currVtxIdx, 1, 1);
      ++currVtxIdx;
    }
    if (hasBottom) {
      const startBIdx = currVtxIdx;
      const lastBIdx = currVtxIdx + radialSegments;
      for (let fBIdx = 0; fBIdx < radialSegments; ++fBIdx) {
        const currSrcBIdx = fBIdx;
        positions.setXYZ(currVtxIdx, positions.getX(currSrcBIdx), positions.getY(currSrcBIdx), positions.getZ(currSrcBIdx));
        normals.setXYZ(currVtxIdx, 0, -1, 0);
        uvs.setXY(currVtxIdx, 0, 0);
        const nextBVtx = startBIdx + (fBIdx + 1) % radialSegments;
        indices.setXYZ(currFaceIdx * PTS_PER_TRIANGLE, nextBVtx, currVtxIdx, lastBIdx);
        currFaceIdx++;
        currVtxIdx++;
      }
      positions.setXYZ(currVtxIdx, 0, -heightHalf, 0);
      normals.setXYZ(currVtxIdx, 0, -1, 0);
      uvs.setXY(currVtxIdx, 0, 0);
    }
    this.setIndex(indices);
    this.setAttribute("position", positions);
    this.setAttribute("normal", normals);
    this.setAttribute("uv", uvs);
  }
  clone() {
    const {
      parameters
    } = this;
    return new _CylinderBufferGeometry(parameters.radiusTop, parameters.radiusBottom, parameters.height, parameters.radialSegments, parameters.heightSegments, parameters.openEnded);
  }
};
var geometries_CylinderBufferGeometry = CylinderBufferGeometry2;
var Instanced2CCylindersGeometry_tmpColor = new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Color();
var invMatrix = new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Matrix4();
var Instanced2CCylindersGeometry_OFFSET_SIZE = 4;
var Instanced2CCylindersGeometry_COLOR_SIZE = 3;
var {
  copySubArrays: Instanced2CCylindersGeometry_copySubArrays
} = utils;
function Instanced2CCylindersGeometry_setArrayXYZ(arr, idx, x3, y2, z) {
  arr[idx] = x3;
  arr[idx + 1] = y2;
  arr[idx + 2] = z;
}
function Instanced2CCylindersGeometry_setArrayXYZW(arr, idx, x3, y2, z, w2) {
  arr[idx] = x3;
  arr[idx + 1] = y2;
  arr[idx + 2] = z;
  arr[idx + 3] = w2;
}
function sortNumber(a2, b2) {
  return a2 - b2;
}
function _prepareCylinderInfo(chunkIndices) {
  chunkIndices.sort(sortNumber);
  const chunksIdx = [];
  const cylinderInfo = [];
  for (let i2 = 0, n = chunkIndices.length; i2 < n; ++i2) {
    const val = chunkIndices[i2];
    const even = (val | 0) % 2 === 0;
    const newPar = {
      first: false,
      second: false
    };
    if (even) {
      newPar.first = true;
      newPar.second = i2 + 1 < n && chunkIndices[i2 + 1] === chunkIndices[i2] + 1;
      if (newPar.second) {
        ++i2;
      }
    } else {
      newPar.second = true;
    }
    chunksIdx.push(Math.floor(val / 2));
    cylinderInfo.push(newPar);
  }
  return {
    indices: chunksIdx,
    cylinderInfo
  };
}
function _assignOpacity(cylinderInfo, color1, color2) {
  for (let i2 = 0, n = cylinderInfo.length; i2 < n; ++i2) {
    const info = cylinderInfo[i2];
    if (!info.first) {
      color1[Instanced2CCylindersGeometry_COLOR_SIZE * i2] = -0.5;
    }
    if (!info.second) {
      color2[Instanced2CCylindersGeometry_COLOR_SIZE * i2] = -0.5;
    }
  }
}
var Instanced2CCylindersGeometry = class extends external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.InstancedBufferGeometry {
  constructor(instanceCount, polyComplexity, useZSprites, openEnded) {
    super();
    this._useZSprites = useZSprites;
    this._cylGeometry = useZSprites ? new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.PlaneGeometry(2, 2, 1, 1) : new geometries_CylinderBufferGeometry(1, 1, 1, Math.max(3, polyComplexity), 2, openEnded);
    this._init(instanceCount, this._cylGeometry, this._useZSprites);
    this._collisionGeo = new geometries_Simple2CCylindersGeometry(instanceCount, 3);
  }
  setItem(itemIdx, botPos, topPos, itemRad) {
    const matrix = gfxutils.calcCylinderMatrix(botPos, topPos, itemRad);
    let me = matrix.elements;
    const mtxOffset = itemIdx * Instanced2CCylindersGeometry_OFFSET_SIZE;
    this._collisionGeo.setItem(itemIdx, botPos, topPos, itemRad);
    Instanced2CCylindersGeometry_setArrayXYZW(this._matVector1, mtxOffset, me[0], me[4], me[8], me[12]);
    Instanced2CCylindersGeometry_setArrayXYZW(this._matVector2, mtxOffset, me[1], me[5], me[9], me[13]);
    Instanced2CCylindersGeometry_setArrayXYZW(this._matVector3, mtxOffset, me[2], me[6], me[10], me[14]);
    if (this._useZSprites) {
      invMatrix.copy(matrix).invert();
      me = invMatrix.elements;
      Instanced2CCylindersGeometry_setArrayXYZW(this._invmatVector1, mtxOffset, me[0], me[4], me[8], me[12]);
      Instanced2CCylindersGeometry_setArrayXYZW(this._invmatVector2, mtxOffset, me[1], me[5], me[9], me[13]);
      Instanced2CCylindersGeometry_setArrayXYZW(this._invmatVector3, mtxOffset, me[2], me[6], me[10], me[14]);
    }
  }
  setColor(itemIdx, colorVal1, colorVal2) {
    const colorIdx = itemIdx * Instanced2CCylindersGeometry_COLOR_SIZE;
    Instanced2CCylindersGeometry_tmpColor.set(colorVal1);
    Instanced2CCylindersGeometry_setArrayXYZ(this._color1, colorIdx, Instanced2CCylindersGeometry_tmpColor.r, Instanced2CCylindersGeometry_tmpColor.g, Instanced2CCylindersGeometry_tmpColor.b);
    Instanced2CCylindersGeometry_tmpColor.set(colorVal2);
    Instanced2CCylindersGeometry_setArrayXYZ(this._color2, colorIdx, Instanced2CCylindersGeometry_tmpColor.r, Instanced2CCylindersGeometry_tmpColor.g, Instanced2CCylindersGeometry_tmpColor.b);
  }
  computeBoundingSphere() {
    this._collisionGeo.computeBoundingSphere();
    this.boundingSphere = this._collisionGeo.boundingSphere;
  }
  computeBoundingBox() {
    this._collisionGeo.computeBoundingBox();
    this.boundingBox = this._collisionGeo.boundingBox;
  }
  raycast(raycaster, intersects2) {
    this._collisionGeo.raycast(raycaster, intersects2);
  }
  startUpdate() {
    return true;
  }
  finishUpdate() {
    this.getAttribute("matVector1").needsUpdate = true;
    this.getAttribute("matVector2").needsUpdate = true;
    this.getAttribute("matVector3").needsUpdate = true;
    this.getAttribute("color").needsUpdate = true;
    this.getAttribute("color2").needsUpdate = true;
    this.getAttribute("alphaColor").needsUpdate = true;
    if (this._useZSprites) {
      this.getAttribute("invmatVector1").needsUpdate = true;
      this.getAttribute("invmatVector2").needsUpdate = true;
      this.getAttribute("invmatVector3").needsUpdate = true;
    }
    this._collisionGeo.finishUpdate();
  }
  finalize() {
    this.finishUpdate();
    this.computeBoundingSphere();
  }
  setOpacity(chunkIndices, value) {
    const alphaArr = this._alpha;
    for (let i2 = 0, n = chunkIndices.length; i2 < n; ++i2) {
      alphaArr[Math.floor(chunkIndices[i2] / 2)] = value;
    }
    this.getAttribute("alphaColor").needsUpdate = true;
  }
  getSubset(chunkIndices) {
    const info = _prepareCylinderInfo(chunkIndices);
    const cylinderIndices = info.indices;
    const instanceCount = cylinderIndices.length;
    const geom = new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.InstancedBufferGeometry();
    this._init.call(geom, instanceCount, this._cylGeometry, this._useZSprites);
    Instanced2CCylindersGeometry_copySubArrays(this._matVector1, geom._matVector1, cylinderIndices, Instanced2CCylindersGeometry_OFFSET_SIZE);
    Instanced2CCylindersGeometry_copySubArrays(this._matVector2, geom._matVector2, cylinderIndices, Instanced2CCylindersGeometry_OFFSET_SIZE);
    Instanced2CCylindersGeometry_copySubArrays(this._matVector3, geom._matVector3, cylinderIndices, Instanced2CCylindersGeometry_OFFSET_SIZE);
    if (this._useZSprites) {
      Instanced2CCylindersGeometry_copySubArrays(this._invmatVector1, geom._invmatVector1, cylinderIndices, Instanced2CCylindersGeometry_OFFSET_SIZE);
      Instanced2CCylindersGeometry_copySubArrays(this._invmatVector2, geom._invmatVector2, cylinderIndices, Instanced2CCylindersGeometry_OFFSET_SIZE);
      Instanced2CCylindersGeometry_copySubArrays(this._invmatVector3, geom._invmatVector3, cylinderIndices, Instanced2CCylindersGeometry_OFFSET_SIZE);
    }
    Instanced2CCylindersGeometry_copySubArrays(this._color1, geom._color1, cylinderIndices, Instanced2CCylindersGeometry_COLOR_SIZE);
    Instanced2CCylindersGeometry_copySubArrays(this._color2, geom._color2, cylinderIndices, Instanced2CCylindersGeometry_COLOR_SIZE);
    _assignOpacity(info.cylinderInfo, geom._color1, geom._color2);
    geom.boundingSphere = this.boundingSphere;
    geom.boundingBox = this.boundingBox;
    return [geom];
  }
  getGeoParams() {
    return this._cylGeometry.parameters;
  }
  _init(instanceCount, cylinderGeo, useZSprites) {
    this.copy(cylinderGeo);
    this._matVector1 = utils.allocateTyped(Float32Array, instanceCount * Instanced2CCylindersGeometry_OFFSET_SIZE);
    this._matVector2 = utils.allocateTyped(Float32Array, instanceCount * Instanced2CCylindersGeometry_OFFSET_SIZE);
    this._matVector3 = utils.allocateTyped(Float32Array, instanceCount * Instanced2CCylindersGeometry_OFFSET_SIZE);
    this._color1 = utils.allocateTyped(Float32Array, instanceCount * Instanced2CCylindersGeometry_COLOR_SIZE);
    this._color2 = utils.allocateTyped(Float32Array, instanceCount * Instanced2CCylindersGeometry_COLOR_SIZE);
    const alpha = this._alpha = utils.allocateTyped(Float32Array, instanceCount);
    external_module_lodash_commonjs_lodash_commonjs2_lodash_amd_lodash_root_namespaceObject["default"].fill(alpha, 1);
    this.setAttribute("matVector1", new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.InstancedBufferAttribute(this._matVector1, Instanced2CCylindersGeometry_OFFSET_SIZE, false, 1));
    this.setAttribute("matVector2", new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.InstancedBufferAttribute(this._matVector2, Instanced2CCylindersGeometry_OFFSET_SIZE, false, 1));
    this.setAttribute("matVector3", new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.InstancedBufferAttribute(this._matVector3, Instanced2CCylindersGeometry_OFFSET_SIZE, false, 1));
    this.setAttribute("color", new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.InstancedBufferAttribute(this._color1, Instanced2CCylindersGeometry_COLOR_SIZE, false, 1));
    this.setAttribute("color2", new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.InstancedBufferAttribute(this._color2, Instanced2CCylindersGeometry_COLOR_SIZE, false, 1));
    this.setAttribute("alphaColor", new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.InstancedBufferAttribute(this._alpha, 1, false, 1));
    if (useZSprites) {
      this._invmatVector1 = utils.allocateTyped(Float32Array, instanceCount * Instanced2CCylindersGeometry_OFFSET_SIZE);
      this._invmatVector2 = utils.allocateTyped(Float32Array, instanceCount * Instanced2CCylindersGeometry_OFFSET_SIZE);
      this._invmatVector3 = utils.allocateTyped(Float32Array, instanceCount * Instanced2CCylindersGeometry_OFFSET_SIZE);
      this.setAttribute("invmatVector1", new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.InstancedBufferAttribute(this._invmatVector1, Instanced2CCylindersGeometry_OFFSET_SIZE, false, 1));
      this.setAttribute("invmatVector2", new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.InstancedBufferAttribute(this._invmatVector2, Instanced2CCylindersGeometry_OFFSET_SIZE, false, 1));
      this.setAttribute("invmatVector3", new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.InstancedBufferAttribute(this._invmatVector3, Instanced2CCylindersGeometry_OFFSET_SIZE, false, 1));
    }
  }
};
var geometries_Instanced2CCylindersGeometry = Instanced2CCylindersGeometry;
var ExtrudedObjectsGeometry_VEC_SIZE = 3;
var TRI_SIZE = 3;
var tmpPrev = new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Vector3();
var tmpNext = new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Vector3();
var tmpRes = new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Vector3();
var simpleNormal = new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Vector3(1, 0, 0);
var normalOnCut = new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Vector3();
var nearRingPt = new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Vector3();
function _createExtrudedChunkGeometry(shape, ringsCount) {
  const geo = new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.BufferGeometry();
  const ptsCount = shape.length;
  const totalPts = ptsCount * ringsCount;
  const type = totalPts <= 65536 ? Uint16Array : Uint32Array;
  const facesPerChunk = (ringsCount - 1) * ptsCount * 2;
  const indices = new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.BufferAttribute(utils.allocateTyped(type, facesPerChunk * TRI_SIZE), 1);
  let currVtxIdx = 0;
  let currFaceIdx = 0;
  for (let y2 = 0; y2 < ringsCount; y2++) {
    if (y2 !== ringsCount - 1) {
      for (let i2 = 0; i2 < ptsCount; i2++) {
        const v1 = currVtxIdx + i2;
        const v2 = currVtxIdx + ptsCount + i2;
        const v3 = currVtxIdx + ptsCount + (i2 + 1) % ptsCount;
        const v4 = currVtxIdx + (i2 + 1) % ptsCount;
        indices.setXYZ(currFaceIdx * TRI_SIZE, v1, v4, v2);
        currFaceIdx++;
        indices.setXYZ(currFaceIdx * TRI_SIZE, v2, v4, v3);
        currFaceIdx++;
      }
    }
    currVtxIdx += ptsCount;
  }
  geo.setIndex(indices);
  const pos = utils.allocateTyped(Float32Array, totalPts * ExtrudedObjectsGeometry_VEC_SIZE);
  geo.setAttribute("position", new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.BufferAttribute(pos, ExtrudedObjectsGeometry_VEC_SIZE));
  geo._positions = shape;
  return geo;
}
var ExtrudedObjectsGeometry = class extends geometries_ChunkedObjectsGeometry {
  constructor(shape, ringsCount, chunksCount) {
    const chunkGeo = _createExtrudedChunkGeometry(shape, ringsCount);
    super(chunkGeo, chunksCount);
    this._ringsCount = ringsCount;
    const tmpShape = this._tmpShape = [];
    for (let i2 = 0; i2 < shape.length; ++i2) {
      tmpShape[i2] = new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Vector3();
    }
  }
  setItem(itemIdx, matrices) {
    let hasSlope = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
    let hasCut = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : false;
    const ptsCount = this._chunkGeo._positions.length;
    const ringsCount = this._ringsCount;
    const chunkStartIdx = ptsCount * this._ringsCount * itemIdx * ExtrudedObjectsGeometry_VEC_SIZE;
    this._setPoints(matrices, ptsCount, ringsCount, chunkStartIdx);
    if (hasSlope) {
      this._setSlopeNormals(ptsCount, ringsCount, chunkStartIdx);
    } else {
      this._setBaseNormals(ptsCount, ringsCount, chunkStartIdx);
    }
    if (hasCut) {
      this._addCut(ptsCount, ringsCount, chunkStartIdx);
    }
  }
  _setPoints(matrices, ptsCount, ringsCount, chunkStartIdx) {
    const tmpShape = this._tmpShape;
    const positions = this._positions;
    const shape = this._chunkGeo._positions;
    for (let i2 = 0, vtxIdx = chunkStartIdx; i2 < ringsCount; ++i2) {
      const mtx = matrices[i2];
      for (let j = 0; j < ptsCount; ++j, vtxIdx += ExtrudedObjectsGeometry_VEC_SIZE) {
        tmpShape[j].copy(shape[j]).applyMatrix4(mtx).toArray(positions, vtxIdx);
      }
    }
  }
  _setBaseNormals(ptsCount, ringsCount, chunkStartIdx) {
    const nPtsInRing = ptsCount * ExtrudedObjectsGeometry_VEC_SIZE;
    for (let i2 = 0, vtxIdx = chunkStartIdx; i2 < ringsCount; ++i2, vtxIdx += nPtsInRing) {
      this._countNormalsInRing(ptsCount, vtxIdx, false);
    }
  }
  _setSlopeNormals(ptsCount, ringsCount, chunkStartIdx) {
    const normals = this._normals;
    const nPtsInRing = ptsCount * ExtrudedObjectsGeometry_VEC_SIZE;
    let vtxIdx = chunkStartIdx;
    for (let j = 0; j < ptsCount; ++j, vtxIdx += ExtrudedObjectsGeometry_VEC_SIZE) {
      simpleNormal.toArray(normals, vtxIdx);
    }
    if (vtxIdx - 2 * nPtsInRing > 0) {
      for (let j = 0; j < ptsCount; ++j, vtxIdx += ExtrudedObjectsGeometry_VEC_SIZE) {
        tmpRes.fromArray(normals, vtxIdx - 2 * nPtsInRing).toArray(normals, vtxIdx);
      }
    } else {
      this._countNormalsInRing(ptsCount, vtxIdx, true, +nPtsInRing);
      vtxIdx += nPtsInRing;
    }
    for (let i2 = 2; i2 < ringsCount; ++i2, vtxIdx += nPtsInRing) {
      this._countNormalsInRing(ptsCount, vtxIdx, true, -nPtsInRing);
    }
  }
  // Counting normals:
  // - Slope
  //   Radius changes throught part => normals aren't parallel with the plane contains section points
  //   normal = vTangentInSectionPlane x vToSuchPointInPrevSection (all vectors are scaled for being 1 in length)
  // - No slope
  //   Radius doesn't change throught part => normals are parallel with the plane contains section points
  //   normal = vToPrevPointInSection + vToNextPointInSection (all vectors are scaled for being 1 in length)
  _countNormalsInRing(ptsCount, vtxIdx, isSlope, shiftToExtraPt) {
    const tmpShape = this._tmpShape;
    const normals = this._normals;
    tmpShape[0].fromArray(this._positions, vtxIdx);
    tmpShape[ptsCount - 1].fromArray(this._positions, vtxIdx + (ptsCount - 1) * ExtrudedObjectsGeometry_VEC_SIZE);
    for (let j = 0; j < ptsCount; ++j, vtxIdx += ExtrudedObjectsGeometry_VEC_SIZE) {
      if (j < ptsCount - 1) {
        tmpShape[j + 1].fromArray(this._positions, vtxIdx + ExtrudedObjectsGeometry_VEC_SIZE);
      }
      if (isSlope) {
        nearRingPt.fromArray(this._positions, vtxIdx + shiftToExtraPt);
        tmpPrev.subVectors(tmpShape[(j + ptsCount - 1) % ptsCount], tmpShape[(j + 1) % ptsCount]).normalize();
        tmpNext.subVectors(tmpShape[j], nearRingPt).normalize();
        tmpRes.crossVectors(tmpNext, tmpPrev).normalize().toArray(normals, vtxIdx);
      } else {
        tmpPrev.subVectors(tmpShape[j], tmpShape[(j + ptsCount - 1) % ptsCount]).normalize();
        tmpNext.subVectors(tmpShape[j], tmpShape[(j + 1) % ptsCount]).normalize();
        tmpRes.addVectors(tmpPrev, tmpNext).normalize().toArray(normals, vtxIdx);
      }
    }
  }
  _addCut(ptsCount, ringsCount, chunkStartIdx) {
    if (ptsCount < 3 || ringsCount < 2) {
      return;
    }
    const positions = this._positions;
    const normals = this._normals;
    const tmpShape = this._tmpShape;
    const nPtsInRing = ptsCount * ExtrudedObjectsGeometry_VEC_SIZE;
    tmpShape[0].fromArray(positions, chunkStartIdx);
    tmpShape[1].fromArray(positions, chunkStartIdx + ExtrudedObjectsGeometry_VEC_SIZE);
    tmpShape[2].fromArray(positions, chunkStartIdx + 2 * ExtrudedObjectsGeometry_VEC_SIZE);
    tmpPrev.subVectors(tmpShape[1], tmpShape[0]).normalize();
    tmpNext.subVectors(tmpShape[1], tmpShape[2]).normalize();
    normalOnCut.crossVectors(tmpPrev, tmpNext).normalize();
    let vtxIdx = chunkStartIdx;
    for (let j = 0; j < ptsCount * 2; ++j, vtxIdx += ExtrudedObjectsGeometry_VEC_SIZE) {
      normalOnCut.toArray(normals, vtxIdx);
    }
    if (ringsCount > 2) {
      for (let j = 0; j < ptsCount; ++j, vtxIdx += ExtrudedObjectsGeometry_VEC_SIZE) {
        tmpRes.fromArray(positions, vtxIdx - nPtsInRing).toArray(positions, vtxIdx);
      }
    }
  }
};
var geometries_ExtrudedObjectsGeometry = ExtrudedObjectsGeometry;
var ThickLinesGeometry_MAX_IDC_16BIT = 65535;
var VERTEX_PER_SEGMENT = 4;
var POS_SIZE = 4;
var DIR_SIZE = 3;
var COL_SIZE = 3;
var ThickLinesGeometry_tmpColor = new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Color();
var direction = new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Vector3();
function ThickLinesGeometry_setArrayXYZ(arr, idx, x3, y2, z) {
  arr[idx] = x3;
  arr[idx + 1] = y2;
  arr[idx + 2] = z;
}
function ThickLinesGeometry_setArrayXYZW(arr, idx, x3, y2, z, w2) {
  arr[idx] = x3;
  arr[idx + 1] = y2;
  arr[idx + 2] = z;
  arr[idx + 3] = w2;
}
function getSubset(arr, startSegmentIdx, segmentsCount, elemSize) {
  const start = startSegmentIdx * VERTEX_PER_SEGMENT;
  const end = start + segmentsCount * VERTEX_PER_SEGMENT;
  return arr.subarray(start * elemSize, end * elemSize);
}
var ThickLinesGeometry = class extends external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.BufferGeometry {
  constructor(segmentsCount) {
    super();
    this._initVertices(segmentsCount);
  }
  startUpdate() {
    return true;
  }
  finishUpdate() {
    this.getAttribute("position").needsUpdate = true;
    this.getAttribute("color").needsUpdate = true;
    this.getAttribute("alphaColor").needsUpdate = true;
    this.getAttribute("direction").needsUpdate = true;
  }
  setColor(segmentIdx, colorVal) {
    ThickLinesGeometry_tmpColor.set(colorVal);
    let idx = segmentIdx * VERTEX_PER_SEGMENT * COL_SIZE;
    ThickLinesGeometry_setArrayXYZ(this._colors, idx, ThickLinesGeometry_tmpColor.r, ThickLinesGeometry_tmpColor.g, ThickLinesGeometry_tmpColor.b);
    idx += COL_SIZE;
    ThickLinesGeometry_setArrayXYZ(this._colors, idx, ThickLinesGeometry_tmpColor.r, ThickLinesGeometry_tmpColor.g, ThickLinesGeometry_tmpColor.b);
    idx += COL_SIZE;
    ThickLinesGeometry_setArrayXYZ(this._colors, idx, ThickLinesGeometry_tmpColor.r, ThickLinesGeometry_tmpColor.g, ThickLinesGeometry_tmpColor.b);
    idx += COL_SIZE;
    ThickLinesGeometry_setArrayXYZ(this._colors, idx, ThickLinesGeometry_tmpColor.r, ThickLinesGeometry_tmpColor.g, ThickLinesGeometry_tmpColor.b);
  }
  setSegment(segmentIdx, pos1, pos2) {
    direction.subVectors(pos1, pos2);
    direction.normalize();
    const positions = this._positions;
    const directions = this._directions;
    let idx = segmentIdx * VERTEX_PER_SEGMENT * POS_SIZE;
    let dirIdx = segmentIdx * VERTEX_PER_SEGMENT * DIR_SIZE;
    ThickLinesGeometry_setArrayXYZW(positions, idx, pos1.x, pos1.y, pos1.z, 0.5);
    ThickLinesGeometry_setArrayXYZ(directions, dirIdx, direction.x, direction.y, direction.z);
    idx += POS_SIZE;
    dirIdx += DIR_SIZE;
    ThickLinesGeometry_setArrayXYZW(positions, idx, pos1.x, pos1.y, pos1.z, -0.5);
    ThickLinesGeometry_setArrayXYZ(directions, dirIdx, direction.x, direction.y, direction.z);
    idx += POS_SIZE;
    dirIdx += DIR_SIZE;
    ThickLinesGeometry_setArrayXYZW(positions, idx, pos2.x, pos2.y, pos2.z, 0.5);
    ThickLinesGeometry_setArrayXYZ(directions, dirIdx, direction.x, direction.y, direction.z);
    idx += POS_SIZE;
    dirIdx += DIR_SIZE;
    ThickLinesGeometry_setArrayXYZW(positions, idx, pos2.x, pos2.y, pos2.z, -0.5);
    ThickLinesGeometry_setArrayXYZ(directions, dirIdx, direction.x, direction.y, direction.z);
  }
  setOpacity(startSegIdx, endSegIdx, value) {
    const start = startSegIdx * VERTEX_PER_SEGMENT;
    const end = endSegIdx * VERTEX_PER_SEGMENT;
    external_module_lodash_commonjs_lodash_commonjs2_lodash_amd_lodash_root_namespaceObject["default"].fill(this.alpha, value, end, start);
    this.getAttribute("alphaColor").needsUpdate = true;
  }
  getSubsetSegments(startSegmentIdx, segmentsCount) {
    return [getSubset(this._positions, startSegmentIdx, segmentsCount, POS_SIZE), getSubset(this._directions, startSegmentIdx, segmentsCount, DIR_SIZE)];
  }
  getSubsetColors(startSegmentIdx, segmentsCount) {
    return getSubset(this._colors, startSegmentIdx, segmentsCount, COL_SIZE);
  }
  getSubsetOpacities(startSegmentIdx, segmentsCount) {
    return getSubset(this._alpha, startSegmentIdx, segmentsCount, 1);
  }
  getNumVertexPerSegment() {
    return VERTEX_PER_SEGMENT;
  }
  getPositionSize() {
    return POS_SIZE;
  }
  setSegments(startSegmentIdx, positions) {
    const startPos = startSegmentIdx * VERTEX_PER_SEGMENT * POS_SIZE;
    if (positions instanceof Array && positions.length === 2) {
      this._positions.set(positions[0], startPos);
      const startDir = startSegmentIdx * VERTEX_PER_SEGMENT * DIR_SIZE;
      this._directions.set(positions[1], startDir);
    } else {
      this._positions.set(positions, startPos);
    }
  }
  setColors(startSegmentIdx, colors) {
    const start = startSegmentIdx * VERTEX_PER_SEGMENT * COL_SIZE;
    this._colors.set(colors, start);
  }
  _initVertices(segmentsCount) {
    this._buffersSize = segmentsCount * VERTEX_PER_SEGMENT;
    const pointsCount = this._buffersSize;
    const use32bitIndex = pointsCount > ThickLinesGeometry_MAX_IDC_16BIT;
    this._index = utils.allocateTyped(use32bitIndex ? Uint32Array : Uint16Array, segmentsCount * 6);
    this._positions = utils.allocateTyped(Float32Array, pointsCount * POS_SIZE);
    this._colors = utils.allocateTyped(Float32Array, pointsCount * COL_SIZE);
    this._directions = utils.allocateTyped(Float32Array, pointsCount * DIR_SIZE);
    const alpha = this._alpha = utils.allocateTyped(Float32Array, pointsCount);
    external_module_lodash_commonjs_lodash_commonjs2_lodash_amd_lodash_root_namespaceObject["default"].fill(alpha, 1);
    const index = this._index;
    let indexOffset = 0;
    let pointOffset = 0;
    for (let j = 0; j < segmentsCount; j++, indexOffset += 6, pointOffset += VERTEX_PER_SEGMENT) {
      index[indexOffset] = pointOffset;
      index[indexOffset + 1] = pointOffset + 1;
      index[indexOffset + 2] = pointOffset + 3;
      index[indexOffset + 3] = pointOffset;
      index[indexOffset + 4] = pointOffset + 2;
      index[indexOffset + 5] = pointOffset + 3;
    }
    this.setIndex(new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.BufferAttribute(this._index, 1));
    this.setAttribute("position", new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.BufferAttribute(this._positions, POS_SIZE));
    this.setAttribute("color", new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.BufferAttribute(this._colors, COL_SIZE));
    this.setAttribute("alphaColor", new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.BufferAttribute(alpha, 1));
    this.setAttribute("direction", new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.BufferAttribute(this._directions, DIR_SIZE));
  }
};
var geometries_ThickLinesGeometry = ThickLinesGeometry;
var LinesGeometry = class extends geometries_ThickLinesGeometry {
  startUpdate() {
    return true;
  }
  computeBoundingSphere() {
    const {
      boundingBox
    } = this;
    let radiusSquared = 0;
    const center = new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Vector3();
    if (boundingBox) {
      boundingBox.getCenter(center);
    }
    const positions = this._positions;
    const sphere = this.boundingSphere || new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Sphere();
    const size = this._positions.length;
    const pos = new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Vector3();
    const posSize = this.getPositionSize();
    for (let i2 = 0; i2 < size; i2 += posSize) {
      pos.set(positions[i2], positions[i2 + 1], positions[i2 + 2]);
      const lengthSquared = center.distanceToSquared(pos);
      if (radiusSquared < lengthSquared) {
        radiusSquared = lengthSquared;
      }
    }
    sphere.set(center, Math.sqrt(radiusSquared));
    this.boundingSphere = sphere;
  }
  computeBoundingBox() {
    const positions = this._positions;
    const box = new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Box3();
    const size = this._positions.length;
    const tmpVec = new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Vector3();
    const posSize = this.getPositionSize();
    for (let i2 = 0; i2 < size; i2 += posSize) {
      tmpVec.set(positions[i2], positions[i2 + 1], positions[i2 + 2]);
      box.expandByPoint(tmpVec);
    }
    this.boundingBox = box;
  }
  finalize() {
    this.finishUpdate();
    this.computeBoundingSphere();
  }
};
var geometries_LinesGeometry = LinesGeometry;
var CylinderCollisionGeo_VEC_SIZE = 3;
var CylinderCollisionGeo_tmpVector = new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Vector3();
var CylinderCollisionGeo_normMtx = new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Matrix3();
var CylinderCollisionGeo = class extends geometries_ChunkedObjectsGeometry {
  constructor(instanceCount, polyComplexity) {
    const cylGeometry = new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.CylinderGeometry(1, 1, 1, Math.max(3, polyComplexity), 2, true);
    super(cylGeometry, instanceCount);
    const chunkSize = this._chunkSize;
    this._chunkPos = this._chunkGeo.attributes.position.array;
    this._chunkNorms = this._chunkGeo.attributes.normal.array;
    this._tmpVector = utils.allocateTyped(Float32Array, chunkSize * CylinderCollisionGeo_VEC_SIZE);
  }
  setItem(itemIdx, botPos, topPos, itemRad) {
    const chunkSize = this._chunkSize;
    const itemOffset = chunkSize * itemIdx * CylinderCollisionGeo_VEC_SIZE;
    const tmpArray = this._tmpVector;
    const geoPos = this._chunkPos;
    const geoNorm = this._chunkNorms;
    const mtx1 = gfxutils.calcCylinderMatrix(botPos, topPos, itemRad);
    CylinderCollisionGeo_normMtx.getNormalMatrix(mtx1);
    let idx;
    for (let i2 = 0; i2 < chunkSize; ++i2) {
      idx = i2 * CylinderCollisionGeo_VEC_SIZE;
      CylinderCollisionGeo_tmpVector.fromArray(geoPos, idx);
      CylinderCollisionGeo_tmpVector.applyMatrix4(mtx1);
      CylinderCollisionGeo_tmpVector.toArray(tmpArray, idx);
    }
    this._positions.set(tmpArray, itemOffset);
    for (let i2 = 0; i2 < chunkSize; ++i2) {
      idx = i2 * CylinderCollisionGeo_VEC_SIZE;
      CylinderCollisionGeo_tmpVector.fromArray(geoNorm, idx);
      CylinderCollisionGeo_tmpVector.applyMatrix3(CylinderCollisionGeo_normMtx);
      CylinderCollisionGeo_tmpVector.toArray(tmpArray, idx);
    }
    this._normals.set(tmpArray, itemOffset);
  }
};
var geometries_CylinderCollisionGeo = CylinderCollisionGeo;
var COLLISION_RAD = 0.1;
var ChunkedLinesGeometry = class _ChunkedLinesGeometry extends geometries_LinesGeometry {
  constructor(chunksCount, segmentsCount, enableCollision) {
    super(chunksCount * segmentsCount);
    this._init(segmentsCount);
    this._collisionGeo = enableCollision ? new geometries_CylinderCollisionGeo(chunksCount * segmentsCount, 3) : null;
  }
  startUpdate() {
    return true;
  }
  computeBoundingSphere() {
    const collisionGeo = this._collisionGeo;
    if (collisionGeo) {
      collisionGeo.computeBoundingSphere();
      this.boundingSphere = collisionGeo.boundingSphere;
      return;
    }
    super.computeBoundingSphere();
  }
  computeBoundingBox() {
    const collisionGeo = this._collisionGeo;
    if (collisionGeo) {
      collisionGeo.computeBoundingBox();
      this.boundingBox = collisionGeo.boundingBox;
      return;
    }
    super.computeBoundingBox();
  }
  raycast(raycaster, intersects2) {
    const collisionGeo = this._collisionGeo;
    if (!collisionGeo) {
      return;
    }
    const segCount = this._chunkSize;
    this._collisionGeo.raycast(raycaster, intersects2);
    for (let i2 = 0, n = intersects2.length; i2 < n; ++i2) {
      let {
        chunkIdx
      } = intersects2[i2];
      if (chunkIdx === void 0) {
        continue;
      }
      chunkIdx = chunkIdx / segCount | 0;
      intersects2[i2].chunkIdx = chunkIdx;
    }
  }
  setColor(chunkIdx, colorVal) {
    const chunkSize = this._chunkSize;
    for (let i2 = chunkIdx * chunkSize, end = i2 + chunkSize; i2 < end; ++i2) {
      super.setColor(i2, colorVal);
    }
  }
  setSegment(chunkIdx, segIdx, pos1, pos2) {
    const chunkSize = this._chunkSize;
    const idx = chunkIdx * chunkSize + segIdx;
    super.setSegment(idx, pos1, pos2);
    if (this._collisionGeo) {
      this._collisionGeo.setItem(chunkIdx * chunkSize + segIdx, pos1, pos2, COLLISION_RAD);
    }
  }
  finalize() {
    this.finishUpdate();
    this.computeBoundingSphere();
  }
  setOpacity(chunkIndices, value) {
    const chunkSize = this._chunkSize;
    for (let i2 = 0, n = chunkIndices.length; i2 < n; ++i2) {
      const left = chunkIndices[i2] * chunkSize;
      super.setOpacity(left, left + chunkSize - 1, value);
    }
  }
  getSubset(chunkIndices) {
    const instanceCount = chunkIndices.length;
    const chunkSize = this._chunkSize;
    const subset = new _ChunkedLinesGeometry(instanceCount, chunkSize, false);
    for (let i2 = 0, n = chunkIndices.length; i2 < n; ++i2) {
      const dstPtOffset = i2 * chunkSize;
      const startSegIdx = chunkIndices[i2] * chunkSize;
      subset.setSegments(dstPtOffset, this.getSubsetSegments(startSegIdx, chunkSize));
      subset.setColors(dstPtOffset, this.getSubsetColors(startSegIdx, chunkSize));
    }
    subset.boundingSphere = this.boundingSphere;
    subset.boundingBox = this.boundingBox;
    return [subset];
  }
  _init(chunkSize) {
    this._chunkSize = chunkSize;
  }
};
var geometries_ChunkedLinesGeometry = ChunkedLinesGeometry;
var TwoColorLinesGeometry_COLLISION_RAD = 0.3;
var TwoColorLinesGeometry_tmpVector = new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Vector3();
var TwoColorLinesGeometry = class _TwoColorLinesGeometry extends geometries_LinesGeometry {
  constructor(segmentsCount) {
    super(segmentsCount * 2);
    this._init(segmentsCount);
    this._collisionGeo = new geometries_Simple2CCylindersGeometry(segmentsCount, 3);
  }
  setItem(itemIdx, botPos, topPos) {
    this._collisionGeo.setItem(itemIdx, botPos, topPos, TwoColorLinesGeometry_COLLISION_RAD);
    const offset = 2 * itemIdx;
    TwoColorLinesGeometry_tmpVector.lerpVectors(botPos, topPos, 0.5);
    super.setSegment(offset, botPos, TwoColorLinesGeometry_tmpVector);
    super.setSegment(offset + 1, TwoColorLinesGeometry_tmpVector, topPos);
  }
  setColor(itemIdx, colorVal1, colorVal2) {
    const offset = 2 * itemIdx;
    super.setColor(offset, colorVal1);
    super.setColor(offset + 1, colorVal2);
  }
  raycast(raycaster, intersects2) {
    if (this._collisionGeo) {
      this._collisionGeo.raycast(raycaster, intersects2);
    }
  }
  getSubset(segmentIndices) {
    const instanceCount = segmentIndices.length;
    const subset = new _TwoColorLinesGeometry(instanceCount, false);
    for (let i2 = 0, n = instanceCount; i2 < n; ++i2) {
      const startSegIdx = segmentIndices[i2];
      subset.setSegments(i2, this.getSubsetSegments(startSegIdx, 1));
      subset.setColors(i2, this.getSubsetColors(startSegIdx, 1));
    }
    subset.boundingSphere = this.boundingSphere;
    subset.boundingBox = this.boundingBox;
    return [subset];
  }
  _init(segmentsCount) {
    this._segCounts = segmentsCount * 2;
  }
};
var geometries_TwoColorLinesGeometry = TwoColorLinesGeometry;
var vectors = [new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Vector3(1, 0, 0), new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Vector3(-1, 0, 0), new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Vector3(0, 1, 0), new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Vector3(0, -1, 0), new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Vector3(0, 0, 1), new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Vector3(0, 0, -1)];
var vecCount = vectors.length;
var tempPos1 = new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Vector3();
var tempPos2 = new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Vector3();
var CrossGeometry = class extends geometries_SphereCollisionGeo(geometries_ChunkedLinesGeometry) {
  constructor(chunksCount) {
    super(chunksCount, chunksCount, vecCount / 2 | 0, false);
  }
  setItem(itemIdx, itemPos, itemRad) {
    this.setSphere(itemIdx, itemPos, itemRad);
    for (let i2 = 0; i2 < vecCount / 2; ++i2) {
      const first = i2 * 2;
      tempPos1.x = itemPos.x + vectors[first].x * itemRad;
      tempPos1.y = itemPos.y + vectors[first].y * itemRad;
      tempPos1.z = itemPos.z + vectors[first].z * itemRad;
      const second = first + 1;
      tempPos2.x = itemPos.x + vectors[second].x * itemRad;
      tempPos2.y = itemPos.y + vectors[second].y * itemRad;
      tempPos2.z = itemPos.z + vectors[second].z * itemRad;
      this.setSegment(itemIdx, i2, tempPos1, tempPos2);
    }
  }
};
var geometries_CrossGeometry = CrossGeometry;
var POS_RAD_SIZE = 4;
var IsoSurfaceGeometry_COLOR_SIZE = 3;
var IsoSurfaceGeometry_tmpColor = new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Color();
var IsoSurfaceGeometry = class extends external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.BufferGeometry {
  constructor(spheresCount, opts) {
    super();
    this._opts = opts;
    this.zClip = this._opts.zClip;
    this._posRad = utils.allocateTyped(Float32Array, spheresCount * POS_RAD_SIZE);
    this._colors = utils.allocateTyped(Float32Array, spheresCount * IsoSurfaceGeometry_COLOR_SIZE);
  }
  setItem(chunkIdx, pos, radius) {
    const posRad = this._posRad;
    let idx = POS_RAD_SIZE * chunkIdx;
    posRad[idx++] = pos.x;
    posRad[idx++] = pos.y;
    posRad[idx++] = pos.z;
    posRad[idx] = radius;
  }
  setColor(chunkIdx, colorVal) {
    IsoSurfaceGeometry_tmpColor.set(colorVal);
    const colors = this._colors;
    let idx = IsoSurfaceGeometry_COLOR_SIZE * chunkIdx;
    colors[idx++] = IsoSurfaceGeometry_tmpColor.r;
    colors[idx++] = IsoSurfaceGeometry_tmpColor.g;
    colors[idx] = IsoSurfaceGeometry_tmpColor.b;
  }
  finalize() {
    this.finishUpdate();
    this.computeBoundingSphere();
  }
  finishUpdate() {
    this._build();
  }
  setOpacity() {
  }
  raycast() {
  }
  getSubset() {
    return [];
  }
};
var geometries_IsoSurfaceGeometry = IsoSurfaceGeometry;
var IsoSurfaceMarchCube = class {
  constructor() {
    this.pointsValuesLinear = null;
    this.hasIntersection = null;
    this.bitsInside = null;
  }
  create(numCellsPerSide) {
    const vx7000000 = 117440512;
    const n3 = numCellsPerSide * numCellsPerSide * numCellsPerSide;
    if (n3 > vx7000000) {
      throw new Error("Too large cube dimension: lead to memory huge uasge");
    }
    this.pointsValuesLinear = utils.allocateTyped(Float32Array, (2 << 2 + 2) * n3);
    this.hasIntersection = utils.allocateTyped(Int32Array, n3);
    this.bitsInside = utils.allocateTyped(Int32Array, n3);
    return 0;
  }
  destroy() {
    this.bitsInside = null;
    this.hasIntersection = null;
    this.pointsValuesLinear = null;
  }
};
IsoSurfaceMarchCube.prototype.striIndicesMarchCube = [-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 0, 8, 3, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 0, 1, 9, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1, 8, 3, 9, 8, 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1, 2, 10, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 0, 8, 3, 1, 2, 10, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 9, 2, 10, 0, 2, 9, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 2, 8, 3, 2, 10, 8, 10, 9, 8, -1, -1, -1, -1, -1, -1, -1, 3, 11, 2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 0, 11, 2, 8, 11, 0, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1, 9, 0, 2, 3, 11, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1, 11, 2, 1, 9, 11, 9, 8, 11, -1, -1, -1, -1, -1, -1, -1, 3, 10, 1, 11, 10, 3, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 0, 10, 1, 0, 8, 10, 8, 11, 10, -1, -1, -1, -1, -1, -1, -1, 3, 9, 0, 3, 11, 9, 11, 10, 9, -1, -1, -1, -1, -1, -1, -1, 9, 8, 10, 10, 8, 11, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 4, 7, 8, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 4, 3, 0, 7, 3, 4, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 0, 1, 9, 8, 4, 7, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 4, 1, 9, 4, 7, 1, 7, 3, 1, -1, -1, -1, -1, -1, -1, -1, 1, 2, 10, 8, 4, 7, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 3, 4, 7, 3, 0, 4, 1, 2, 10, -1, -1, -1, -1, -1, -1, -1, 9, 2, 10, 9, 0, 2, 8, 4, 7, -1, -1, -1, -1, -1, -1, -1, 2, 10, 9, 2, 9, 7, 2, 7, 3, 7, 9, 4, -1, -1, -1, -1, 8, 4, 7, 3, 11, 2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 11, 4, 7, 11, 2, 4, 2, 0, 4, -1, -1, -1, -1, -1, -1, -1, 9, 0, 1, 8, 4, 7, 2, 3, 11, -1, -1, -1, -1, -1, -1, -1, 4, 7, 11, 9, 4, 11, 9, 11, 2, 9, 2, 1, -1, -1, -1, -1, 3, 10, 1, 3, 11, 10, 7, 8, 4, -1, -1, -1, -1, -1, -1, -1, 1, 11, 10, 1, 4, 11, 1, 0, 4, 7, 11, 4, -1, -1, -1, -1, 4, 7, 8, 9, 0, 11, 9, 11, 10, 11, 0, 3, -1, -1, -1, -1, 4, 7, 11, 4, 11, 9, 9, 11, 10, -1, -1, -1, -1, -1, -1, -1, 9, 5, 4, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 9, 5, 4, 0, 8, 3, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 0, 5, 4, 1, 5, 0, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 8, 5, 4, 8, 3, 5, 3, 1, 5, -1, -1, -1, -1, -1, -1, -1, 1, 2, 10, 9, 5, 4, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 3, 0, 8, 1, 2, 10, 4, 9, 5, -1, -1, -1, -1, -1, -1, -1, 5, 2, 10, 5, 4, 2, 4, 0, 2, -1, -1, -1, -1, -1, -1, -1, 2, 10, 5, 3, 2, 5, 3, 5, 4, 3, 4, 8, -1, -1, -1, -1, 9, 5, 4, 2, 3, 11, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 0, 11, 2, 0, 8, 11, 4, 9, 5, -1, -1, -1, -1, -1, -1, -1, 0, 5, 4, 0, 1, 5, 2, 3, 11, -1, -1, -1, -1, -1, -1, -1, 2, 1, 5, 2, 5, 8, 2, 8, 11, 4, 8, 5, -1, -1, -1, -1, 10, 3, 11, 10, 1, 3, 9, 5, 4, -1, -1, -1, -1, -1, -1, -1, 4, 9, 5, 0, 8, 1, 8, 10, 1, 8, 11, 10, -1, -1, -1, -1, 5, 4, 0, 5, 0, 11, 5, 11, 10, 11, 0, 3, -1, -1, -1, -1, 5, 4, 8, 5, 8, 10, 10, 8, 11, -1, -1, -1, -1, -1, -1, -1, 9, 7, 8, 5, 7, 9, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 9, 3, 0, 9, 5, 3, 5, 7, 3, -1, -1, -1, -1, -1, -1, -1, 0, 7, 8, 0, 1, 7, 1, 5, 7, -1, -1, -1, -1, -1, -1, -1, 1, 5, 3, 3, 5, 7, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 9, 7, 8, 9, 5, 7, 10, 1, 2, -1, -1, -1, -1, -1, -1, -1, 10, 1, 2, 9, 5, 0, 5, 3, 0, 5, 7, 3, -1, -1, -1, -1, 8, 0, 2, 8, 2, 5, 8, 5, 7, 10, 5, 2, -1, -1, -1, -1, 2, 10, 5, 2, 5, 3, 3, 5, 7, -1, -1, -1, -1, -1, -1, -1, 7, 9, 5, 7, 8, 9, 3, 11, 2, -1, -1, -1, -1, -1, -1, -1, 9, 5, 7, 9, 7, 2, 9, 2, 0, 2, 7, 11, -1, -1, -1, -1, 2, 3, 11, 0, 1, 8, 1, 7, 8, 1, 5, 7, -1, -1, -1, -1, 11, 2, 1, 11, 1, 7, 7, 1, 5, -1, -1, -1, -1, -1, -1, -1, 9, 5, 8, 8, 5, 7, 10, 1, 3, 10, 3, 11, -1, -1, -1, -1, 5, 7, 0, 5, 0, 9, 7, 11, 0, 1, 0, 10, 11, 10, 0, -1, 11, 10, 0, 11, 0, 3, 10, 5, 0, 8, 0, 7, 5, 7, 0, -1, 11, 10, 5, 7, 11, 5, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 10, 6, 5, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 0, 8, 3, 5, 10, 6, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 9, 0, 1, 5, 10, 6, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1, 8, 3, 1, 9, 8, 5, 10, 6, -1, -1, -1, -1, -1, -1, -1, 1, 6, 5, 2, 6, 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1, 6, 5, 1, 2, 6, 3, 0, 8, -1, -1, -1, -1, -1, -1, -1, 9, 6, 5, 9, 0, 6, 0, 2, 6, -1, -1, -1, -1, -1, -1, -1, 5, 9, 8, 5, 8, 2, 5, 2, 6, 3, 2, 8, -1, -1, -1, -1, 2, 3, 11, 10, 6, 5, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 11, 0, 8, 11, 2, 0, 10, 6, 5, -1, -1, -1, -1, -1, -1, -1, 0, 1, 9, 2, 3, 11, 5, 10, 6, -1, -1, -1, -1, -1, -1, -1, 5, 10, 6, 1, 9, 2, 9, 11, 2, 9, 8, 11, -1, -1, -1, -1, 6, 3, 11, 6, 5, 3, 5, 1, 3, -1, -1, -1, -1, -1, -1, -1, 0, 8, 11, 0, 11, 5, 0, 5, 1, 5, 11, 6, -1, -1, -1, -1, 3, 11, 6, 0, 3, 6, 0, 6, 5, 0, 5, 9, -1, -1, -1, -1, 6, 5, 9, 6, 9, 11, 11, 9, 8, -1, -1, -1, -1, -1, -1, -1, 5, 10, 6, 4, 7, 8, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 4, 3, 0, 4, 7, 3, 6, 5, 10, -1, -1, -1, -1, -1, -1, -1, 1, 9, 0, 5, 10, 6, 8, 4, 7, -1, -1, -1, -1, -1, -1, -1, 10, 6, 5, 1, 9, 7, 1, 7, 3, 7, 9, 4, -1, -1, -1, -1, 6, 1, 2, 6, 5, 1, 4, 7, 8, -1, -1, -1, -1, -1, -1, -1, 1, 2, 5, 5, 2, 6, 3, 0, 4, 3, 4, 7, -1, -1, -1, -1, 8, 4, 7, 9, 0, 5, 0, 6, 5, 0, 2, 6, -1, -1, -1, -1, 7, 3, 9, 7, 9, 4, 3, 2, 9, 5, 9, 6, 2, 6, 9, -1, 3, 11, 2, 7, 8, 4, 10, 6, 5, -1, -1, -1, -1, -1, -1, -1, 5, 10, 6, 4, 7, 2, 4, 2, 0, 2, 7, 11, -1, -1, -1, -1, 0, 1, 9, 4, 7, 8, 2, 3, 11, 5, 10, 6, -1, -1, -1, -1, 9, 2, 1, 9, 11, 2, 9, 4, 11, 7, 11, 4, 5, 10, 6, -1, 8, 4, 7, 3, 11, 5, 3, 5, 1, 5, 11, 6, -1, -1, -1, -1, 5, 1, 11, 5, 11, 6, 1, 0, 11, 7, 11, 4, 0, 4, 11, -1, 0, 5, 9, 0, 6, 5, 0, 3, 6, 11, 6, 3, 8, 4, 7, -1, 6, 5, 9, 6, 9, 11, 4, 7, 9, 7, 11, 9, -1, -1, -1, -1, 10, 4, 9, 6, 4, 10, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 4, 10, 6, 4, 9, 10, 0, 8, 3, -1, -1, -1, -1, -1, -1, -1, 10, 0, 1, 10, 6, 0, 6, 4, 0, -1, -1, -1, -1, -1, -1, -1, 8, 3, 1, 8, 1, 6, 8, 6, 4, 6, 1, 10, -1, -1, -1, -1, 1, 4, 9, 1, 2, 4, 2, 6, 4, -1, -1, -1, -1, -1, -1, -1, 3, 0, 8, 1, 2, 9, 2, 4, 9, 2, 6, 4, -1, -1, -1, -1, 0, 2, 4, 4, 2, 6, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 8, 3, 2, 8, 2, 4, 4, 2, 6, -1, -1, -1, -1, -1, -1, -1, 10, 4, 9, 10, 6, 4, 11, 2, 3, -1, -1, -1, -1, -1, -1, -1, 0, 8, 2, 2, 8, 11, 4, 9, 10, 4, 10, 6, -1, -1, -1, -1, 3, 11, 2, 0, 1, 6, 0, 6, 4, 6, 1, 10, -1, -1, -1, -1, 6, 4, 1, 6, 1, 10, 4, 8, 1, 2, 1, 11, 8, 11, 1, -1, 9, 6, 4, 9, 3, 6, 9, 1, 3, 11, 6, 3, -1, -1, -1, -1, 8, 11, 1, 8, 1, 0, 11, 6, 1, 9, 1, 4, 6, 4, 1, -1, 3, 11, 6, 3, 6, 0, 0, 6, 4, -1, -1, -1, -1, -1, -1, -1, 6, 4, 8, 11, 6, 8, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 7, 10, 6, 7, 8, 10, 8, 9, 10, -1, -1, -1, -1, -1, -1, -1, 0, 7, 3, 0, 10, 7, 0, 9, 10, 6, 7, 10, -1, -1, -1, -1, 10, 6, 7, 1, 10, 7, 1, 7, 8, 1, 8, 0, -1, -1, -1, -1, 10, 6, 7, 10, 7, 1, 1, 7, 3, -1, -1, -1, -1, -1, -1, -1, 1, 2, 6, 1, 6, 8, 1, 8, 9, 8, 6, 7, -1, -1, -1, -1, 2, 6, 9, 2, 9, 1, 6, 7, 9, 0, 9, 3, 7, 3, 9, -1, 7, 8, 0, 7, 0, 6, 6, 0, 2, -1, -1, -1, -1, -1, -1, -1, 7, 3, 2, 6, 7, 2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 2, 3, 11, 10, 6, 8, 10, 8, 9, 8, 6, 7, -1, -1, -1, -1, 2, 0, 7, 2, 7, 11, 0, 9, 7, 6, 7, 10, 9, 10, 7, -1, 1, 8, 0, 1, 7, 8, 1, 10, 7, 6, 7, 10, 2, 3, 11, -1, 11, 2, 1, 11, 1, 7, 10, 6, 1, 6, 7, 1, -1, -1, -1, -1, 8, 9, 6, 8, 6, 7, 9, 1, 6, 11, 6, 3, 1, 3, 6, -1, 0, 9, 1, 11, 6, 7, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 7, 8, 0, 7, 0, 6, 3, 11, 0, 11, 6, 0, -1, -1, -1, -1, 7, 11, 6, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 7, 6, 11, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 3, 0, 8, 11, 7, 6, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 0, 1, 9, 11, 7, 6, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 8, 1, 9, 8, 3, 1, 11, 7, 6, -1, -1, -1, -1, -1, -1, -1, 10, 1, 2, 6, 11, 7, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1, 2, 10, 3, 0, 8, 6, 11, 7, -1, -1, -1, -1, -1, -1, -1, 2, 9, 0, 2, 10, 9, 6, 11, 7, -1, -1, -1, -1, -1, -1, -1, 6, 11, 7, 2, 10, 3, 10, 8, 3, 10, 9, 8, -1, -1, -1, -1, 7, 2, 3, 6, 2, 7, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 7, 0, 8, 7, 6, 0, 6, 2, 0, -1, -1, -1, -1, -1, -1, -1, 2, 7, 6, 2, 3, 7, 0, 1, 9, -1, -1, -1, -1, -1, -1, -1, 1, 6, 2, 1, 8, 6, 1, 9, 8, 8, 7, 6, -1, -1, -1, -1, 10, 7, 6, 10, 1, 7, 1, 3, 7, -1, -1, -1, -1, -1, -1, -1, 10, 7, 6, 1, 7, 10, 1, 8, 7, 1, 0, 8, -1, -1, -1, -1, 0, 3, 7, 0, 7, 10, 0, 10, 9, 6, 10, 7, -1, -1, -1, -1, 7, 6, 10, 7, 10, 8, 8, 10, 9, -1, -1, -1, -1, -1, -1, -1, 6, 8, 4, 11, 8, 6, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 3, 6, 11, 3, 0, 6, 0, 4, 6, -1, -1, -1, -1, -1, -1, -1, 8, 6, 11, 8, 4, 6, 9, 0, 1, -1, -1, -1, -1, -1, -1, -1, 9, 4, 6, 9, 6, 3, 9, 3, 1, 11, 3, 6, -1, -1, -1, -1, 6, 8, 4, 6, 11, 8, 2, 10, 1, -1, -1, -1, -1, -1, -1, -1, 1, 2, 10, 3, 0, 11, 0, 6, 11, 0, 4, 6, -1, -1, -1, -1, 4, 11, 8, 4, 6, 11, 0, 2, 9, 2, 10, 9, -1, -1, -1, -1, 10, 9, 3, 10, 3, 2, 9, 4, 3, 11, 3, 6, 4, 6, 3, -1, 8, 2, 3, 8, 4, 2, 4, 6, 2, -1, -1, -1, -1, -1, -1, -1, 0, 4, 2, 4, 6, 2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1, 9, 0, 2, 3, 4, 2, 4, 6, 4, 3, 8, -1, -1, -1, -1, 1, 9, 4, 1, 4, 2, 2, 4, 6, -1, -1, -1, -1, -1, -1, -1, 8, 1, 3, 8, 6, 1, 8, 4, 6, 6, 10, 1, -1, -1, -1, -1, 10, 1, 0, 10, 0, 6, 6, 0, 4, -1, -1, -1, -1, -1, -1, -1, 4, 6, 3, 4, 3, 8, 6, 10, 3, 0, 3, 9, 10, 9, 3, -1, 10, 9, 4, 6, 10, 4, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 4, 9, 5, 7, 6, 11, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 0, 8, 3, 4, 9, 5, 11, 7, 6, -1, -1, -1, -1, -1, -1, -1, 5, 0, 1, 5, 4, 0, 7, 6, 11, -1, -1, -1, -1, -1, -1, -1, 11, 7, 6, 8, 3, 4, 3, 5, 4, 3, 1, 5, -1, -1, -1, -1, 9, 5, 4, 10, 1, 2, 7, 6, 11, -1, -1, -1, -1, -1, -1, -1, 6, 11, 7, 1, 2, 10, 0, 8, 3, 4, 9, 5, -1, -1, -1, -1, 7, 6, 11, 5, 4, 10, 4, 2, 10, 4, 0, 2, -1, -1, -1, -1, 3, 4, 8, 3, 5, 4, 3, 2, 5, 10, 5, 2, 11, 7, 6, -1, 7, 2, 3, 7, 6, 2, 5, 4, 9, -1, -1, -1, -1, -1, -1, -1, 9, 5, 4, 0, 8, 6, 0, 6, 2, 6, 8, 7, -1, -1, -1, -1, 3, 6, 2, 3, 7, 6, 1, 5, 0, 5, 4, 0, -1, -1, -1, -1, 6, 2, 8, 6, 8, 7, 2, 1, 8, 4, 8, 5, 1, 5, 8, -1, 9, 5, 4, 10, 1, 6, 1, 7, 6, 1, 3, 7, -1, -1, -1, -1, 1, 6, 10, 1, 7, 6, 1, 0, 7, 8, 7, 0, 9, 5, 4, -1, 4, 0, 10, 4, 10, 5, 0, 3, 10, 6, 10, 7, 3, 7, 10, -1, 7, 6, 10, 7, 10, 8, 5, 4, 10, 4, 8, 10, -1, -1, -1, -1, 6, 9, 5, 6, 11, 9, 11, 8, 9, -1, -1, -1, -1, -1, -1, -1, 3, 6, 11, 0, 6, 3, 0, 5, 6, 0, 9, 5, -1, -1, -1, -1, 0, 11, 8, 0, 5, 11, 0, 1, 5, 5, 6, 11, -1, -1, -1, -1, 6, 11, 3, 6, 3, 5, 5, 3, 1, -1, -1, -1, -1, -1, -1, -1, 1, 2, 10, 9, 5, 11, 9, 11, 8, 11, 5, 6, -1, -1, -1, -1, 0, 11, 3, 0, 6, 11, 0, 9, 6, 5, 6, 9, 1, 2, 10, -1, 11, 8, 5, 11, 5, 6, 8, 0, 5, 10, 5, 2, 0, 2, 5, -1, 6, 11, 3, 6, 3, 5, 2, 10, 3, 10, 5, 3, -1, -1, -1, -1, 5, 8, 9, 5, 2, 8, 5, 6, 2, 3, 8, 2, -1, -1, -1, -1, 9, 5, 6, 9, 6, 0, 0, 6, 2, -1, -1, -1, -1, -1, -1, -1, 1, 5, 8, 1, 8, 0, 5, 6, 8, 3, 8, 2, 6, 2, 8, -1, 1, 5, 6, 2, 1, 6, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1, 3, 6, 1, 6, 10, 3, 8, 6, 5, 6, 9, 8, 9, 6, -1, 10, 1, 0, 10, 0, 6, 9, 5, 0, 5, 6, 0, -1, -1, -1, -1, 0, 3, 8, 5, 6, 10, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 10, 5, 6, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 11, 5, 10, 7, 5, 11, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 11, 5, 10, 11, 7, 5, 8, 3, 0, -1, -1, -1, -1, -1, -1, -1, 5, 11, 7, 5, 10, 11, 1, 9, 0, -1, -1, -1, -1, -1, -1, -1, 10, 7, 5, 10, 11, 7, 9, 8, 1, 8, 3, 1, -1, -1, -1, -1, 11, 1, 2, 11, 7, 1, 7, 5, 1, -1, -1, -1, -1, -1, -1, -1, 0, 8, 3, 1, 2, 7, 1, 7, 5, 7, 2, 11, -1, -1, -1, -1, 9, 7, 5, 9, 2, 7, 9, 0, 2, 2, 11, 7, -1, -1, -1, -1, 7, 5, 2, 7, 2, 11, 5, 9, 2, 3, 2, 8, 9, 8, 2, -1, 2, 5, 10, 2, 3, 5, 3, 7, 5, -1, -1, -1, -1, -1, -1, -1, 8, 2, 0, 8, 5, 2, 8, 7, 5, 10, 2, 5, -1, -1, -1, -1, 9, 0, 1, 5, 10, 3, 5, 3, 7, 3, 10, 2, -1, -1, -1, -1, 9, 8, 2, 9, 2, 1, 8, 7, 2, 10, 2, 5, 7, 5, 2, -1, 1, 3, 5, 3, 7, 5, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 0, 8, 7, 0, 7, 1, 1, 7, 5, -1, -1, -1, -1, -1, -1, -1, 9, 0, 3, 9, 3, 5, 5, 3, 7, -1, -1, -1, -1, -1, -1, -1, 9, 8, 7, 5, 9, 7, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 5, 8, 4, 5, 10, 8, 10, 11, 8, -1, -1, -1, -1, -1, -1, -1, 5, 0, 4, 5, 11, 0, 5, 10, 11, 11, 3, 0, -1, -1, -1, -1, 0, 1, 9, 8, 4, 10, 8, 10, 11, 10, 4, 5, -1, -1, -1, -1, 10, 11, 4, 10, 4, 5, 11, 3, 4, 9, 4, 1, 3, 1, 4, -1, 2, 5, 1, 2, 8, 5, 2, 11, 8, 4, 5, 8, -1, -1, -1, -1, 0, 4, 11, 0, 11, 3, 4, 5, 11, 2, 11, 1, 5, 1, 11, -1, 0, 2, 5, 0, 5, 9, 2, 11, 5, 4, 5, 8, 11, 8, 5, -1, 9, 4, 5, 2, 11, 3, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 2, 5, 10, 3, 5, 2, 3, 4, 5, 3, 8, 4, -1, -1, -1, -1, 5, 10, 2, 5, 2, 4, 4, 2, 0, -1, -1, -1, -1, -1, -1, -1, 3, 10, 2, 3, 5, 10, 3, 8, 5, 4, 5, 8, 0, 1, 9, -1, 5, 10, 2, 5, 2, 4, 1, 9, 2, 9, 4, 2, -1, -1, -1, -1, 8, 4, 5, 8, 5, 3, 3, 5, 1, -1, -1, -1, -1, -1, -1, -1, 0, 4, 5, 1, 0, 5, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 8, 4, 5, 8, 5, 3, 9, 0, 5, 0, 3, 5, -1, -1, -1, -1, 9, 4, 5, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 4, 11, 7, 4, 9, 11, 9, 10, 11, -1, -1, -1, -1, -1, -1, -1, 0, 8, 3, 4, 9, 7, 9, 11, 7, 9, 10, 11, -1, -1, -1, -1, 1, 10, 11, 1, 11, 4, 1, 4, 0, 7, 4, 11, -1, -1, -1, -1, 3, 1, 4, 3, 4, 8, 1, 10, 4, 7, 4, 11, 10, 11, 4, -1, 4, 11, 7, 9, 11, 4, 9, 2, 11, 9, 1, 2, -1, -1, -1, -1, 9, 7, 4, 9, 11, 7, 9, 1, 11, 2, 11, 1, 0, 8, 3, -1, 11, 7, 4, 11, 4, 2, 2, 4, 0, -1, -1, -1, -1, -1, -1, -1, 11, 7, 4, 11, 4, 2, 8, 3, 4, 3, 2, 4, -1, -1, -1, -1, 2, 9, 10, 2, 7, 9, 2, 3, 7, 7, 4, 9, -1, -1, -1, -1, 9, 10, 7, 9, 7, 4, 10, 2, 7, 8, 7, 0, 2, 0, 7, -1, 3, 7, 10, 3, 10, 2, 7, 4, 10, 1, 10, 0, 4, 0, 10, -1, 1, 10, 2, 8, 7, 4, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 4, 9, 1, 4, 1, 7, 7, 1, 3, -1, -1, -1, -1, -1, -1, -1, 4, 9, 1, 4, 1, 7, 0, 8, 1, 8, 7, 1, -1, -1, -1, -1, 4, 0, 3, 7, 4, 3, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 4, 8, 7, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 9, 10, 8, 10, 11, 8, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 3, 0, 9, 3, 9, 11, 11, 9, 10, -1, -1, -1, -1, -1, -1, -1, 0, 1, 10, 0, 10, 8, 8, 10, 11, -1, -1, -1, -1, -1, -1, -1, 3, 1, 10, 11, 3, 10, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1, 2, 11, 1, 11, 9, 9, 11, 8, -1, -1, -1, -1, -1, -1, -1, 3, 0, 9, 3, 9, 11, 1, 2, 9, 2, 11, 9, -1, -1, -1, -1, 0, 2, 11, 8, 0, 11, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 3, 2, 11, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 2, 3, 8, 2, 8, 10, 10, 8, 9, -1, -1, -1, -1, -1, -1, -1, 9, 10, 2, 0, 9, 2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 2, 3, 8, 2, 8, 10, 0, 1, 8, 1, 10, 8, -1, -1, -1, -1, 1, 10, 2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1, 3, 8, 9, 1, 8, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 0, 9, 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 0, 3, 8, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1];
var geometries_IsoSurfaceMarchCube = IsoSurfaceMarchCube;
var edgeTable = [0, 265, 515, 778, 1030, 1295, 1541, 1804, 2060, 2309, 2575, 2822, 3082, 3331, 3593, 3840, 400, 153, 915, 666, 1430, 1183, 1941, 1692, 2460, 2197, 2975, 2710, 3482, 3219, 3993, 3728, 560, 825, 51, 314, 1590, 1855, 1077, 1340, 2620, 2869, 2111, 2358, 3642, 3891, 3129, 3376, 928, 681, 419, 170, 1958, 1711, 1445, 1196, 2988, 2725, 2479, 2214, 4010, 3747, 3497, 3232, 1120, 1385, 1635, 1898, 102, 367, 613, 876, 3180, 3429, 3695, 3942, 2154, 2403, 2665, 2912, 1520, 1273, 2035, 1786, 502, 255, 1013, 764, 3580, 3317, 4095, 3830, 2554, 2291, 3065, 2800, 1616, 1881, 1107, 1370, 598, 863, 85, 348, 3676, 3925, 3167, 3414, 2650, 2899, 2137, 2384, 1984, 1737, 1475, 1226, 966, 719, 453, 204, 4044, 3781, 3535, 3270, 3018, 2755, 2505, 2240, 2240, 2505, 2755, 3018, 3270, 3535, 3781, 4044, 204, 453, 719, 966, 1226, 1475, 1737, 1984, 2384, 2137, 2899, 2650, 3414, 3167, 3925, 3676, 348, 85, 863, 598, 1370, 1107, 1881, 1616, 2800, 3065, 2291, 2554, 3830, 4095, 3317, 3580, 764, 1013, 255, 502, 1786, 2035, 1273, 1520, 2912, 2665, 2403, 2154, 3942, 3695, 3429, 3180, 876, 613, 367, 102, 1898, 1635, 1385, 1120, 3232, 3497, 3747, 4010, 2214, 2479, 2725, 2988, 1196, 1445, 1711, 1958, 170, 419, 681, 928, 3376, 3129, 3891, 3642, 2358, 2111, 2869, 2620, 1340, 1077, 1855, 1590, 314, 51, 825, 560, 3728, 3993, 3219, 3482, 2710, 2975, 2197, 2460, 1692, 1941, 1183, 1430, 666, 915, 153, 400, 3840, 3593, 3331, 3082, 2822, 2575, 2309, 2060, 1804, 1541, 1295, 1030, 778, 515, 265, 0];
function _voxelGradientFast(v2, point, grad) {
  const g2 = v2.getValue(point.x, point.y, point.z);
  grad.set(g2[0], g2[1], g2[2]);
}
var GridCell = class {
  constructor() {
    this._arrSize = 8;
    this.p = new Array(this._arrSize);
    this.g = new Array(this._arrSize);
    this.val = new Array(this._arrSize);
    for (let i2 = 0; i2 < this._arrSize; ++i2) {
      this.p[i2] = new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Vector3();
      this.g[i2] = new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Vector3();
    }
    this.cubeIndex = 0;
  }
};
var Triangle2 = class {
  constructor() {
    this.a = {
      p: new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Vector3(),
      n: new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Vector3()
    };
    this.b = {
      p: new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Vector3(),
      n: new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Vector3()
    };
    this.c = {
      p: new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Vector3(),
      n: new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Vector3()
    };
  }
};
function createArray(arrSize) {
  const arr = new Array(arrSize);
  for (let i2 = 0; i2 < arrSize; ++i2) {
    arr[i2] = new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Vector3();
  }
  return arr;
}
var _IsoSurface = class _IsoSurface {
  constructor() {
    this._numTriangles = 0;
    this._numVertices = 0;
    this._position = [];
    this._normals = [];
    this._colors = null;
    this._indices = [];
    this._volumetricData = null;
    this._xAxis = new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Vector3();
    this._yAxis = new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Vector3();
    this._zAxis = new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Vector3();
    this._xDir = new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Vector3();
    this._yDir = new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Vector3();
    this._zDir = new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Vector3();
  }
  _prepareAxesAndDirs() {
    const volData = this._volumetricData;
    const cellSize = volData.getCellSize();
    const xAxis = this._xAxis;
    const yAxis = this._yAxis;
    const zAxis = this._zAxis;
    const xDir = this._xDir;
    const yDir = this._yDir;
    const zDir = this._zDir;
    xAxis.set(cellSize.x, 0, 0);
    yAxis.set(0, cellSize.y, 0);
    zAxis.set(0, 0, cellSize.z);
    xDir.set(1, 0, 0);
    yDir.set(0, 1, 0);
    zDir.set(0, 0, 1);
    const tmp2 = new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Vector3();
    tmp2.crossVectors(xDir, yDir);
    if (tmp2.dot(zDir) < 0) {
      xDir.negate();
      yDir.negate();
      zDir.negate();
    }
    if (xDir.x < 0 || xDir.y < 0 || xDir.z < 0 || yDir.x < 0 || yDir.y < 0 || yDir.z < 0 || zDir.x < 0 || zDir.y < 0 || zDir.z < 0) {
      return false;
    }
    const notZero = (axe) => Math.abs(axe) > Number.EPSILON;
    return !(notZero(xAxis.y) || notZero(xAxis.z) || notZero(yAxis.x) || notZero(yAxis.z) || notZero(zAxis.x) || notZero(zAxis.y));
  }
  _vertexInterp(isoLevel, grid, ind1, ind2, vertex2, normal) {
    const p1 = grid.p[ind1];
    const p2 = grid.p[ind2];
    const n1 = grid.g[ind1];
    const n2 = grid.g[ind2];
    const valP1 = grid.val[ind1];
    const valP2 = grid.val[ind2];
    const isoDiffP1 = isoLevel - valP1;
    const diffValP2P1 = valP2 - valP1;
    let mu = 0;
    if (Math.abs(diffValP2P1) > 0) {
      mu = isoDiffP1 / diffValP2P1;
    }
    mu = mu > 1 ? 1 : mu;
    vertex2.lerpVectors(p1, p2, mu);
    normal.lerpVectors(n1, n2, mu);
  }
  _polygonize(grid, isoLevel, triangles) {
    const {
      cubeIndex
    } = grid;
    let i2 = 0;
    const arrSize = _IsoSurface._arrSize;
    const firstIndices = _IsoSurface._firstIndices;
    const secondIndices = _IsoSurface._secondIndices;
    const vertexList = _IsoSurface._vertexList;
    const normalList = _IsoSurface._normalList;
    for (; i2 < arrSize; ++i2) {
      if (edgeTable[cubeIndex] & 1 << i2) {
        this._vertexInterp(isoLevel, grid, firstIndices[i2], secondIndices[i2], vertexList[i2], normalList[i2]);
      }
    }
    let triCount = 0;
    const triTblIdx = cubeIndex * 16;
    const triTable = _IsoSurface._triTable;
    for (i2 = 0; triTable[triTblIdx + i2] !== -1; i2 += 3) {
      triangles[triCount].a.p.copy(vertexList[triTable[triTblIdx + i2]]);
      triangles[triCount].a.n.copy(normalList[triTable[triTblIdx + i2]]);
      triangles[triCount].b.p.copy(vertexList[triTable[triTblIdx + i2 + 1]]);
      triangles[triCount].b.n.copy(normalList[triTable[triTblIdx + i2 + 1]]);
      triangles[triCount].c.p.copy(vertexList[triTable[triTblIdx + i2 + 2]]);
      triangles[triCount].c.n.copy(normalList[triTable[triTblIdx + i2 + 2]]);
      ++triCount;
    }
    return triCount;
  }
  _doGridPosNorms(isoValue, step, appendSimple) {
    const vol = this._volumetricData;
    const volData = this._volumetricData.getData();
    const dim = vol.getDimensions();
    const xSize = dim[0];
    const ySize = dim[1];
    const zSize = dim[2];
    const stepX = step * vol.getStrideX();
    const stepY = step * vol.getStrideY();
    const stepZ = step * vol.getStrideZ();
    const gc = new GridCell();
    const gcVal = gc.val;
    const gcValSize = gc.val.length;
    const additions = [
      new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Vector3(0, 0, 0),
      // 0
      new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Vector3(step, 0, 0),
      // 1
      new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Vector3(step, step, 0),
      // 2
      new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Vector3(0, step, 0),
      // 3
      new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Vector3(0, 0, step),
      // 4
      new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Vector3(step, 0, step),
      // 5
      new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Vector3(step, step, step),
      // 6
      new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Vector3(0, step, step)
      // 7
    ];
    const tmpTriCount = 5;
    const triangles = new Array(tmpTriCount);
    for (let j = 0; j < tmpTriCount; ++j) {
      triangles[j] = new Triangle2();
    }
    let appendVertex;
    const self2 = this;
    const positions = this._position;
    const normals = this._normals;
    if (appendSimple) {
      appendVertex = function() {
        const axis = new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Vector3(self2._xAxis.x, self2._yAxis.y, self2._zAxis.z);
        return function(triVertex) {
          const vertex2 = triVertex.p.clone();
          vertex2.multiply(axis);
          positions.push(vertex2.add(self2._origin));
          normals.push(triVertex.n.clone());
        };
      }();
    } else {
      appendVertex = function() {
        const posMtx = new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Matrix3();
        posMtx.set(self2._xAxis.x, self2._yAxis.x, self2._zAxis.x, self2._xAxis.y, self2._yAxis.y, self2._zAxis.y, self2._xAxis.z, self2._yAxis.z, self2._zAxis.z);
        const normMtx2 = new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Matrix3();
        normMtx2.set(self2._xDir.x, self2._yDir.x, self2._zDir.x, self2._xDir.y, self2._yDir.y, self2._zDir.y, self2._xDir.z, self2._yDir.z, self2._zDir.z);
        return function(triVertex) {
          positions.push(triVertex.p.clone().applyMatrix3(posMtx).add(self2._origin));
          normals.push(triVertex.n.clone().applyMatrix3(normMtx2));
        };
      }();
    }
    const indices = this._indices;
    let globTriCount = 0;
    for (let z = 0; z < zSize - step; z += step) {
      for (let y2 = 0; y2 < ySize - step; y2 += step) {
        let idx = vol.getDirectIdx(0, y2, z);
        for (let x3 = 0; x3 < xSize - step; x3 += step, idx += stepX) {
          gcVal[0] = volData[idx];
          gcVal[1] = volData[idx + stepX];
          gcVal[3] = volData[idx + stepY];
          gcVal[2] = volData[idx + stepX + stepY];
          gcVal[4] = volData[idx + stepZ];
          gcVal[5] = volData[idx + stepX + stepZ];
          gcVal[7] = volData[idx + stepY + stepZ];
          gcVal[6] = volData[idx + stepX + stepY + stepZ];
          let cubeIndex = 0;
          let i2 = 0;
          for (; i2 < gcValSize; ++i2) {
            if (gcVal[i2] < isoValue) {
              cubeIndex |= 1 << i2;
            }
          }
          if (edgeTable[cubeIndex] === 0) {
            continue;
          }
          gc.cubeIndex = cubeIndex;
          for (i2 = 0; i2 < gcValSize; ++i2) {
            gc.p[i2].set(x3 + additions[i2].x, y2 + additions[i2].y, z + additions[i2].z);
            _voxelGradientFast(this._gradient, gc.p[i2], gc.g[i2]);
          }
          const triCount = this._polygonize(gc, isoValue, triangles);
          globTriCount += triCount;
          for (i2 = 0; i2 < triCount; ++i2) {
            indices.push(this._numTriangles * 3);
            indices.push(this._numTriangles * 3 + 1);
            indices.push(this._numTriangles * 3 + 2);
            ++this._numTriangles;
            appendVertex(triangles[i2].a);
            appendVertex(triangles[i2].b);
            appendVertex(triangles[i2].c);
          }
        }
      }
    }
    return globTriCount;
  }
  compute(volData, origin, isoValue, step) {
    this._volumetricData = volData;
    this._origin = origin;
    this._gradient = volData.computeGradient();
    this._doGridPosNorms(isoValue, step, this._prepareAxesAndDirs());
  }
  _remapIndices(vertexMap, idcCount) {
    const indices = this._indices;
    const newIndices = utils.allocateTyped(Uint32Array, idcCount);
    for (let i2 = 0; i2 < idcCount; ++i2) {
      indices[i2] = vertexMap[indices[i2]];
      newIndices[i2] = indices[i2];
    }
    this._indices = newIndices;
  }
  _remapVertices(vertices, normals, count) {
    const newPositions = utils.allocateTyped(Float32Array, count * 3);
    const newNormals = utils.allocateTyped(Float32Array, count * 3);
    for (let i2 = 0; i2 < count; ++i2) {
      const pos = vertices[i2];
      newPositions[i2 * 3] = pos.x;
      newPositions[i2 * 3 + 1] = pos.y;
      newPositions[i2 * 3 + 2] = pos.z;
      const norm = normals[i2].normalize();
      newNormals[i2 * 3] = norm.x;
      newNormals[i2 * 3 + 1] = norm.y;
      newNormals[i2 * 3 + 2] = norm.z;
    }
    this._position = newPositions;
    this._normals = newNormals;
  }
  vertexFusion(offset, len) {
    const faceVer = this._indices.length;
    const vertices = this._position;
    const normals = this._normals;
    const oldVerCount = vertices.length | 0;
    if (faceVer === 0 || oldVerCount === 0) {
      return;
    }
    const vMap = utils.allocateTyped(Uint32Array, oldVerCount);
    vMap[0] = 0;
    let newVer = 1;
    let i2 = 1;
    for (; i2 < oldVerCount; ++i2) {
      const start = newVer - offset < 0 ? 0 : newVer - offset;
      const end = start + len > newVer ? newVer : start + len;
      let matchedIndex = -1;
      for (let j = start; j < end; ++j) {
        if (Math.abs(vertices[i2] - vertices[j]) < Number.EPSILON) {
          matchedIndex = j;
          break;
        }
      }
      if (matchedIndex !== -1) {
        vMap[i2] = matchedIndex;
      } else {
        vertices[newVer].copy(vertices[i2]);
        normals[newVer].copy(normals[i2]);
        vMap[i2] = newVer;
        ++newVer;
      }
    }
    this._remapIndices(vMap, faceVer);
    this._remapVertices(vertices, normals, newVer);
  }
  // Assign per-vertex colors from a volumetric texture map (same dimensions as the original volumetric data).
  // Along with color dominating atom is determined for each vertex
  // and vertices with atom out of "visible" subset get filtered out.
  // XXX only handles orthogonal volumes currently
  setColorVolTex(colorMap, atomMap, atomWeightMap, visibilitySelector) {
    let i2;
    let idx;
    const numVerts = this._position.length / 3;
    const vertices = this._position;
    const origin = this._origin;
    const dim = this._volumetricData.getDimensions();
    const xs = dim[0] - 1;
    const ys = dim[1] - 1;
    const zs = dim[2] - 1;
    const colorData = colorMap.getData();
    const strideX = colorMap.getStrideX();
    const strideY = colorMap.getStrideY();
    const strideZ = colorMap.getStrideZ();
    let atomWeightData;
    let atomStrideX;
    let atomStrideY;
    let atomStrideZ;
    if (visibilitySelector !== null) {
      atomWeightData = atomWeightMap.getData();
      atomStrideX = atomWeightMap.getStrideX();
      atomStrideY = atomWeightMap.getStrideY();
      atomStrideZ = atomWeightMap.getStrideZ();
    }
    const xInv = 1 / this._xAxis.x;
    const yInv = 1 / this._yAxis.y;
    const zInv = 1 / this._zAxis.z;
    let atomLookup = [];
    let atomWeights = [];
    const colors = utils.allocateTyped(Float32Array, numVerts * 3);
    function interp(mu, idx1, idx2, c2) {
      c2[0] = (1 - mu) * colorData[idx1] + mu * colorData[idx2];
      c2[1] = (1 - mu) * colorData[idx1 + 1] + mu * colorData[idx2 + 1];
      c2[2] = (1 - mu) * colorData[idx1 + 2] + mu * colorData[idx2 + 2];
    }
    function collectWeight(ai, coefX, coefY, coefZ) {
      const a2 = atomMap[ai];
      if (a2 != null) {
        atomLookup[a2.index] = a2;
        const w2 = coefX * coefY * coefZ * atomWeightData[ai];
        if (typeof atomWeights[a2.index] === "undefined") {
          atomWeights[a2.index] = w2;
        } else {
          atomWeights[a2.index] += w2;
        }
      }
    }
    const vMap = utils.allocateTyped(Int32Array, numVerts);
    let newVerCount = 0;
    for (i2 = 0; i2 < numVerts; i2++) {
      const ind = i2 * 3;
      const vx = (vertices[ind] - origin.x) * xInv;
      const vy = (vertices[ind + 1] - origin.y) * yInv;
      const vz = (vertices[ind + 2] - origin.z) * zInv;
      const x3 = Math.min(Math.max(vx, 0), xs) | 0;
      const y2 = Math.min(Math.max(vy, 0), ys) | 0;
      const z = Math.min(Math.max(vz, 0), zs) | 0;
      const mux = vx - x3;
      const muy = vy - y2;
      const muz = vz - z;
      if (visibilitySelector != null) {
        atomLookup = [];
        atomWeights = [];
        idx = atomWeightMap.getDirectIdx(x3, y2, z);
        collectWeight(idx, 1 - mux, 1 - muy, 1 - muz);
        collectWeight(idx + atomStrideX, mux, 1 - muy, 1 - muz);
        collectWeight(idx + atomStrideY, 1 - mux, muy, 1 - muz);
        collectWeight(idx + atomStrideX + atomStrideY, mux, muy, 1 - muz);
        collectWeight(idx + atomStrideZ, 1 - mux, 1 - muy, muz);
        collectWeight(idx + atomStrideX + atomStrideZ, mux, 1 - muy, muz);
        collectWeight(idx + atomStrideY + atomStrideZ, 1 - mux, muy, muz);
        collectWeight(idx + atomStrideX + atomStrideY + atomStrideZ, mux, muy, muz);
        let maxWeight = 0;
        let dominantIdx = -1;
        for (const atomIdx in atomWeights) {
          if (atomWeights[atomIdx] > maxWeight) {
            dominantIdx = atomIdx;
            maxWeight = atomWeights[atomIdx];
          }
        }
        if (dominantIdx < 0 || !visibilitySelector.includesAtom(atomLookup[dominantIdx])) {
          vMap[i2] = -1;
          continue;
        }
      }
      vMap[i2] = newVerCount++;
      const dx = x3 < xs ? strideX : 0;
      const dy = y2 < ys ? strideY : 0;
      const dz = z < zs ? strideZ : 0;
      const c0 = [0, 0, 0];
      const c1 = [0, 0, 0];
      const c2 = [0, 0, 0];
      const c3 = [0, 0, 0];
      idx = colorMap.getDirectIdx(x3, y2, z);
      interp(mux, idx, idx + dx, c0);
      interp(mux, idx + dy, idx + dx + dy, c1);
      interp(mux, idx + dz, idx + dx + dz, c2);
      interp(mux, idx + dy + dz, idx + dx + dy + dz, c3);
      const cz0 = [0, 0, 0];
      cz0[0] = (1 - muy) * c0[0] + muy * c1[0];
      cz0[1] = (1 - muy) * c0[1] + muy * c1[1];
      cz0[2] = (1 - muy) * c0[2] + muy * c1[2];
      const cz1 = [0, 0, 0];
      cz1[0] = (1 - muy) * c2[0] + muy * c3[0];
      cz1[1] = (1 - muy) * c2[1] + muy * c3[1];
      cz1[2] = (1 - muy) * c2[2] + muy * c3[2];
      colors[ind] = (1 - muz) * cz0[0] + muz * cz1[0];
      colors[ind + 1] = (1 - muz) * cz0[1] + muz * cz1[1];
      colors[ind + 2] = (1 - muz) * cz0[2] + muz * cz1[2];
    }
    this._colors = colors;
    if (visibilitySelector != null) {
      for (i2 = 0; i2 < numVerts; ++i2) {
        const j = vMap[i2];
        if (j < 0) {
          continue;
        }
        this._position[j * 3] = this._position[i2 * 3];
        this._position[j * 3 + 1] = this._position[i2 * 3 + 1];
        this._position[j * 3 + 2] = this._position[i2 * 3 + 2];
        this._normals[j * 3] = this._normals[i2 * 3];
        this._normals[j * 3 + 1] = this._normals[i2 * 3 + 1];
        this._normals[j * 3 + 2] = this._normals[i2 * 3 + 2];
        this._colors[j * 3] = this._colors[i2 * 3];
        this._colors[j * 3 + 1] = this._colors[i2 * 3 + 1];
        this._colors[j * 3 + 2] = this._colors[i2 * 3 + 2];
      }
      const numTriangles = this._indices.length / 3;
      let newTriCount = 0;
      for (i2 = 0; i2 < numTriangles; ++i2) {
        const i0 = vMap[this._indices[3 * i2]];
        const i1 = vMap[this._indices[3 * i2 + 1]];
        const i22 = vMap[this._indices[3 * i2 + 2]];
        if (i0 >= 0 && i1 >= 0 && i22 >= 0) {
          this._indices[3 * newTriCount] = i0;
          this._indices[3 * newTriCount + 1] = i1;
          this._indices[3 * newTriCount + 2] = i22;
          ++newTriCount;
        }
      }
      this._position = new Float32Array(this._position.buffer.slice(0, newVerCount * 3 * 4));
      this._normals = new Float32Array(this._normals.buffer.slice(0, newVerCount * 3 * 4));
      this._colors = new Float32Array(this._colors.buffer.slice(0, newVerCount * 3 * 4));
      this._indices = new Uint32Array(this._indices.buffer.slice(0, newTriCount * 3 * 4));
    }
  }
  toMesh() {
    const geo = new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.BufferGeometry();
    geo.setIndex(new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.BufferAttribute(this._indices, 1));
    geo.setAttribute("position", new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.BufferAttribute(this._position, 3));
    geo.setAttribute("normal", new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.BufferAttribute(this._normals, 3));
    geo.setAttribute("color", new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.BufferAttribute(this._colors, 3));
    geo.computeBoundingSphere();
    return geo;
  }
};
__publicField(_IsoSurface, "_triTable", (() => geometries_IsoSurfaceMarchCube.prototype.striIndicesMarchCube)());
__publicField(_IsoSurface, "_arrSize", 12);
__publicField(_IsoSurface, "_firstIndices", [0, 1, 2, 3, 4, 5, 6, 7, 0, 1, 2, 3]);
__publicField(_IsoSurface, "_secondIndices", [1, 2, 3, 0, 5, 6, 7, 4, 4, 5, 6, 7]);
__publicField(_IsoSurface, "_vertexList", (() => createArray(_IsoSurface._arrSize))());
__publicField(_IsoSurface, "_normalList", (() => createArray(_IsoSurface._arrSize))());
var IsoSurface = _IsoSurface;
var geometries_IsoSurface = IsoSurface;
var VolumeSurfaceGeometry = class extends geometries_IsoSurfaceGeometry {
  _build() {
    const params = this._opts;
    this.numVoxels = [128, 128, 128];
    this.xAxis = new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Vector3(1, 0, 0);
    this.yAxis = new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Vector3(0, 1, 0);
    this.zAxis = new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Vector3(0, 0, 1);
    this.origin = new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Vector3(0, 0, 0);
    this._visibilitySelector = params.visibilitySelector;
    this._calcSurface(params);
  }
  _findMinMax(posRadArray) {
    const itemSize = 4;
    const itemsCount = posRadArray.length / itemSize;
    const maxPosRad = [posRadArray[0], posRadArray[1], posRadArray[2], posRadArray[3]];
    const minPosRad = [posRadArray[0], posRadArray[1], posRadArray[2], posRadArray[3]];
    for (let i2 = 1; i2 < itemsCount; ++i2) {
      const ind = i2 * itemSize;
      for (let itemIdx = 0; itemIdx < itemSize; ++itemIdx) {
        const tmpVal = posRadArray[ind + itemIdx];
        maxPosRad[itemIdx] = Math.max(tmpVal, maxPosRad[itemIdx]);
        minPosRad[itemIdx] = Math.min(tmpVal, minPosRad[itemIdx]);
      }
    }
    return {
      maxPosRad,
      minPosRad
    };
  }
  _findNumVoxels(posRadArray, params) {
    const {
      numVoxels
    } = this;
    const minMaxValues = this._findMinMax(posRadArray);
    const minCoordRad = minMaxValues.minPosRad;
    const maxCoordRad = minMaxValues.maxPosRad;
    if (minCoordRad[3] > 4) {
      params.gridSpacing *= minCoordRad[3];
    }
    let gridPadding = params.radScale * maxCoordRad[3] * 1.7;
    let padRad = gridPadding;
    padRad = 0.65 * Math.sqrt(4 / 3 * Math.PI * padRad * padRad * padRad);
    gridPadding = Math.max(gridPadding, padRad);
    let i2 = 0;
    for (; i2 < 3; ++i2) {
      minCoordRad[i2] -= gridPadding;
      maxCoordRad[i2] += gridPadding;
    }
    for (i2 = 0; i2 < 3; ++i2) {
      numVoxels[i2] = Math.ceil((maxCoordRad[i2] - minCoordRad[i2]) / params.gridSpacing);
    }
    this.xAxis.x = (numVoxels[0] - 1) * params.gridSpacing;
    this.yAxis.y = (numVoxels[1] - 1) * params.gridSpacing;
    this.zAxis.z = (numVoxels[2] - 1) * params.gridSpacing;
    [this.origin.x, this.origin.y, this.origin.z] = minCoordRad;
    return {
      bbox: minMaxValues,
      dim: numVoxels
    };
  }
  _makeSurface(surface, params) {
    const isoSurf = new geometries_IsoSurface();
    isoSurf.compute(surface.volMap, this.origin, params.isoValue, 1);
    isoSurf.vertexFusion(9, 9);
    if (isoSurf._numTriangles > 0) {
      isoSurf.setColorVolTex(surface.volTexMap, surface.atomMap, surface.atomWeightMap, this._visibilitySelector);
      this.setIndex(new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.BufferAttribute(isoSurf._indices, 1));
      this.setAttribute("position", new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.BufferAttribute(isoSurf._position, 3));
      this.setAttribute("normal", new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.BufferAttribute(isoSurf._normals, 3));
      this.setAttribute("color", new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.BufferAttribute(isoSurf._colors, 3));
    } else {
      this.setAttribute("position", new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.BufferAttribute(utils.allocateTyped(Float32Array, 0), 3));
    }
  }
  _calcSurface(params) {
    const packedArrays = {
      posRad: this._posRad,
      colors: this._colors,
      atoms: this._opts.atoms
    };
    if (packedArrays.posRad.length === 0) {
      return;
    }
    const boundaries = this._findNumVoxels(packedArrays.posRad, params);
    const box = new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Box3(this.origin, new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Vector3(this.xAxis.x, this.yAxis.y, this.zAxis.z).add(this.origin));
    const surface = this._computeSurface(packedArrays, box, boundaries, params);
    this._makeSurface(surface, params);
  }
};
var geometries_VolumeSurfaceGeometry = VolumeSurfaceGeometry;
var {
  Volume: QuickSurfGeometry_Volume
} = chem;
var QuickSurfGeometry = class extends geometries_VolumeSurfaceGeometry {
  _computeSurface(packedArrays, box, boundaries, params) {
    this._shiftByOrigin(packedArrays.posRad);
    const surface = {
      volMap: new QuickSurfGeometry_Volume(Float32Array, this.numVoxels, box),
      volTexMap: new QuickSurfGeometry_Volume(Float32Array, this.numVoxels, box, 3)
    };
    if (this._visibilitySelector != null) {
      surface.atomMap = [];
      surface.atomWeightMap = new QuickSurfGeometry_Volume(Float32Array, this.numVoxels, box);
    }
    this.gaussdensity(surface, packedArrays, null, params);
    return surface;
  }
  gaussdensity(surface, packedArrays, atomicNum, params) {
    const numAtoms = packedArrays.posRad.length / 4;
    const {
      posRad,
      colors
    } = packedArrays;
    const {
      numVoxels
    } = this;
    const {
      radScale,
      gaussLim,
      gridSpacing
    } = params;
    const invIsoValue = 1 / params.isoValue;
    const invGridSpacing = 1 / gridSpacing;
    const maxVoxelX = numVoxels[0] - 1;
    const maxVoxelY = numVoxels[1] - 1;
    const maxVoxelZ = numVoxels[2] - 1;
    const {
      volMap,
      volTexMap
    } = surface;
    const volData = volMap.getData();
    const strideX = volMap.getStrideX();
    const volTexData = volTexMap.getData();
    const texStrideX = volTexMap.getStrideX();
    let atomWeightData;
    if (this._visibilitySelector != null) {
      atomWeightData = surface.atomWeightMap.getData();
    }
    const {
      atomMap
    } = surface;
    for (let i2 = 0; i2 < numAtoms; ++i2) {
      const ind = i2 * 4;
      const scaledRad = posRad[ind + 3] * radScale;
      const atomicNumFactor = atomicNum === null ? 1 : atomicNum[i2];
      const radInv = 1 / (2 * scaledRad * scaledRad);
      let radLim = gaussLim * scaledRad;
      const radLim2 = radLim * radLim;
      radLim *= invGridSpacing;
      let tmp2 = posRad[ind] * invGridSpacing;
      const xMin = Math.max(tmp2 - radLim | 0, 0);
      const xMax = Math.min(tmp2 + radLim | 0, maxVoxelX);
      tmp2 = posRad[ind + 1] * invGridSpacing;
      const yMin = Math.max(tmp2 - radLim | 0, 0);
      const yMax = Math.min(tmp2 + radLim | 0, maxVoxelY);
      tmp2 = posRad[ind + 2] * invGridSpacing;
      const zMin = Math.max(tmp2 - radLim | 0, 0);
      const zMax = Math.min(tmp2 + radLim | 0, maxVoxelZ);
      let dz = zMin * gridSpacing - posRad[ind + 2];
      for (let z = zMin; z <= zMax; ++z, dz += gridSpacing) {
        let dy = yMin * gridSpacing - posRad[ind + 1];
        for (let y2 = yMin; y2 <= yMax; ++y2, dy += gridSpacing) {
          const dy2dz2 = dy * dy + dz * dz;
          if (dy2dz2 >= radLim2) {
            continue;
          }
          let addr = volMap.getDirectIdx(xMin, y2, z);
          let texAddr = volTexMap.getDirectIdx(xMin, y2, z);
          let dx = xMin * gridSpacing - posRad[ind];
          for (let x3 = xMin; x3 <= xMax; ++x3, dx += gridSpacing, addr += strideX, texAddr += texStrideX) {
            const r2 = dx * dx + dy2dz2;
            const expVal = -r2 * radInv;
            let density = Math.exp(expVal) * atomicNumFactor;
            if (this._visibilitySelector != null && density > atomWeightData[addr]) {
              atomWeightData[addr] = density;
              atomMap[addr] = packedArrays.atoms[i2];
            }
            volData[addr] += density;
            density *= invIsoValue;
            const colInd = i2 * 3;
            volTexData[texAddr] += density * colors[colInd];
            volTexData[texAddr + 1] += density * colors[colInd + 1];
            volTexData[texAddr + 2] += density * colors[colInd + 2];
          }
        }
      }
    }
  }
  _shiftByOrigin(posRadArray) {
    const originX = this.origin.x;
    const originY = this.origin.y;
    const originZ = this.origin.z;
    const itemSize = 4;
    const itemsCount = posRadArray.length / itemSize;
    for (let i2 = 0; i2 < itemsCount; ++i2) {
      const ind = i2 * itemSize;
      posRadArray[ind] -= originX;
      posRadArray[ind + 1] -= originY;
      posRadArray[ind + 2] -= originZ;
    }
  }
};
var geometries_QuickSurfGeometry = QuickSurfGeometry;
function AVHash(posRad, min, max, maxDistance) {
  const itemSize = 4;
  const nAtoms = posRad.length / itemSize;
  const minX = min[0];
  const minY = min[1];
  const minZ = min[2];
  const maxX = max[0];
  const maxY = max[1];
  const maxZ = max[2];
  function hashFunc(w2, minW) {
    return Math.floor((w2 - minW) / maxDistance);
  }
  const iDim = hashFunc(maxX, minX) + 1;
  const jDim = hashFunc(maxY, minY) + 1;
  const kDim = hashFunc(maxZ, minZ) + 1;
  const nCells = iDim * jDim * kDim;
  const jkDim = jDim * kDim;
  const cellID = function(x3, y2, z) {
    return (hashFunc(x3, minX) * jDim + hashFunc(y2, minY)) * kDim + hashFunc(z, minZ);
  };
  const preHash = [];
  let i2;
  let cid;
  for (i2 = 0; i2 < nAtoms; i2++) {
    const iIdx = itemSize * i2;
    cid = cellID(posRad[iIdx], posRad[iIdx + 1], posRad[iIdx + 2]);
    if (preHash[cid] === void 0) {
      preHash[cid] = [i2];
    } else {
      preHash[cid].push(i2);
    }
  }
  const cellOffsets = utils.allocateTyped(Uint32Array, nCells);
  const cellLengths = utils.allocateTyped(Uint16Array, nCells);
  const data = utils.allocateTyped(Uint32Array, nAtoms);
  let offset = 0;
  let maxCellLength = 0;
  let j;
  for (i2 = 0; i2 < nCells; i2++) {
    const start = cellOffsets[i2] = offset;
    const subArray = preHash[i2];
    if (subArray !== void 0) {
      for (j = 0; j < subArray.length; j++) {
        data[offset] = subArray[j];
        offset++;
      }
    }
    const cellLength = offset - start;
    cellLengths[i2] = cellLength;
    if (cellLength > maxCellLength) {
      maxCellLength = cellLength;
    }
  }
  this.neighbourListLength = 27 * maxCellLength + 1;
  this.withinRadii = function(x3, y2, z, rExtra, out) {
    let outIdx = 0;
    const nearI = hashFunc(x3, minX);
    const nearJ = hashFunc(y2, minY);
    const nearK = hashFunc(z, minZ);
    const loI = Math.max(0, nearI - 1);
    const loJ = Math.max(0, nearJ - 1);
    const loK = Math.max(0, nearK - 1);
    const hiI = Math.min(iDim - 1, nearI + 1);
    const hiJ = Math.min(jDim - 1, nearJ + 1);
    const hiK = Math.min(kDim - 1, nearK + 1);
    for (i2 = loI; i2 <= hiI; ++i2) {
      const iOffset = i2 * jkDim;
      for (j = loJ; j <= hiJ; ++j) {
        const jOffset = j * kDim;
        for (let k2 = loK; k2 <= hiK; ++k2) {
          cid = iOffset + jOffset + k2;
          const cellStart = cellOffsets[cid];
          const cellEnd = cellStart + cellLengths[cid];
          for (let dataIndex = cellStart; dataIndex < cellEnd; dataIndex++) {
            const atomIndex = data[dataIndex];
            const baseIndex = itemSize * atomIndex;
            const dx = posRad[baseIndex] - x3;
            const dy = posRad[baseIndex + 1] - y2;
            const dz = posRad[baseIndex + 2] - z;
            const rSum = posRad[baseIndex + 3] + rExtra;
            if (dx * dx + dy * dy + dz * dz <= rSum * rSum) {
              out[outIdx++] = data[dataIndex];
            }
          }
        }
      }
    }
    out[outIdx] = -1;
  };
}
function ContactSurface(packedArrays, boundaries, params, _indexList) {
  const itemSize = 4;
  const {
    posRad,
    colors,
    atoms
  } = packedArrays;
  const nAtoms = posRad.length / itemSize;
  const {
    bbox
  } = boundaries;
  const min = bbox.minPosRad;
  const max = bbox.maxPosRad;
  let r2;
  let maxRadius;
  let probeRadius;
  let scaleFactor;
  let probePositions;
  let lastClip = -1;
  let dim;
  let grid;
  let volTex;
  let weights;
  let weightsMap = null;
  let atomMap = null;
  let visibilitySelector = null;
  let gridx;
  let gridy;
  let gridz;
  let sinTable;
  let cosTable;
  let hash;
  let neighbours;
  const mid = new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Vector3(0, 0, 0);
  const n1 = new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Vector3(0, 0, 0);
  const n2 = new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Vector3(0, 0, 0);
  let ngTorus;
  function uniformArray(TypeName, n, a2) {
    const array = utils.allocateTyped(TypeName, n);
    for (let innI = 0; innI < n; ++innI) {
      array[innI] = a2;
    }
    return array;
  }
  function fillGridDim(a2, start, step) {
    for (let innI = 0; innI < a2.length; innI++) {
      a2[innI] = start + step * innI;
    }
  }
  function initializeGrid() {
    ({
      scaleFactor
    } = params);
    ({
      dim
    } = boundaries);
    ngTorus = Math.min(5, 2 + Math.floor(probeRadius * scaleFactor));
    const gridSize = dim[0] * dim[1] * dim[2];
    grid = uniformArray(Float32Array, gridSize, -1001);
    volTex = utils.allocateTyped(Float32Array, gridSize * 3);
    weights = utils.allocateTyped(Float32Array, gridSize);
    if (visibilitySelector) {
      weightsMap = utils.allocateTyped(Float32Array, gridSize);
      atomMap = [];
    }
    gridx = utils.allocateTyped(Float32Array, dim[0]);
    gridy = utils.allocateTyped(Float32Array, dim[1]);
    gridz = utils.allocateTyped(Float32Array, dim[2]);
    fillGridDim(gridx, min[0], 1 / scaleFactor);
    fillGridDim(gridy, min[1], 1 / scaleFactor);
    fillGridDim(gridz, min[2], 1 / scaleFactor);
  }
  function initializeAngleTables() {
    let theta = 0;
    const step = 2 * Math.PI / probePositions;
    cosTable = utils.allocateTyped(Float32Array, probePositions);
    sinTable = utils.allocateTyped(Float32Array, probePositions);
    for (let innI = 0; innI < probePositions; innI++) {
      cosTable[innI] = Math.cos(theta);
      sinTable[innI] = Math.sin(theta);
      theta += step;
    }
  }
  function initializeHash() {
    hash = new AVHash(posRad, min, max, 2.01 * maxRadius);
    neighbours = new Int32Array(hash.neighbourListLength);
  }
  function init() {
    ({
      probeRadius,
      scaleFactor,
      probePositions,
      visibilitySelector
    } = params);
    r2 = utils.allocateTyped(Float32Array, nAtoms);
    maxRadius = 0;
    for (let innI = 0; innI < nAtoms; ++innI) {
      const rExt = posRad[innI * itemSize + 3] += probeRadius;
      if (rExt > maxRadius) {
        maxRadius = rExt;
      }
      r2[innI] = rExt * rExt;
    }
    initializeGrid();
    initializeAngleTables();
    initializeHash();
    lastClip = -1;
  }
  function singleAtomObscures(ai, innX, innY, innZ) {
    const innCI = itemSize * ai;
    const ra2 = r2[ai];
    const dx = posRad[innCI] - innX;
    const dy = posRad[innCI + 1] - innY;
    const dz = posRad[innCI + 2] - innZ;
    const d2 = dx * dx + dy * dy + dz * dz;
    return d2 < ra2;
  }
  function obscured(innX, innY, innZ, a2, b2) {
    let ai;
    if (lastClip !== -1) {
      ai = lastClip;
      if (ai !== a2 && ai !== b2 && singleAtomObscures(ai, innX, innY, innZ)) {
        return ai;
      }
      lastClip = -1;
    }
    let ni = 0;
    ai = neighbours[ni];
    while (ai >= 0) {
      if (ai !== a2 && ai !== b2 && singleAtomObscures(ai, innX, innY, innZ)) {
        lastClip = ai;
        return ai;
      }
      ai = neighbours[++ni];
    }
    lastClip = -1;
    return -1;
  }
  function projectPoints() {
    const maxRad = 4;
    const sigma = maxRad / 3;
    const sigma2Inv = 1 / (2 * sigma * sigma);
    for (let innI = 0; innI < nAtoms; innI++) {
      const innCI = itemSize * innI;
      const ax = posRad[innCI];
      const ay = posRad[innCI + 1];
      const az = posRad[innCI + 2];
      const ar = posRad[innCI + 3];
      const ar2 = r2[innI];
      hash.withinRadii(ax, ay, az, ar, neighbours);
      const ng = Math.ceil(ar * scaleFactor);
      const iax = Math.floor(scaleFactor * (ax - min[0]));
      const iay = Math.floor(scaleFactor * (ay - min[1]));
      const iaz = Math.floor(scaleFactor * (az - min[2]));
      const minx = Math.max(0, iax - ng);
      const miny = Math.max(0, iay - ng);
      const minz = Math.max(0, iaz - ng);
      const maxx = Math.min(dim[0], iax + ng + 2);
      const maxy = Math.min(dim[1], iay + ng + 2);
      const maxz = Math.min(dim[2], iaz + ng + 2);
      const colIdx = innI * 3;
      const cr = colors[colIdx];
      const cg = colors[colIdx + 1];
      const cb = colors[colIdx + 2];
      for (let iz = minz; iz < maxz; iz++) {
        const dz = gridz[iz] - az;
        const zOffset = dim[1] * dim[0] * iz;
        for (let iy = miny; iy < maxy; iy++) {
          const dy = gridy[iy] - ay;
          const dzy2 = dz * dz + dy * dy;
          const zyOffset = zOffset + dim[0] * iy;
          for (let ix = minx; ix < maxx; ix++) {
            const idx = ix + zyOffset;
            const dx = gridx[ix] - ax;
            const d2 = dzy2 + dx * dx;
            if (d2 < ar2) {
              const w2 = Math.exp(-d2 * sigma2Inv);
              const cIdx = idx * 3;
              volTex[cIdx] += cr * w2;
              volTex[cIdx + 1] += cg * w2;
              volTex[cIdx + 2] += cb * w2;
              weights[idx] += w2;
              if (visibilitySelector !== null && w2 > weightsMap[idx]) {
                weightsMap[idx] = w2;
                atomMap[idx] = atoms[innI];
              }
              if (grid[idx] < 0) {
                grid[idx] = -grid[idx];
              }
              const d3 = Math.sqrt(d2);
              const ap = ar / d3;
              let spx = dx * ap;
              let spy = dy * ap;
              let spz = dz * ap;
              spx += ax;
              spy += ay;
              spz += az;
              if (obscured(spx, spy, spz, innI, -1) === -1) {
                const dd = ar - d3;
                if (dd < grid[idx]) {
                  grid[idx] = dd;
                }
              }
            }
          }
        }
      }
    }
  }
  function normalToLine(out, p2) {
    out.x = out.y = out.z = 1;
    if (p2.x !== 0) {
      out.x = (p2.y + p2.z) / -p2.x;
    } else if (p2.y !== 0) {
      out.y = (p2.x + p2.z) / -p2.y;
    } else if (p2.z !== 0) {
      out.z = (p2.x + p2.y) / -p2.z;
    }
    return out;
  }
  function projectTorus(a2, b2) {
    const aIdx = itemSize * a2;
    const bIdx = itemSize * b2;
    const xa = posRad[aIdx];
    const ya = posRad[aIdx + 1];
    const za = posRad[aIdx + 2];
    const r1 = posRad[aIdx + 3];
    let dx = mid.x = posRad[bIdx] - xa;
    let dy = mid.y = posRad[bIdx + 1] - ya;
    let dz = mid.z = posRad[bIdx + 2] - za;
    const innR2 = posRad[bIdx + 3];
    let d2 = dx * dx + dy * dy + dz * dz;
    const d3 = Math.sqrt(d2);
    const cosA = (r1 * r1 + d3 * d3 - innR2 * innR2) / (2 * r1 * d3);
    const dmp = r1 * cosA;
    mid.normalize();
    normalToLine(n1, mid);
    n1.normalize();
    n2.crossVectors(mid, n1);
    n2.normalize();
    const rInt = Math.sqrt(r1 * r1 - dmp * dmp);
    n1.multiplyScalar(rInt);
    n2.multiplyScalar(rInt);
    mid.multiplyScalar(dmp);
    mid.x += xa;
    mid.y += ya;
    mid.z += za;
    lastClip = -1;
    const ng = ngTorus;
    for (let innI = 0; innI < probePositions; innI++) {
      const cost = cosTable[innI];
      const sint = sinTable[innI];
      const px2 = mid.x + cost * n1.x + sint * n2.x;
      const py2 = mid.y + cost * n1.y + sint * n2.y;
      const pz2 = mid.z + cost * n1.z + sint * n2.z;
      if (obscured(px2, py2, pz2, a2, b2) === -1) {
        const iax = Math.floor(scaleFactor * (px2 - min[0]));
        const iay = Math.floor(scaleFactor * (py2 - min[1]));
        const iaz = Math.floor(scaleFactor * (pz2 - min[2]));
        const minx = Math.max(0, iax - ng);
        const miny = Math.max(0, iay - ng);
        const minz = Math.max(0, iaz - ng);
        const maxx = Math.min(dim[0], iax + ng + 2);
        const maxy = Math.min(dim[1], iay + ng + 2);
        const maxz = Math.min(dim[2], iaz + ng + 2);
        for (let iz = minz; iz < maxz; iz++) {
          dz = pz2 - gridz[iz];
          const zOffset = dim[1] * dim[0] * iz;
          for (let iy = miny; iy < maxy; iy++) {
            dy = py2 - gridy[iy];
            const dzy2 = dz * dz + dy * dy;
            const zyOffset = zOffset + dim[0] * iy;
            for (let ix = minx; ix < maxx; ix++) {
              dx = px2 - gridx[ix];
              d2 = dzy2 + dx * dx;
              const idx = ix + zyOffset;
              const current = grid[idx];
              if (current > 0 && d2 < current * current) {
                grid[idx] = Math.sqrt(d2);
              }
            }
          }
        }
      }
    }
  }
  function projectTorii() {
    for (let innI = 0; innI < nAtoms; innI++) {
      const innIdx = itemSize * innI;
      hash.withinRadii(posRad[innIdx], posRad[innIdx + 1], posRad[innIdx + 2], posRad[innIdx + 3], neighbours);
      let ia = 0;
      let ni = neighbours[ia];
      while (ni >= 0) {
        if (innI < ni) {
          projectTorus(innI, ni);
        }
        ni = neighbours[++ia];
      }
    }
  }
  function fixNegatives() {
    for (let innI = 0, n = grid.length; innI < n; innI++) {
      if (grid[innI] < 0) grid[innI] = 0;
      let w2 = weights[innI];
      if (w2 > 0) {
        w2 = 1 / w2;
        const innInnI = innI * 3;
        volTex[innInnI] *= w2;
        volTex[innInnI + 1] *= w2;
        volTex[innInnI + 2] *= w2;
      }
    }
  }
  function getVolume() {
    console.time("ContactSurface.getVolume");
    console.time("ContactSurface.init");
    init();
    console.timeEnd("ContactSurface.init");
    console.time("ContactSurface.projectPoints");
    projectPoints();
    console.timeEnd("ContactSurface.projectPoints");
    console.time("ContactSurface.projectTorii");
    projectTorii();
    console.timeEnd("ContactSurface.projectTorii");
    fixNegatives();
    console.timeEnd("ContactSurface.getVolume");
  }
  this.build = function() {
    getVolume();
    this.volTexMap = volTex;
    this.weightsMap = weightsMap;
    this.atomMap = atomMap;
    this.volMap = grid;
  };
}
var geometries_ContactSurface = ContactSurface;
var {
  Volume: ContactSurfaceGeometry_Volume
} = chem;
var ContactSurfaceGeometry = class extends geometries_VolumeSurfaceGeometry {
  _computeSurface(packedArrays, box, boundaries, params) {
    const contactSurface = new geometries_ContactSurface(packedArrays, boundaries, params);
    contactSurface.build();
    const surface = {
      volMap: new ContactSurfaceGeometry_Volume(Float32Array, this.numVoxels, box, 1, contactSurface.volMap),
      volTexMap: new ContactSurfaceGeometry_Volume(Float32Array, this.numVoxels, box, 3, contactSurface.volTexMap),
      atomMap: contactSurface.atomMap,
      atomWeightMap: new ContactSurfaceGeometry_Volume(Float32Array, this.numVoxels, box, 1, contactSurface.weightsMap)
    };
    return surface;
  }
};
var geometries_ContactSurfaceGeometry = ContactSurfaceGeometry;
var IsoSurfaceAtomColored = class {
  constructor(vCenter, radiusAt) {
    this.coord = new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Vector3();
    this.coord.copy(vCenter);
    this.radius = radiusAt;
    this.colorX = 0.99999;
    this.colorY = 0;
    this.colorZ = 0;
    this.atomType = 0;
    this.srcAtom = null;
  }
};
var geometries_IsoSurfaceAtomColored = IsoSurfaceAtomColored;
var IsosurfaceBuildNormals = class {
  constructor(numAtoms, atoms, vBoxMin, vBoxMax, probeRadius) {
    this._numAtoms = numAtoms;
    this._atoms = atoms;
    this._vBoxMin = new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Vector3();
    this._vBoxMax = new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Vector3();
    this._vBoxMin.copy(vBoxMin);
    this._vBoxMax.copy(vBoxMax);
    this._probeRadius = probeRadius;
    this._atomsList = null;
    this._voxelList = null;
  }
  createVoxels() {
    let numAtomsRefs;
    let rad;
    const ATOM_VOXEL_REF_SCALE = 4.5;
    const numAtoms = this._numAtoms | 0;
    const atoms = this._atoms;
    const dx = this._vBoxMax.x - this._vBoxMin.x;
    const dy = this._vBoxMax.y - this._vBoxMin.y;
    const dz = this._vBoxMax.z - this._vBoxMin.z;
    let w2 = dx < dy ? dx : dy;
    w2 = dz < w2 ? dz : w2;
    let maxRad = 0;
    let aveRad = 0;
    let i2;
    for (i2 = 0; i2 < numAtoms; i2++) {
      rad = (atoms[i2].radius + this._probeRadius) * 2;
      maxRad = rad > maxRad ? rad : maxRad;
      aveRad += rad;
    }
    let numCells = Math.floor(w2 / maxRad);
    if (numCells < 2) {
      numCells = 2;
    }
    aveRad /= numAtoms;
    this._numCells = numCells;
    this._aveRad = aveRad;
    this._maxRad = maxRad;
    const side = numCells;
    const side2 = numCells * numCells;
    const side3 = numCells * numCells * numCells;
    const xScale = this._xScale = 1 / (this._vBoxMax.x - this._vBoxMin.x);
    const yScale = this._yScale = 1 / (this._vBoxMax.y - this._vBoxMin.y);
    const zScale = this._zScale = 1 / (this._vBoxMax.z - this._vBoxMin.z);
    let maxAtomsRefs = 0;
    const xNumVoxMult = xScale * numCells;
    const yNumVoxMult = yScale * numCells;
    const zNumVoxMult = zScale * numCells;
    for (i2 = 0; i2 < numAtoms; i2++) {
      const radAffect = (atoms[i2].radius + this._probeRadius) * ATOM_VOXEL_REF_SCALE;
      const diaAffect = radAffect * 2;
      let numVoxX = Math.floor(xNumVoxMult * diaAffect + 0.8);
      let numVoxY = Math.floor(yNumVoxMult * diaAffect + 0.8);
      let numVoxZ = Math.floor(zNumVoxMult * diaAffect + 0.8);
      numVoxX++;
      numVoxY++;
      numVoxZ++;
      maxAtomsRefs += numVoxX * numVoxY * numVoxZ;
    }
    this._voxelList = utils.allocateTyped(Int32Array, side3);
    const atomsList = [];
    atomsList.length = maxAtomsRefs;
    if (this._voxelList === null || atomsList === null) {
      return 0 - 1;
    }
    for (i2 = 0; i2 < side3; i2++) {
      this._voxelList[i2] = -1;
    }
    numAtomsRefs = 0;
    for (i2 = 0; i2 < numAtoms; i2++) {
      rad = (atoms[i2].radius + this._probeRadius) * ATOM_VOXEL_REF_SCALE;
      let xIndMin = Math.floor((atoms[i2].coord.x - this._vBoxMin.x - rad) * numCells * xScale);
      let yIndMin = Math.floor((atoms[i2].coord.y - this._vBoxMin.y - rad) * numCells * yScale);
      let zIndMin = Math.floor((atoms[i2].coord.z - this._vBoxMin.z - rad) * numCells * zScale);
      let xIndMax = Math.floor((atoms[i2].coord.x - this._vBoxMin.x + rad) * numCells * xScale);
      let yIndMax = Math.floor((atoms[i2].coord.y - this._vBoxMin.y + rad) * numCells * yScale);
      let zIndMax = Math.floor((atoms[i2].coord.z - this._vBoxMin.z + rad) * numCells * zScale);
      xIndMin = xIndMin >= 0 ? xIndMin : 0;
      yIndMin = yIndMin >= 0 ? yIndMin : 0;
      zIndMin = zIndMin >= 0 ? zIndMin : 0;
      xIndMax = xIndMax < numCells ? xIndMax : numCells - 1;
      yIndMax = yIndMax < numCells ? yIndMax : numCells - 1;
      zIndMax = zIndMax < numCells ? zIndMax : numCells - 1;
      for (let z = zIndMin; z <= zIndMax; z++) {
        for (let y2 = yIndMin; y2 <= yIndMax; y2++) {
          for (let x3 = xIndMin; x3 <= xIndMax; x3++) {
            const indVoxel = x3 + y2 * side + z * side2;
            if (this._voxelList[indVoxel] < 0) {
              atomsList[numAtomsRefs * 2 + 0] = i2;
              atomsList[numAtomsRefs * 2 + 1] = 0 - 1;
              this._voxelList[indVoxel] = numAtomsRefs;
              numAtomsRefs++;
              continue;
            }
            const indexNext = this._voxelList[indVoxel];
            this._voxelList[indVoxel] = numAtomsRefs;
            atomsList[numAtomsRefs * 2 + 0] = i2;
            atomsList[numAtomsRefs * 2 + 1] = indexNext;
            numAtomsRefs++;
          }
        }
      }
    }
    this._atomsList = Int32Array.from(atomsList);
    return 0;
  }
  destroyVoxels() {
    this._atomsList = null;
    this._voxelList = null;
    this._atoms = null;
    this._vertices = null;
    this._vBoxMin = null;
    this._vBoxMax = null;
  }
  /**
   * Enumerate all atoms affecting specified point
   *
   * @param {Vector3}    point    - point in 3D
   * @param {func(atom)} process  - function to call for each atom
   */
  forEachRelatedAtom(point, process) {
    const xInd = Math.floor((point.x - this._vBoxMin.x) * this._numCells * this._xScale);
    const yInd = Math.floor((point.y - this._vBoxMin.y) * this._numCells * this._yScale);
    const zInd = Math.floor((point.z - this._vBoxMin.z) * this._numCells * this._zScale);
    const indVoxel = xInd + yInd * this._numCells + zInd * this._numCells * this._numCells;
    const atoms = this._atoms;
    for (let ref = this._voxelList[indVoxel]; ref >= 0; ref = this._atomsList[ref * 2 + 1]) {
      const indexAtom = this._atomsList[ref * 2];
      process(atoms[indexAtom]);
    }
  }
  /**
   * Get atom closest to specified point
   *
   * @param {Vector3} point  - point in 3D
   *
   * @returns {IsoSurfaceAtomColored} atom, or null if not found
   */
  getClosestAtom(point) {
    let closest = null;
    let minDist2 = Number.MAX_VALUE;
    this.forEachRelatedAtom(point, (atom) => {
      const dist2 = point.distanceToSquared(atom.coord);
      if (dist2 < minDist2) {
        minDist2 = dist2;
        closest = atom;
      }
    });
    return closest;
  }
  /**
   * Build normals for isosurface, using atoms information
   *
   * @param {number} numVertices  - Number of vertices in final geometry (to render)
   * @param {Vector3} vertices    - Geometry vertices (3d coordinates array)
   * @param {Vector3} normals     - Normals for output
   *
   * @returns {number} 0, if success
   */
  buildNormals(numVertices, vertices, normals) {
    const self2 = this;
    let numCloseAtoms = 0;
    let vx = 0;
    let vy = 0;
    let vz = 0;
    let dist2;
    let vNormalX = 0;
    let vNormalY = 0;
    let vNormalZ = 0;
    let koef = 0;
    let w2 = 0;
    const r25 = 2.5;
    const r01 = 0.1;
    const maxRadAffect = this._aveRad * r25;
    const maxRadAffect2 = maxRadAffect * maxRadAffect;
    const expScale = -this._aveRad * r01;
    const gatherNormals = function(atom) {
      const dx = vx - atom.coord.x;
      const dy = vy - atom.coord.y;
      const dz = vz - atom.coord.z;
      dist2 = dx * dx + dy * dy + dz * dz;
      if (dist2 > maxRadAffect2) {
        return;
      }
      const rad = atom.radius + self2._probeRadius;
      koef = dist2 - rad * rad;
      if (koef < 0) {
        koef = -koef;
      }
      w2 = Math.exp(expScale * koef);
      vNormalX += dx * w2;
      vNormalY += dy * w2;
      vNormalZ += dz * w2;
      numCloseAtoms++;
    };
    let maxClosedAtoms = 0;
    for (let i2 = 0; i2 < numVertices; i2++) {
      vx = vertices[i2].x;
      vy = vertices[i2].y;
      vz = vertices[i2].z;
      numCloseAtoms = 0;
      vNormalX = vNormalY = vNormalZ = 0;
      this.forEachRelatedAtom(vertices[i2], gatherNormals);
      maxClosedAtoms = numCloseAtoms > maxClosedAtoms ? numCloseAtoms : maxClosedAtoms;
      dist2 = vNormalX * vNormalX + vNormalY * vNormalY + vNormalZ * vNormalZ;
      if (numCloseAtoms > 0) {
        koef = 1 / Math.sqrt(dist2);
        vNormalX *= koef;
        vNormalY *= koef;
        vNormalZ *= koef;
      }
      normals[i2].x = vNormalX;
      normals[i2].y = vNormalY;
      normals[i2].z = vNormalZ;
    }
    return 0;
  }
  /**
   * Build vertex colors for isosurface, using atoms information
   *
   * @param {number} numVertices  - Number of vertices in final geometry (to render)
   * @param {Vector3} vertices    - Geometry vertices (3d coordinates array)
   * @param {Vector3} colors                - Colors for output
   * @param {number} radiusColorSmoothness  - Radius of smoothness sphere
   *
   * @returns {number} 0, if success
   */
  buildColors(numVertices, vertices, colors, radiusColorSmoothness) {
    const self2 = this;
    let vx = 0;
    let vy = 0;
    let vz = 0;
    let koef = 0;
    let w2 = 0;
    const KOEF_ADD = 0.8;
    const maxRadAffect = radiusColorSmoothness;
    const maxRadAffect2 = maxRadAffect * maxRadAffect;
    let colorsClose = [];
    let weights = [];
    let weightsSum = 0;
    const gatherColors = function(atom) {
      const dx = vx - atom.coord.x;
      const dy = vy - atom.coord.y;
      const dz = vz - atom.coord.z;
      const dist2 = dx * dx + dy * dy + dz * dz;
      if (dist2 > maxRadAffect2) {
        return;
      }
      const rad = atom.radius + self2._probeRadius;
      koef = dist2 - rad * rad;
      if (koef < 0) {
        koef = -koef;
      }
      w2 = 1 / (KOEF_ADD + koef);
      colorsClose.push([atom.colorX, atom.colorY, atom.colorZ]);
      weights.push(w2);
      weightsSum += w2;
    };
    for (let i2 = 0; i2 < numVertices; i2++) {
      vx = vertices[i2].x;
      vy = vertices[i2].y;
      vz = vertices[i2].z;
      colorsClose = [];
      weights = [];
      weightsSum = 0;
      this.forEachRelatedAtom(vertices[i2], gatherColors);
      for (let j = 0; j < colorsClose.length; ++j) {
        const weightNormalized = weights[j] / weightsSum;
        colors[i2].x += colorsClose[j][0] * weightNormalized;
        colors[i2].y += colorsClose[j][1] * weightNormalized;
        colors[i2].z += colorsClose[j][2] * weightNormalized;
      }
    }
    return 0;
  }
};
var geometries_IsosurfaceBuildNormals = IsosurfaceBuildNormals;
var IsoSurfaceGeo = class {
  constructor(maxNumVertices, maxNumTriangles, needVertexColors) {
    this._maxNumVertices = maxNumVertices;
    this._maxNumTriangles = maxNumTriangles;
    this._vertices = new Array(maxNumVertices);
    this._normals = new Array(maxNumVertices);
    this._colors = null;
    if (needVertexColors) {
      this._colors = new Array(maxNumVertices);
    }
    this._indices = new Array(maxNumTriangles * (1 + 2));
    this._numVertices = 0;
    this._numTriangles = 0;
    let i2;
    for (i2 = 0; i2 < maxNumVertices; i2++) {
      this._vertices[i2] = new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Vector3();
      this._normals[i2] = new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Vector3();
    }
    for (i2 = 0; i2 < maxNumTriangles * (1 + 2); i2++) {
      this._indices[i2] = -1;
    }
    if (needVertexColors) {
      for (i2 = 0; i2 < maxNumVertices; i2++) {
        this._colors[i2] = new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Vector3();
      }
    }
  }
  destroy() {
    this._vertices = null;
    this._normals = null;
    this._indices = null;
  }
};
var geometries_IsoSurfaceGeo = IsoSurfaceGeo;
var SSIsosurfaceGeometry_COLOR_SIZE = 3;
var HASH_SIZE = 32768;
var {
  Element: SSIsosurfaceGeometry_Element
} = chem;
var SSIsosurfaceGeometry = class extends geometries_IsoSurfaceGeometry {
  _build() {
    this._innerBuild();
    const geoOut = this.getGeo();
    this.destroy();
    this._fromGeo(geoOut);
  }
  _fromGeo(geoOut) {
    let colors = null;
    const positions = utils.allocateTyped(Float32Array, (1 + 2) * geoOut._numVertices);
    const normals = utils.allocateTyped(Float32Array, (1 + 2) * geoOut._numVertices);
    if (geoOut._colors !== null) {
      colors = utils.allocateTyped(Float32Array, (1 + 2) * geoOut._numVertices);
    }
    const indices = utils.allocateTyped(Uint32Array, (1 + 2) * geoOut._numTriangles);
    for (let i2 = 0, j = 0; i2 < geoOut._numVertices; i2++) {
      positions[j + 0] = geoOut._vertices[i2].x;
      positions[j + 1] = geoOut._vertices[i2].y;
      positions[j + 2] = geoOut._vertices[i2].z;
      normals[j + 0] = geoOut._normals[i2].x;
      normals[j + 1] = geoOut._normals[i2].y;
      normals[j + 2] = geoOut._normals[i2].z;
      j += 3;
    }
    if (colors !== null) {
      for (let i2 = 0, j = 0; i2 < geoOut._numVertices; i2++, j += 3) {
        colors[j + 0] = geoOut._colors[i2].x;
        colors[j + 1] = geoOut._colors[i2].y;
        colors[j + 2] = geoOut._colors[i2].z;
      }
    }
    const numTri3 = geoOut._numTriangles * (1 + 2);
    for (let i2 = 0; i2 < numTri3; i2++) {
      indices[i2] = geoOut._indices[i2];
    }
    this.setIndex(new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.BufferAttribute(indices, 1));
    this.setAttribute("position", new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.BufferAttribute(positions, 3));
    this.setAttribute("normal", new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.BufferAttribute(normals, 3));
    this.setAttribute("color", new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.BufferAttribute(colors, 3));
    this.computeBoundingBox();
    this.computeBoundingSphere();
    geoOut.destroy();
  }
  convertToAtomsColored(packedArrays, atomsColored) {
    const {
      atoms,
      colors
    } = packedArrays;
    for (let i2 = 0, numAtoms = atoms.length; i2 < numAtoms; i2++) {
      const vCenter = atoms[i2].position;
      const {
        radius
      } = atoms[i2].element;
      atomsColored[i2] = new geometries_IsoSurfaceAtomColored(vCenter, radius);
      const nm = atoms[i2].element.number;
      atomsColored[i2].atomType = this.getType(nm);
      let cIdx = SSIsosurfaceGeometry_COLOR_SIZE * i2;
      atomsColored[i2].colorX = colors[cIdx++];
      atomsColored[i2].colorY = colors[cIdx++];
      atomsColored[i2].colorZ = colors[cIdx];
      atomsColored[i2].srcAtom = atoms[i2];
    }
  }
  getGeo() {
    return this.geoOut;
  }
  destroy() {
    this.atoms = null;
    this.hashLines = null;
    this.hashEntries = null;
  }
  /**
   * Calculates bounding box for array with spheres (atoms)
   *
   * @param {Object}  atoms      Atoms array
   * @param {Vector3} vBoxMin    Bounding box min point
   * @param {Vector3} vBoxMax    Bounding box max point
   */
  getBoundingBox(atoms, vBoxMin, vBoxMax) {
    const bigNum = 1e7;
    vBoxMin.x = vBoxMin.y = vBoxMin.z = bigNum;
    vBoxMax.x = vBoxMax.y = vBoxMax.z = 0 - bigNum;
    const probeRadius2 = this.probeRadius * this.atomRadiusScale;
    let radMax = 0;
    for (let i2 = 0, num = atoms.length; i2 < num; i2++) {
      const vCenter = atoms[i2].coord;
      const rad = atoms[i2].radius + probeRadius2;
      radMax = rad > radMax ? rad : radMax;
      if (vCenter.x - rad < vBoxMin.x) {
        vBoxMin.x = vCenter.x - rad;
      }
      if (vCenter.y - rad < vBoxMin.y) {
        vBoxMin.y = vCenter.y - rad;
      }
      if (vCenter.z - rad < vBoxMin.z) {
        vBoxMin.z = vCenter.z - rad;
      }
      if (vCenter.x + rad > vBoxMax.x) {
        vBoxMax.x = vCenter.x + rad;
      }
      if (vCenter.y + rad > vBoxMax.y) {
        vBoxMax.y = vCenter.y + rad;
      }
      if (vCenter.z + rad > vBoxMax.z) {
        vBoxMax.z = vCenter.z + rad;
      }
    }
    vBoxMin.x -= radMax;
    vBoxMin.y -= radMax;
    vBoxMin.z -= radMax;
    vBoxMax.x += radMax;
    vBoxMax.y += radMax;
    vBoxMax.z += radMax;
  }
  /**
   * Calculate (x,y,z) cordinate of the cell corner point
   *
   * @param {Vector3} vBoxMin Bounding box min point
   * @param {Vector3} vBoxMax Bounding box max point
   * @param {number} x Cell integer x coordinate
   * @param {number} y Cell integer y coordinate
   * @param {number} z Cell integer z coordinate
   * @param {number} numPoints NUm points in cell on side
   * @param {Vector3} vOut Output vector
   */
  getCornerCoord(vBoxMin, vBoxMax, x3, y2, z, numPoints, vOut) {
    const invNP = 1 / (numPoints - 1);
    const tx = x3 * invNP;
    const ty = y2 * invNP;
    const tz = z * invNP;
    vOut.x = vBoxMin.x * (1 - tx) + vBoxMax.x * tx;
    vOut.y = vBoxMin.y * (1 - ty) + vBoxMax.y * ty;
    vOut.z = vBoxMin.z * (1 - tz) + vBoxMax.z * tz;
  }
  /**
   * Calculate point of intersection of sphere surface
   * and cell edge, given by [indexA, indexB] line
   *
   * @param {number} indexA Cell vertex index in [0..11]
   * @param {number} indexB Cell vertex index in [0..11]
   * @param {array}  sign   Sign array for all 8 vertices
   * @param {object} cube   Cube
   * @param {number} indexPointValue for value placement
   * @param {Vector3} vOut  Point of intersection
   */
  buildEdgePoint(indexA, indexB, sign2, cube, indexPointValue, vOut) {
    if (sign2[indexA] ^ sign2[indexB]) {
      const cTwentyFour = 24;
      const t2 = (0 - cube.pointsValuesLinear[indexPointValue + cTwentyFour + indexA]) / (cube.pointsValuesLinear[indexPointValue + cTwentyFour + indexB] - cube.pointsValuesLinear[indexPointValue + cTwentyFour + indexA]);
      const xa = cube.pointsValuesLinear[indexPointValue + indexA * (2 + 1) + 0];
      const ya = cube.pointsValuesLinear[indexPointValue + indexA * (2 + 1) + 1];
      const za = cube.pointsValuesLinear[indexPointValue + indexA * (2 + 1) + 2];
      const xb = cube.pointsValuesLinear[indexPointValue + indexB * (2 + 1) + 0];
      const yb = cube.pointsValuesLinear[indexPointValue + indexB * (2 + 1) + 1];
      const zb = cube.pointsValuesLinear[indexPointValue + indexB * (2 + 1) + 2];
      vOut.x = xa * (1 - t2) + xb * t2;
      vOut.y = ya * (1 - t2) + yb * t2;
      vOut.z = za * (1 - t2) + zb * t2;
    }
  }
  /**
   * Check if triangle is visible (vertices are close to atoms included in visibility set)
   *
   * @param {Vector3} v0 Vertex #0
   * @param {Vector3} v1 Vertex #1
   * @param {Vector3} v2 Vertex #2
   * @returns {boolean} true if triangle is visible
   */
  isTriangleVisible(v0, v1, v2) {
    const a0 = this.voxelWorld.getClosestAtom(v0);
    const a1 = this.voxelWorld.getClosestAtom(v1);
    const a2 = this.voxelWorld.getClosestAtom(v2);
    if (a0 === null || a1 === null || a2 === null || a0.srcAtom === null || a1.srcAtom === null || a2.srcAtom === null) {
      return false;
    }
    return this.visibilitySelector.includesAtom(a0.srcAtom) && this.visibilitySelector.includesAtom(a1.srcAtom) && this.visibilitySelector.includesAtom(a2.srcAtom);
  }
  /**
   * Add triangle to result geometry
   *
   * @param {Vector3} v0 Vertex #0
   * @param {Vector3} v1 Vertex #1
   * @param {Vector3} v2 Vertex #2
   * @returns {boolean} false if no more triangles can be added
   */
  addTriangle(v0, v1, v2) {
    if (this.visibilitySelector && !this.isTriangleVisible(v0, v1, v2)) {
      return true;
    }
    const geo = this.geoOut;
    if (geo._numTriangles >= this.maxNumTriangles) {
      return false;
    }
    const indInGeo0 = this.addVertexToGeo(geo, v0);
    const indInGeo1 = this.addVertexToGeo(geo, v1);
    const indInGeo2 = this.addVertexToGeo(geo, v2);
    if ((indInGeo0 | indInGeo1 | indInGeo2) < 0) {
      return false;
    }
    const itr = 3 * geo._numTriangles;
    geo._indices[itr + 0] = indInGeo0;
    geo._indices[itr + 1] = indInGeo1;
    geo._indices[itr + 2] = indInGeo2;
    geo._numTriangles++;
    return true;
  }
  /**
   * Build result geometry (triangle mesh) from marching cube cells
   *
   * @param {number} meshRes Marchnig cube vertex count on each side
   * @param {Vector3} vBoxMin Bounding box point min
   * @param {Vector3} vBoxMax Bounding box point max
   * @param {number} corners float values array for each cube point
   * @param {Vector3} vCellStep vector to next cube cell diagonal point
   * @param {object} cube IsoSurfaceMarchCube object
   * @returns {number} 0, if success (<0) is error
   */
  buildGeoFromCorners(meshRes, vBoxMin, vBoxMax, corners, vCellStep, cube) {
    const arrSize = 12;
    const cNumVerts = 8;
    const numCells = meshRes - 1;
    const side = meshRes;
    const side2 = meshRes * meshRes;
    const vaEdges = new Array(arrSize);
    for (let i2 = 0; i2 < arrSize; i2++) {
      vaEdges[i2] = new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Vector3();
    }
    const sign2 = [];
    for (let i2 = 0; i2 < cNumVerts; i2++) {
      sign2[i2] = 1;
    }
    const vCorner = new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Vector3();
    let indCell = 0;
    let indY = 0;
    for (let y2 = 0; y2 < numCells; y2++, indY += side2) {
      let indZ = 0;
      for (let z = 0; z < numCells; z++, indZ += side) {
        for (let x3 = 0; x3 < numCells; x3++) {
          if (!cube.hasIntersection[indCell]) {
            indCell++;
            continue;
          }
          const bitsInside = cube.bitsInside[indCell];
          this.getCornerCoord(vBoxMin, vBoxMax, x3, y2, z, meshRes, vCorner);
          const indPointValues = indCell * (2 << 2 + 2);
          for (let i2 = 0, j = 0; i2 < cNumVerts; i2++) {
            cube.pointsValuesLinear[indPointValues + j++] = vCorner.x;
            cube.pointsValuesLinear[indPointValues + j++] = vCorner.y;
            cube.pointsValuesLinear[indPointValues + j++] = vCorner.z;
          }
          cube.pointsValuesLinear[indPointValues + 3] += vCellStep.x;
          cube.pointsValuesLinear[indPointValues + 2 * 3] += vCellStep.x;
          cube.pointsValuesLinear[indPointValues + 5 * 3] += vCellStep.x;
          cube.pointsValuesLinear[indPointValues + 6 * 3] += vCellStep.x;
          cube.pointsValuesLinear[indPointValues + 2 * 3 + 2] += vCellStep.z;
          cube.pointsValuesLinear[indPointValues + 3 * 3 + 2] += vCellStep.z;
          cube.pointsValuesLinear[indPointValues + 6 * 3 + 2] += vCellStep.z;
          cube.pointsValuesLinear[indPointValues + 7 * 3 + 2] += vCellStep.z;
          cube.pointsValuesLinear[indPointValues + 4 * 3 + 1] += vCellStep.y;
          cube.pointsValuesLinear[indPointValues + 5 * 3 + 1] += vCellStep.y;
          cube.pointsValuesLinear[indPointValues + 6 * 3 + 1] += vCellStep.y;
          cube.pointsValuesLinear[indPointValues + 7 * 3 + 1] += vCellStep.y;
          const indValues = indPointValues + 24;
          for (let i2 = 0; i2 < cNumVerts; ++i2) {
            sign2[i2] = cube.pointsValuesLinear[indValues + i2] < 0 ? 1 : 0;
          }
          this.buildEdgePoint(0, 1, sign2, cube, indPointValues, vaEdges[0]);
          this.buildEdgePoint(1, 2, sign2, cube, indPointValues, vaEdges[1]);
          this.buildEdgePoint(2, 3, sign2, cube, indPointValues, vaEdges[2]);
          this.buildEdgePoint(3, 0, sign2, cube, indPointValues, vaEdges[3]);
          this.buildEdgePoint(4, 5, sign2, cube, indPointValues, vaEdges[4]);
          this.buildEdgePoint(5, 6, sign2, cube, indPointValues, vaEdges[5]);
          this.buildEdgePoint(6, 7, sign2, cube, indPointValues, vaEdges[6]);
          this.buildEdgePoint(7, 4, sign2, cube, indPointValues, vaEdges[7]);
          this.buildEdgePoint(0, 4, sign2, cube, indPointValues, vaEdges[8]);
          this.buildEdgePoint(1, 5, sign2, cube, indPointValues, vaEdges[9]);
          this.buildEdgePoint(2, 6, sign2, cube, indPointValues, vaEdges[10]);
          this.buildEdgePoint(3, 7, sign2, cube, indPointValues, vaEdges[11]);
          const offs = bitsInside * (2 << 1 + 2);
          for (let numTri = 0, indTri = 0; numTri < 2 + 2 + 2; numTri++, indTri += 3) {
            const i0 = cube.striIndicesMarchCube[offs + indTri];
            if (i0 < 0) {
              break;
            }
            const i1 = cube.striIndicesMarchCube[offs + indTri + 1];
            const i2 = cube.striIndicesMarchCube[offs + indTri + 2];
            if (!this.addTriangle(vaEdges[i0], vaEdges[i1], vaEdges[i2])) {
              return 0 - 2;
            }
          }
          indCell++;
        }
      }
    }
    return 0;
  }
  /**
   * Returns number of cell with intersection with at least one sphere.
   * Using this number, we can estimate required number of vertices
   * and triangles to build result mesh.
   *
   * @param {number} side Number of points in cube voxels
   * @param {number} numCells Number of cells in cube voxels (per direction)
   * @param {array} corners Array of float values for cube corner points
   * @param {object} cube IsoSurfaceMarchCube object
   * @returns {number} numIntersectedCells
   */
  getNumIntersectedCells(side, numCells, corners, cube) {
    const side2 = side * side;
    const cNumVerts = 8;
    let numIntersectedCells = 0;
    let indCell = 0;
    let indY = 0;
    for (let y2 = 0; y2 < numCells; y2++, indY += side2) {
      let indZ = 0;
      for (let z = 0; z < numCells; z++, indZ += side) {
        for (let x3 = 0; x3 < numCells; x3++) {
          const cubeValuesIndex = indCell * (2 << 2 + 2) + 24;
          const indCorner = x3 + indZ + indY;
          cube.pointsValuesLinear[cubeValuesIndex] = corners[indCorner];
          cube.pointsValuesLinear[cubeValuesIndex + 1] = corners[indCorner + 1];
          cube.pointsValuesLinear[cubeValuesIndex + 2] = corners[indCorner + side + 1];
          cube.pointsValuesLinear[cubeValuesIndex + 3] = corners[indCorner + side];
          cube.pointsValuesLinear[cubeValuesIndex + 4] = corners[side2 + indCorner];
          cube.pointsValuesLinear[cubeValuesIndex + 5] = corners[side2 + indCorner + 1];
          cube.pointsValuesLinear[cubeValuesIndex + 6] = corners[side2 + indCorner + side + 1];
          cube.pointsValuesLinear[cubeValuesIndex + 7] = corners[side2 + indCorner + side];
          let bitsInside = 0;
          for (let i2 = 0; i2 < cNumVerts; ++i2) {
            if (cube.pointsValuesLinear[cubeValuesIndex + i2] < 0) {
              bitsInside |= 1 << i2;
            }
          }
          if (bitsInside === 0 || bitsInside === (1 << cNumVerts) - 1) {
            cube.hasIntersection[indCell] = false;
          } else {
            cube.hasIntersection[indCell] = true;
            numIntersectedCells++;
          }
          cube.bitsInside[indCell] = bitsInside;
          indCell++;
        }
      }
    }
    return numIntersectedCells;
  }
  getType(letter) {
    const atomT = [0, 0, 1, 1, 2, 6, 3, 6, 4, 6, 5, 6, 6, 0, 7, 3, 8, 2, 9, 6, 10, 6, 11, 6, 12, 6, 13, 6, 14, 6, 15, 4, 16, 5, 17, 6, 18, 6, 19, 6, 20, 6, 21, 6, 22, 6, 23, 6, 24, 6, 25, 6, 26, 6, 27, 6, 28, 6, 29, 6, 30, 6, 31, 6, 32, 6, 33, 6, 34, 6, 35, 6, 36, 6, 37, 6, 38, 6, 39, 6, 40, 6, 41, 6, 42, 6, 43, 6, 44, 6, 45, 6, 46, 6, 47, 6, 48, 6, 49, 6, 50, 6, 51, 6, 52, 6, 53, 6, 54, 6, 55, 6, 56, 6, 57, 6, 58, 6, 59, 6, 60, 6, 61, 6, 62, 6, 63, 6, 64, 6, 65, 6, 66, 6, 67, 6, 68, 6, 69, 6, 70, 6, 71, 6, 72, 6, 73, 6, 74, 6, 75, 6, 76, 6, 77, 6, 78, 6, 79, 6, 80, 6, 81, 6, 82, 6, 83, 6, 84, 6, 85, 6, 86, 6, 87, 6, 88, 6, 89, 6, 90, 6, 91, 6, 92, 6, 93, 6, 94, 6, 95, 6, 96, 6, 97, 6, 98, 6, 99, 6, 100, 6, 101, 6, 102, 6, 103, 6, 104, 6, 105, 6, 106, 6, 107, 6, 108, 6, 109, 6];
    if (letter < 1 || letter > atomT.length / 2 || Object.keys(SSIsosurfaceGeometry_Element.ByAtomicNumber).length * 2 !== atomT.length) {
      throw new Error("atomT.length  should be equal Element.ByAtomicNumber.length * 2");
    }
    return atomT[letter * 2];
  }
  /**
   * Calculate values for marching cube grid points
   * positive values are outside sphere, negative - is inside
   *
   * @param {array} corners array of float values
   * @param {number} side Number of point in cube in 1 dimennsion
   * @param {Vector3} vBoxMin Bounding box min point
   * @param {Vector3} vBoxMax Bounding box max point
   * @param {array} atoms Array of input atoms
   * @param {number} probeRad radius for atom probing
   */
  calculateGridCorners(corners, side, vBoxMin, vBoxMax, atoms, probeRad) {
    const side2 = side * side;
    const side3 = side2 * side;
    const vCorner = new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Vector3();
    const vDif = new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Vector3();
    const aLot = 1e12;
    for (let i2 = 0; i2 < side3; i2++) {
      corners[i2] = aLot;
    }
    const xScale = (side - 1) / (vBoxMax.x - vBoxMin.x);
    const yScale = (side - 1) / (vBoxMax.y - vBoxMin.y);
    const zScale = (side - 1) / (vBoxMax.z - vBoxMin.z);
    for (let s2 = 0, numAtoms = atoms.length; s2 < numAtoms; s2++) {
      const atom = atoms[s2];
      const radius = atom.radius + probeRad;
      const fx = (atom.coord.x - radius - vBoxMin.x) * xScale;
      const fy = (atom.coord.y - radius - vBoxMin.y) * yScale;
      const fz = (atom.coord.z - radius - vBoxMin.z) * zScale;
      const indXMin = Math.floor(fx);
      const indYMin = Math.floor(fy);
      const indZMin = Math.floor(fz);
      let indXMax = Math.floor((atom.coord.x + radius - vBoxMin.x) * xScale);
      let indYMax = Math.floor((atom.coord.y + radius - vBoxMin.y) * yScale);
      let indZMax = Math.floor((atom.coord.z + radius - vBoxMin.z) * zScale);
      indXMax++;
      indYMax++;
      indZMax++;
      indXMax = indXMax <= side - 1 ? indXMax : side - 1;
      indYMax = indYMax <= side - 1 ? indYMax : side - 1;
      indZMax = indZMax <= side - 1 ? indZMax : side - 1;
      for (let y2 = indYMin; y2 <= indYMax; y2++) {
        const indY = y2 * side2;
        for (let z = indZMin; z <= indZMax; z++) {
          const indZ = z * side;
          for (let x3 = indXMin; x3 <= indXMax; x3++) {
            const ind = indY + indZ + x3;
            this.getCornerCoord(vBoxMin, vBoxMax, x3, y2, z, side, vCorner);
            vDif.x = vCorner.x - atom.coord.x;
            vDif.y = vCorner.y - atom.coord.y;
            vDif.z = vCorner.z - atom.coord.z;
            const distToSphere = Math.sqrt(vDif.x * vDif.x + vDif.y * vDif.y + vDif.z * vDif.z);
            const val = distToSphere - radius;
            if (val < corners[ind]) {
              corners[ind] = val;
            }
          }
        }
      }
    }
  }
  /**
   * Create memory pool for vertex hash management
   *
   * @param {number} maxNumVertices Maximum possible number of vertices (that will be build)
   * @param {number} maxNumTriangles Maximum possible number of triangles (that will be build)
   * @returns {number} 0, if success. (<0) is non memory
   */
  createVertexHash(maxNumVertices, maxNumTriangles) {
    this.hashLines = utils.allocateTyped(Int32Array, HASH_SIZE * 2);
    if (this.hashLines === null) {
      return 0 - 1;
    }
    for (let i2 = 0, j = 0; i2 < HASH_SIZE; i2++) {
      this.hashLines[j++] = 0;
      this.hashLines[j++] = 0 - 1;
    }
    this.maxNumVertices = maxNumVertices;
    this.maxNumTriangles = maxNumTriangles;
    this.numHashEtriesAllocated = maxNumVertices;
    this.hashEntries = utils.allocateTyped(Int32Array, 2 * this.numHashEtriesAllocated);
    if (this.hashEntries === null) {
      return 0 - 1;
    }
    for (let i2 = 0, j = 0; i2 < this.numHashEtriesAllocated; i2++) {
      this.hashEntries[j++] = 0 - 1;
      this.hashEntries[j++] = 0 - 1;
    }
    this.numHashEntryIndex = 0;
    return 0;
  }
  /**
   * Allocate and return new hash entry. Just check possible amount.
   *
   * @returns {number} index of hash entry, that can be used for geometry add vertex functionality
   */
  getNewHashEntry() {
    if (this.numHashEntryIndex < this.numHashEtriesAllocated) {
      const i2 = this.numHashEntryIndex;
      this.numHashEntryIndex++;
      return i2;
    }
    return 0 - 1;
  }
  /**
   * Add vertex to geometry structure
   * using vertex hash table to quickly check, is this vertex already exist in geometry
   *
   * @param {object} geoOut Geometry to build
   * @param {Vector3} vAdd Vertex to add
   * @returns {number} index of added (or existing) vertex in geometry.
   */
  addVertexToGeo(geoOut, vAdd) {
    let entry;
    const oneHynberes = 0.01;
    const n815851 = 815851;
    const n37633 = 37633;
    const n2453543 = 2453543;
    const r106 = 1e-6;
    const hashResolution = this.marCubeResoultion << 2;
    const v2 = new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Vector3();
    const ix = Math.floor(hashResolution * (vAdd.x - this.vBoxMin.x) / (this.vBoxMax.x + oneHynberes - this.vBoxMin.x));
    const iy = Math.floor(hashResolution * (vAdd.y - this.vBoxMin.y) / (this.vBoxMax.y + oneHynberes - this.vBoxMin.y));
    const iz = Math.floor(hashResolution * (vAdd.z - this.vBoxMin.z) / (this.vBoxMax.z + oneHynberes - this.vBoxMin.z));
    let iHash = ix * n815851 + iz * n37633 + iy * n2453543;
    iHash &= HASH_SIZE - 1;
    const hLineIndex = iHash + iHash;
    if (this.vBoxMin !== null && this.vBoxMax !== null) {
      for (entry = this.hashLines[hLineIndex + 1]; entry >= 0; entry = this.hashEntries[entry * 2 + 1]) {
        const ind = this.hashEntries[entry * 2 + 0];
        v2.copy(geoOut._vertices[ind]);
        v2.x -= vAdd.x;
        v2.y -= vAdd.y;
        v2.z -= vAdd.z;
        const dot2 = v2.x * v2.x + v2.y * v2.y + v2.z * v2.z;
        if (dot2 < r106) {
          return ind;
        }
      }
    }
    if (geoOut._numVertices >= this.maxNumVertices) {
      return 0 - 1;
    }
    const iVertAdd = geoOut._numVertices;
    geoOut._vertices[iVertAdd].copy(vAdd);
    if (this.vBoxMin !== null && this.vBoxMax !== null) {
      entry = this.getNewHashEntry();
      if (entry < 0) {
        return 0 - 1;
      }
      const entryFirst = this.hashLines[hLineIndex + 1];
      this.hashLines[hLineIndex + 1] = entry;
      this.hashEntries[entry * 2 + 0] = iVertAdd;
      this.hashEntries[entry * 2 + 1] = entryFirst;
      this.hashLines[hLineIndex + 0]++;
    }
    geoOut._numVertices++;
    return iVertAdd;
  }
  /**
   *
   * @param {number} side some placeholder description
   * @param {number} probeSphereRadius some placeholder description
   * @param {object} vBoxMin some placeholder description
   * @param {object} vBoxMax some placeholder description
   * @param {object} geoOut some placeholder description
   * @param {object} corners some placeholder description
   * @returns {number} always 0
   */
  modifyExcludedFromGeo(side, probeSphereRadius, vBoxMin, vBoxMax, geoOut, corners) {
    let ind;
    let distToSphere;
    let distToBorder;
    const r11 = 1.1;
    function innerBlockWorkAround() {
      if (distToBorder > 0) {
        if (corners[ind] < 0) {
          corners[ind] = distToBorder;
        }
        if (distToBorder > corners[ind]) {
          corners[ind] = distToBorder;
        }
      } else if (distToBorder > corners[ind]) {
        corners[ind] = distToBorder;
      }
    }
    const side2 = side * side;
    const xScale = (side - 1) / (vBoxMax.x - vBoxMin.x);
    const yScale = (side - 1) / (vBoxMax.y - vBoxMin.y);
    const zScale = (side - 1) / (vBoxMax.z - vBoxMin.z);
    const probeSpRad2 = probeSphereRadius * 2 * (probeSphereRadius * 2);
    const sideInv = 1 / (side - 1);
    for (let i2 = 0; i2 < geoOut._numVertices; i2++) {
      const vCenter = geoOut._vertices[i2];
      const radEst = probeSphereRadius * r11;
      let indXMin = Math.floor((vCenter.x - radEst - vBoxMin.x) * xScale);
      let indYMin = Math.floor((vCenter.y - radEst - vBoxMin.y) * yScale);
      let indZMin = Math.floor((vCenter.z - radEst - vBoxMin.z) * zScale);
      let indXMax = Math.floor((vCenter.x + radEst - vBoxMin.x) * xScale);
      let indYMax = Math.floor((vCenter.y + radEst - vBoxMin.y) * yScale);
      let indZMax = Math.floor((vCenter.z + radEst - vBoxMin.z) * zScale);
      indXMin = indXMin >= 0 ? indXMin : 0;
      indYMin = indYMin >= 0 ? indYMin : 0;
      indZMin = indZMin >= 0 ? indZMin : 0;
      indXMax = indXMax <= side - 1 ? indXMax : side - 1;
      indYMax = indYMax <= side - 1 ? indYMax : side - 1;
      indZMax = indZMax <= side - 1 ? indZMax : side - 1;
      for (let iy = indYMin; iy <= indYMax; iy++) {
        const indY = iy * side2;
        for (let iz = indZMin; iz <= indZMax; iz++) {
          const indZ = iz * side;
          for (let ix = indXMin; ix <= indXMax; ix++) {
            ind = indY + indZ + ix;
            let t2 = ix * sideInv;
            const xCorner = vBoxMin.x * (1 - t2) + vBoxMax.x * t2;
            t2 = iy * sideInv;
            const yCorner = vBoxMin.y * (1 - t2) + vBoxMax.y * t2;
            t2 = iz * sideInv;
            const zCorner = vBoxMin.z * (1 - t2) + vBoxMax.z * t2;
            const dx = xCorner - vCenter.x;
            const dy = yCorner - vCenter.y;
            const dz = zCorner - vCenter.z;
            const dist2 = dx * dx + dy * dy + dz * dz;
            if (dist2 < probeSpRad2) {
              distToSphere = Math.sqrt(dist2);
              distToBorder = -(distToSphere - probeSphereRadius);
              innerBlockWorkAround();
            }
          }
        }
      }
    }
    return 0;
  }
  _innerBuild() {
    let ok;
    const expandFactor = 1.2;
    const packedArrays = {
      posRad: this._posRad,
      colors: this._colors,
      atoms: this._opts.atoms
    };
    this.complex = this._opts.parent;
    this.atoms = packedArrays.atoms;
    this.meshResolution = this._opts.gridSpacing;
    this.atomRadiusScale = this._opts.radScale;
    this.colorMode = this._opts.colorMode;
    this.probeRadius = this._opts.probeRadius;
    this.useVertexColors = true;
    this.excludeProbe = this._opts.excludeProbe;
    this.visibilitySelector = this._opts.visibilitySelector;
    this.geoOut = null;
    this.hashLines = null;
    this.hashEntries = null;
    this.numHashEtriesAllocated = 0;
    this.numHashEntryIndex = 0;
    this.maxNumVertices = 0;
    this.maxNumTriangles = 0;
    const atomsColored = new Array(this.atoms.length);
    this.convertToAtomsColored(packedArrays, atomsColored);
    const vBoxMin = this.vBoxMin = new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Vector3();
    const vBoxMax = this.vBoxMax = new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Vector3();
    this.getBoundingBox(atomsColored, vBoxMin, vBoxMax);
    const marCubeResoultion = this.marCubeResoultion = this.meshResolution * (2 + 2);
    const side = marCubeResoultion;
    const side2 = side * side;
    const side3 = side2 * side;
    const corners = utils.allocateTyped(Float32Array, side3);
    const rProbeRadius = this.probeRadius * this.atomRadiusScale;
    this.calculateGridCorners(corners, side, vBoxMin, vBoxMax, atomsColored, rProbeRadius);
    const numCells = marCubeResoultion - 1;
    const cube = new geometries_IsoSurfaceMarchCube();
    ok = cube.create(numCells);
    if (ok < 0) {
      return ok;
    }
    const vCellStep = new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Vector3();
    vCellStep.x = (vBoxMax.x - vBoxMin.x) / numCells;
    vCellStep.y = (vBoxMax.y - vBoxMin.y) / numCells;
    vCellStep.z = (vBoxMax.z - vBoxMin.z) / numCells;
    let numIntersectedCellsEstim = this.getNumIntersectedCells(side, numCells, corners, cube);
    let maxNumVertices = Math.floor(numIntersectedCellsEstim * expandFactor);
    let maxNumTriangles = Math.floor(numIntersectedCellsEstim * expandFactor * 2);
    this.geoOut = new geometries_IsoSurfaceGeo(maxNumVertices, maxNumTriangles, this.useVertexColors);
    ok = this.createVertexHash(maxNumVertices, maxNumTriangles);
    if (ok < 0) {
      return ok;
    }
    let probeRadForNormalsColors = rProbeRadius;
    if (this.excludeProbe) {
      probeRadForNormalsColors = 0.01;
    }
    this.voxelWorld = new geometries_IsosurfaceBuildNormals(atomsColored.length, atomsColored, vBoxMin, vBoxMax, probeRadForNormalsColors);
    this.voxelWorld.createVoxels();
    ok = this.buildGeoFromCorners(marCubeResoultion, vBoxMin, vBoxMax, corners, vCellStep, cube);
    if (this.excludeProbe) {
      this.modifyExcludedFromGeo(side, rProbeRadius, vBoxMin, vBoxMax, this.geoOut, corners);
      this.geoOut._vertices = null;
      this.geoOut._colors = null;
      this.geoOut._indices = null;
      this.geoOut._normals = null;
      this.geoOut._numVertices = 0;
      this.geoOut._numTriangles = 0;
      this.geoOut = null;
      numIntersectedCellsEstim = this.getNumIntersectedCells(side, numCells, corners, cube);
      maxNumVertices = Math.floor(numIntersectedCellsEstim * expandFactor);
      maxNumTriangles = Math.floor(numIntersectedCellsEstim * expandFactor * 2);
      this.geoOut = new geometries_IsoSurfaceGeo(maxNumVertices, maxNumTriangles, this.useVertexColors);
      ok = this.createVertexHash(maxNumVertices, maxNumTriangles);
      if (ok < 0) {
        return ok;
      }
      ok = this.buildGeoFromCorners(side, vBoxMin, vBoxMax, corners, vCellStep, cube);
    }
    this.voxelWorld.buildNormals(this.geoOut._vertices.length, this.geoOut._vertices, this.geoOut._normals);
    let radiusColorSmoothness = 6.5;
    if (this.excludeProbe) {
      radiusColorSmoothness -= 1.5;
    }
    if (this.useVertexColors) {
      this.voxelWorld.buildColors(this.geoOut._vertices.length, this.geoOut._vertices, this.geoOut._colors, radiusColorSmoothness);
    }
    this.voxelWorld.destroyVoxels();
    this.voxelWorld = null;
    cube.destroy();
    return ok;
  }
};
var geometries_SSIsosurfaceGeometry = SSIsosurfaceGeometry;
function createLabel(fieldTxt, className) {
  const text = document.createElement("div");
  text.className = className;
  if (typeof fieldTxt === "string") {
    const spanText = document.createElement("span");
    spanText.style.fontSize = "150%";
    const strings = fieldTxt.split("\n");
    for (let i2 = 0, n = strings.length; i2 < n; ++i2) {
      const spanNodeP = document.createElement("span");
      const spanNodeText = document.createTextNode(strings[i2]);
      spanNodeP.appendChild(spanNodeText);
      spanText.appendChild(spanNodeP);
      if (i2 < n - 1) {
        spanText.appendChild(document.createElement("br"));
      }
    }
    text.appendChild(spanText);
  } else {
    text.appendChild(fieldTxt);
  }
  text.worldPos = new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Vector3();
  return text;
}
var LabelsGeometry = class extends utils_EventDispatcher {
  constructor(instanceCount, opts) {
    super();
    this._opts = opts;
    this.items = [];
    this.needsUpdate = false;
    let xTranslation = -50;
    let yTranslation = -50;
    switch (opts.horizontalAlign) {
      case "left":
        xTranslation = 0;
        break;
      case "right":
        xTranslation = -100;
        break;
      default:
        break;
    }
    switch (opts.verticalAlign) {
      case "top":
        yTranslation = -100;
        break;
      case "bottom":
        yTranslation = 0;
        break;
      default:
        break;
    }
    const deltaPos = new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Vector3(opts.dx || 0, opts.dy || 0, opts.dz || 0);
    this.userData = {
      translation: `translate(${xTranslation}%, ${yTranslation}%)`,
      offset: deltaPos
    };
  }
  setItem(itemIdx, itemPos, fieldTxt) {
    const opts = this._opts;
    const text = this.items[itemIdx] || createLabel(fieldTxt, "label");
    text.worldPos.copy(itemPos);
    text.style.textAlign = opts.horizontalAlign;
    text.style.verticalAlign = opts.verticalAlign;
    this.items[itemIdx] = text;
  }
  setColor(itemIdx, fColor, bColor) {
    const text = this.items[itemIdx];
    text.opts = {
      color: fColor,
      background: bColor
    };
  }
  startUpdate() {
    return true;
  }
  finishUpdate() {
    this.needsUpdate = true;
    this.dispatchEvent({
      type: "update"
    });
  }
  finalize() {
    this.finishUpdate();
  }
  // unimplemented functions
  raycast() {
  }
  setOpacity() {
  }
  getSubset() {
    return [];
  }
};
var geometries_LabelsGeometry = LabelsGeometry;
var geometries = {
  InstancedSpheresGeometry: geometries_InstancedSpheresGeometry,
  SimpleSpheresGeometry: geometries_SimpleSpheresGeometry,
  Simple2CCylindersGeometry: geometries_Simple2CCylindersGeometry,
  Instanced2CCylindersGeometry: geometries_Instanced2CCylindersGeometry,
  ExtrudedObjectsGeometry: geometries_ExtrudedObjectsGeometry,
  ChunkedLinesGeometry: geometries_ChunkedLinesGeometry,
  TwoColorLinesGeometry: geometries_TwoColorLinesGeometry,
  CrossGeometry: geometries_CrossGeometry,
  QuickSurfGeometry: geometries_QuickSurfGeometry,
  ContactSurfaceGeometry: geometries_ContactSurfaceGeometry,
  SSIsosurfaceGeometry: geometries_SSIsosurfaceGeometry,
  LabelsGeometry: geometries_LabelsGeometry
};
var Uber_namespaceObject = "float INSTANCED_SPRITE_OVERSCALE = 1.3;\r\n\r\nattribute vec3 normal;\r\n\r\n#ifdef NORMALS_TO_G_BUFFER\r\n  varying vec3 viewNormal;\r\n#endif\r\n#if !defined (SPHERE_SPRITE) && !defined (CYLINDER_SPRITE)\r\n  varying vec3 vNormal;\r\n#endif\r\n\r\n#ifdef THICK_LINE\r\n  attribute vec4 position; // W contains vert pos or neg offset\r\n#else\r\n  attribute vec3 position;\r\n#endif\r\n\r\nvarying vec3 vWorldPosition;\r\nvarying vec3 vViewPosition;\r\n\r\n#ifdef ATTR_ALPHA_COLOR\r\n  attribute float alphaColor;\r\n  varying float alphaCol;\r\n#endif\r\n\r\n#if defined(USE_LIGHTS) && defined(SHADOWMAP)\r\n	#if NUM_DIR_LIGHTS > 0\r\n		uniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHTS ];\r\n		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\r\n		varying vec3 vDirectionalShadowNormal[ NUM_DIR_LIGHTS ];\r\n	#endif\r\n#endif\r\n\r\n#ifdef ATTR_COLOR\r\n  attribute vec3 color;\r\n  varying vec3 vColor;\r\n#endif\r\n\r\n#ifdef ATTR_COLOR2\r\n  attribute vec3 color2;\r\n  varying vec3 vColor2;\r\n  attribute vec2 uv;\r\n  #ifndef CYLINDER_SPRITE\r\n    varying vec2 vUv;\r\n  #endif\r\n#endif\r\n\r\n#ifdef INSTANCED_POS\r\n  attribute vec4 offset;\r\n  #ifdef SPHERE_SPRITE\r\n    varying vec4 instOffset;\r\n  varying vec4 spritePosEye;\r\n  #endif\r\n#endif\r\n\r\n#ifdef INSTANCED_MATRIX\r\n  attribute vec4 matVector1;\r\n  attribute vec4 matVector2;\r\n  attribute vec4 matVector3;\r\n  attribute vec4 invmatVector1;\r\n  attribute vec4 invmatVector2;\r\n  attribute vec4 invmatVector3;\r\n\r\n  #ifdef CYLINDER_SPRITE\r\n    varying vec4 matVec1;\r\n    varying vec4 matVec2;\r\n    varying vec4 matVec3;\r\n    varying vec4 invmatVec1;\r\n    varying vec4 invmatVec2;\r\n    varying vec4 invmatVec3;\r\n    varying vec4 spritePosEye;\r\n  #endif\r\n#endif\r\n\r\nuniform mat4 modelViewMatrix; // optional\r\nuniform mat4 projectionMatrix; // optional\r\nuniform mat3 normalMatrix; // optional\r\nuniform mat4 modelMatrix; // optional\r\n\r\n#ifdef DASHED_LINE\r\n  attribute float lineDistance;\r\n  varying float vLineDistance;\r\n#endif\r\n\r\n#ifdef THICK_LINE\r\n  attribute vec3 direction;\r\n  uniform mat4 projMatrixInv;\r\n  uniform vec2 viewport;\r\n  uniform float lineWidth;\r\n\r\n  vec4 transform(vec4 coord){\r\n    return projectionMatrix * modelViewMatrix * coord;\r\n  }\r\n\r\n  vec2 project(vec4 device){\r\n    vec3 device_normal = device.xyz/device.w;\r\n    vec2 clip_pos = (device_normal*0.5+0.5).xy;\r\n    return clip_pos * viewport;\r\n  }\r\n\r\n  vec4 unproject(vec2 screen, float z, float w){\r\n    vec2 clip_pos = screen/viewport;\r\n    vec2 device_normal = clip_pos*2.0-1.0;\r\n    return vec4(device_normal*w, z, w);\r\n  }\r\n#endif\r\n\r\n\r\n/////////////////////////////////////////// Main ///////////////////////////////////////////////\r\nvoid main() {\r\n\r\n#ifdef ATTR_ALPHA_COLOR\r\n  alphaCol = alphaColor;\r\n#endif\r\n\r\n#ifdef INSTANCED_MATRIX\r\n  vec3 objectNormal = vec3(\r\n    dot(normal, matVector1.xyz),\r\n    dot(normal, matVector2.xyz),\r\n    dot(normal, matVector3.xyz));\r\n#else\r\n  vec3 objectNormal = vec3( normal );\r\n#endif\r\n\r\nvec3 transformedNormal = normalMatrix * objectNormal;\r\n\r\n#if !defined (SPHERE_SPRITE) && !defined (CYLINDER_SPRITE)\r\n  vNormal = normalize(transformedNormal);\r\n#endif\r\n\r\n#ifdef NORMALS_TO_G_BUFFER\r\n  viewNormal = normalize(mat3(modelViewMatrix)*objectNormal);\r\n#endif\r\n\r\n  vec4 localPos = vec4(position.xyz, 1.0);\r\n  vec4 worldPos = modelMatrix * localPos;\r\n  vec4 mvPosition = modelViewMatrix * localPos;\r\n\r\n// make thick line offset\r\n#ifdef THICK_LINE\r\n   // get screen pos\r\n   vec4 dPos = transform(vec4(position.xyz, 1.0));\r\n   vec2 sPos = project(dPos);\r\n   // move pos forward\r\n   vec3 position2 = position.xyz + direction.xyz * 0.5;\r\n   // get screen offset pos\r\n   vec4 dPos2 = transform(vec4(position2.xyz, 1.0));\r\n   vec2 sPos2 = project(dPos2);\r\n   // screen line direction\r\n   vec2 sDir = normalize(sPos2 - sPos);\r\n   // vertex offset (orthogonal to line direction)\r\n   vec2 offset1 = vec2(-sDir.y, sDir.x);\r\n   // move screen vertex\r\n   vec2 newPos = sPos + offset1 * position.w * lineWidth;\r\n   // get moved pos in view space\r\n   vec4 dNewPos =  unproject(newPos, dPos.z, dPos.w);\r\n   mvPosition.xyz = (projMatrixInv * dNewPos).xyz;\r\n#endif // THICK_LINE\r\n\r\n#ifdef INSTANCED_POS\r\n  #ifdef SPHERE_SPRITE\r\n    instOffset = offset;\r\n\r\n    vec4 posEye = modelViewMatrix * vec4( offset.xyz, 1.0 );\r\n    float scale = length(modelViewMatrix[0]);\r\n    mvPosition = posEye + vec4( position.xyz * offset.w * scale * INSTANCED_SPRITE_OVERSCALE, 0.0 );\r\n    posEye.w = offset.w * scale;\r\n\r\n    spritePosEye = posEye;\r\n #else\r\n    localPos = vec4( offset.xyz + position.xyz * offset.w, 1.0 );\r\n    worldPos = modelMatrix * localPos;\r\n    mvPosition = modelViewMatrix * localPos;\r\n  #endif\r\n#endif\r\n\r\n#ifdef INSTANCED_MATRIX\r\n  #ifdef CYLINDER_SPRITE\r\n    matVec1 = matVector1;\r\n    matVec2 = matVector2;\r\n    matVec3 = matVector3;\r\n    invmatVec1 = invmatVector1;\r\n    invmatVec2 = invmatVector2;\r\n    invmatVec3 = invmatVector3;\r\n\r\n    // calculate eye coords of cylinder endpoints\r\n    vec4 v = vec4(0, -0.5, 0, 1);\r\n    vec4 p1 = modelViewMatrix * vec4(dot(v, matVector1), dot(v, matVector2), dot(v, matVector3), 1.0);\r\n    v.y = 0.5;\r\n    vec4 p2 = modelViewMatrix * vec4(dot(v, matVector1), dot(v, matVector2), dot(v, matVector3), 1.0);\r\n\r\n    // sprite is placed at the center of cylinder\r\n    vec4 posEye;\r\n    posEye.xyz = mix(p1.xyz, p2.xyz, 0.5);\r\n    posEye.w = 1.0;\r\n    spritePosEye = posEye;\r\n\r\n    // cylinder radius in eye space\r\n    float rad = length(modelViewMatrix[0]) * length(vec3(matVector1.x, matVector2.x, matVector3.x));\r\n    vec2 spriteSize;\r\n    #ifdef ORTHOGRAPHIC_CAMERA\r\n      // In ortho projection we skip z coordinate\r\n      // basic sprite size at screen plane (covers only cylinder axis)\r\n      vec2 spriteSizeScreen = abs(p2.xy - p1.xy);\r\n\r\n      spriteSize = vec2(1.0, 1.0) * INSTANCED_SPRITE_OVERSCALE * (spriteSizeScreen + 2.0 * rad);\r\n    #else\r\n      // basic sprite size at screen plane (covers only cylinder axis)\r\n      vec2 spriteSizeScreen = abs(p2.xy / p2.z - p1.xy / p1.z);\r\n\r\n      // full sprite size in eye coords\r\n      float minZ = min(abs(p1.z), abs(p2.z));\r\n      spriteSize = vec2(1.0, 1.0) * INSTANCED_SPRITE_OVERSCALE * abs(posEye.z) * (spriteSizeScreen + 2.0 * rad / minZ);\r\n    #endif\r\n\r\n    mvPosition = posEye + vec4( position.xy * 0.5 * spriteSize, 0, 0 );\r\n  #else\r\n    localPos = vec4(dot(localPos, matVector1), dot(localPos, matVector2), dot(localPos, matVector3), 1.0);\r\n    worldPos = modelMatrix * localPos;\r\n    mvPosition = modelViewMatrix * localPos;\r\n  #endif\r\n#endif\r\n\r\n  gl_Position = projectionMatrix * mvPosition;\r\n\r\n  vWorldPosition = worldPos.xyz;\r\n  vViewPosition = - mvPosition.xyz;\r\n\r\n#if defined(USE_LIGHTS) && defined(SHADOWMAP)\r\n	#if NUM_DIR_LIGHTS > 0\r\n	  vec4 worldPosition;\r\n	  // see THREE.WebGLProgram.unrollLoops\r\n	  #pragma unroll_loop_start\r\n	  for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\r\n      vDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * vec4(vWorldPosition, 1.0);\r\n      vDirectionalShadowNormal[ i ] = (directionalShadowMatrix[ i ] * (modelMatrix * vec4(objectNormal, 0.0))).xyz;\r\n	  }\r\n	  #pragma unroll_loop_end\r\n	#endif\r\n#endif\r\n\r\n#ifdef ATTR_COLOR\r\n  vColor = color.xyz;\r\n#endif\r\n\r\n#ifdef ATTR_COLOR2\r\n  vColor2 = color2;\r\n  #ifndef CYLINDER_SPRITE\r\n    vUv = uv;\r\n  #endif\r\n#endif\r\n\r\n#ifdef DASHED_LINE\r\n  vLineDistance = lineDistance;\r\n#endif\r\n}\r\n";
var gfx_shaders_Uber_namespaceObject = "#if defined (NORMALS_TO_G_BUFFER)\r\n  #define fragColor gl_FragData[0]\r\n#else\r\n  #define fragColor gl_FragColor\r\n#endif\r\n\r\n#ifdef ATTR_ALPHA_COLOR\r\n  varying float alphaCol;\r\n#endif\r\n\r\n#ifdef COLOR_FROM_POS\r\n  uniform mat4 world2colorMatrix;\r\n#endif\r\n\r\n#if defined(USE_LIGHTS) && defined(SHADOWMAP)\r\n	#if NUM_DIR_LIGHTS > 0\r\n		uniform sampler2D directionalShadowMap[ NUM_DIR_LIGHTS ];\r\n    uniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHTS ]; //only for sprites\r\n		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\r\n		varying vec3 vDirectionalShadowNormal[ NUM_DIR_LIGHTS ];\r\n    vec4 vDirLightWorldCoord[ NUM_DIR_LIGHTS ];\r\n    vec3 vDirLightWorldNormal[ NUM_DIR_LIGHTS ];\r\n\r\n    #ifdef SHADOWMAP_PCF_RAND\r\n      // We use 4 instead uniform variable or define because this value is used in for(... i < value; ...) with\r\n      // unroll_loop and unroll_loop has pattern:\r\n      // /#pragma unroll_loop[\\s]+?for \\( int i \\= (\\d+)\\; i < (\\d+)\\; i \\+\\+ \\) \\{([\\s\\S]+?)(?=\\})\\}/g\r\n      uniform vec2 samplesKernel[4]; // 4 is length of _samplesKernel which is defined in UberMaterial.js\r\n      uniform sampler2D noiseTex;\r\n      uniform vec2 noiseTexelSize;\r\n      uniform vec2 srcTexelSize;\r\n      uniform mat4 projectionMatrix;\r\n    #endif\r\n	#endif\r\n#endif\r\n\r\n#ifdef ATTR_COLOR\r\n  varying vec3 vColor;\r\n#endif\r\n\r\n#ifdef ATTR_COLOR2\r\n  varying vec3 vColor2;\r\n  #ifndef CYLINDER_SPRITE\r\n    varying vec2 vUv;\r\n  #endif\r\n#endif\r\n\r\nuniform vec3 diffuse;\r\nuniform vec3 emissive;\r\nuniform vec3 specular;\r\nuniform float shininess;\r\nuniform vec3 fixedColor;\r\nuniform float opacity;\r\nuniform float zClipValue;\r\nuniform float clipPlaneValue;\r\n\r\n#ifdef NORMALS_TO_G_BUFFER\r\n  varying vec3 viewNormal;\r\n#endif\r\n\r\n#define RECIPROCAL_PI 0.31830988618\r\n#define saturate(a) clamp( a, 0.0, 1.0 )\r\n\r\n#ifdef USE_FOG\r\n  uniform vec3 fogColor;\r\n  uniform float fogAlpha;\r\n  uniform float fogNear;\r\n  uniform float fogFar;\r\n#endif\r\n\r\nvarying vec3 vWorldPosition; // world position of the pixel (invalid when INSTANCED_SPRITE is defined)\r\nvarying vec3 vViewPosition;\r\n\r\n#if !defined (SPHERE_SPRITE) && !defined (CYLINDER_SPRITE)\r\n  varying vec3 vNormal;\r\n#endif\r\n\r\n/////////////////////////////////////////// ZSprites ////////////////////////////////////////////////\r\n#if defined (SPHERE_SPRITE) || defined (CYLINDER_SPRITE)\r\n  uniform float nearPlaneValue;\r\n#endif\r\n\r\n#ifdef SPHERE_SPRITE\r\n  varying vec4 spritePosEye;\r\n#endif\r\n\r\n#if defined(SPHERE_SPRITE) || defined(CYLINDER_SPRITE)\r\n  uniform float zOffset;\r\n\r\n  #if !defined(USE_LIGHTS) || !defined(SHADOWMAP) || !defined(SHADOWMAP_PCF_RAND) || !(NUM_DIR_LIGHTS > 0)\r\n    uniform mat4 projectionMatrix;\r\n  #endif\r\n\r\n  float calcDepthForSprites(vec4 pixelPosEye, float zOffset, mat4 projMatrix) {\r\n    vec4 pixelPosScreen = projMatrix * pixelPosEye;\r\n    return 0.5 * (pixelPosScreen.z / pixelPosScreen.w + 1.0) + zOffset;\r\n  }\r\n#endif\r\n\r\n#ifdef SPHERE_SPRITE\r\n  varying vec4 instOffset;\r\n  uniform mat4 modelMatrix;\r\n  uniform mat4 modelViewMatrix;\r\n  uniform mat4 invModelViewMatrix;\r\n  uniform mat3 normalMatrix;\r\n\r\n\r\n  bool intersect_ray_sphere(in vec3 origin, in vec3 ray, out vec3 point, out float frontFaced) {\r\n\r\n    // intersect XZ-projected ray with circle\r\n    float a = dot(ray, ray);\r\n    float b = dot(ray, origin);\r\n    float c = dot(origin, origin) - 1.0;\r\n    float det = b * b - a * c;\r\n    if (det < 0.0) return false;\r\n    float t1 = (-b - sqrt(det)) / a;\r\n    float t2 = (-b + sqrt(det)) / a;\r\n\r\n    // calculate both intersection points\r\n    vec3 p1 = origin + ray * t1;\r\n    vec3 p2 = origin + ray * t2;\r\n\r\n    // choose nearest point inside frustum\r\n    #ifdef ORTHOGRAPHIC_CAMERA\r\n      // orthografic camera is used for dirLight sources. So in it for all spheres the point with smaller 't' is visible\r\n      // t1 is always smaller than t2 (from calculations)\r\n      point = p1;\r\n      frontFaced = 1.0;\r\n      return true;\r\n    #else\r\n      // for perspective camera first intersection can be in front of near plane. If not intersection is p1 else - p2\r\n      // t* = 0.0 corresponds to point of intersection near plane by the ray from camera to curPixel\r\n      if (t1 >= 0.0) {\r\n        point = p1;\r\n        frontFaced = 1.0;\r\n        return true;\r\n      }\r\n      if (t2 >= 0.0) {\r\n        point = p2;\r\n        frontFaced = -1.0;\r\n        return true;\r\n      }\r\n    #endif\r\n\r\n    return false;\r\n  }\r\n\r\n  bool get_sphere_point(in vec3 pixelPosEye, out vec3 point, out float frontFaced) {\r\n    vec3 origin, ray;\r\n\r\n    #ifdef ORTHOGRAPHIC_CAMERA\r\n      // transform vector from sprite center to curPixel into sphere local coords\r\n      origin = pixelPosEye.xyz - spritePosEye.xyz;\r\n      origin = (invModelViewMatrix * vec4(origin, 0.0)).xyz / instOffset.w;\r\n\r\n      // transform camera orientation vector into sphere local coords\r\n      ray = (invModelViewMatrix * vec4(0.0, 0.0, -1.0, 0.0)).xyz;\r\n    #else\r\n      // find point of intersection near plane by the ray from camera to curPixel\r\n      vec4 v = vec4(-(nearPlaneValue / pixelPosEye.z) * pixelPosEye, 1.0);\r\n\r\n      // transform intersection point into sphere local coords\r\n      v = invModelViewMatrix * v;\r\n      origin = (v.xyz - instOffset.xyz) / instOffset.w;\r\n\r\n      // transform vector from camera pos to curPixel into sphere local coords\r\n      ray = (invModelViewMatrix * vec4(pixelPosEye, 0.0)).xyz;\r\n    #endif\r\n    ray = normalize(ray);\r\n\r\n    return intersect_ray_sphere(origin, ray, point, frontFaced);\r\n  }\r\n#endif\r\n\r\n#ifdef CYLINDER_SPRITE\r\n  varying vec4 matVec1;\r\n  varying vec4 matVec2;\r\n  varying vec4 matVec3;\r\n  varying vec4 invmatVec1;\r\n  varying vec4 invmatVec2;\r\n  varying vec4 invmatVec3;\r\n\r\n  uniform mat4 modelMatrix;\r\n  uniform mat4 modelViewMatrix;\r\n  uniform mat4 invModelViewMatrix;\r\n  uniform mat3 normalMatrix;\r\n\r\n  varying vec4 spritePosEye;\r\n\r\n  bool intersect_ray_cylinder(in vec3 origin, in vec3 ray, out vec3 point, out float frontFaced) {\r\n\r\n    // intersect XZ-projected ray with circle\r\n    float a = dot(ray.xz, ray.xz);\r\n    float b = dot(ray.xz, origin.xz);\r\n    float c = dot(origin.xz, origin.xz) - 1.0;\r\n    float det = b * b - a * c;\r\n    if (det < 0.0) return false;\r\n    float t1 = (-b - sqrt(det)) / a;\r\n    float t2 = (-b + sqrt(det)) / a;\r\n\r\n    // calculate both intersection points\r\n    vec3 p1 = origin + ray * t1;\r\n    vec3 p2 = origin + ray * t2;\r\n\r\n    float halfHeight = 0.5;\r\n\r\n    // choose nearest point\r\n    #ifdef ORTHOGRAPHIC_CAMERA\r\n      // orthografic camera is used for dirLight sources. So in it for all cylinders the point with smaller 't' is visible\r\n      // if it is not outside of cylinnder (t1 is always smaller than t2).\r\n      if (p1.y >= -halfHeight && p1.y <= halfHeight) {\r\n        point = p1;\r\n        frontFaced = 1.0;\r\n        return true;\r\n      }\r\n      if (p2.y >= -halfHeight && p2.y <= halfHeight) {\r\n        point = p2;\r\n        frontFaced = -1.0;\r\n        return true;\r\n      }\r\n    #else\r\n      // for perspective camera first intersection can be in front of near plane. If not intersection is p1 else - p2\r\n      // t* = 0.0 corresponds to point of intersection near plane by the ray from camera to curPixel\r\n      if (t1 >= 0.0 && p1.y >= -halfHeight && p1.y <= halfHeight) {\r\n        point = p1;\r\n        frontFaced = 1.0;\r\n        return true;\r\n      }\r\n      if (t2 >= 0.0 && p2.y >= -halfHeight && p2.y <= halfHeight) {\r\n        point = p2;\r\n        frontFaced = -1.0;\r\n        return true;\r\n      }\r\n    #endif\r\n\r\n    return false;\r\n  }\r\n\r\n  bool get_cylinder_point(in vec3 pixelPosEye, out vec3 point, out float frontFaced) {\r\n    vec3 origin, ray;\r\n    vec4 v;\r\n\r\n    #ifdef ORTHOGRAPHIC_CAMERA\r\n      // transform vector from sprite center to curPixel into cylinder local coords\r\n      v = invModelViewMatrix * vec4(pixelPosEye.xyz - spritePosEye.xyz, 0.0);\r\n      origin = vec3(dot(v, invmatVec1), dot(v, invmatVec2), dot(v, invmatVec3));\r\n\r\n      // transform camera orientation vector into cylinder local coords\r\n      v = invModelViewMatrix * vec4(0.0, 0.0, -1.0, 0.0);\r\n      ray = vec3(dot(v, invmatVec1), dot(v, invmatVec2), dot(v, invmatVec3));\r\n    #else\r\n      // find point of intersection near plane by the ray from camera to curPixel\r\n      v = vec4(-(nearPlaneValue / pixelPosEye.z) * pixelPosEye, 1.0);\r\n\r\n      // transform intersection point into cylinder local coords\r\n      v = invModelViewMatrix * v;\r\n      origin = vec3(dot(v, invmatVec1), dot(v, invmatVec2), dot(v, invmatVec3));\r\n\r\n      // transform vector from camera pos to curPixel into cylinder local coords\r\n      v = invModelViewMatrix * vec4(pixelPosEye, 0.0);\r\n      ray = vec3(dot(v, invmatVec1), dot(v, invmatVec2), dot(v, invmatVec3));\r\n    #endif\r\n    ray = normalize(ray);\r\n\r\n    return intersect_ray_cylinder(origin, ray, point, frontFaced);\r\n  }\r\n#endif\r\n\r\n///////////////////////////////////// Pack and unpack ///////////////////////////////////////////////\r\nconst float PackUpscale = 256. / 255.; // fraction -> 0..1 (including 1)\r\nconst float UnpackDownscale = 255. / 256.; // 0..1 -> fraction (excluding 1)\r\n\r\nconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256.,  256. );\r\nconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\r\n\r\n\r\nconst float ShiftRight8 = 1. / 256.;\r\n\r\nvec4 packDepthToRGBA( const in float v ) {\r\n  vec4 r = vec4( fract( v * PackFactors ), v );\r\n  r.yzw -= r.xyz * ShiftRight8; // tidy overflow\r\n  return r * PackUpscale;\r\n}\r\n\r\nfloat unpackRGBAToDepth( const in vec4 v ) {\r\n  return dot( v, UnpackFactors );\r\n}\r\n\r\n////////////////////////////////////////// All Lighting /////////////////////////////////////////////////\r\n#ifdef TOON_SHADING\r\n  #define LOW_TOON_BORDER 0.0\r\n  #define MEDIUM_TOON_BORDER 0.7\r\n  #define HIGH_TOON_BORDER 1.0\r\n\r\n  #define MEDIUM_TOON_RANGE 0.5\r\n  #define HIGH_TOON_RANGE 0.95\r\n#endif\r\n#if defined(USE_LIGHTS) && NUM_DIR_LIGHTS > 0\r\n  struct ReflectedLight {\r\n    vec3 directDiffuse;\r\n    vec3 directSpecular;\r\n    vec3 indirectDiffuse;\r\n  };\r\n\r\n  struct BlinnPhongMaterial {\r\n    vec3  diffuseColor;\r\n    vec3  specularColor;\r\n    float specularShininess;\r\n  };\r\n\r\n  struct GeometricContext {\r\n    vec3 normal;\r\n    vec3 viewDir;\r\n  };\r\n\r\n  struct DirectionalLight {\r\n    vec3 direction;\r\n    vec3 color;\r\n  };\r\n  uniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\r\n\r\n  struct DirectionalLightShadow {\r\n     vec2 shadowMapSize;\r\n     float shadowBias;\r\n     float shadowRadius;\r\n   };\r\n  uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHTS ];\r\n\r\n  uniform vec3 ambientLightColor;\r\n\r\n  /////////////////////////////////////////// Shadowmap ////////////////////////////////////////////////\r\n\r\n  #if defined(SHADOWMAP)\r\n  	float texture2DCompare( sampler2D depths, vec2 uv, float compare ) {\r\n  		return step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\r\n  	}\r\n\r\n    float getShadow( sampler2D shadowMap, DirectionalLightShadow dirLight, vec4 shadowCoord, vec3 vViewPosition, vec3 vNormal ) {\r\n   	  float shadow = 0.0;\r\n\r\n      // When shadows for sprites will appear use here for them normals as it done for G-buffer\r\n      shadowCoord.xyz += dirLight.shadowBias * vNormal;\r\n      shadowCoord.xyz /= shadowCoord.w;\r\n\r\n      bvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\r\n      bool inFrustum = all( inFrustumVec );\r\n      bvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\r\n      bool frustumTest = all( frustumTestVec );\r\n\r\n      if ( frustumTest ) {\r\n        #ifdef SHADOWMAP_BASIC\r\n      	  shadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\r\n      	#endif\r\n\r\n      	#ifdef SHADOWMAP_PCF_SHARP\r\n      	  vec2 texelSize = vec2( 1.0 ) / dirLight.shadowMapSize;\r\n\r\n            float dx0 = - texelSize.x * dirLight.shadowRadius;\r\n            float dy0 = - texelSize.y * dirLight.shadowRadius;\r\n            float dx1 = + texelSize.x * dirLight.shadowRadius;\r\n            float dy1 = + texelSize.y * dirLight.shadowRadius;\r\n\r\n            shadow = (\r\n            	texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\r\n            	texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\r\n            	texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\r\n            	texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\r\n            	texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\r\n            	texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\r\n            	texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\r\n            	texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\r\n            	texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\r\n            ) * ( 1.0 / 9.0 );\r\n        #endif\r\n\r\n        #ifdef SHADOWMAP_PCF_RAND\r\n          vec2 texelSize = vec2( 1.0 ) / dirLight.shadowMapSize;\r\n\r\n          vec4 vUv = ((projectionMatrix * vec4(vViewPosition, 1.0)) + 1.0) / 2.0;\r\n          vec2 vUvNoise = vUv.xy / srcTexelSize * noiseTexelSize;\r\n\r\n          vec2 noiseVec = normalize(texture2D(noiseTex, vUvNoise).rg);\r\n          mat2 mNoise = mat2(noiseVec.x, noiseVec.y, -noiseVec.y, noiseVec.x);\r\n\r\n          vec2 offset;\r\n          #pragma unroll_loop_start\r\n          for ( int i = 0; i < 4; i ++ ) { // 4 is length of _samplesKernel which is defined in UberMaterial.js\r\n            offset = mNoise * ( normalize( samplesKernel[ i ]) * texelSize * dirLight.shadowRadius );\r\n            shadow +=  texture2DCompare( shadowMap, shadowCoord.xy + offset, shadowCoord.z );\r\n          }\r\n          #pragma unroll_loop_end\r\n          shadow /= float( 4 ); // 4 is length of _samplesKernel which is defined in UberMaterial.js\r\n        #endif\r\n      }\r\n      return shadow;//(shadow != 1.0) ? 0.5 : 1.0;//vec4(shadow, shadow, shadow, 1.0);\r\n   }\r\n  #endif\r\n\r\n  /////////////////////////////////////////// Lighting /////////////////////////////////////////////////\r\n\r\n  vec3 BRDF_Diffuse_Lambert( const in vec3 diffuseColor ) {\r\n    return RECIPROCAL_PI * diffuseColor;\r\n  } // validated\r\n\r\n  vec3 F_Schlick( const in vec3 specularColor, const in float dotLH ) {\r\n    // Original approximation by Christophe Schlick '94\r\n    //;float fresnel = pow( 1.0 - dotLH, 5.0 );\r\n    // Optimized variant (presented by Epic at SIGGRAPH '13)\r\n    float fresnel = exp2( ( -5.55473 * dotLH - 6.98316 ) * dotLH );\r\n    return ( 1.0 - specularColor ) * fresnel + specularColor;\r\n  } // validated\r\n\r\n  float G_BlinnPhong_Implicit( /* const in float dotNL, const in float dotNV */ ) {\r\n    // geometry term is (n dot l)(n dot v) / 4(n dot l)(n dot v)\r\n    return 0.25;\r\n  }\r\n\r\n  float D_BlinnPhong( const in float shininess, const in float dotNH ) {\r\n    return RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );\r\n  }\r\n\r\n  vec3 BRDF_Specular_BlinnPhong( const in DirectionalLight incidentLight, const in GeometricContext geometry, const in vec3 specularColor, const in float shininess ) {\r\n    vec3 halfDir = normalize( incidentLight.direction + geometry.viewDir );\r\n    float dotNH = saturate(dot( geometry.normal, halfDir ));\r\n    float dotLH = saturate(dot( incidentLight.direction, halfDir ));\r\n\r\n    vec3 F = F_Schlick( specularColor, dotLH );\r\n    float G = G_BlinnPhong_Implicit( /* dotNL, dotNV */ );\r\n    float D = D_BlinnPhong( shininess, dotNH );\r\n\r\n    return F * ( G * D );\r\n  } // validated\r\n\r\n  void RE_Direct_BlinnPhong( const in DirectionalLight directLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight, float penumbra ) {\r\n\r\n    float dotNL = saturate( dot( geometry.normal, directLight.direction ));\r\n    #ifdef TOON_SHADING\r\n      if(dotNL < MEDIUM_TOON_RANGE){\r\n        dotNL = LOW_TOON_BORDER;\r\n      }\r\n      else if(dotNL < HIGH_TOON_RANGE){\r\n        dotNL = MEDIUM_TOON_BORDER;\r\n      }\r\n      else{\r\n        dotNL = HIGH_TOON_BORDER;\r\n      }\r\n    #endif\r\n\r\n    vec3 irradiance = dotNL * directLight.color;\r\n    reflectedLight.directDiffuse += penumbra * irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\r\n    reflectedLight.directSpecular += penumbra * irradiance * BRDF_Specular_BlinnPhong( directLight, geometry, material.specularColor, material.specularShininess );\r\n  }\r\n\r\n  void RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\r\n    reflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\r\n  }\r\n\r\n  vec3 calcLighting(const in GeometricContext geometry, const in BlinnPhongMaterial material, vec3 vViewPosition) {\r\n    ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ));\r\n    vec3 irradiance = ambientLightColor;\r\n\r\n    float shadowMask = 1.0;\r\n    // see THREE.WebGLProgram.unrollLoops\r\n  	#pragma unroll_loop_start\r\n  	  for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\r\n  	    #ifdef SHADOWMAP\r\n  	      shadowMask = getShadow( directionalShadowMap[ i ], directionalLightShadows[ i ], vDirLightWorldCoord[ i ], vViewPosition, vDirLightWorldNormal[ i ] );\r\n        #endif\r\n\r\n  		  if ( shadowMask > 0.0 ) RE_Direct_BlinnPhong( directionalLights[ i ], geometry, material, reflectedLight, shadowMask );\r\n  		}\r\n  		#pragma unroll_loop_end\r\n\r\n    RE_IndirectDiffuse_BlinnPhong(irradiance, material, reflectedLight);\r\n\r\n    return saturate(reflectedLight.indirectDiffuse + reflectedLight.directDiffuse + reflectedLight.directSpecular);\r\n  }\r\n#endif\r\n\r\n/////////////////////////////////////////// Dashed Line ///////////////////////////////////////////////\r\n#ifdef DASHED_LINE\r\n  uniform float dashedLineSize;\r\n  uniform float dashedLinePeriod;\r\n  varying float vLineDistance;\r\n#endif\r\n\r\n/////////////////////////////////////////// Main ///////////////////////////////////////////////\r\nvoid main() {\r\n\r\n#ifdef CLIP_PLANE\r\n  if (vViewPosition.z < clipPlaneValue) discard;\r\n#endif\r\n\r\n#ifdef ZCLIP\r\n  if (vViewPosition.z < zClipValue) discard;\r\n#endif\r\n\r\n#if defined(USE_LIGHTS) && defined(SHADOWMAP)\r\n  #if NUM_DIR_LIGHTS > 0\r\n    // see THREE.WebGLProgram.unrollLoops\r\n    #pragma unroll_loop_start\r\n    for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\r\n      vDirLightWorldCoord[ i ] = vDirectionalShadowCoord[ i ];\r\n      vDirLightWorldNormal[ i ] = vDirectionalShadowNormal[ i ];\r\n    }\r\n    #pragma unroll_loop_end\r\n  #endif\r\n#endif\r\n\r\n  vec4 pixelPosWorld = vec4(vWorldPosition, 1.0);\r\n  vec4 pixelPosEye;\r\n\r\n#ifdef SPHERE_SPRITE\r\n\r\n  vec3 viewNormalSprites;\r\n  float frontFaced = 1.0;\r\n  vec3 normal;\r\n\r\n/* quick-and-dirty method\r\n  normal.xy = ' + INSTANCED_SPRITE_OVERSCALE + ' * (2.0 * vUv - 1.0);\r\n  float r2 = dot(normal.xy, normal.xy);\r\n  if (r2 > 1.0) discard;\r\n  float normalZ = sqrt(1.0 - r2);\r\n  normal.z = normalZ;\r\n  normal = normal * ( -1.0 + 2.0 * float( gl_FrontFacing ) );\r\n  pixelPosEye = vec4(spritePosEye.xyz, 1.0);\r\n  pixelPosEye.z += spritePosEye.w * normalZ;\r\n*/\r\n\r\n  // ray-trace sphere surface\r\n  {\r\n    vec3 p;\r\n    if (!get_sphere_point(-vViewPosition, p, frontFaced)) discard;\r\n    vec4 v = vec4(instOffset.xyz + p * instOffset.w, 1.0);\r\n    pixelPosWorld = modelMatrix * v;\r\n    pixelPosEye = modelViewMatrix * v;\r\n    normal = normalize(normalMatrix * p);\r\n    #ifdef NORMALS_TO_G_BUFFER\r\n      viewNormalSprites = normalize(mat3(modelViewMatrix)*p);\r\n    #endif\r\n\r\n    #if defined(USE_LIGHTS) && defined(SHADOWMAP)\r\n      #if NUM_DIR_LIGHTS > 0\r\n        // see THREE.WebGLProgram.unrollLoops\r\n        #pragma unroll_loop_start\r\n          for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\r\n            vDirLightWorldCoord[ i ] = directionalShadowMatrix[ i ] * pixelPosWorld;\r\n            vDirLightWorldNormal[ i ] = (directionalShadowMatrix[ i ] * (modelMatrix * vec4(p, 0.0))).xyz;\r\n          }\r\n        #pragma unroll_loop_end\r\n      #endif\r\n    #endif\r\n  }\r\n#endif\r\n\r\n#ifdef CYLINDER_SPRITE\r\n  vec3 normal;\r\n  vec3 viewNormalSprites;\r\n  float frontFaced = 1.0;\r\n  float cylinderY = 0.0;\r\n\r\n  // ray-trace cylinder surface\r\n  {\r\n    vec3 p;\r\n    if (!get_cylinder_point(-vViewPosition, p, frontFaced)) discard;\r\n\r\n    cylinderY = 0.5 * (p.y + 1.0);\r\n\r\n    vec4 v = vec4(p, 1.0);\r\n    v = vec4(dot(v, matVec1), dot(v, matVec2), dot(v, matVec3), 1.0);\r\n    pixelPosWorld = modelMatrix * v;\r\n    pixelPosEye = modelViewMatrix * v;\r\n\r\n    vec3 localNormal = normalize(vec3(p.x, 0.0, p.z));\r\n    normal = vec3(\r\n      dot(localNormal, matVec1.xyz),\r\n      dot(localNormal, matVec2.xyz),\r\n      dot(localNormal, matVec3.xyz));\r\n    #ifdef NORMALS_TO_G_BUFFER\r\n      viewNormalSprites = normalize(mat3(modelViewMatrix)*normal);\r\n    #endif\r\n\r\n    #if defined(USE_LIGHTS) && defined(SHADOWMAP)\r\n      #if NUM_DIR_LIGHTS > 0\r\n        // see THREE.WebGLProgram.unrollLoops\r\n        #pragma unroll_loop_start\r\n          for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\r\n            vDirLightWorldCoord[ i ] = directionalShadowMatrix[ i ] * pixelPosWorld;\r\n            vDirLightWorldNormal[ i ] = (directionalShadowMatrix[ i ] * (modelMatrix * vec4(normal, 0.0))).xyz;\r\n          }\r\n        #pragma unroll_loop_end\r\n      #endif\r\n    #endif\r\n\r\n    normal = normalize(normalMatrix * normal);\r\n  }\r\n#endif\r\n\r\n  #ifdef ATTR_COLOR\r\n    vec3 vertexColor = vColor;\r\n  #else\r\n    vec3 vertexColor = vec3(1.0, 1.0, 1.0);\r\n  #endif\r\n\r\n  #ifdef ATTR_COLOR2\r\n    #ifdef CYLINDER_SPRITE\r\n      float colorCoef = cylinderY; // cylinder parameter is calculated from ray-tracing\r\n    #else\r\n      float colorCoef = vUv.y; // cylinder parameter is interpolated as tex coord\r\n    #endif\r\n      // choose either color or color2\r\n    vertexColor = mix(vColor2, vColor, step(0.5, colorCoef));\r\n  #endif\r\n\r\n  // negative red component is a special condition\r\n  if (vertexColor.x < 0.0) discard;\r\n\r\n  #ifdef DASHED_LINE\r\n    if ( mod( vLineDistance, dashedLinePeriod ) > dashedLineSize ) discard;\r\n  #endif\r\n\r\n  // transparency prepass writes only z, so we don't need to calc the color\r\n  #ifdef PREPASS_TRANSP\r\n    fragColor = vec4(1.0, 1.0, 1.0, 1.0);\r\n    #if defined(SPHERE_SPRITE) || defined(CYLINDER_SPRITE)\r\n      gl_FragDepthEXT = calcDepthForSprites(pixelPosEye, zOffset, projectionMatrix);\r\n    #endif\r\n    return;\r\n  #endif\r\n\r\n    float totalOpacity = opacity;\r\n\r\n  #ifdef ATTR_ALPHA_COLOR\r\n    totalOpacity *= alphaCol;\r\n  #endif\r\n\r\n  // discard fully transparent pixels\r\n  if (totalOpacity == 0.0) discard;\r\n\r\n  #ifdef FAKE_OPACITY\r\n    // discard pixels in checker pattern\r\n    vec2 dm_coord = floor(gl_FragCoord.xy);\r\n    dm_coord = fract(dm_coord * 0.5);\r\n    if (totalOpacity < 1.0 && (dm_coord.x < 0.5 ^^ dm_coord.y < 0.5)) discard;\r\n    vec4 diffuseColor = vec4(diffuse, 1.0);\r\n  #else\r\n    vec4 diffuseColor = vec4(diffuse, totalOpacity);\r\n  #endif\r\n\r\n  float flipNormal;\r\n  #if !defined (SPHERE_SPRITE) && !defined (CYLINDER_SPRITE)\r\n    flipNormal = 1.0;\r\n    #ifdef DOUBLE_SIDED\r\n      flipNormal = float( gl_FrontFacing );\r\n    #endif\r\n    vec3 normal = normalize( vNormal ) * flipNormal;\r\n  #endif\r\n\r\n    diffuseColor.rgb *= vertexColor;\r\n\r\n  #if defined(SPHERE_SPRITE) || defined(CYLINDER_SPRITE)\r\n    gl_FragDepthEXT = calcDepthForSprites(pixelPosEye, zOffset, projectionMatrix);\r\n  #endif\r\n\r\n  #ifdef NORMALS_TO_G_BUFFER\r\n    #if defined (SPHERE_SPRITE) || defined (CYLINDER_SPRITE)\r\n      vec3 viewNormaInColor = viewNormalSprites;\r\n    #else\r\n      vec3 viewNormaInColor = viewNormal;\r\n      float frontFaced = float( gl_FrontFacing );\r\n    #endif\r\n    // [-1, 1] -> [0, 1]\r\n    viewNormaInColor = 0.5 * viewNormaInColor + 0.5;\r\n    gl_FragData[1] = vec4(viewNormaInColor, frontFaced);\r\n  #endif\r\n\r\n  #if defined(USE_LIGHTS) && NUM_DIR_LIGHTS > 0\r\n    vec3 viewDir;\r\n    #if defined(SPHERE_SPRITE) || defined(CYLINDER_SPRITE)\r\n      viewDir = -pixelPosEye.xyz;\r\n    #else\r\n      viewDir = vViewPosition;\r\n    #endif\r\n    GeometricContext geometry = GeometricContext(normal, normalize( viewDir ));\r\n    BlinnPhongMaterial material = BlinnPhongMaterial(diffuseColor.rgb, specular, shininess);\r\n    vec3 outgoingLight = calcLighting(geometry, material, viewDir);\r\n  #else\r\n    vec3 outgoingLight = diffuseColor.rgb;\r\n  #endif\r\n\r\n  #ifdef COLOR_FROM_DEPTH\r\n    float depth = 0.0;\r\n    #if defined(SPHERE_SPRITE) || defined(CYLINDER_SPRITE)\r\n      gl_FragDepthEXT = calcDepthForSprites(pixelPosEye, zOffset, projectionMatrix);\r\n      depth = gl_FragDepthEXT;\r\n    #else\r\n      depth = gl_FragCoord.z;\r\n    #endif\r\n    fragColor = packDepthToRGBA(depth);\r\n    return;\r\n  #endif\r\n\r\n  #ifdef COLOR_FROM_POS\r\n    fragColor = world2colorMatrix * pixelPosWorld;\r\n  #else\r\n    #ifdef OVERRIDE_COLOR\r\n      fragColor = vec4(fixedColor, diffuseColor.a);\r\n    #else\r\n      fragColor = vec4(outgoingLight, diffuseColor.a);//vec4(vNormal, 1.0);\r\n    #endif\r\n\r\n    #ifdef USE_FOG\r\n      float viewDistance;\r\n      #if defined(SPHERE_SPRITE) || defined(CYLINDER_SPRITE)\r\n        viewDistance = abs(pixelPosEye.z);\r\n      #else\r\n        viewDistance = vViewPosition.z;\r\n      #endif\r\n      float fogFactor = smoothstep( fogNear, fogFar, viewDistance) * fogAlpha;\r\n      #ifdef FOG_TRANSPARENT\r\n        fragColor.a = fragColor.a * (1.0 - fogFactor);\r\n      #else\r\n        fragColor.rgb = mix( fragColor.rgb, fogColor, fogFactor );\r\n      #endif\r\n    #endif\r\n\r\n  #endif\r\n}\r\n";
var capabilities = {
  precision: "mediump",
  /**
   *
   * @param {THREE.WebGLRenderer} renderer
   */
  init(renderer) {
    this.precision = renderer.capabilities.getMaxPrecision("highp");
  }
};
var noiseWidth = 4;
var noiseHeight = 4;
var _noiseData = new Uint8Array([24, 52, 0, 255, 254, 145, 0, 255, 122, 0, 0, 255, 7, 170, 0, 255, 34, 214, 0, 255, 173, 8, 0, 255, 86, 249, 0, 255, 160, 4, 0, 255, 226, 46, 0, 255, 224, 211, 0, 255, 3, 157, 0, 255, 174, 247, 0, 255, 12, 182, 0, 255, 220, 216, 0, 255, 1, 109, 0, 255, 253, 154, 0, 255]);
var _noiseWrapS = external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.RepeatWrapping;
var _noiseWrapT = external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.RepeatWrapping;
var _noiseMinFilter = external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.NearestFilter;
var _noiseMagFilter = external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.NearestFilter;
var _noiseMapping = external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.UVMapping;
var noiseTexture = new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.DataTexture(_noiseData, noiseWidth, noiseHeight, external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.RGBAFormat, external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.UnsignedByteType, _noiseMapping, _noiseWrapS, _noiseWrapT, _noiseMagFilter, _noiseMinFilter, 1);
noiseTexture.needsUpdate = true;
var gfx_noiseTexture = {
  noiseWidth,
  noiseHeight,
  noiseTexture
};
var _samplesKernel = [new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Vector2(-0.541978, 0.840393), new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Vector2(0.125533, -0.992089), new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Vector2(0.374329, 0.927296), new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Vector2(-0.105475, 0.994422)];
var defaultUniforms = external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.UniformsUtils.merge([external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.UniformsLib.fog, external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.UniformsLib.lights, {
  // are updated automatically by three.js (see THREE.ShaderLib.common)
  diffuse: {
    value: new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Color(15658734)
  },
  opacity: {
    value: 1
  },
  specular: {
    type: "c",
    value: new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Color(1118481)
  },
  shininess: {
    type: "f",
    value: 30
  },
  fixedColor: {
    type: "c",
    value: new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Color(16777215)
  },
  zOffset: {
    type: "f",
    value: 0
  },
  zClipValue: {
    type: "f",
    value: 0
  },
  clipPlaneValue: {
    type: "f",
    value: 0
  },
  nearPlaneValue: {
    type: "f",
    value: -0.5
  },
  invModelViewMatrix: {
    type: "4fv",
    value: new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Matrix4()
  },
  world2colorMatrix: {
    type: "4fv",
    value: new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Matrix4()
  },
  dashedLineSize: {
    type: "f",
    value: 0.1
  },
  dashedLinePeriod: {
    type: "f",
    value: 0.2
  },
  projMatrixInv: {
    type: "4fv",
    value: new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Matrix4()
  },
  viewport: {
    type: "v2",
    value: new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Vector2()
  },
  lineWidth: {
    type: "f",
    value: 2
  },
  // default value must be the same as settings
  fogAlpha: {
    type: "f",
    value: 1
  },
  samplesKernel: {
    type: "v2v",
    value: null
  },
  noiseTex: {
    type: "t",
    value: null
  },
  noiseTexelSize: {
    type: "v2",
    value: null
  },
  srcTexelSize: {
    type: "v2",
    value: null
  }
}]);
var uberOptionNames = ["shininess", "opacity", "zOffset", "diffuse", "specular", "fixedColor", "zClipCoef", "zClipValue", "clipPlaneValue", "world2colorMatrix", "dashedLineSize", "dashedLinePeriod", "projMatrixInv", "viewport", "lineWidth", "fogAlpha", "samplesKernel", "noiseTex", "noiseTexelSize", "srcTexelSize"];
var uberOptions = {
  diffuse: new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Color(16777215),
  // used in phong lighting
  specular: new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Color(1118481),
  // used in phong lighting
  shininess: 30,
  // used in phong lighting
  opacity: 1,
  // set mesh opacity
  fixedColor: new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Color(16777215),
  // color to override (see OVERRIDE_COLOR)
  zOffset: 0,
  // used fo zsprites (see SPHERE_SPRITE CYLINDER_SPRITE)
  zClipCoef: 2,
  // use for Surfs clipping (mesh param, isn't used in shader)  FIXME move to representation param
  zClipValue: 0,
  //  value to clip Surfs in shader  (see ZCLIP)
  clipPlaneValue: 0,
  // value to clip scene globally (see CLIPPLANE)
  world2colorMatrix: new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Matrix4(),
  dashedLineSize: 0.1,
  dashedLinePeriod: 0.3,
  projMatrixInv: new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Matrix4(),
  viewport: new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Vector2(800, 600),
  lineWidth: 2,
  fogAlpha: 1,
  samplesKernel: _samplesKernel,
  noiseTex: gfx_noiseTexture.noiseTexture,
  noiseTexelSize: new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Vector2(1 / gfx_noiseTexture.noiseWidth, 1 / gfx_noiseTexture.noiseHeight),
  srcTexelSize: new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Vector2(1 / 800, 1 / 600),
  copy(source) {
    this.diffuse.copy(source.diffuse);
    this.specular.copy(source.specular);
    this.shininess = source.shininess;
    this.opacity = source.opacity;
    this.fixedColor.copy(source.fixedColor);
    this.zOffset = source.zOffset;
    this.zClipCoef = source.zClipCoef;
    this.zClipValue = source.zClipValue;
    this.clipPlaneValue = source.clipPlaneValue;
    this.world2colorMatrix.copy(source.world2colorMatrix);
    this.dashedLineSize = source.dashedLineSize;
    this.dashedLinePeriod = source.dashedLinePeriod;
    this.projMatrixInv = source.projMatrixInv;
    this.viewport = source.viewport;
    this.lineWidth = source.lineWidth;
    this.toonShading = source.toonShading;
    this.fogAlpha = source.fogAlpha;
    this.samplesKernel = source.samplesKernel;
    this.noiseTex = source.noiseTex;
    this.noiseTexelSize = source.noiseTexelSize;
    this.srcTexelSize = source.srcTexelSize;
  }
};
var UberMaterial = class _UberMaterial extends external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.RawShaderMaterial {
  constructor(params) {
    super(params);
    this.fog = true;
    this.instancedPos = false;
    this.instancedMatrix = false;
    this.attrColor = false;
    this.attrColor2 = false;
    this.attrAlphaColor = false;
    this.overrideColor = false;
    this.sphereSprite = false;
    this.cylinderSprite = false;
    this.zClip = false;
    this.clipPlane = false;
    this.fakeOpacity = false;
    this.prepassTransparancy = false;
    this.colorFromPos = false;
    this.shadowmap = false;
    this.shadowmapType = "random";
    this.colorFromDepth = false;
    this.orthoCam = false;
    this.dashedLine = false;
    this.transparent = true;
    this.thickLine = false;
    this.fogTransparent = false;
    this.normalsToGBuffer = false;
    this.toonShading = false;
    this.uberOptions = Object.create(_UberMaterial.prototype.uberOptions);
    super.setValues({
      uniforms: external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.UniformsUtils.clone(defaultUniforms),
      vertexShader: this.precisionString() + Uber_namespaceObject,
      fragmentShader: this.precisionString() + gfx_shaders_Uber_namespaceObject,
      lights: true,
      fog: true,
      side: external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.DoubleSide
    });
    this.setValues(params);
  }
  precisionString() {
    const {
      precision
    } = capabilities;
    const str = `precision ${precision} float;
precision ${precision} int;

`;
    return str;
  }
  copy(source) {
    super.copy(source);
    this.fragmentShader = source.fragmentShader;
    this.vertexShader = source.vertexShader;
    this.uniforms = external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.UniformsUtils.clone(source.uniforms);
    this.defines = {
      ...source.defines
    };
    this.extensions = source.extensions;
    this.fog = source.fog;
    this.instancedPos = source.instancedPos;
    this.instancedMatrix = source.instancedMatrix;
    this.attrColor = source.attrColor;
    this.attrColor2 = source.attrColor2;
    this.attrAlphaColor = source.attrAlphaColor;
    this.overrideColor = source.overrideColor;
    this.sphereSprite = source.sphereSprite;
    this.cylinderSprite = source.cylinderSprite;
    this.zClip = source.zClip;
    this.clipPlane = source.clipPlane;
    this.fakeOpacity = source.fakeOpacity;
    this.colorFromPos = source.colorFromPos;
    this.shadowmap = source.shadowmap;
    this.shadowmapType = source.shadowmapType;
    this.colorFromDepth = source.colorFromDepth;
    this.orthoCam = source.orthoCam;
    this.prepassTransparancy = source.prepassTransparancy;
    this.dashedLine = source.dashedLine;
    this.thickLine = source.thickLine;
    this.fogTransparent = source.fogTransparent;
    this.normalsToGBuffer = source.normalsToGBuffer;
    this.toonShading = source.toonShading;
    this.uberOptions.copy(source.uberOptions);
    return this;
  }
  // create copy of this material
  // its options are prototyped after this material's options
  createInstance() {
    const inst = new _UberMaterial();
    inst.copy(this);
    inst.uberOptions = Object.create(this.uberOptions);
    return inst;
  }
  setValues(values) {
    if (typeof values === "undefined") {
      return;
    }
    super.setValues(values);
    const defines = {};
    const extensions = {};
    if (this.fog) {
      defines.USE_FOG = 1;
    }
    if (this.instancedPos) {
      defines.INSTANCED_POS = 1;
    }
    if (this.instancedMatrix) {
      defines.INSTANCED_MATRIX = 1;
    }
    if (this.attrColor) {
      defines.ATTR_COLOR = 1;
    }
    if (this.attrColor2) {
      defines.ATTR_COLOR2 = 1;
    }
    if (this.attrAlphaColor) {
      defines.ATTR_ALPHA_COLOR = 1;
    }
    if (this.overrideColor) {
      defines.OVERRIDE_COLOR = 1;
    }
    if (this.sphereSprite) {
      defines.SPHERE_SPRITE = 1;
      extensions.fragDepth = true;
    }
    if (this.cylinderSprite) {
      defines.CYLINDER_SPRITE = 1;
      extensions.fragDepth = true;
    }
    if (this.zClip) {
      defines.ZCLIP = 1;
    }
    if (this.clipPlane) {
      defines.CLIP_PLANE = 1;
    }
    if (this.fakeOpacity) {
      defines.FAKE_OPACITY = 1;
    }
    if (this.lights) {
      defines.USE_LIGHTS = 1;
    }
    if (this.colorFromPos) {
      defines.COLOR_FROM_POS = 1;
    }
    if (this.shadowmap) {
      defines.SHADOWMAP = 1;
      if (this.shadowmapType === "pcf") {
        defines.SHADOWMAP_PCF_SHARP = 1;
      } else if (this.shadowmapType === "random") {
        defines.SHADOWMAP_PCF_RAND = 1;
      } else {
        defines.SHADOWMAP_BASIC = 1;
      }
    }
    if (this.colorFromDepth) {
      defines.COLOR_FROM_DEPTH = 1;
    }
    if (this.orthoCam) {
      defines.ORTHOGRAPHIC_CAMERA = 1;
    }
    if (this.prepassTransparancy) {
      defines.PREPASS_TRANSP = 1;
    }
    if (this.dashedLine) {
      defines.DASHED_LINE = 1;
    }
    if (this.thickLine) {
      defines.THICK_LINE = 1;
    }
    if (this.fogTransparent) {
      defines.FOG_TRANSPARENT = 1;
    }
    if (this.normalsToGBuffer) {
      extensions.drawBuffers = true;
      defines.NORMALS_TO_G_BUFFER = 1;
    }
    if (this.toonShading) {
      defines.TOON_SHADING = 1;
    }
    this.defines = defines;
    this.extensions = extensions;
  }
  setUberOptions(values) {
    if (typeof values === "undefined") {
      return;
    }
    for (const key in values) {
      if (!values.hasOwnProperty(key)) {
        continue;
      }
      if (this.uberOptions[key] instanceof external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Color) {
        this.uberOptions[key] = values[key].clone();
      } else {
        this.uberOptions[key] = values[key];
      }
    }
  }
  clone(shallow) {
    if (!shallow) {
      return super.clone();
    }
    return this.createInstance();
  }
  updateUniforms() {
    const self2 = this;
    uberOptionNames.forEach((p2) => {
      if (self2.uniforms.hasOwnProperty(p2)) {
        if (self2.uberOptions[p2] instanceof external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Color || self2.uberOptions[p2] instanceof external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Matrix4) {
          self2.uniforms[p2].value = self2.uberOptions[p2].clone();
        } else {
          self2.uniforms[p2].value = self2.uberOptions[p2];
        }
      }
    });
  }
};
UberMaterial.prototype.uberOptions = uberOptions;
var shaders_UberMaterial = UberMaterial;
function UberObject(SuperClass) {
  class NewObjectType extends SuperClass {
    constructor() {
      super(...arguments);
      this.onBeforeRender = NewObjectType.prototype.onBeforeRender;
    }
    onBeforeRender(renderer, scene, camera, geometry, material, group) {
      this._onBeforeRender(renderer, scene, camera, geometry, material, group);
      this._update();
    }
    _onBeforeRender() {
    }
    _update() {
      const {
        material
      } = this;
      if (!material) {
        return;
      }
      if (material instanceof shaders_UberMaterial) {
        material.updateUniforms();
      }
    }
  }
  return NewObjectType;
}
var Mesh2 = UberObject(external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Mesh);
var ZSpriteMesh = class extends Mesh2 {
  constructor() {
    super(...arguments);
    this.castShadow = true;
    this.receiveShadow = true;
  }
  _onBeforeRender(renderer, scene, camera, _geometry2, _material, _group) {
    Mesh2.prototype._onBeforeRender.call(this, renderer, scene, camera);
    const {
      material
    } = this;
    if (!material) {
      return;
    }
    if (material.uniforms.invModelViewMatrix) {
      this.modelViewMatrix.multiplyMatrices(camera.matrixWorldInverse, this.matrixWorld);
      material.uniforms.invModelViewMatrix.value.copy(this.modelViewMatrix).invert();
      material.uniforms.nearPlaneValue.value = camera.near;
      material.uniformsNeedUpdate = true;
    }
  }
};
var meshes_ZSpriteMesh = ZSpriteMesh;
var ZClippedMesh_Mesh = UberObject(external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Mesh);
var _ZClippedMesh = class _ZClippedMesh extends ZClippedMesh_Mesh {
  constructor(geometry, material) {
    super(geometry, material);
    this.castShadow = true;
    this.receiveShadow = true;
  }
  _onBeforeRender(renderer, scene, camera) {
    ZClippedMesh_Mesh.prototype._onBeforeRender.call(this, renderer, scene, camera);
    const geo = this.geometry;
    const {
      material
    } = this;
    if (!geo.zClip || !material.uberOptions) {
      return;
    }
    const zClipCoef = 0.5;
    const modelView = _ZClippedMesh._modelView;
    const mvLength = _ZClippedMesh._mvLength;
    const center = _ZClippedMesh._center;
    modelView.multiplyMatrices(this.matrixWorld, camera.matrixWorldInverse);
    const s2 = mvLength.setFromMatrixColumn(modelView, 0).length();
    center.copy(geo.boundingSphere.center);
    this.localToWorld(center);
    material.uberOptions.zClipValue = camera.position.z - center.z - s2 * (zClipCoef * geo.boundingSphere.radius);
  }
};
__publicField(_ZClippedMesh, "_mvLength", (() => new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Vector3())());
__publicField(_ZClippedMesh, "_center", (() => new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Vector3())());
__publicField(_ZClippedMesh, "_modelView", (() => new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Matrix4())());
var ZClippedMesh = _ZClippedMesh;
var meshes_ZClippedMesh = ZClippedMesh;
var TextMesh = class extends external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Group {
  constructor(geometry, _material) {
    super();
    this.geometry = geometry;
    const self2 = this;
    self2.initialized = false;
    this.geometry.addEventListener("update", () => {
      self2.update();
    });
  }
  init() {
    const {
      children
    } = this;
    for (let i2 = children.length - 1; i2 >= 0; --i2) {
      this.remove(children[i2]);
    }
    const {
      items,
      userData
    } = this.geometry;
    for (let i2 = 0, n = items.length; i2 < n; ++i2) {
      const srcItem = items[i2];
      if (!srcItem) {
        continue;
      }
      const item = utils.shallowCloneNode(srcItem);
      const label = new gfx_CSS2DObject(item);
      label.userData = external_module_lodash_commonjs_lodash_commonjs2_lodash_amd_lodash_root_namespaceObject["default"].clone(userData);
      const el = label.getElement();
      el.style.visibility = "visible";
      label.source = srcItem;
      this.add(label);
    }
    this.initialized = true;
  }
  update() {
    const geo = this.geometry;
    if (!geo.needsUpdate) {
      return;
    }
    const {
      children
    } = this;
    if (!this.initialized) {
      this.init();
    }
    for (let i2 = 0, n = children.length; i2 < n; ++i2) {
      const child = children[i2];
      const item = child.source;
      child.position.copy(item.worldPos);
      child.userData.color = item.opts.color;
      child.userData.background = item.opts.background;
    }
  }
};
var meshes_TextMesh = TextMesh;
var SimpleMesh_Mesh = UberObject(external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Mesh);
var SimpleMesh = class extends SimpleMesh_Mesh {
  constructor(geometry, material) {
    super(geometry, material);
    this.castShadow = true;
    this.receiveShadow = true;
  }
};
var meshes_SimpleMesh = SimpleMesh;
var ThickLineMesh_Mesh = UberObject(external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Mesh);
var _viewport = new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Vector2();
var ThickLineMesh = class extends ThickLineMesh_Mesh {
  _onBeforeRender(renderer, scene, camera, _geometry2, _material, _group) {
    const {
      material
    } = this;
    if (!material.uberOptions) {
      return;
    }
    material.uberOptions.projMatrixInv.copy(camera.projectionMatrix).invert();
    renderer.getSize(_viewport);
    material.uberOptions.viewport.set(_viewport.width, _viewport.height);
  }
};
var meshes_ThickLineMesh = ThickLineMesh;
var InstancedMesh_Mesh = UberObject(external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Mesh);
var InstancedMesh2 = class extends InstancedMesh_Mesh {
  constructor() {
    super(...arguments);
    this.castShadow = true;
    this.receiveShadow = true;
  }
};
var meshes_InstancedMesh = InstancedMesh2;
var meshes = {
  ZClipped: meshes_ZClippedMesh,
  ZSprite: meshes_ZSpriteMesh,
  Text: meshes_TextMesh,
  Line: UberObject(external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Line),
  LineSegments: UberObject(external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.LineSegments),
  Mesh: meshes_SimpleMesh,
  ThickLineMesh: meshes_ThickLineMesh,
  Instanced: meshes_InstancedMesh
};
function setMatParams(params, uniforms) {
  return function(material) {
    material.setValues(params);
    material.setUberOptions(uniforms);
  };
}
function _createInstancedCylinders(useZSprites, openEnded) {
  function Geometry(a2, b2) {
    return new geometries.Instanced2CCylindersGeometry(a2, b2, useZSprites, openEnded);
  }
  return {
    Geometry,
    Object: useZSprites ? meshes.ZSprite : meshes.Instanced,
    initMaterial: setMatParams({
      instancedMatrix: true,
      attrColor: true,
      attrColor2: true,
      attrAlphaColor: true,
      cylinderSprite: useZSprites
    })
  };
}
function _createLineSegmentsGeoTriplet(geo, renderParams) {
  const thickLines = geo.prototype instanceof geometries_ThickLinesGeometry;
  const lineWidth = renderParams.lineWidth || 0;
  return {
    Geometry: geo,
    Object: thickLines ? meshes.ThickLineMesh : meshes.LineSegments,
    initMaterial: setMatParams({
      lights: false,
      attrColor: true,
      attrAlphaColor: true,
      thickLine: thickLines
    }, {
      lineWidth
    })
  };
}
function _createSimpleGeoTriplet(geoClass) {
  return {
    Geometry: geoClass,
    Object: meshes.Mesh,
    initMaterial: setMatParams({
      attrColor: true,
      attrAlphaColor: true
    })
  };
}
function _createIsoSurfaceGeoTriplet(geoClass, caps, settings2, renderParams) {
  const surfaceOpts = {
    wireframe: !!renderParams.wireframe,
    fakeOpacity: settings2.now.isoSurfaceFakeOpacity,
    zClip: renderParams.zClip
  };
  return {
    Geometry: geoClass,
    Object: meshes.ZClipped,
    initMaterial: setMatParams({
      attrColor: true,
      attrAlphaColor: false,
      wireframe: surfaceOpts.wireframe,
      fakeOpacity: surfaceOpts.fakeOpacity,
      zClip: surfaceOpts.zClip
    })
  };
}
var MeshCreator = class {
  static createSpheres(caps, settings2) {
    const useZSprites = settings2.now.zSprites;
    function Geometry(a2, b2) {
      return new geometries.InstancedSpheresGeometry(a2, b2, useZSprites);
    }
    return {
      Geometry,
      Object: useZSprites ? meshes.ZSprite : meshes.Instanced,
      initMaterial: setMatParams({
        instancedPos: true,
        attrColor: true,
        attrAlphaColor: true,
        sphereSprite: useZSprites
      })
    };
  }
  static create2CClosedCylinders(_caps, _settings) {
    return _createInstancedCylinders(false, false);
  }
  static create2CCylinders(caps, settings2) {
    return _createInstancedCylinders(settings2.now.zSprites, true);
  }
  static create2CLines(_caps, _settings, renderParams) {
    return _createLineSegmentsGeoTriplet(geometries.TwoColorLinesGeometry, renderParams);
  }
  static createCrosses(_caps, _settings, renderParams) {
    return _createLineSegmentsGeoTriplet(geometries.CrossGeometry, renderParams);
  }
  static createExtrudedChains(_caps, _settings) {
    return _createSimpleGeoTriplet(geometries.ExtrudedObjectsGeometry);
  }
  static createChunkedLines(_caps, _settings, renderParams) {
    return _createLineSegmentsGeoTriplet(geometries.ChunkedLinesGeometry, renderParams);
  }
  static createQuickSurface(caps, settings2, renderParams) {
    return _createIsoSurfaceGeoTriplet(geometries.QuickSurfGeometry, caps, settings2, renderParams);
  }
  static createContactSurface(caps, settings2, renderParams) {
    return _createIsoSurfaceGeoTriplet(geometries.ContactSurfaceGeometry, caps, settings2, renderParams);
  }
  static createSASSES(caps, settings2, renderParams) {
    return _createIsoSurfaceGeoTriplet(geometries.SSIsosurfaceGeometry, caps, settings2, renderParams);
  }
  static createLabels(_caps, _settings) {
    return {
      Geometry: geometries.LabelsGeometry,
      Object: meshes.Text,
      initMaterial() {
      }
    };
  }
};
var meshes_MeshCreator = MeshCreator;
var _TransformGroup = class _TransformGroup extends external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Object3D {
  constructor(geometry, geoParams, material, transforms) {
    super();
    this._geometry = geometry;
    this._geoParams = geoParams;
    const mat = material.createInstance();
    geoParams.initMaterial(mat);
    this._material = mat;
    this._transforms = transforms.length > 0 ? transforms : [new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Matrix4()];
    const meshes2 = this._createMeshes(geometry);
    for (let i2 = 0, n = meshes2.length; i2 < n; ++i2) {
      this.add(meshes2[i2]);
    }
  }
  raycast(raycaster, intersects2) {
    const ray = _TransformGroup._ray;
    const inverseMatrix = _TransformGroup._inverseMatrix;
    const {
      children
    } = this;
    ray.copy(raycaster.ray);
    for (let i2 = 0, n = children.length; i2 < n; ++i2) {
      const child = children[i2];
      if (!gfxutils.belongToSelectLayers(child)) {
        continue;
      }
      child.updateMatrixWorld();
      const mtx = child.matrixWorld;
      inverseMatrix.copy(mtx).invert();
      raycaster.ray.copy(ray).applyMatrix4(inverseMatrix);
      const childIntersects = [];
      this._geometry.raycast(raycaster, childIntersects);
      for (let j = 0, ciCount = childIntersects.length; j < ciCount; ++j) {
        const inters = childIntersects[j];
        if (inters.point) {
          inters.point.applyMatrix4(mtx);
          inters.distance = ray.origin.distanceTo(inters.point);
        }
        inters.object = child;
        intersects2[intersects2.length] = inters;
      }
    }
    raycaster.ray.copy(ray);
  }
  getSubset(chunkIndices) {
    const geos = this._geometry.getSubset(chunkIndices);
    const subset = [];
    let subIdx = 0;
    for (let i2 = 0, n = geos.length; i2 < n; ++i2) {
      const meshes2 = this._createMeshes(geos[i2]);
      for (let j = 0, meshCnt = meshes2.length; j < meshCnt; ++j) {
        subset[subIdx++] = meshes2[j];
      }
    }
    return subset;
  }
  _createMeshes(geometry) {
    const transforms = this._transforms;
    const Mesh3 = this._geoParams.Object;
    const material = this._material;
    const meshes2 = [];
    for (let i2 = 0, n = transforms.length; i2 < n; ++i2) {
      const mesh = new Mesh3(geometry, material);
      mesh.applyMatrix4(transforms[i2]);
      meshes2[i2] = mesh;
    }
    return meshes2;
  }
};
__publicField(_TransformGroup, "_inverseMatrix", (() => new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Matrix4())());
__publicField(_TransformGroup, "_ray", (() => new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Ray())());
var TransformGroup = _TransformGroup;
var meshes_TransformGroup = TransformGroup;
function wrapper(Name, args) {
  const params = [Name].concat(args);
  return Name.bind(...params);
}
var ChemGroup = class _ChemGroup extends gfx_RCGroup {
  constructor(geoParams, selection, colorer, mode, transforms, polyComplexity, material) {
    super();
    if (this.constructor === _ChemGroup) {
      throw new Error("Can not instantiate abstract class!");
    }
    this._selection = selection;
    this._mode = mode;
    this._colorer = colorer;
    this._chunksIdc = selection.chunks;
    this._polyComplexity = polyComplexity;
    this._geo = new (wrapper(geoParams.Geometry, this._makeGeoArgs()))();
    this._mesh = new meshes_TransformGroup(this._geo, geoParams, material, transforms);
    this.add(this._mesh);
    this._build();
  }
  _makeGeoArgs() {
    throw new Error("ChemGroup subclass must override _makeGeoArgs() method");
  }
  /**
   * Builds subset geometry by ATOMS index list
   *
   * @param {Number} mask - Representation mask
   * @param {Boolean} innerOnly - if true returns inner bonds only - without halves
   * @returns {Array} Subset geometry
   */
  getSubset(mask, innerOnly) {
    innerOnly = innerOnly !== void 0 ? innerOnly : false;
    const chunksList = this._calcChunksList(mask, innerOnly);
    if (chunksList.length === 0) {
      return [];
    }
    return this._mesh.getSubset(chunksList);
  }
  _changeSubsetOpacity(mask, value, innerOnly) {
    const chunksList = this._calcChunksList(mask, innerOnly);
    if (chunksList.length === 0) {
      return;
    }
    this._geo.setOpacity(chunksList, value);
  }
  enableSubset(mask, innerOnly) {
    innerOnly = innerOnly !== void 0 ? innerOnly : true;
    this._changeSubsetOpacity(mask, 1, innerOnly);
  }
  disableSubset(mask, innerOnly) {
    innerOnly = innerOnly !== void 0 ? innerOnly : true;
    this._changeSubsetOpacity(mask, 0, innerOnly);
  }
};
var groups_ChemGroup = ChemGroup;
var AtomsGroup = class extends groups_ChemGroup {
  raycast(raycaster, intersects2) {
    const {
      atoms
    } = this._selection;
    const inters = [];
    this._mesh.raycast(raycaster, inters);
    const atomsIdc = this._chunksIdc;
    for (let i2 = 0, n = inters.length; i2 < n; ++i2) {
      if (!inters[i2].hasOwnProperty("chunkIdx")) {
        continue;
      }
      const atomIdx = atomsIdc[inters[i2].chunkIdx];
      if (atomIdx < atoms.length) {
        inters[i2].atom = atoms[atomIdx];
        intersects2.push(inters[i2]);
      }
    }
  }
  _calcChunksList(mask) {
    const chunksList = [];
    const {
      atoms
    } = this._selection;
    const atomsIdc = this._chunksIdc;
    for (let i2 = 0, n = atomsIdc.length; i2 < n; ++i2) {
      const atom = atoms[atomsIdc[i2]];
      if ((atom.mask & mask) !== 0) {
        chunksList.push(i2);
      }
    }
    return chunksList;
  }
};
var groups_AtomsGroup = AtomsGroup;
var AtomsSphereGroup = class extends groups_AtomsGroup {
  _makeGeoArgs() {
    return [this._selection.chunks.length, this._polyComplexity];
  }
  _build() {
    const atomsIdc = this._selection.chunks;
    const {
      atoms,
      parent
    } = this._selection;
    const mode = this._mode;
    const colorer = this._colorer;
    const geo = this._geo;
    for (let i2 = 0, n = atomsIdc.length; i2 < n; ++i2) {
      const atom = atoms[atomsIdc[i2]];
      geo.setItem(i2, atom.position, mode.calcAtomRadius(atom));
      geo.setColor(i2, colorer.getAtomColor(atom, parent));
    }
    geo.finalize();
  }
  updateToFrame(frameData) {
    const atomsIdc = this._selection.chunks;
    const {
      atoms
    } = this._selection;
    const mode = this._mode;
    const colorer = this._colorer;
    const updateColor = frameData.needsColorUpdate(colorer);
    const geo = this._geo;
    for (let i2 = 0, n = atomsIdc.length; i2 < n; ++i2) {
      const atom = atoms[atomsIdc[i2]];
      geo.setItem(i2, frameData.getAtomPos(atomsIdc[i2]), mode.calcAtomRadius(atom));
      if (updateColor) {
        geo.setColor(i2, frameData.getAtomColor(colorer, atom));
      }
    }
    geo.finalize();
  }
};
var groups_AtomsSphereGroup = AtomsSphereGroup;
var AtomsSurfaceGroup = class extends groups_AtomsSphereGroup {
  _makeGeoArgs() {
    const selectedAtoms = [];
    const {
      atoms,
      chunks
    } = this._selection;
    const n = chunks.length;
    for (let i2 = 0; i2 < n; ++i2) {
      selectedAtoms[i2] = atoms[chunks[i2]];
    }
    const opts = this._mode.getSurfaceOpts();
    opts.atoms = selectedAtoms;
    return [n, opts];
  }
};
var groups_AtomsSurfaceGroup = AtomsSurfaceGroup;
var AtomsSASSESGroupStub = class extends groups_AtomsSphereGroup {
  _makeGeoArgs() {
    const selectedAtoms = [];
    const {
      atoms,
      chunks
    } = this._selection;
    const n = chunks.length;
    for (let i2 = 0; i2 < n; ++i2) {
      selectedAtoms[i2] = atoms[chunks[i2]];
    }
    const opts = this._mode.getSurfaceOpts();
    opts.atoms = selectedAtoms;
    opts.selection = this._selection;
    opts.colorMode = this._colorer;
    return [n, opts];
  }
};
var groups_AtomsSASSESGroupStub = AtomsSASSESGroupStub;
function adjustColor(color) {
  let r2 = color >> 16 & 255;
  let g2 = color >> 8 & 255;
  let b2 = color & 255;
  if (0.2126 * r2 + 0.7152 * g2 + 0.0722 * b2 > 127) {
    r2 = r2 * 3 / 10;
    g2 = g2 * 3 / 10;
    b2 = b2 * 3 / 10;
  } else {
    r2 = 255 - (255 - r2) * 3 / 10;
    g2 = 255 - (255 - g2) * 3 / 10;
    b2 = 255 - (255 - b2) * 3 / 10;
  }
  return r2 << 16 | g2 << 8 | b2;
}
function inverseColor(color) {
  const r2 = color >> 16 & 255;
  const g2 = color >> 8 & 255;
  const b2 = color & 255;
  return 255 - r2 << 16 | 255 - g2 << 8 | 255 - b2;
}
function getAtomText(atom) {
  if (atom.name.getNode() !== null) {
    return atom.name.getNode();
  }
  return atom.getVisualName();
}
var colorMappings = {
  none(c2) {
    return c2;
  },
  adjust: adjustColor,
  inverse: inverseColor
};
function propagateColor(color, rule) {
  let result;
  if (colorMappings.hasOwnProperty(rule)) {
    result = utils.hexColor(colorMappings[rule](color));
  } else {
    const val = parseInt(rule, 16);
    if (!Number.isNaN(val) && rule.toLowerCase().startsWith("0x")) {
      result = utils.hexColor(val);
    } else {
      result = "#000000";
    }
  }
  return result;
}
var templateMappings = {
  serial(a2) {
    return a2.serial;
  },
  name(a2) {
    return a2.getVisualName();
  },
  elem(a2) {
    return a2.element.name;
  },
  residue(a2) {
    return a2.residue.getType().getName();
  },
  sequence(a2) {
    return a2.residue.getSequence();
  },
  chain(a2) {
    return a2.residue.getChain().getName();
  },
  hetatm(a2) {
    return a2.isHet();
  },
  water(a2) {
    return a2.residue.getType().getName() === "HOH" || a2.residue.getType().getName() === "WAT";
  }
};
var parseTemplate = function(atom, str) {
  return str.replace(/\{\{(\s*\w+\s*)\}\}/g, (m2) => {
    let key = m2.replace(/\s+/g, "");
    key = key.substring(2, key.length - 2).toLowerCase();
    if (templateMappings.hasOwnProperty(key)) {
      return templateMappings[key](atom);
    }
    return "null";
  });
};
var AtomsTextGroup = class extends groups_AtomsGroup {
  _makeGeoArgs() {
    const opts = this._mode.getLabelOpts();
    return [this._selection.chunks.length, opts];
  }
  _build() {
    const opts = this._mode.getLabelOpts();
    const atomsIdc = this._selection.chunks;
    const {
      atoms,
      parent
    } = this._selection;
    const colorer = this._colorer;
    const geo = this._geo;
    for (let i2 = 0, n = atomsIdc.length; i2 < n; ++i2) {
      const atom = atoms[atomsIdc[i2]];
      const text = opts.template ? parseTemplate(atom, opts.template) : getAtomText(atom);
      if (!text) {
        continue;
      }
      const color = colorer.getAtomColor(atom, parent);
      const fgColor = parseInt(propagateColor(color, opts.fg).substring(1), 16);
      const bgColor = opts.showBg ? parseInt(propagateColor(color, opts.bg).substring(1), 16) : "transparent";
      geo.setItem(i2, atom.position, text);
      geo.setColor(i2, fgColor, bgColor);
    }
    geo.finalize();
  }
  updateToFrame(frameData) {
    const opts = this._mode.getLabelOpts();
    const atomsIdc = this._selection.chunks;
    const {
      atoms
    } = this._selection;
    const colorer = this._colorer;
    const geo = this._geo;
    const updateColor = frameData.needsColorUpdate(colorer);
    for (let i2 = 0, n = atomsIdc.length; i2 < n; ++i2) {
      const atom = atoms[atomsIdc[i2]];
      const text = opts.template ? parseTemplate(atom, opts.template) : getAtomText(atom);
      if (!text) {
        continue;
      }
      const color = frameData.getAtomColor(colorer, atom);
      const fgColor = parseInt(propagateColor(color, opts.fg).substring(1), 16);
      const bgColor = opts.showBg ? parseInt(propagateColor(color, opts.bg).substring(1), 16) : "transparent";
      geo.setItem(i2, frameData.getAtomPos(atomsIdc[i2]), text);
      if (updateColor) {
        geo.setColor(i2, fgColor, bgColor);
      }
    }
    geo.finalize();
  }
};
var groups_AtomsTextGroup = AtomsTextGroup;
function _slerp(omega, v1, v2, t2) {
  const oSin = Math.sin(omega);
  return v1.clone().multiplyScalar(Math.sin((1 - t2) * omega) / oSin).addScaledVector(v2, Math.sin(t2 * omega) / oSin);
}
var AromaticGroup = class extends groups_AtomsGroup {
  _buildInner(radOffset, addChunk) {
    const chunksToIdx = this._selection.chunks;
    const prevVector = new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Vector3();
    const currVector = new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Vector3();
    const segmentsHeight = this._segmentsHeight;
    const leprStep = 1 / segmentsHeight;
    const colorer = this._colorer;
    const {
      cycles,
      parent
    } = this._selection;
    let chunkIdx = 0;
    let currAtomIdx = chunksToIdx[chunkIdx];
    for (let cIdx = 0, cCount = cycles.length; cIdx < cCount; ++cIdx) {
      const cycle = cycles[cIdx];
      const cycAtoms = cycle.atoms;
      const chunkPoints = [];
      const tmpDir = [];
      const {
        center
      } = cycle;
      const cycleRad = cycle.radius - radOffset;
      const n = cycAtoms.length;
      let i2 = 0;
      const prevPos = cycAtoms[n - 1].position;
      let currPos = cycAtoms[i2].position;
      prevVector.subVectors(prevPos, center);
      currVector.subVectors(currPos, center);
      const upDir = currVector.clone().cross(prevVector).normalize();
      for (; i2 < n; ++i2) {
        const omega = prevVector.angleTo(currVector);
        tmpDir[i2] = _slerp(omega, prevVector, currVector, 0.5).normalize();
        currPos = cycAtoms[(i2 + 1) % n].position;
        prevVector.copy(currVector);
        currVector.subVectors(currPos, center);
      }
      for (i2 = 0; i2 < n; ++i2) {
        if (cycAtoms[i2].index !== currAtomIdx) {
          continue;
        }
        const start = tmpDir[i2];
        const end = tmpDir[(i2 + 1) % n];
        const color = colorer.getAtomColor(cycAtoms[i2], parent);
        const currAngle = start.angleTo(end);
        for (let j = 0; j <= segmentsHeight; ++j) {
          chunkPoints[j] = _slerp(currAngle, start, end, j * leprStep).multiplyScalar(cycleRad).add(center);
        }
        addChunk(chunkIdx++, color, chunkPoints, center, upDir);
        currAtomIdx = chunksToIdx[chunkIdx];
      }
    }
  }
};
var groups_AromaticGroup = AromaticGroup;
function _createShape(rad, parts) {
  const pts = [];
  for (let i2 = 0; i2 < parts; ++i2) {
    const a2 = -2 * i2 / parts * Math.PI;
    pts.push(new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Vector3(Math.cos(a2) * rad, Math.sin(a2) * rad, 0));
  }
  return pts;
}
var {
  calcChunkMatrix
} = gfxutils;
var AromaticTorusGroup = class extends groups_AromaticGroup {
  _build() {
    const segmentsHeight = this._segmentsHeight;
    const torusRad = this._mode.getAromRadius();
    const radiusV = new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Vector2(torusRad, torusRad);
    const radOffset = this._mode.calcStickRadius() + 2 * torusRad;
    const lookAtVector = new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Vector3();
    const mtc = [];
    const geo = this._geo;
    this._buildInner(radOffset, (chunkIdx, color, points, center, upDir) => {
      for (let j = 0; j <= segmentsHeight; ++j) {
        const currPoint = points[j];
        const currDir = currPoint.clone().sub(center).cross(upDir);
        lookAtVector.addVectors(currPoint, currDir);
        mtc[j] = calcChunkMatrix(currPoint, lookAtVector, upDir, radiusV);
      }
      geo.setItem(chunkIdx, mtc);
      geo.setColor(chunkIdx, color);
    });
    geo.finalize();
  }
  _makeGeoArgs() {
    this._segmentsHeight = this._polyComplexity;
    return [_createShape(1, this._polyComplexity), this._segmentsHeight + 1, this._selection.chunks.length];
  }
};
var groups_AromaticTorusGroup = AromaticTorusGroup;
var AromaticLinesGroup = class extends groups_AromaticGroup {
  _build() {
    const geo = this._geo;
    const radOffset = this._mode.getAromaticOffset();
    this._buildInner(radOffset, (chunkIdx, color, points) => {
      let prevPt = points[0];
      for (let j = 1; j <= this._segmentsHeight; ++j) {
        const currPoint = points[j];
        geo.setSegment(chunkIdx, j - 1, prevPt, currPoint);
        prevPt = currPoint;
      }
      geo.setColor(chunkIdx, color);
    });
    geo.finalize();
  }
  _makeGeoArgs() {
    this._segmentsHeight = this._mode.getAromaticArcChunks();
    return [this._selection.chunks.length, this._segmentsHeight, true];
  }
};
var groups_AromaticLinesGroup = AromaticLinesGroup;
var ResiduesGroup = class extends groups_ChemGroup {
  raycast(raycaster, intersects2) {
    const {
      residues
    } = this._selection;
    const inters = [];
    this._mesh.raycast(raycaster, inters);
    const chunksIdc = this._chunksIdc;
    for (let i2 = 0, n = inters.length; i2 < n; ++i2) {
      if (!inters[i2].hasOwnProperty("chunkIdx")) {
        continue;
      }
      const resIdx = chunksIdc[inters[i2].chunkIdx];
      if (resIdx < residues.length) {
        inters[i2].residue = residues[resIdx];
        intersects2.push(inters[i2]);
      }
    }
  }
  _calcChunksList(mask) {
    const chunksList = [];
    const {
      residues
    } = this._selection;
    const resIdc = this._chunksIdc;
    for (let i2 = 0, n = resIdc.length; i2 < n; ++i2) {
      const res = residues[resIdc[i2]];
      if ((res._mask & mask) !== 0) {
        chunksList.push(i2);
      }
    }
    return chunksList;
  }
};
var groups_ResiduesGroup = ResiduesGroup;
var NucleicItemGroup = class extends groups_ResiduesGroup {
  raycast(raycaster, intersects2) {
    const {
      residues
    } = this._selection;
    const inters = [];
    this._mesh.raycast(raycaster, inters);
    const chunksIdc = this._chunksIdc;
    for (let i2 = 0, n = inters.length; i2 < n; ++i2) {
      if (!inters[i2].hasOwnProperty("chunkIdx")) {
        continue;
      }
      const resIdx = chunksIdc[Math.floor(inters[i2].chunkIdx / 2)];
      if (resIdx < residues.length) {
        inters[i2].residue = residues[resIdx];
        intersects2.push(inters[i2]);
      }
    }
  }
  _build() {
    const {
      residues,
      parent
    } = this._selection;
    const colorer = this._colorer;
    const geo = this._geo;
    const stickRad = this._mode.calcStickRadius();
    let chunkIdx = 0;
    const resIdc = this._selection.chunks;
    for (let i2 = 0, n = resIdc.length; i2 < n; ++i2) {
      const res = residues[resIdc[i2]];
      const color = colorer.getResidueColor(res, parent);
      this._processItem(chunkIdx++, res._cylinders[0], res._cylinders[1], stickRad, color);
    }
    geo.finalize();
  }
  _calcChunksList(mask) {
    const chunksList = [];
    let chunkIdx = 0;
    const {
      residues
    } = this._selection;
    const resIdc = this._chunksIdc;
    for (let i2 = 0, n = resIdc.length; i2 < n; ++i2) {
      const res = residues[resIdc[i2]];
      if ((res._mask & mask) !== 0) {
        chunksList[chunkIdx++] = 2 * i2;
        chunksList[chunkIdx++] = 2 * i2 + 1;
      }
    }
    return chunksList;
  }
  updateToFrame(frameData) {
    const residues = frameData.getResidues();
    const {
      parent
    } = this._selection;
    const colorer = this._colorer;
    const geo = this._geo;
    const stickRad = this._mode.calcStickRadius();
    let chunkIdx = 0;
    const resIdc = this._selection.chunks;
    for (let i2 = 0, n = resIdc.length; i2 < n; ++i2) {
      const res = residues[resIdc[i2]];
      const color = colorer.getResidueColor(res, parent);
      this._processItem(chunkIdx++, res._cylinders[0], res._cylinders[1], stickRad, color);
    }
    geo.finishUpdate();
  }
};
var groups_NucleicItemGroup = NucleicItemGroup;
var NucleicCylindersGroup = class extends groups_NucleicItemGroup {
  _makeGeoArgs() {
    return [this._selection.chunks.length, this._polyComplexity];
  }
  _processItem(chunkIdx, cyl1, cyl2, stickRad, color) {
    const geo = this._geo;
    geo.setItem(chunkIdx, cyl1, cyl2, stickRad);
    geo.setColor(chunkIdx, color, color);
  }
};
var groups_NucleicCylindersGroup = NucleicCylindersGroup;
var NucleicSpheresGroup = class extends groups_NucleicItemGroup {
  _makeGeoArgs() {
    return [this._selection.chunks.length * 2, this._polyComplexity];
  }
  _processItem(chunkIdx, cyl1, cyl2, stickRad, color) {
    const geo = this._geo;
    let idx = chunkIdx * 2;
    geo.setItem(idx, cyl1, stickRad);
    geo.setColor(idx, color);
    idx++;
    geo.setItem(idx, cyl2, stickRad);
    geo.setColor(idx, color);
  }
};
var groups_NucleicSpheresGroup = NucleicSpheresGroup;
var Smooth = __webpack_require__(690);
var {
  ResidueType: CartoonHelper_ResidueType
} = chem;
var calcMatrix = gfxutils.calcChunkMatrix;
function _buildStructureInterpolator(points, tension) {
  const path = (0, Smooth.Smooth)(points, {
    method: Smooth.Smooth.METHOD_CUBIC,
    clip: Smooth.Smooth.CLIP_CLAMP,
    cubicTension: tension,
    scaleTo: 1
  });
  return function(t2, argTrans) {
    let transformT = argTrans;
    if (transformT === null) {
      transformT = function(tt) {
        return (tt * (points.length - 1 - 2) + 1) / (points.length - 1);
      };
    }
    const newt = transformT(t2);
    const ans = path(newt);
    return new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Vector3(ans[0], ans[1], ans[2]);
  };
}
function _addPoints(centerPoints, topPoints, idx, residue) {
  if (!residue._isValid) {
    centerPoints[idx] = centerPoints[idx - 1];
    topPoints[idx] = topPoints[idx - 1];
    return;
  }
  const cp = residue._controlPoint;
  centerPoints[idx] = [cp.x, cp.y, cp.z];
  const tp = cp.clone().add(residue._wingVector);
  topPoints[idx] = [tp.x, tp.y, tp.z];
}
function _addPointsForLoneResidue(centerPoints, topPoints, idx, residue) {
  const nucleic = (residue._type.flags & CartoonHelper_ResidueType.Flags.NUCLEIC) !== 0;
  const nameFrom = nucleic ? "C5'" : "N";
  const nameTo = nucleic ? "C3'" : "C";
  let posFrom;
  let posTo;
  residue.forEachAtom((atom) => {
    const name = atom.getVisualName();
    if (!posFrom && name === nameFrom) {
      posFrom = atom.position;
    } else if (!posTo && name === nameTo) {
      posTo = atom.position;
    }
  });
  if (!(posFrom && posTo)) {
    posFrom = residue._firstAtom.position;
    posTo = residue._lastAtom.position;
  }
  if (posFrom && posTo) {
    const shift = posTo.clone().sub(posFrom);
    const wing = residue._wingVector;
    const cp = residue._controlPoint;
    const tp = cp.clone().add(wing);
    const cpPrev = cp.clone().sub(shift);
    const tpPrev = cpPrev.clone().add(wing);
    centerPoints[idx] = [cpPrev.x, cpPrev.y, cpPrev.z];
    topPoints[idx] = [tpPrev.x, tpPrev.y, tpPrev.z];
    ++idx;
    centerPoints[idx] = [cpPrev.x, cpPrev.y, cpPrev.z];
    topPoints[idx] = [tpPrev.x, tpPrev.y, tpPrev.z];
    ++idx;
    centerPoints[idx] = [cp.x, cp.y, cp.z];
    topPoints[idx] = [tp.x, tp.y, tp.z];
    ++idx;
    const cpNext = cp.clone().add(shift);
    const tpNext = cpNext.clone().add(wing);
    centerPoints[idx] = [cpNext.x, cpNext.y, cpNext.z];
    topPoints[idx] = [tpNext.x, tpNext.y, tpNext.z];
    ++idx;
    centerPoints[idx] = [cpNext.x, cpNext.y, cpNext.z];
    topPoints[idx] = [tpNext.x, tpNext.y, tpNext.z];
  }
}
function _calcPoints(residues, firstIdx, lastIdx, boundaries) {
  const left = boundaries.start;
  const right = boundaries.end;
  function _prevIdx(idx) {
    return idx > left && residues[idx - 1]._isValid ? idx - 1 : idx;
  }
  function _nextIdx(idx) {
    return idx < right && residues[idx + 1]._isValid ? idx + 1 : idx;
  }
  const topPoints = [];
  const centerPoints = [];
  let arrIdx = 0;
  function _extrapolate2(currIdx, otherIdx) {
    const cp = residues[currIdx]._controlPoint.clone().lerp(residues[otherIdx]._controlPoint, -0.25);
    const tp = cp.clone().add(residues[currIdx]._wingVector);
    centerPoints[arrIdx] = [cp.x, cp.y, cp.z];
    topPoints[arrIdx++] = [tp.x, tp.y, tp.z];
    centerPoints[arrIdx] = [cp.x, cp.y, cp.z];
    topPoints[arrIdx++] = [tp.x, tp.y, tp.z];
  }
  const prevIdx = _prevIdx(firstIdx);
  const nextIdx = _nextIdx(lastIdx);
  if (prevIdx === nextIdx) {
    _addPointsForLoneResidue(centerPoints, topPoints, arrIdx, residues[firstIdx]);
    return {
      centerPoints,
      topPoints
    };
  }
  if (firstIdx === prevIdx) {
    _extrapolate2(firstIdx, _nextIdx(firstIdx));
  } else {
    _addPoints(centerPoints, topPoints, arrIdx++, residues[_prevIdx(prevIdx)]);
    _addPoints(centerPoints, topPoints, arrIdx++, residues[prevIdx]);
  }
  for (let idx = firstIdx; idx <= lastIdx; ++idx) {
    _addPoints(centerPoints, topPoints, arrIdx++, residues[idx]);
  }
  if (nextIdx === _nextIdx(nextIdx)) {
    _extrapolate2(lastIdx, _prevIdx(lastIdx));
  } else {
    _addPoints(centerPoints, topPoints, arrIdx++, residues[nextIdx]);
    _addPoints(centerPoints, topPoints, arrIdx, residues[_nextIdx(nextIdx)]);
  }
  return {
    centerPoints,
    topPoints
  };
}
var CartoonHelper = class {
  constructor(residues, startIdx, endIdx, segmentsCount, tension, boundaries) {
    const pointsArrays = _calcPoints(residues, startIdx, endIdx, boundaries);
    this._topInterp = _buildStructureInterpolator(pointsArrays.topPoints, tension);
    this._centerInterp = _buildStructureInterpolator(pointsArrays.centerPoints, tension);
    this._shift = 0.5 / (endIdx - startIdx + 2);
    this._valueStep = (1 - 2 * this._shift) / (2 * (endIdx - startIdx + 1) * (segmentsCount - 1));
    this._segmentsCount = segmentsCount;
  }
  prepareMatrices(idx, firstRad, secondRad) {
    const mtcCount = this._segmentsCount;
    const outMtc = new Array(mtcCount);
    const currRad = new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Vector2(0, 0);
    const topInterp = this._topInterp;
    const cenInterp = this._centerInterp;
    let currentValue = this._shift + this._valueStep * (mtcCount - 1) * idx;
    for (let mtxIdx = 0; mtxIdx < mtcCount; ++mtxIdx) {
      const lerpVal = Math.min(1, mtxIdx / (mtcCount - 1));
      currRad.lerpVectors(firstRad, secondRad, lerpVal);
      const currTop = topInterp(currentValue, null);
      const currCenter = cenInterp(currentValue, null);
      currentValue += this._valueStep;
      const nextCenter = cenInterp(currentValue, null);
      outMtc[mtxIdx] = calcMatrix(currCenter.clone(), nextCenter.clone(), currTop.clone().sub(currCenter), currRad);
    }
    return outMtc;
  }
};
var groups_CartoonHelper = CartoonHelper;
function ResiduesSubseqGroup_createShape(rad, parts) {
  const pts = [];
  for (let i2 = 0; i2 < parts; ++i2) {
    const a2 = Math.PI / 2 - 2 * Math.PI * i2 / parts;
    pts.push(new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Vector3(Math.cos(a2) * rad, Math.sin(a2) * rad, 0));
  }
  return pts;
}
function _loopThrough(subDiv, residues, segmentsHeight, tension, mode, callback) {
  for (let subDivI = 0, subDivN = subDiv.length; subDivI < subDivN; ++subDivI) {
    const subs = subDiv[subDivI].arr;
    const {
      boundaries
    } = subDiv[subDivI];
    for (let i2 = 0, n = subs.length; i2 < n; ++i2) {
      const idc = [subs[i2].start, subs[i2].end];
      const matrixHelper = new groups_CartoonHelper(residues, idc[0], idc[1], segmentsHeight, tension, boundaries);
      let prevLast = null;
      const startIdx = subs[i2].start * 2;
      const endIdx = subs[i2].end * 2 + 1;
      let prevSecondRad = mode.getResidueRadius(residues[0], 0);
      for (let idx = startIdx; idx <= endIdx; ++idx) {
        const resIdx = idx / 2 | 0;
        const currRes = residues[resIdx];
        const firstRad = mode.getResidueRadius(currRes, idx % 2);
        const secondRad = mode.getResidueRadius(currRes, 1 + idx % 2);
        const mtc = matrixHelper.prepareMatrices(idx - idc[0] * 2, firstRad, secondRad);
        mtc.unshift(prevLast === null ? mtc[0] : prevLast);
        const hasSlope = firstRad.x !== secondRad.x || firstRad.y !== secondRad.y;
        const hasCut = firstRad.x !== prevSecondRad.x || firstRad.y !== prevSecondRad.y;
        callback(currRes, mtc, hasSlope, hasCut);
        prevLast = mtc[segmentsHeight];
        prevSecondRad = secondRad;
      }
    }
  }
}
var ResiduesSubseqGroup = class extends groups_ResiduesGroup {
  _makeGeoArgs() {
    const cmpMultiplier = this._mode.getHeightSegmentsRatio();
    this._segmentsHeight = this._polyComplexity * cmpMultiplier | 0;
    return [ResiduesSubseqGroup_createShape(1, this._polyComplexity), this._segmentsHeight + 1, this._selection.chunks.length * 2];
  }
  _build() {
    const {
      residues,
      parent
    } = this._selection;
    const mode = this._mode;
    const colorer = this._colorer;
    const tension = mode.getTension();
    const geo = this._geo;
    let chunkIdx = 0;
    const chunkIdc = [];
    _loopThrough(this._selection.subdivs, residues, this._segmentsHeight, tension, mode, function(currRes, mtc) {
      let hasSlope = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
      let hasCut = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : false;
      const color = colorer.getResidueColor(currRes, parent);
      chunkIdc[chunkIdx] = currRes._index;
      geo.setItem(chunkIdx, mtc, hasSlope, hasCut);
      geo.setColor(chunkIdx++, color);
    });
    this._chunksIdc = chunkIdc;
    geo.finalize();
  }
  updateToFrame(frameData) {
    const {
      parent
    } = this._selection;
    const mode = this._mode;
    const colorer = this._colorer;
    const tension = mode.getTension();
    const geo = this._geo;
    const frameRes = frameData.getResidues();
    let chunkIdx = 0;
    const updateColor = frameData.needsColorUpdate(colorer);
    _loopThrough(this._selection.subdivs, frameRes, this._segmentsHeight, tension, mode, (currRes, mtc) => {
      geo.setItem(chunkIdx, mtc);
      if (updateColor) {
        geo.setColor(chunkIdx, colorer.getResidueColor(currRes, parent));
      }
      chunkIdx++;
    });
    geo.finalize();
  }
};
var groups_ResiduesSubseqGroup = ResiduesSubseqGroup;
var ResiduesTraceGroup = class extends groups_ChemGroup {
  _makeGeoArgs() {
    const subDiv = this._selection.subdivs;
    let chunksCount = 0;
    for (let subDivI = 0, subDivN = subDiv.length; subDivI < subDivN; ++subDivI) {
      const subs = subDiv[subDivI].arr;
      for (let i2 = 0, n = subs.length; i2 < n; ++i2) {
        chunksCount += subs[i2].end - subs[i2].start;
      }
    }
    return [chunksCount, this._polyComplexity];
  }
  _build() {
    const {
      residues,
      parent
    } = this._selection;
    const mode = this._mode;
    const colorer = this._colorer;
    const geo = this._geo;
    let chunkIdx = 0;
    const chunkIdc = [];
    const subDiv = this._selection.subdivs;
    const stickRad = mode.calcStickRadius();
    for (let subDivI = 0, subDivN = subDiv.length; subDivI < subDivN; ++subDivI) {
      const subs = subDiv[subDivI].arr;
      for (let i2 = 0, n = subs.length; i2 < n; ++i2) {
        const startIdx = subs[i2].start;
        const endIdx = subs[i2].end;
        let prevRes = residues[startIdx];
        for (let idx = startIdx + 1; idx <= endIdx; ++idx) {
          const currRes = residues[idx];
          chunkIdc[chunkIdx] = {
            first: prevRes._index,
            second: currRes._index
          };
          geo.setItem(chunkIdx, prevRes._controlPoint, currRes._controlPoint, stickRad);
          geo.setColor(chunkIdx, colorer.getResidueColor(prevRes, parent), colorer.getResidueColor(currRes, parent));
          chunkIdx++;
          prevRes = currRes;
        }
      }
    }
    this._chunksIdc = chunkIdc;
    geo.finalize();
  }
  updateToFrame(frameData) {
    const residues = frameData.getResidues();
    const {
      parent
    } = this._selection;
    const mode = this._mode;
    const colorer = this._colorer;
    const geo = this._geo;
    let chunkIdx = 0;
    const subDiv = this._selection.subdivs;
    const stickRad = mode.calcStickRadius();
    const updateColor = frameData.needsColorUpdate(colorer);
    for (let subDivI = 0, subDivN = subDiv.length; subDivI < subDivN; ++subDivI) {
      const subs = subDiv[subDivI].arr;
      for (let i2 = 0, n = subs.length; i2 < n; ++i2) {
        const startIdx = subs[i2].start;
        const endIdx = subs[i2].end;
        let prevRes = residues[startIdx];
        for (let idx = startIdx + 1; idx <= endIdx; ++idx) {
          const currRes = residues[idx];
          geo.setItem(chunkIdx, prevRes._controlPoint, currRes._controlPoint, stickRad);
          if (updateColor) {
            geo.setColor(chunkIdx, colorer.getResidueColor(prevRes, parent), colorer.getResidueColor(currRes, parent));
          }
          chunkIdx++;
          prevRes = currRes;
        }
      }
    }
    geo.finalize();
  }
  raycast(raycaster, intersects2) {
    const inters = [];
    const {
      residues
    } = this._selection;
    this._mesh.raycast(raycaster, inters);
    const chunksToIdx = this._chunksIdc;
    for (let i2 = 0, n = inters.length; i2 < n; ++i2) {
      if (!inters[i2].hasOwnProperty("chunkIdx")) {
        continue;
      }
      const {
        chunkIdx
      } = inters[i2];
      const chunk = chunksToIdx[Math.floor(chunkIdx / 2)];
      const resIdx = chunkIdx % 2 === 0 ? chunk.first : chunk.second;
      if (resIdx < residues.length) {
        inters[i2].residue = residues[resIdx];
        intersects2.push(inters[i2]);
      }
    }
  }
  _calcChunksList(mask) {
    const chunksList = [];
    const chunksToIdx = this._chunksIdc;
    const {
      residues
    } = this._selection;
    for (let i2 = 0, n = chunksToIdx.length; i2 < n; ++i2) {
      const chunk = chunksToIdx[i2];
      if (residues[chunk.first]._mask & mask) {
        chunksList.push(i2 * 2);
      }
      if (residues[chunk.second]._mask & mask) {
        chunksList.push(i2 * 2 + 1);
      }
    }
    return chunksList;
  }
};
var groups_ResiduesTraceGroup = ResiduesTraceGroup;
function getCylinderCount(bondOrder) {
  return bondOrder < 2 ? 1 : bondOrder;
}
var BondsGroup = class extends groups_ChemGroup {
  _makeGeoArgs() {
    const drawMultiple = this._mode.drawMultiorderBonds();
    const showAromatic = this._mode.showAromaticLoops();
    const bondsIdc = this._selection.chunks;
    const {
      bonds
    } = this._selection;
    let bondsCount = 0;
    for (let i2 = 0, n = bondsIdc.length; i2 < n; ++i2) {
      bondsCount += this.getBondOrder(bonds[bondsIdc[i2]], drawMultiple, showAromatic);
    }
    return [bondsCount, this._polyComplexity];
  }
  getBondOrder(bond, drawMultiple, showAromatic) {
    let bondOrder = 1;
    if (drawMultiple && (!showAromatic || bond._type !== chem_Bond.BondType.AROMATIC)) {
      bondOrder = getCylinderCount(bond._order);
    }
    return bondOrder;
  }
  raycast(raycaster, intersects2) {
    const {
      bonds
    } = this._selection;
    const inters = [];
    this._mesh.raycast(raycaster, inters);
    const bondsIdc = this._chunksIdc;
    for (let i2 = 0, n = inters.length; i2 < n; ++i2) {
      if (!inters[i2].hasOwnProperty("chunkIdx")) {
        continue;
      }
      const {
        chunkIdx
      } = inters[i2];
      const bondIdx = bondsIdc[Math.floor(chunkIdx / 2)];
      if (bondIdx < bonds.length) {
        const bond = bonds[bondIdx];
        inters[i2].atom = chunkIdx % 2 === 0 ? bond._left : bond._right;
        intersects2.push(inters[i2]);
      }
    }
  }
  _calcChunksList(mask, innerOnly) {
    const chunksList = [];
    const {
      bonds
    } = this._selection;
    const chunksToIdx = this._chunksIdc;
    for (let i2 = 0, n = chunksToIdx.length; i2 < n; ++i2) {
      const bond = bonds[chunksToIdx[i2]];
      if (bond._left.mask & mask && (!innerOnly || bond._right.mask & mask)) {
        chunksList.push(2 * i2);
      }
      if (bond._right.mask & mask && (!innerOnly || bond._left.mask & mask)) {
        chunksList.push(2 * i2 + 1);
      }
    }
    return chunksList;
  }
};
var groups_BondsGroup = BondsGroup;
var BondsCylinderGroup = class extends groups_BondsGroup {
  _build() {
    const bondsIdc = this._selection.chunks;
    const {
      bonds,
      parent
    } = this._selection;
    const mode = this._mode;
    const colorer = this._colorer;
    const geo = this._geo;
    const drawMultiple = mode.drawMultiorderBonds();
    const showAromatic = mode.showAromaticLoops();
    const stickRad = mode.calcStickRadius();
    const emptyOffset = mode.calcSpaceFraction();
    let normDir;
    const leftPos = new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Vector3();
    const rightPos = new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Vector3();
    let currBondIdx = 0;
    const chunksToIdx = [];
    for (let i2 = 0, n = bondsIdc.length; i2 < n; ++i2) {
      const bond = bonds[bondsIdc[i2]];
      const atom1 = bond._left;
      const atom2 = bond._right;
      const a1Pos = atom1.position;
      const a2Pos = atom2.position;
      normDir = bond.calcNormalDir();
      const order = this.getBondOrder(bond, drawMultiple, showAromatic);
      const minRad = Math.min(mode.calcAtomRadius(atom1), mode.calcAtomRadius(atom2));
      const dist = 2 * minRad / order;
      const currStickRad = drawMultiple ? Math.min(stickRad, dist * 0.5 * (1 - emptyOffset)) : stickRad;
      for (let j = 0; j < order; ++j) {
        const scale = dist * (order % 2 === 0 ? ((j / 2 | 0) + 0.5) * (1 - 2 * (j % 2)) : ((j + 1) / 2 | 0) * (-1 + 2 * (j % 2)));
        chunksToIdx[currBondIdx] = bond._index;
        leftPos.copy(a1Pos);
        leftPos.addScaledVector(normDir, scale);
        rightPos.copy(a2Pos);
        rightPos.addScaledVector(normDir, scale);
        geo.setItem(currBondIdx, leftPos, rightPos, currStickRad);
        geo.setColor(currBondIdx++, colorer.getAtomColor(atom1, parent), colorer.getAtomColor(atom2, parent));
      }
    }
    geo.finalize();
    this._chunksIdc = chunksToIdx;
  }
  updateToFrame(frameData) {
    const bondsIdc = this._selection.chunks;
    const {
      bonds
    } = this._selection;
    const mode = this._mode;
    const colorer = this._colorer;
    const geo = this._geo;
    const drawMultiple = mode.drawMultiorderBonds();
    const showAromatic = mode.showAromaticLoops();
    const stickRad = mode.calcStickRadius();
    const emptyOffset = mode.calcSpaceFraction();
    let normDir;
    const leftPos = new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Vector3();
    const rightPos = new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Vector3();
    let currBondIdx = 0;
    const updateColor = frameData.needsColorUpdate(colorer);
    for (let i2 = 0, n = bondsIdc.length; i2 < n; ++i2) {
      const bond = bonds[bondsIdc[i2]];
      const atom1 = bond._left;
      const atom2 = bond._right;
      const a1Pos = frameData.getAtomPos(atom1.index).clone();
      const a2Pos = frameData.getAtomPos(atom2.index);
      normDir = bond.calcNormalDir();
      const order = this.getBondOrder(bond, drawMultiple, showAromatic);
      const minRad = Math.min(mode.calcAtomRadius(atom1), mode.calcAtomRadius(atom2));
      const dist = 2 * minRad / order;
      const currStickRad = drawMultiple ? Math.min(stickRad, dist * 0.5 * (1 - emptyOffset)) : stickRad;
      for (let j = 0; j < order; ++j) {
        const scale = dist * (order % 2 === 0 ? ((j / 2 | 0) + 0.5) * (1 - 2 * (j % 2)) : ((j + 1) / 2 | 0) * (-1 + 2 * (j % 2)));
        leftPos.copy(a1Pos);
        leftPos.addScaledVector(normDir, scale);
        rightPos.copy(a2Pos);
        rightPos.addScaledVector(normDir, scale);
        geo.setItem(currBondIdx, leftPos, rightPos, currStickRad);
        if (updateColor) {
          geo.setColor(currBondIdx, frameData.getAtomColor(colorer, atom1), frameData.getAtomColor(colorer, atom2));
        }
        currBondIdx++;
      }
    }
    geo.finalize();
  }
};
var groups_BondsCylinderGroup = BondsCylinderGroup;
var STEP_SIZE = 0.15;
var BondsLinesGroup = class extends groups_BondsGroup {
  _build() {
    const bondsIdc = this._selection.chunks;
    const {
      bonds,
      parent
    } = this._selection;
    const mode = this._mode;
    const colorer = this._colorer;
    const geo = this._geo;
    const drawMultiple = mode.drawMultiorderBonds();
    const showAromatic = mode.showAromaticLoops();
    const bondDir = new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Vector3();
    const leftPos = new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Vector3();
    const rightPos = new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Vector3();
    let currBondIdx = 0;
    const chunksToIdx = [];
    for (let i2 = 0, n = bondsIdc.length; i2 < n; ++i2) {
      const bond = bonds[bondsIdc[i2]];
      const atom1 = bond._left;
      const atom2 = bond._right;
      const a1Pos = atom1.position;
      const a2Pos = atom2.position;
      const a1Hangs = atom1.bonds.length === 1;
      const a2Hangs = atom2.bonds.length === 1;
      bondDir.subVectors(a2Pos, a1Pos);
      const len = bondDir.length();
      const normDir = bond.calcNormalDir();
      const order = this.getBondOrder(bond, drawMultiple, showAromatic);
      for (let j = 0; j < order; ++j) {
        leftPos.copy(a1Pos);
        rightPos.copy(a2Pos);
        let scale = order % 2 === 0 ? ((j / 2 | 0) + 0.5) * (1 - 2 * (j % 2)) : ((j + 1) / 2 | 0) * (-1 + 2 * (j % 2));
        chunksToIdx[currBondIdx] = bond._index;
        if (order === 2 && !a1Hangs && !a2Hangs) {
          scale -= 0.5;
          scale *= -1;
        }
        if (!a1Hangs && !a2Hangs && order > 1 && scale !== 0) {
          leftPos.lerpVectors(a1Pos, a2Pos, STEP_SIZE / len);
          rightPos.lerpVectors(a1Pos, a2Pos, 1 - STEP_SIZE / len);
        }
        scale *= STEP_SIZE;
        leftPos.addScaledVector(normDir, scale);
        rightPos.addScaledVector(normDir, scale);
        geo.setItem(currBondIdx, leftPos, rightPos);
        geo.setColor(currBondIdx++, colorer.getAtomColor(atom1, parent), colorer.getAtomColor(atom2, parent));
      }
    }
    geo.finalize();
    this._chunksIdc = chunksToIdx;
  }
  updateToFrame(frameData) {
    const bondsIdc = this._selection.chunks;
    const {
      bonds
    } = this._selection;
    const mode = this._mode;
    const colorer = this._colorer;
    const geo = this._geo;
    const drawMultiple = mode.drawMultiorderBonds();
    const showAromatic = mode.showAromaticLoops();
    const bondDir = new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Vector3();
    const leftPos = new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Vector3();
    const rightPos = new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Vector3();
    let currBondIdx = 0;
    const updateColor = frameData.needsColorUpdate(colorer);
    for (let i2 = 0, n = bondsIdc.length; i2 < n; ++i2) {
      const bond = bonds[bondsIdc[i2]];
      const atom1 = bond._left;
      const atom2 = bond._right;
      const a1Pos = frameData.getAtomPos(atom1.index).clone();
      const a2Pos = frameData.getAtomPos(atom2.index);
      const a1Hangs = atom1.bonds.length === 1;
      const a2Hangs = atom2.bonds.length === 1;
      bondDir.subVectors(a2Pos, a1Pos);
      const len = bondDir.length();
      const normDir = bond.calcNormalDir();
      const order = this.getBondOrder(bond, drawMultiple, showAromatic);
      for (let j = 0; j < order; ++j) {
        leftPos.copy(a1Pos);
        rightPos.copy(a2Pos);
        let scale = order % 2 === 0 ? ((j / 2 | 0) + 0.5) * (1 - 2 * (j % 2)) : ((j + 1) / 2 | 0) * (-1 + 2 * (j % 2));
        if (order === 2 && !a1Hangs && !a2Hangs) {
          scale -= 0.5;
          scale *= -1;
        }
        if (!a1Hangs && !a2Hangs && order > 1 && scale !== 0) {
          leftPos.lerpVectors(a1Pos, a2Pos, STEP_SIZE / len);
          rightPos.lerpVectors(a1Pos, a2Pos, 1 - STEP_SIZE / len);
        }
        scale *= STEP_SIZE;
        leftPos.addScaledVector(normDir, scale);
        rightPos.addScaledVector(normDir, scale);
        geo.setItem(currBondIdx, leftPos, rightPos);
        if (updateColor) {
          geo.setColor(currBondIdx, frameData.getAtomColor(colorer, atom1), frameData.getAtomColor(colorer, atom2));
        }
        currBondIdx++;
      }
    }
    geo.finalize();
  }
};
var groups_BondsLinesGroup = BondsLinesGroup;
var groups = {
  AtomsSphereGroup: groups_AtomsSphereGroup,
  AtomsSurfaceGroup: groups_AtomsSurfaceGroup,
  AtomsSASSESGroupStub: groups_AtomsSASSESGroupStub,
  AtomsTextGroup: groups_AtomsTextGroup,
  AromaticTorusGroup: groups_AromaticTorusGroup,
  AromaticLinesGroup: groups_AromaticLinesGroup,
  NucleicCylindersGroup: groups_NucleicCylindersGroup,
  NucleicSpheresGroup: groups_NucleicSpheresGroup,
  ResiduesSubseqGroup: groups_ResiduesSubseqGroup,
  ResiduesTraceGroup: groups_ResiduesTraceGroup,
  BondsCylinderGroup: groups_BondsCylinderGroup,
  BondsLinesGroup: groups_BondsLinesGroup
};
var AtomsProcessor = class extends gfx_RCGroup {
  constructor(AtomsGroup2, geoParams, complex, colorer, mode, polyComplexity, mask, material) {
    super();
    const self2 = this;
    this._complex = complex;
    this._mode = mode;
    const atoms = complex.getAtoms();
    const transforms = complex.getTransforms();
    complex.forEachComponent((component) => {
      const atomsIdc = [];
      let atomCount = 0;
      component.forEachAtom((atom) => {
        if (!self2._checkAtom(atom, mask)) {
          return;
        }
        atomsIdc[atomCount++] = atom.index;
      });
      if (atomCount === 0) {
        return;
      }
      const atomsGroup = new AtomsGroup2(geoParams, {
        atoms,
        chunks: atomsIdc,
        parent: complex
      }, colorer, mode, transforms, polyComplexity, material);
      atomsGroup._component = component;
      self2.add(atomsGroup);
    });
  }
  _checkAtom(atom, mask) {
    return atom.mask & mask;
  }
  getSubset(mask, innerOnly) {
    const totalSubset = [];
    const {
      children
    } = this;
    let meshIdx = 0;
    for (let i2 = 0, n = children.length; i2 < n; ++i2) {
      if (children[i2].getSubset) {
        const chSubset = children[i2].getSubset(mask, innerOnly);
        for (let j = 0, m2 = chSubset.length; j < m2; ++j) {
          const subsetEl = chSubset[j];
          subsetEl._component = children[i2]._component;
          totalSubset[meshIdx++] = subsetEl;
        }
      }
    }
    return totalSubset;
  }
};
var processors_AtomsProcessor = AtomsProcessor;
var OrphanAtomsProcessor = class extends processors_AtomsProcessor {
  _checkAtom(atom, mask) {
    if (!(atom.mask & mask)) {
      return false;
    }
    const {
      bonds
    } = atom;
    for (let i2 = 0, n = bonds.length; i2 < n; ++i2) {
      if (bonds[i2]._left.mask & mask && bonds[i2]._right.mask & mask) {
        return false;
      }
    }
    return true;
  }
};
var processors_OrphanAtomsProcessor = OrphanAtomsProcessor;
var ResiduesProcessor = class extends gfx_RCGroup {
  constructor(ResidueGroup, geoParams, complex, colorer, mode, polyComplexity, mask, material) {
    super();
    const self2 = this;
    this._complex = complex;
    const residues = complex.getResidues();
    const transforms = complex.getTransforms();
    complex.forEachComponent((component) => {
      let chunksCount = 0;
      const resIdc = [];
      component.forEachResidue((residue) => {
        if (self2._checkResidue(residue, mask)) {
          resIdc[chunksCount++] = residue._index;
        }
      });
      if (chunksCount === 0) {
        return;
      }
      const residuesGroup = new ResidueGroup(geoParams, {
        residues,
        chunks: resIdc,
        parent: complex
      }, colorer, mode, transforms, polyComplexity, material);
      residuesGroup._component = component;
      self2.add(residuesGroup);
    });
  }
  checkResidue(residue, mask) {
    return residue._mask & mask;
  }
  getSubset(mask, innerOnly) {
    const totalSubset = [];
    const {
      children
    } = this;
    let meshIdx = 0;
    for (let i2 = 0, n = children.length; i2 < n; ++i2) {
      if (children[i2].getSubset) {
        const chSubset = children[i2].getSubset(mask, innerOnly);
        for (let j = 0, m2 = chSubset.length; j < m2; ++j) {
          const subsetEl = chSubset[j];
          subsetEl._component = children[i2]._component;
          totalSubset[meshIdx++] = subsetEl;
        }
      }
    }
    return totalSubset;
  }
};
var processors_ResiduesProcessor = ResiduesProcessor;
var NucleicProcessor = class extends processors_ResiduesProcessor {
  _checkResidue(residue, mask) {
    return mask & residue._mask && residue._cylinders !== null;
  }
};
var processors_NucleicProcessor = NucleicProcessor;
var SubseqsProcessor = class extends gfx_RCGroup {
  constructor(ResidueGroup, geoParams, complex, colorer, mode, polyComplexity, mask, material) {
    super();
    const self2 = this;
    this._complex = complex;
    const residues = complex.getResidues();
    const transforms = complex.getTransforms();
    complex.forEachComponent((component) => {
      const subDivs = component.getMaskedSubdivSequences(mask);
      let chunksCount = 0;
      const resIdc = [];
      for (let subDivI = 0, subDivN = subDivs.length; subDivI < subDivN; ++subDivI) {
        const subs = subDivs[subDivI].arr;
        for (let i2 = 0, n = subs.length; i2 < n; ++i2) {
          for (let j = subs[i2].start, jEnd = subs[i2].end; j <= jEnd; ++j) {
            resIdc[chunksCount++] = residues[j]._index;
          }
        }
      }
      if (chunksCount === 0) {
        return;
      }
      const residuesGroup = new ResidueGroup(geoParams, {
        residues,
        chunks: resIdc,
        subdivs: subDivs,
        parent: complex
      }, colorer, mode, transforms, polyComplexity, material);
      residuesGroup._component = component;
      self2.add(residuesGroup);
    });
  }
  getSubset(mask, innerOnly) {
    const totalSubset = [];
    const {
      children
    } = this;
    let meshIdx = 0;
    for (let i2 = 0, n = children.length; i2 < n; ++i2) {
      if (children[i2].getSubset) {
        const chSubset = children[i2].getSubset(mask, innerOnly);
        for (let j = 0, m2 = chSubset.length; j < m2; ++j) {
          const subsetEl = chSubset[j];
          subsetEl._component = children[i2]._component;
          totalSubset[meshIdx++] = subsetEl;
        }
      }
    }
    return totalSubset;
  }
};
var processors_SubseqsProcessor = SubseqsProcessor;
var BondsProcessor = class extends gfx_RCGroup {
  constructor(BondsGroup2, geoParams, complex, colorer, mode, polyComplexity, mask, material) {
    super();
    const self2 = this;
    this._complex = complex;
    const bonds = complex.getBonds();
    const transforms = complex.getTransforms();
    complex.forEachComponent((component) => {
      const bondsIdc = [];
      let bondsCount = 0;
      component.forEachBond((bond) => {
        const atom1 = bond._left;
        const atom2 = bond._right;
        if (!(atom1.mask & mask) || !(atom2.mask & mask)) {
          return;
        }
        bondsIdc[bondsCount++] = bond._index;
      });
      if (bondsCount === 0) {
        return;
      }
      const bondsGroup = new BondsGroup2(geoParams, {
        bonds,
        chunks: bondsIdc,
        parent: complex
      }, colorer, mode, transforms, polyComplexity, material);
      bondsGroup._component = component;
      self2.add(bondsGroup);
    });
  }
  getSubset(mask, innerOnly) {
    const totalSubset = [];
    const {
      children
    } = this;
    let meshIdx = 0;
    for (let i2 = 0, n = children.length; i2 < n; ++i2) {
      if (children[i2].getSubset) {
        const chSubset = children[i2].getSubset(mask, innerOnly);
        for (let j = 0, m2 = chSubset.length; j < m2; ++j) {
          const subsetEl = chSubset[j];
          subsetEl._component = children[i2]._component;
          totalSubset[meshIdx++] = subsetEl;
        }
      }
    }
    return totalSubset;
  }
};
var processors_BondsProcessor = BondsProcessor;
var AromaticProcessor = class extends gfx_RCGroup {
  constructor(AromaticGroup2, geoParams, complex, colorer, mode, polyComplexity, mask, material) {
    super();
    const self2 = this;
    this._complex = complex;
    const atoms = complex.getAtoms();
    const transforms = complex.getTransforms();
    if (!mode.showAromaticLoops()) {
      return;
    }
    complex.forEachComponent((component) => {
      const atomsIdc = [];
      let chunksCount = 0;
      const cycles = [];
      let cycleIdx = 0;
      component.forEachCycle((cycle) => {
        const cycAtoms = cycle.atoms;
        let perCycle = 0;
        for (let i2 = 0, n = cycAtoms.length; i2 < n; ++i2) {
          if ((cycAtoms[i2].mask & mask) !== 0) {
            ++perCycle;
            atomsIdc[chunksCount++] = cycAtoms[i2].index;
          }
        }
        if (perCycle > 0) {
          cycles[cycleIdx++] = cycle;
        }
      });
      const atomsGroup = new AromaticGroup2(geoParams, {
        cycles,
        atoms,
        chunks: atomsIdc,
        parent: complex
      }, colorer, mode, transforms, polyComplexity, material);
      atomsGroup._component = component;
      self2.add(atomsGroup);
    });
  }
  getSubset(mask, innerOnly) {
    const totalSubset = [];
    const {
      children
    } = this;
    let meshIdx = 0;
    for (let i2 = 0, n = children.length; i2 < n; ++i2) {
      if (children[i2].getSubset) {
        const chSubset = children[i2].getSubset(mask, innerOnly);
        for (let j = 0, m2 = chSubset.length; j < m2; ++j) {
          const subsetEl = chSubset[j];
          subsetEl._component = children[i2]._component;
          totalSubset[meshIdx++] = subsetEl;
        }
      }
    }
    return totalSubset;
  }
};
var processors_AromaticProcessor = AromaticProcessor;
var processors = {
  Atoms: processors_AtomsProcessor,
  OrphanAtoms: processors_OrphanAtomsProcessor,
  Residues: processors_ResiduesProcessor,
  Nucleic: processors_NucleicProcessor,
  Subseqs: processors_SubseqsProcessor,
  Bonds: processors_BondsProcessor,
  Aromatic: processors_AromaticProcessor
};
function _bakeGroup(triplet, Processor, Group2) {
  return function(complex, colorer, mode, polyComplexity, mask, material) {
    return new Processor(Group2, triplet, complex, colorer, mode, polyComplexity, mask, material);
  };
}
var GroupsFactory = class {
  static AtomsSpheres(caps, settings2) {
    const gfxTriplet = meshes_MeshCreator.createSpheres(caps, settings2);
    return _bakeGroup(gfxTriplet, processors.Atoms, groups.AtomsSphereGroup);
  }
  static OrphanedAtomsCrosses(caps, settings2, renderParams) {
    const gfxTriplet = meshes_MeshCreator.createCrosses(caps, settings2, renderParams);
    return _bakeGroup(gfxTriplet, processors.OrphanAtoms, groups.AtomsSphereGroup);
  }
  static BondsCylinders(caps, settings2) {
    const gfxTriplet = meshes_MeshCreator.create2CCylinders(caps, settings2);
    return _bakeGroup(gfxTriplet, processors.Bonds, groups.BondsCylinderGroup);
  }
  static BondsLines(caps, settings2, renderParams) {
    const gfxTriplet = meshes_MeshCreator.create2CLines(caps, settings2, renderParams);
    return _bakeGroup(gfxTriplet, processors.Bonds, groups.BondsLinesGroup);
  }
  static CartoonChains(caps, settings2) {
    const gfxTriplet = meshes_MeshCreator.createExtrudedChains(caps, settings2);
    return _bakeGroup(gfxTriplet, processors.Subseqs, groups.ResiduesSubseqGroup);
  }
  static TraceChains(caps, settings2) {
    const gfxTriplet = meshes_MeshCreator.create2CClosedCylinders(caps, settings2);
    return _bakeGroup(gfxTriplet, processors.Subseqs, groups.ResiduesTraceGroup);
  }
  static NucleicSpheres(caps, settings2) {
    const gfxTriplet = meshes_MeshCreator.createSpheres(caps, settings2);
    return _bakeGroup(gfxTriplet, processors.Nucleic, groups.NucleicSpheresGroup);
  }
  static NucleicCylinders(caps, settings2) {
    const gfxTriplet = meshes_MeshCreator.create2CCylinders(caps, settings2);
    return _bakeGroup(gfxTriplet, processors.Nucleic, groups.NucleicCylindersGroup);
  }
  static ALoopsTorus(caps, settings2) {
    const gfxTriplet = meshes_MeshCreator.createExtrudedChains(caps, settings2);
    return _bakeGroup(gfxTriplet, processors.Aromatic, groups.AromaticTorusGroup);
  }
  static ALoopsLines(caps, settings2, renderParams) {
    const gfxTriplet = meshes_MeshCreator.createChunkedLines(caps, settings2, renderParams);
    return _bakeGroup(gfxTriplet, processors.Aromatic, groups.AromaticLinesGroup);
  }
  static QuickSurfGeo(caps, settings2, renderParams) {
    const gfxTriplet = meshes_MeshCreator.createQuickSurface(caps, settings2, renderParams);
    return _bakeGroup(gfxTriplet, processors.Atoms, groups.AtomsSurfaceGroup);
  }
  static ContactSurfaceGeo(caps, settings2, renderParams) {
    const gfxTriplet = meshes_MeshCreator.createContactSurface(caps, settings2, renderParams);
    return _bakeGroup(gfxTriplet, processors.Atoms, groups.AtomsSurfaceGroup);
  }
  static SASSESSurfaceGeo(caps, settings2, renderParams) {
    const gfxTriplet = meshes_MeshCreator.createSASSES(caps, settings2, renderParams);
    return _bakeGroup(gfxTriplet, processors.Atoms, groups.AtomsSASSESGroupStub);
  }
  static TextLabelsGeo(caps, settings2) {
    const gfxTriplet = meshes_MeshCreator.createLabels(caps, settings2);
    return _bakeGroup(gfxTriplet, processors.Atoms, groups.AtomsTextGroup);
  }
};
var groups_GroupsFactory = GroupsFactory;
var Mode = class _Mode {
  constructor(opts) {
    if (this.constructor === _Mode) {
      throw new Error("Can not instantiate abstract class!");
    }
    this.opts = external_module_lodash_commonjs_lodash_commonjs2_lodash_amd_lodash_root_namespaceObject["default"].merge(utils.deriveDeep(this.settings.now.modes[this.id], true), opts);
  }
  /**
   * Get mode identification, probably with options.
   * @returns {string|Array} Mode identifier string ({@link Mode#id}) or two-element array containing both mode
   *   identifier and options ({@link Mode#opts}).
   * Options are returned if they were changed during or after the mode creation.
   */
  identify() {
    const diff = utils.objectsDiff(this.opts, this.settings.now.modes[this.id]);
    if (!external_module_lodash_commonjs_lodash_commonjs2_lodash_amd_lodash_root_namespaceObject["default"].isEmpty(diff)) {
      return [this.id, diff];
    }
    return this.id;
  }
  buildGeometry(complex, colorer, mask, material) {
    const polyComplexity = this.opts.polyComplexity ? this.opts.polyComplexity[this.settings.now.resolution] : 0;
    const groupList = this.depGroups;
    const groupCount = groupList.length;
    const group = new gfxutils.RCGroup();
    const self2 = this;
    for (let i2 = 0; i2 < groupCount; ++i2) {
      let currGroup = groupList[i2];
      let renderParams = {};
      if (external_module_lodash_commonjs_lodash_commonjs2_lodash_amd_lodash_root_namespaceObject["default"].isArray(currGroup)) {
        renderParams = currGroup[1].call(this);
        [currGroup] = currGroup;
      }
      const Group2 = groups_GroupsFactory[currGroup](null, this.settings, renderParams);
      const newGroup = new Group2(complex, colorer, self2, polyComplexity, mask, material);
      if (newGroup.children.length > 0) {
        group.add(newGroup);
      }
    }
    return group;
  }
};
utils_makeContextDependent(Mode.prototype);
Mode.prototype.id = "__";
Mode.prototype.depGroups = [];
var modes_Mode = Mode;
function getRenderParams() {
  return {
    lineWidth: this.opts.lineWidth
  };
}
var LinesMode = class extends modes_Mode {
  constructor(opts) {
    super(opts);
    this.depGroups = this.depGroups.slice(0);
    const groups2 = this.depGroups;
    for (let i2 = 0, n = groups2.length; i2 < n; ++i2) {
      groups2[i2] = [groups2[i2], getRenderParams];
    }
  }
  drawMultiorderBonds() {
    return this.opts.multibond;
  }
  calcAtomRadius() {
    return this.opts.atom;
  }
  getAromaticOffset() {
    return this.opts.offsarom;
  }
  getAromaticArcChunks() {
    return this.opts.chunkarom;
  }
  showAromaticLoops() {
    return this.opts.showarom;
  }
};
__publicField(LinesMode, "id", "LN");
LinesMode.prototype.id = "LN";
LinesMode.prototype.name = "Lines";
LinesMode.prototype.shortName = "Lines";
LinesMode.prototype.depGroups = ["ALoopsLines", "BondsLines", "OrphanedAtomsCrosses"];
var modes_LinesMode = LinesMode;
var LicoriceMode = class extends modes_Mode {
  calcAtomRadius(_atom) {
    return this.opts.bond;
  }
  calcStickRadius() {
    return this.opts.bond;
  }
  calcSpaceFraction() {
    return this.opts.space;
  }
  getAromRadius() {
    return this.opts.aromrad;
  }
  showAromaticLoops() {
    return this.opts.showarom;
  }
  drawMultiorderBonds() {
    return this.opts.multibond;
  }
};
__publicField(LicoriceMode, "id", "LC");
LicoriceMode.prototype.id = "LC";
LicoriceMode.prototype.name = "Licorice";
LicoriceMode.prototype.shortName = "Licorice";
LicoriceMode.prototype.depGroups = ["AtomsSpheres", "BondsCylinders", "ALoopsTorus"];
var modes_LicoriceMode = LicoriceMode;
var BallsAndSticksMode = class extends modes_Mode {
  calcAtomRadius(atom) {
    return atom.element.radius * this.opts.atom;
  }
  calcStickRadius() {
    return this.opts.bond;
  }
  getAromRadius() {
    return this.opts.aromrad;
  }
  showAromaticLoops() {
    return this.opts.showarom;
  }
  calcSpaceFraction() {
    return this.opts.space;
  }
  drawMultiorderBonds() {
    return this.opts.multibond;
  }
};
__publicField(BallsAndSticksMode, "id", "BS");
BallsAndSticksMode.prototype.id = "BS";
BallsAndSticksMode.prototype.name = "Balls and Sticks";
BallsAndSticksMode.prototype.shortName = "Balls";
BallsAndSticksMode.prototype.depGroups = ["AtomsSpheres", "BondsCylinders", "ALoopsTorus"];
var modes_BallsAndSticksMode = BallsAndSticksMode;
var VanDerWaalsMode = class extends modes_Mode {
  calcAtomRadius(atom) {
    return atom.element.radius;
  }
};
__publicField(VanDerWaalsMode, "id", "VW");
VanDerWaalsMode.prototype.id = "VW";
VanDerWaalsMode.prototype.name = "Van der Waals";
VanDerWaalsMode.prototype.shortName = "VDW";
VanDerWaalsMode.prototype.depGroups = ["AtomsSpheres"];
var modes_VanDerWaalsMode = VanDerWaalsMode;
var TraceMode = class extends modes_Mode {
  calcStickRadius() {
    return this.opts.radius;
  }
};
__publicField(TraceMode, "id", "TR");
TraceMode.prototype.id = "TR";
TraceMode.prototype.name = "Trace";
TraceMode.prototype.shortName = "Trace";
TraceMode.prototype.depGroups = ["TraceChains"];
var modes_TraceMode = TraceMode;
var TubeMode = class extends modes_Mode {
  getResidueRadius(_residue) {
    return this.TUBE_RADIUS;
  }
  getHeightSegmentsRatio() {
    return this.opts.heightSegmentsRatio;
  }
  getTension() {
    return this.opts.tension;
  }
  buildGeometry(complex, colorer, mask, material) {
    const rad = this.opts.radius;
    this.TUBE_RADIUS = new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Vector2(rad, rad);
    return modes_Mode.prototype.buildGeometry.call(this, complex, colorer, mask, material);
  }
};
__publicField(TubeMode, "id", "TU");
TubeMode.prototype.id = "TU";
TubeMode.prototype.name = "Tube";
TubeMode.prototype.shortName = "Tube";
TubeMode.prototype.depGroups = ["CartoonChains"];
var modes_TubeMode = TubeMode;
var CartoonMode = class extends modes_Mode {
  constructor(opts) {
    super(opts);
    this.secCache = {};
  }
  getResidueStartRadius(residue) {
    const second = residue.getSecondary();
    if (!second || !second.generic) {
      return this.TUBE_RADIUS;
    }
    const secOpts = this.secCache[second.generic];
    if (!secOpts) {
      return this.TUBE_RADIUS;
    }
    if (second.term === residue) {
      return secOpts.start;
    }
    return secOpts.center;
  }
  getResidueEndRadius(residue) {
    const second = residue.getSecondary();
    if (second === null || !second.generic) {
      return this.TUBE_RADIUS;
    }
    const secOpts = this.secCache[second.generic];
    if (!secOpts) {
      return this.TUBE_RADIUS;
    }
    if (second.term === residue) {
      return this.ARROW_END;
    }
    return secOpts.center;
  }
  getResidueRadius(residue, val) {
    const startRad = this.getResidueStartRadius(residue);
    if (val === 0) {
      return startRad;
    }
    const endRad = this.getResidueEndRadius(residue);
    if (val === 2) {
      return endRad;
    }
    return startRad.clone().lerp(endRad, val / 2);
  }
  calcStickRadius(_res) {
    return this.opts.radius;
  }
  getHeightSegmentsRatio() {
    return this.opts.heightSegmentsRatio;
  }
  getTension() {
    return this.opts.tension;
  }
  buildGeometry(complex, colorer, mask, material) {
    const tubeRad = this.opts.radius;
    const secHeight = this.opts.depth;
    this.TUBE_RADIUS = new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Vector2(tubeRad, tubeRad);
    this.ARROW_END = new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Vector2(secHeight, tubeRad);
    const secCache = {};
    const secData = this.opts.ss;
    for (const prop in secData) {
      secCache[prop] = {
        center: new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Vector2(secHeight, secData[prop].width),
        start: new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Vector2(secHeight, secData[prop].arrow)
      };
    }
    this.secCache = secCache;
    return modes_Mode.prototype.buildGeometry.call(this, complex, colorer, mask, material);
  }
};
__publicField(CartoonMode, "id", "CA");
CartoonMode.prototype.id = "CA";
CartoonMode.prototype.name = "Cartoon";
CartoonMode.prototype.shortName = "Cartoon";
CartoonMode.prototype.depGroups = ["CartoonChains", "NucleicSpheres", "NucleicCylinders"];
var modes_CartoonMode = CartoonMode;
var {
  selectors: SurfaceMode_selectors
} = chem;
function SurfaceMode_getRenderParams() {
  return {
    wireframe: this.opts.wireframe,
    zClip: this.opts.zClip
  };
}
var SurfaceMode = class extends modes_Mode {
  constructor(opts) {
    super(opts);
    this.depGroups = this.depGroups.slice(0);
    const surfaces = this.surfaceNames;
    const groups2 = this.depGroups;
    for (let i2 = 0, n = surfaces.length; i2 < n; ++i2) {
      groups2[groups2.length] = [surfaces[i2], SurfaceMode_getRenderParams];
    }
  }
  calcAtomRadius(atom) {
    return atom.element.radius;
  }
  getVisibilitySelector() {
    let visibilitySelector = null;
    if (this.opts.subset !== "") {
      const res = SurfaceMode_selectors.parse(this.opts.subset);
      if (!res.error) {
        visibilitySelector = res.selector;
      }
    }
    return visibilitySelector;
  }
};
SurfaceMode.prototype.isSurface = true;
SurfaceMode.prototype.surfaceNames = [];
var modes_SurfaceMode = SurfaceMode;
var QuickSurfaceMode = class extends modes_SurfaceMode {
  getSurfaceOpts() {
    return {
      useBeads: false,
      isoValue: this.opts.isoValue,
      gaussLim: this.opts.gaussLim[this.settings.now.resolution],
      radScale: this.opts.scale,
      gridSpacing: this.opts.gridSpacing[this.settings.now.resolution],
      zClip: this.opts.zClip,
      visibilitySelector: this.getVisibilitySelector()
    };
  }
};
__publicField(QuickSurfaceMode, "id", "QS");
QuickSurfaceMode.prototype.id = "QS";
QuickSurfaceMode.prototype.name = "Quick Surface";
QuickSurfaceMode.prototype.shortName = "Quick Surf";
QuickSurfaceMode.prototype.surfaceNames = ["QuickSurfGeo"];
var modes_QuickSurfaceMode = QuickSurfaceMode;
var IsoSurfaceMode = class extends modes_SurfaceMode {
  constructor(excludeProbe, opts) {
    super(opts);
    this._excludeProbe = excludeProbe;
  }
  calcAtomRadius(atom) {
    return atom.element.radius;
  }
  getSurfaceOpts() {
    return {
      gridSpacing: this.opts.polyComplexity[this.settings.now.resolution],
      radScale: this._radScale,
      zClip: this.opts.zClip,
      visibilitySelector: this.getVisibilitySelector(),
      probeRadius: this.opts.probeRadius,
      excludeProbe: this._excludeProbe
    };
  }
};
IsoSurfaceMode.prototype.id = "SU";
IsoSurfaceMode.prototype.name = "Surface";
IsoSurfaceMode.prototype.shortName = "Surface";
IsoSurfaceMode.prototype.surfaceNames = ["SASSESSurfaceGeo"];
IsoSurfaceMode.prototype._radScale = 1;
IsoSurfaceMode.prototype._excludeProbe = false;
var modes_IsoSurfaceMode = IsoSurfaceMode;
var IsoSurfaceSASMode = class extends modes_IsoSurfaceMode {
  constructor(opts) {
    super(false, opts);
  }
};
__publicField(IsoSurfaceSASMode, "id", "SA");
IsoSurfaceSASMode.prototype.id = "SA";
IsoSurfaceSASMode.prototype.name = "Solvent Accessible Surface";
IsoSurfaceSASMode.prototype.shortName = "SAS";
var modes_IsoSurfaceSASMode = IsoSurfaceSASMode;
var IsoSurfaceSESMode = class extends modes_IsoSurfaceMode {
  constructor(opts) {
    super(true, opts);
  }
};
__publicField(IsoSurfaceSESMode, "id", "SE");
IsoSurfaceSESMode.prototype.id = "SE";
IsoSurfaceSESMode.prototype.name = "Solvent Excluded Surface";
IsoSurfaceSESMode.prototype.shortName = "SES";
var modes_IsoSurfaceSESMode = IsoSurfaceSESMode;
var ContactSurfaceMode = class extends modes_SurfaceMode {
  getSurfaceOpts() {
    return {
      probeRadius: this.opts.probeRadius,
      radScale: this.opts.polyComplexity[this.settings.now.resolution],
      scaleFactor: this.opts.polyComplexity[this.settings.now.resolution],
      gridSpacing: 1 / this.opts.polyComplexity[this.settings.now.resolution],
      isoValue: this.opts.isoValue,
      probePositions: this.opts.probePositions,
      zClip: this.opts.zClip,
      visibilitySelector: this.getVisibilitySelector()
    };
  }
};
__publicField(ContactSurfaceMode, "id", "CS");
ContactSurfaceMode.prototype.id = "CS";
ContactSurfaceMode.prototype.name = "Contact Surface";
ContactSurfaceMode.prototype.shortName = "Contact Surf";
ContactSurfaceMode.prototype.isSurface = true;
ContactSurfaceMode.prototype.surfaceNames = ["ContactSurfaceGeo"];
var modes_ContactSurfaceMode = ContactSurfaceMode;
var TextMode = class extends modes_Mode {
  getTemplateOptions() {
    return this.opts.template;
  }
  getLabelOpts() {
    return external_module_lodash_commonjs_lodash_commonjs2_lodash_amd_lodash_root_namespaceObject["default"].merge(this.opts, {
      colors: true,
      adjustColor: true,
      transparent: true
    });
  }
};
__publicField(TextMode, "id", "TX");
TextMode.prototype.id = "TX";
TextMode.prototype.name = "Text mode";
TextMode.prototype.shortName = "Text";
TextMode.prototype.depGroups = ["TextLabelsGeo"];
var modes_TextMode = TextMode;
var modes = new utils_EntityList([modes_LinesMode, modes_LicoriceMode, modes_BallsAndSticksMode, modes_VanDerWaalsMode, modes_TraceMode, modes_TubeMode, modes_CartoonMode, modes_QuickSurfaceMode, modes_IsoSurfaceSASMode, modes_IsoSurfaceSESMode, modes_ContactSurfaceMode, modes_TextMode]);
var gfx_modes = modes;
function clamp2(x3, a2, b2) {
  return x3 <= b2 ? x3 < 0 ? 0 : x3 : b2;
}
function lerpColor(c1, c2, alpha) {
  const beta = 1 - alpha;
  const r1 = c1 >> 16 & 255;
  const g1 = c1 >> 8 & 255;
  const b1 = c1 & 255;
  const r2 = c2 >> 16 & 255;
  const g2 = c2 >> 8 & 255;
  const b2 = c2 & 255;
  const r3 = beta * r1 + alpha * r2;
  const g3 = beta * g1 + alpha * g2;
  const b3 = beta * b1 + alpha * b2;
  return r3 << 16 | g3 << 8 | b3;
}
var Palette = class {
  constructor(name, id2) {
    this.name = name || "Custom";
    this.id = id2 || "CP";
  }
  getElementColor(name) {
    let asIs = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
    const color = this.elementColors[name];
    return color === void 0 && !asIs ? this.defaultElementColor : color;
  }
  getResidueColor(name) {
    let asIs = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
    const color = this.residueColors[name];
    return color === void 0 && !asIs ? this.defaultResidueColor : color;
  }
  getChainColor(name) {
    let chain = name.charCodeAt(0);
    chain = ((chain < 0 ? 0 : chain >= 256 ? chain - 256 : chain) & 31) % this.chainColors.length;
    return this.chainColors[chain];
  }
  getSecondaryColor(type) {
    let asIs = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
    const color = this.secondaryColors[type];
    return color === void 0 && !asIs ? this.defaultSecondaryColor : color;
  }
  getSequentialColor(index) {
    const {
      colors
    } = this;
    const len = colors.length;
    return index < 0 ? colors[index % len + len] : colors[index % len];
  }
  getGradientColor(value, gradientName) {
    const gradient = this.gradients[gradientName];
    if (!gradient) {
      return this.defaultNamedColor;
    }
    const count = gradient.length;
    const index = value * (count - 1);
    let left = Math.floor(index);
    const right = clamp2(left + 1, 0, count - 1);
    left = clamp2(left, 0, count - 1);
    return lerpColor(gradient[left], gradient[right], index - left);
  }
  getNamedColor(name) {
    let asIs = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
    const color = this.namedColors[name];
    return color === void 0 && !asIs ? this.defaultNamedColor : color;
  }
};
external_module_lodash_commonjs_lodash_commonjs2_lodash_amd_lodash_root_namespaceObject["default"].assign(Palette.prototype, {
  colors: [16777215, 16711680, 65280, 255, 8421504],
  minRangeColor: 0,
  midRangeColor: 8355711,
  maxRangeColor: 16777215,
  defaultElementColor: 16777215,
  elementColors: {},
  defaultResidueColor: 16777215,
  residueColors: {},
  chainColors: [16777215],
  defaultSecondaryColor: 16777215,
  secondaryColors: {},
  defaultGradientColor: 0,
  defaultNamedColor: 16777215,
  namedColorsArray: [
    /* eslint-disable no-multi-spaces */
    ["indianred", 13458524],
    ["lightcoral", 15761536],
    ["salmon", 16416882],
    ["darksalmon", 15308410],
    ["lightsalmon", 16752762],
    ["crimson", 14423100],
    ["red", 16711680],
    ["firebrick", 11674146],
    ["darkred", 9109504],
    ["pink", 16761035],
    ["lightpink", 16758465],
    ["hotpink", 16738740],
    ["deeppink", 16716947],
    ["mediumvioletred", 13047173],
    ["palevioletred", 14381203],
    ["coral", 16744272],
    ["tomato", 16737095],
    ["orangered", 16729344],
    ["darkorange", 16747520],
    ["orange", 16753920],
    ["gold", 16766720],
    ["yellow", 16776960],
    ["lightyellow", 16777184],
    ["lemonchiffon", 16775885],
    ["lightgoldenrodyellow", 16448210],
    ["papayawhip", 16773077],
    ["moccasin", 16770229],
    ["peachpuff", 16767673],
    ["palegoldenrod", 15657130],
    ["khaki", 15787660],
    ["darkkhaki", 12433259],
    ["lavender", 15132410],
    ["thistle", 14204888],
    ["plum", 14524637],
    ["violet", 15631086],
    ["orchid", 14315734],
    ["fuchsia", 16711935],
    ["magenta", 16711935],
    ["mediumorchid", 12211667],
    ["mediumpurple", 9662683],
    ["rebeccapurple", 6697881],
    ["blueviolet", 9055202],
    ["darkviolet", 9699539],
    ["darkorchid", 10040012],
    ["darkmagenta", 9109643],
    ["purple", 8388736],
    ["indigo", 4915330],
    ["slateblue", 6970061],
    ["mediumslateblue", 8087790],
    ["darkslateblue", 4734347],
    ["greenyellow", 11403055],
    ["chartreuse", 8388352],
    ["lawngreen", 8190976],
    ["lime", 65280],
    ["limegreen", 3329330],
    ["palegreen", 10025880],
    ["lightgreen", 9498256],
    ["mediumspringgreen", 64154],
    ["springgreen", 65407],
    ["mediumseagreen", 3978097],
    ["seagreen", 3050327],
    ["forestgreen", 2263842],
    ["green", 32768],
    ["darkgreen", 25600],
    ["yellowgreen", 10145074],
    ["olivedrab", 7048739],
    ["olive", 8421376],
    ["darkolivegreen", 5597999],
    ["mediumaquamarine", 6737322],
    ["darkseagreen", 9419919],
    ["lightseagreen", 2142890],
    ["darkcyan", 35723],
    ["teal", 32896],
    ["aqua", 65535],
    ["cyan", 65535],
    ["lightcyan", 14745599],
    ["paleturquoise", 11529966],
    ["aquamarine", 8388564],
    ["turquoise", 4251856],
    ["mediumturquoise", 4772300],
    ["darkturquoise", 52945],
    ["cadetblue", 6266528],
    ["steelblue", 4620980],
    ["lightsteelblue", 11584734],
    ["powderblue", 11591910],
    ["lightblue", 11393254],
    ["skyblue", 8900331],
    ["lightskyblue", 8900346],
    ["deepskyblue", 49151],
    ["dodgerblue", 2003199],
    ["cornflowerblue", 6591981],
    ["royalblue", 4286945],
    ["blue", 255],
    ["mediumblue", 205],
    ["darkblue", 139],
    ["navy", 128],
    ["midnightblue", 1644912],
    ["cornsilk", 16775388],
    ["blanchedalmond", 16772045],
    ["bisque", 16770244],
    ["navajowhite", 16768685],
    ["wheat", 16113331],
    ["burlywood", 14596231],
    ["tan", 13808780],
    ["rosybrown", 12357519],
    ["sandybrown", 16032864],
    ["goldenrod", 14329120],
    ["darkgoldenrod", 12092939],
    ["peru", 13468991],
    ["chocolate", 13789470],
    ["saddlebrown", 9127187],
    ["sienna", 10506797],
    ["brown", 10824234],
    ["maroon", 8388608],
    ["white", 16777215],
    ["snow", 16775930],
    ["honeydew", 15794160],
    ["mintcream", 16121850],
    ["azure", 15794175],
    ["aliceblue", 15792383],
    ["ghostwhite", 16316671],
    ["whitesmoke", 16119285],
    ["seashell", 16774638],
    ["beige", 16119260],
    ["oldlace", 16643558],
    ["floralwhite", 16775920],
    ["ivory", 16777200],
    ["antiquewhite", 16444375],
    ["linen", 16445670],
    ["lavenderblush", 16773365],
    ["mistyrose", 16770273],
    ["gainsboro", 14474460],
    ["lightgray", 13882323],
    ["silver", 12632256],
    ["darkgray", 11119017],
    ["gray", 8421504],
    ["dimgray", 6908265],
    ["lightslategray", 7833753],
    ["slategray", 7372944],
    ["darkslategray", 3100495],
    ["black", 0]
    /* eslint-enable no-multi-spaces */
  ],
  namedColors: {},
  /* eslint-enable no-magic-numbers */
  gradients: {
    rainbow: [
      255,
      // blue
      65535,
      // cyan
      65280,
      // green
      16776960,
      // yellow
      16711680
      // red
    ],
    temp: [
      255,
      // blue
      32767,
      // light-blue
      16777215,
      // white
      16744192,
      // orange
      16711680
      // red
    ],
    hot: [
      16777215,
      // white
      16744192,
      // orange
      16711680
      // red
    ],
    cold: [
      16777215,
      // white
      32767,
      // light-blue
      255
      // blue
    ],
    "blue-red": [
      255,
      // blue
      16777215,
      // white
      16711680
      // red
    ],
    reds: [
      16777215,
      // white
      16711680
      // red
    ],
    blues: [
      16777215,
      // white
      255
      // blue
    ]
  }
});
var {
  namedColorsArray,
  namedColors
} = Palette.prototype;
for (let i2 = 0, {
  length
} = namedColorsArray; i2 < length; ++i2) {
  const [name, value] = namedColorsArray[i2];
  namedColors[name] = value;
}
var palettes_Palette = Palette;
var palette = new palettes_Palette("CPK", "CP");
palette.elementColors = {
  /* eslint-disable no-magic-numbers */
  H: 16777215,
  C: 2105376,
  N: 2121983,
  O: 15605776,
  F: 65280,
  P: 8397055,
  S: 16776960,
  CL: 47872,
  FE: 13684944,
  CO: 13684944,
  NI: 13684944,
  CU: 13684944,
  BR: 34816,
  I: 21760
  /* eslint-enable no-magic-numbers */
};
var cpkPalette = palette;
var jmolPalette_palette = new palettes_Palette("Jmol", "JM");
jmolPalette_palette.colors = [
  /* eslint-disable no-magic-numbers */
  255,
  // blue
  22015,
  //
  44031,
  //
  65535,
  // cyan
  65451,
  //
  65365,
  //
  65280,
  // green
  5635840,
  //
  11271936,
  //
  16776960,
  // yellow
  16755456,
  //
  16733440,
  //
  16711680,
  // red
  16711765,
  //
  16711851,
  //
  16711935,
  // magenta
  11206911,
  //
  5570815
  //
  /* eslint-enable no-magic-numbers */
];
jmolPalette_palette.elementColors = {
  /* eslint-disable no-magic-numbers */
  H: 16777215,
  D: 16777152,
  T: 16777120,
  HE: 14286847,
  LI: 13402367,
  BE: 12779264,
  B: 16758197,
  C: 9474192,
  N: 3166456,
  O: 16715021,
  F: 9494608,
  NE: 11789301,
  NA: 11230450,
  MG: 9109248,
  AL: 12560038,
  SI: 1578e4,
  P: 16744448,
  S: 16777008,
  CL: 2093087,
  AR: 8442339,
  K: 9388244,
  CA: 4062976,
  SC: 15132390,
  TI: 12567239,
  V: 10921643,
  CR: 9083335,
  MN: 10255047,
  FE: 14706227,
  CO: 15765664,
  NI: 5296208,
  CU: 13140019,
  ZN: 8224944,
  GA: 12750735,
  GE: 6721423,
  AS: 12419299,
  SE: 16752896,
  BR: 10889513,
  KR: 6076625,
  RB: 7351984,
  SR: 65280,
  Y: 9764863,
  ZR: 9756896,
  NB: 7586505,
  MO: 5551541,
  TC: 3907230,
  RU: 2396047,
  RH: 687500,
  PD: 27013,
  AG: 12632256,
  CD: 16767375,
  IN: 10909043,
  SN: 6717568,
  SB: 10380213,
  TE: 13924864,
  I: 9699476,
  XE: 4366e3,
  CS: 5707663,
  BA: 51456,
  LA: 7394559,
  CE: 16777159,
  PR: 14286791,
  ND: 13107143,
  PM: 10747847,
  SM: 9437127,
  EU: 6422471,
  GD: 4587463,
  TB: 3211207,
  DY: 2097095,
  HO: 65436,
  ER: 58997,
  TM: 54354,
  YB: 48952,
  LU: 43812,
  HF: 5096191,
  TA: 5089023,
  W: 2200790,
  RE: 2522539,
  OS: 2516630,
  IR: 1528967,
  PT: 13684960,
  AU: 16765219,
  HG: 12105936,
  TL: 10900557,
  PB: 5724513,
  BI: 10375093,
  PO: 11230208,
  AT: 7688005,
  RN: 4358806,
  FR: 4325478,
  RA: 32e3,
  AC: 7384058,
  TH: 47871,
  PA: 41471,
  U: 36863,
  NP: 33023,
  PU: 27647,
  AM: 5528818,
  CM: 7888099,
  BK: 9064419,
  CF: 10565332,
  ES: 11739092,
  FM: 11739066,
  MD: 11734438,
  NO: 12389767,
  LR: 13041766,
  RF: 13369433,
  DB: 13697103,
  SG: 14221381,
  BH: 14680120,
  HS: 15073326,
  MT: 15400998
  /* eslint-enable no-magic-numbers */
};
jmolPalette_palette.defaultResidueColor = 12492910;
jmolPalette_palette.residueColors = {
  /* eslint-disable no-magic-numbers */
  ALA: 13158600,
  ARG: 1334015,
  ASN: 56540,
  ASP: 15075850,
  CYS: 15132160,
  GLN: 56540,
  GLU: 15075850,
  GLY: 15461355,
  HIS: 8553170,
  ILE: 1016335,
  LEU: 1016335,
  LYS: 1334015,
  MET: 15132160,
  PHE: 3289770,
  PRO: 14456450,
  SER: 16422400,
  THR: 16422400,
  TRP: 11819700,
  TYR: 3289770,
  VAL: 1016335,
  A: 10526975,
  C: 16747595,
  G: 16740464,
  I: 8454143,
  T: 10551200,
  U: 16744576,
  DA: 10526975,
  DC: 16747595,
  DG: 16740464,
  DI: 8454143,
  DT: 10551200,
  DU: 16744576,
  "+A": 10526975,
  "+C": 16747595,
  "+G": 16740464,
  "+I": 8454143,
  "+T": 10551200,
  "+U": 16744576
  /* eslint-enable no-magic-numbers */
};
jmolPalette_palette.chainColors = [
  // ' '->0 'A'->1, 'B'->2
  4294967295,
  // ' ' & '0' white
  //
  4290826495,
  // skyblue
  4289789872,
  // pastel green
  4294951112,
  // pink
  4294967168,
  // pastel yellow
  4294951167,
  // pastel magenta
  4289786096,
  // pastel cyan
  4294955120,
  // pastel gold
  4293951616,
  // lightcoral
  4294303411,
  // wheat
  4278239231,
  // deepskyblue
  4291648604,
  // indianred
  4284927402,
  // mediumaquamarine
  4288335154,
  // yellowgreen
  4293821166,
  // violet
  4278243025,
  // darkturquoise
  4278255487,
  // springgreen
  4282168177,
  // mediumseagreen
  4278190219,
  // darkblue
  4290623339,
  // darkkhaki
  4278215680,
  // darkgreen
  4286578688,
  // maroon
  4286611456,
  // olive
  4286578816,
  // purple
  4278222976,
  // teal
  4290283019,
  // darkgoldenrod
  4289864226
  // firebrick
];
var jmolPalette_StructuralElementType = chem_StructuralElement.Type;
jmolPalette_palette.secondaryColors = {
  [jmolPalette_StructuralElementType.HELIX_ALPHA]: 16711808,
  [jmolPalette_StructuralElementType.HELIX_PI]: 6291584,
  [jmolPalette_StructuralElementType.HELIX_310]: 10485888,
  [jmolPalette_StructuralElementType.STRAND]: 16762880,
  [jmolPalette_StructuralElementType.TURN]: 6324479,
  dna: 11403518,
  rna: 16580962
};
var jmolPalette = jmolPalette_palette;
var vmdPalette_palette = new palettes_Palette("VMD", "VM");
vmdPalette_palette.colors = [
  /* eslint-disable no-magic-numbers */
  255,
  // blue
  16711680,
  // red
  6316128,
  // gray
  16744448,
  // orange
  16776960,
  // yellow
  8421427,
  // tan
  10066329,
  // silver
  65280,
  // green
  16777215,
  // white
  16751001,
  // pink
  4243648,
  // cyan
  10879142,
  // purple
  8447590,
  // lime
  15099571,
  // mauve
  8408320,
  // ochre
  8421568
  // ice blue
  /* eslint-enable no-magic-numbers */
];
vmdPalette_palette.defaultElementColor = 8408320;
vmdPalette_palette.elementColors = {
  /* eslint-disable no-magic-numbers */
  H: 16777215,
  C: 4243391,
  N: 255,
  O: 16711680,
  P: 8421427,
  S: 16776960
  /* eslint-enable no-magic-numbers */
};
vmdPalette_palette.defaultResidueColor = 4243648;
vmdPalette_palette.residueColors = {
  /* eslint-disable no-magic-numbers */
  ALA: 255,
  ARG: 16777215,
  ASN: 8421427,
  ASP: 16711680,
  CYS: 16776960,
  GLN: 16744448,
  GLU: 16751001,
  GLY: 16777215,
  HIS: 4243648,
  ILE: 65280,
  LEU: 16751001,
  LYS: 4243648,
  MET: 16776960,
  PHE: 10879142,
  PRO: 8408064,
  SER: 16776960,
  THR: 15099571,
  TRP: 10066329,
  TYR: 65280,
  VAL: 8421427,
  A: 255,
  C: 16744448,
  G: 16776960,
  T: 10879142,
  U: 65280,
  DA: 255,
  DC: 16744448,
  DG: 16776960,
  DT: 10879142,
  DU: 65280,
  "+A": 255,
  "+C": 16744448,
  "+G": 16776960,
  "+T": 10879142,
  "+U": 65280,
  WAT: 4243648,
  H2O: 4243648,
  HOH: 4243648
  /* eslint-enable no-magic-numbers */
};
vmdPalette_palette.chainColors = [16777215].concat(vmdPalette_palette.colors);
var vmdPalette_StructuralElementType = chem_StructuralElement.Type;
vmdPalette_palette.secondaryColors = {
  [vmdPalette_StructuralElementType.HELIX_ALPHA]: 10879142,
  [vmdPalette_StructuralElementType.HELIX_310]: 255,
  [vmdPalette_StructuralElementType.HELIX_PI]: 16711680,
  [vmdPalette_StructuralElementType.STRAND]: 16776960,
  [vmdPalette_StructuralElementType.BRIDGE]: 8421427,
  [vmdPalette_StructuralElementType.TURN]: 4243648
};
var vmdPalette = vmdPalette_palette;
var palettes = new utils_EntityList([cpkPalette, jmolPalette, vmdPalette]);
var gfx_palettes = palettes;
var Colorer = class _Colorer {
  constructor(opts) {
    if (this.constructor === _Colorer) {
      throw new Error("Can not instantiate abstract class!");
    }
    this.opts = external_module_lodash_commonjs_lodash_commonjs2_lodash_amd_lodash_root_namespaceObject["default"].merge(utils.deriveDeep(settings.now.colorers[this.id], true), opts);
    this.palette = gfx_palettes.first;
  }
  /**
   * Get Colorer identification, probably with options.
   * @returns {string|Array} Colorer identifier string ({@link Colorer#id}) or two-element array containing both colorer
   *   identifier and options ({@link Colorer#opts}).
   * Options are returned if they were changed during or after colorer creation.
   */
  identify() {
    const diff = utils.objectsDiff(this.opts, settings.now.colorers[this.id]);
    if (!external_module_lodash_commonjs_lodash_commonjs2_lodash_amd_lodash_root_namespaceObject["default"].isEmpty(diff)) {
      return [this.id, diff];
    }
    return this.id;
  }
};
Colorer.prototype.id = "__";
var colorers_Colorer = Colorer;
var ElementColorer = class extends colorers_Colorer {
  getAtomColor(atom, _complex) {
    const type = atom.element.name;
    if (type === "C" && this.opts.carbon >= 0) {
      return this.opts.carbon;
    }
    return this.palette.getElementColor(type);
  }
  getResidueColor(_residue, _complex) {
    return this.palette.defaultResidueColor;
  }
};
__publicField(ElementColorer, "id", "EL");
ElementColorer.prototype.id = "EL";
ElementColorer.prototype.name = "Element";
ElementColorer.prototype.shortName = "Element";
var colorers_ElementColorer = ElementColorer;
var ResidueTypeColorer = class extends colorers_Colorer {
  getAtomColor(atom, complex) {
    return this.getResidueColor(atom.residue, complex);
  }
  getResidueColor(residue, _complex) {
    return this.palette.getResidueColor(residue._type._name);
  }
};
__publicField(ResidueTypeColorer, "id", "RT");
ResidueTypeColorer.prototype.id = "RT";
ResidueTypeColorer.prototype.name = "Residue Type";
ResidueTypeColorer.prototype.shortName = "Residue";
var colorers_ResidueTypeColorer = ResidueTypeColorer;
var SequenceColorer = class extends colorers_Colorer {
  getAtomColor(atom, complex) {
    return this.getResidueColor(atom.residue, complex);
  }
  getResidueColor(residue, _complex) {
    const chain = residue._chain;
    if (chain.minSequence === Number.POSITIVE_INFINITY && chain.maxSequence === Number.NEGATIVE_INFINITY) {
      return this.palette.defaultNamedColor;
    }
    const min = chain.minSequence;
    const max = chain.maxSequence > min ? chain.maxSequence : min + 1;
    return this.palette.getGradientColor((residue._sequence - min) / (max - min), this.opts.gradient);
  }
};
__publicField(SequenceColorer, "id", "SQ");
SequenceColorer.prototype.id = "SQ";
SequenceColorer.prototype.name = "Sequence";
SequenceColorer.prototype.shortName = "Sequence";
var colorers_SequenceColorer = SequenceColorer;
var ChainColorer = class extends colorers_Colorer {
  getAtomColor(atom, complex) {
    return this.getResidueColor(atom.residue, complex);
  }
  getResidueColor(residue, _complex) {
    return this.palette.getChainColor(residue.getChain()._name);
  }
};
__publicField(ChainColorer, "id", "CH");
ChainColorer.prototype.id = "CH";
ChainColorer.prototype.name = "Chain";
ChainColorer.prototype.shortName = "Chain";
var colorers_ChainColorer = ChainColorer;
var SecondaryStructureColorer = class extends colorers_Colorer {
  getAtomColor(atom, complex) {
    return this.getResidueColor(atom.residue, complex);
  }
  getResidueColor(residue, _complex) {
    if (residue._type.flags & chem_ResidueType.Flags.DNA) {
      return this.palette.getSecondaryColor("dna");
    }
    if (residue._type.flags & chem_ResidueType.Flags.RNA) {
      return this.palette.getSecondaryColor("rna");
    }
    const secondary = residue.getSecondary();
    if (secondary) {
      let color = this.palette.getSecondaryColor(secondary.type, true);
      if (color === void 0) {
        color = this.palette.getSecondaryColor(secondary.generic);
      }
      return color;
    }
    return this.palette.defaultSecondaryColor;
  }
};
__publicField(SecondaryStructureColorer, "id", "SS");
SecondaryStructureColorer.prototype.id = "SS";
SecondaryStructureColorer.prototype.name = "Secondary Structure";
SecondaryStructureColorer.prototype.shortName = "Structure";
var colorers_SecondaryStructureColorer = SecondaryStructureColorer;
var UniformColorer = class extends colorers_Colorer {
  getAtomColor(_atom, _complex) {
    return this.opts.color;
  }
  getResidueColor(_residue, _complex) {
    return this.opts.color;
  }
};
__publicField(UniformColorer, "id", "UN");
UniformColorer.prototype.id = "UN";
UniformColorer.prototype.name = "Uniform";
UniformColorer.prototype.shortName = "Uniform";
var colorers_UniformColorer = UniformColorer;
var ConditionalColorer = class extends colorers_Colorer {
  constructor(opts) {
    super(opts);
    const parsed = chem_selectors.parse(this.opts.subset);
    this._subsetCached = parsed.error ? chem_selectors.none() : parsed.selector;
  }
  getAtomColor(atom, _complex) {
    return this._subsetCached.includesAtom(atom) ? this.opts.color : this.opts.baseColor;
  }
  getResidueColor(residue, _complex) {
    const subset = this._subsetCached;
    const atoms = residue._atoms;
    for (let i2 = 0, n = atoms.length; i2 < n; ++i2) {
      if (!subset.includesAtom(atoms[i2])) {
        return this.opts.baseColor;
      }
    }
    return this.opts.color;
  }
};
__publicField(ConditionalColorer, "id", "CO");
ConditionalColorer.prototype.id = "CO";
ConditionalColorer.prototype.name = "Conditional";
ConditionalColorer.prototype.shortName = "Conditional";
var colorers_ConditionalColorer = ConditionalColorer;
var ConformationColorer = class extends colorers_Colorer {
  getAtomColor(atom, _complex) {
    return this.palette.getChainColor(String.fromCharCode(atom.location));
  }
  getResidueColor(_residue, _complex) {
    return this.palette.defaultResidueColor;
  }
};
__publicField(ConformationColorer, "id", "CF");
ConformationColorer.prototype.id = "CF";
ConformationColorer.prototype.name = "Conformation";
ConformationColorer.prototype.shortName = "Conformation";
var colorers_ConformationColorer = ConformationColorer;
var TemperatureColorer = class extends colorers_Colorer {
  getAtomColor(atom, _complex) {
    const {
      opts
    } = this;
    let factor = 1;
    if (atom.temperature && opts) {
      if (opts.min === opts.max) {
        factor = atom.temperature > opts.max ? 1 : 0;
      } else {
        factor = (atom.temperature - opts.min) / (opts.max - opts.min);
      }
      return this.palette.getGradientColor(factor, opts.gradient);
    }
    return this.palette.defaultGradientColor;
  }
  getResidueColor(residue, _complex) {
    const {
      opts
    } = this;
    if (!opts) {
      return this.palette.defaultGradientColor;
    }
    if (residue.temperature) {
      let factor = 0;
      if (opts.min === opts.max) {
        factor = residue.temperature > opts.max ? 1 : 0;
      } else {
        factor = (residue.temperature - opts.min) / (opts.max - opts.min);
      }
      return this.palette.getGradientColor(factor, opts.gradient);
    }
    return this.palette.defaultGradientColor;
  }
};
__publicField(TemperatureColorer, "id", "TM");
TemperatureColorer.prototype.id = "TM";
TemperatureColorer.prototype.name = "Temperature";
TemperatureColorer.prototype.shortName = "Temperature";
var colorers_TemperatureColorer = TemperatureColorer;
var OccupancyColorer = class extends colorers_Colorer {
  _getColorByOccupancy(occupancy, opts) {
    if (occupancy !== void 0) {
      const factor = 1 - occupancy;
      return this.palette.getGradientColor(factor, opts.gradient);
    }
    return this.palette.defaultGradientColor;
  }
  getAtomColor(atom, _complex) {
    const {
      opts
    } = this;
    return this._getColorByOccupancy(atom.occupancy, opts);
  }
  getResidueColor(residue, _complex) {
    const {
      opts
    } = this;
    return this._getColorByOccupancy(residue.occupancy, opts);
  }
};
__publicField(OccupancyColorer, "id", "OC");
OccupancyColorer.prototype.id = "OC";
OccupancyColorer.prototype.name = "Occupancy";
OccupancyColorer.prototype.shortName = "Occupancy";
var colorers_OccupancyColorer = OccupancyColorer;
var HydrophobicityColorer = class extends colorers_Colorer {
  getAtomColor(atom, complex) {
    return this.getResidueColor(atom.residue, complex);
  }
  getResidueColor(residue, _complex) {
    let color = this.palette.defaultResidueColor;
    if (residue._type.hydrophobicity !== void 0) {
      const min = -4.5;
      const max = 4.5;
      color = this.palette.getGradientColor((residue._type.hydrophobicity - min) / (max - min), this.opts.gradient);
    }
    return color;
  }
};
__publicField(HydrophobicityColorer, "id", "HY");
HydrophobicityColorer.prototype.id = "HY";
HydrophobicityColorer.prototype.name = "Hydrophobicity";
HydrophobicityColorer.prototype.shortName = "Hydrophobicity";
var colorers_HydrophobicityColorer = HydrophobicityColorer;
var MoleculeColorer = class extends colorers_Colorer {
  getAtomColor(atom, complex) {
    return this.getResidueColor(atom.residue, complex);
  }
  getResidueColor(residue, _complex) {
    const molecule = residue._molecule;
    const count = _complex.getMoleculeCount();
    if (count > 1) {
      return this.palette.getGradientColor((molecule.index - 1) / (count - 1), this.opts.gradient);
    }
    return this.palette.getGradientColor(0, this.opts.gradient);
  }
};
__publicField(MoleculeColorer, "id", "MO");
MoleculeColorer.prototype.id = "MO";
MoleculeColorer.prototype.name = "Molecule";
MoleculeColorer.prototype.shortName = "Molecule";
var colorers_MoleculeColorer = MoleculeColorer;
function scaleColor(c2, factor) {
  const r1 = c2 >> 16 & 255;
  const g1 = c2 >> 8 & 255;
  const b1 = c2 & 255;
  const r2 = factor * r1;
  const g2 = factor * g1;
  const b2 = factor * b1;
  return r2 << 16 | g2 << 8 | b2;
}
var CarbonColorer = class extends colorers_Colorer {
  getAtomColor(atom, _complex) {
    const colorCarbon = this.opts.color;
    const colorNotCarbon = scaleColor(colorCarbon, this.opts.factor);
    return atom.flags & chem_Atom.Flags.CARBON ? colorCarbon : colorNotCarbon;
  }
  getResidueColor(_residue, _complex) {
    return this.opts.color;
  }
};
__publicField(CarbonColorer, "id", "CB");
CarbonColorer.prototype.id = "CB";
CarbonColorer.prototype.name = "Carbon";
CarbonColorer.prototype.shortName = "Carbon";
var colorers_CarbonColorer = CarbonColorer;
var colorers = new utils_EntityList([colorers_ElementColorer, colorers_ResidueTypeColorer, colorers_SequenceColorer, colorers_ChainColorer, colorers_SecondaryStructureColorer, colorers_UniformColorer, colorers_ConditionalColorer, colorers_ConformationColorer, colorers_TemperatureColorer, colorers_OccupancyColorer, colorers_HydrophobicityColorer, colorers_MoleculeColorer, colorers_CarbonColorer]);
var gfx_colorers = colorers;
function neutralColor(intensity) {
  return new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Color(intensity, intensity, intensity);
}
var materialList = [{
  id: "DF",
  name: "Diffuse",
  shortName: "Diffuse",
  uberOptions: {
    diffuse: neutralColor(1),
    specular: neutralColor(0),
    shininess: 1,
    opacity: 1
  },
  values: {
    lights: true,
    fog: true,
    depthWrite: true,
    transparent: false,
    toonShading: false
  }
}, {
  id: "SF",
  name: "Soft Plastic",
  shortName: "Soft",
  uberOptions: {
    diffuse: neutralColor(1),
    specular: neutralColor(0.1),
    shininess: 30,
    opacity: 1
  },
  values: {
    lights: true,
    fog: true,
    depthWrite: true,
    transparent: false,
    toonShading: false
  }
}, {
  id: "PL",
  name: "Glossy Plastic",
  shortName: "Glossy",
  uberOptions: {
    diffuse: neutralColor(0.56),
    specular: neutralColor(0.28),
    shininess: 100,
    opacity: 1
  },
  values: {
    lights: true,
    fog: true,
    depthWrite: true,
    transparent: false,
    toonShading: false
  }
}, {
  id: "ME",
  name: "Metal",
  shortName: "Metal",
  uberOptions: {
    diffuse: neutralColor(0.56),
    specular: neutralColor(0.55),
    shininess: 30,
    opacity: 1
  },
  values: {
    lights: true,
    fog: true,
    depthWrite: true,
    transparent: false,
    toonShading: false
  }
}, {
  id: "TR",
  name: "Transparent",
  shortName: "Transparent",
  uberOptions: {
    diffuse: neutralColor(1),
    specular: neutralColor(0),
    shininess: 1,
    opacity: 0.5
  },
  values: {
    lights: true,
    fog: true,
    depthWrite: true,
    transparent: true,
    toonShading: false
  }
}, {
  id: "GL",
  name: "Glass",
  shortName: "Glass",
  uberOptions: {
    diffuse: neutralColor(0.5),
    specular: neutralColor(0.65),
    shininess: 100,
    opacity: 0.5
  },
  values: {
    lights: true,
    fog: true,
    depthWrite: true,
    transparent: true,
    toonShading: false
  }
}, {
  id: "BA",
  name: "Backdrop",
  shortName: "Backdrop",
  uberOptions: {
    diffuse: neutralColor(1),
    specular: neutralColor(0),
    shininess: 1,
    opacity: 1
  },
  values: {
    lights: false,
    fog: false,
    depthWrite: false,
    transparent: false,
    toonShading: false
  }
}, {
  id: "TN",
  name: "Toon",
  shortName: "Toon",
  uberOptions: {
    diffuse: neutralColor(1),
    specular: neutralColor(0),
    shininess: 1,
    opacity: 1
  },
  values: {
    lights: true,
    fog: true,
    depthWrite: true,
    transparent: false,
    toonShading: true
  }
}, {
  id: "FL",
  name: "Flat",
  shortName: "Flat",
  uberOptions: {
    diffuse: neutralColor(1),
    specular: neutralColor(0),
    shininess: 0,
    opacity: 1
  },
  values: {
    lights: false,
    fog: true,
    depthWrite: true,
    transparent: false
  }
}];
var materials = new utils_EntityList(materialList);
var gfx_materials = materials;
function _gatherObjects(root, meshTypes) {
  const meshes2 = [];
  root.traverse((object) => {
    for (let i2 = 0; i2 < meshTypes.length; i2++) {
      if (object instanceof meshTypes[i2]) {
        meshes2[meshes2.length] = object;
        break;
      }
    }
  });
  return meshes2;
}
function createDerivativeMesh(mesh, values, layer) {
  const material = mesh.material.createInstance();
  material.setValues(values);
  const newMesh = new mesh.constructor(mesh.geometry, material);
  newMesh.material.needsUpdate = true;
  newMesh.applyMatrix4(mesh.matrix);
  newMesh.layers.set(layer);
  return newMesh;
}
function traverseMeshes(root, meshTypes, func) {
  const meshes2 = _gatherObjects(root, meshTypes);
  for (let i2 = 0, n = meshes2.length; i2 < n; ++i2) {
    const mesh = meshes2[i2];
    if (!mesh.parent) {
      continue;
    }
    func(mesh);
  }
}
function applyTransformsToMeshes(root, mtc) {
  const mtcCount = mtc.length;
  if (mtcCount < 1) {
    return;
  }
  const meshTypes = [external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Mesh, external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.LineSegments, external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Line];
  traverseMeshes(root, meshTypes, (mesh) => {
    mesh.applyMatrix4(mtc[0]);
    for (let j = 1; j < mtcCount; ++j) {
      const newMesh = new mesh.constructor(mesh.geometry, mesh.material);
      mesh.parent.add(newMesh);
      newMesh.applyMatrix4(mtc[j]);
    }
  });
}
var processTransparentMaterial = /* @__PURE__ */ function() {
  const matValues = {
    prepassTransparancy: true,
    fakeOpacity: false,
    transparent: false,
    colorFromDepth: false,
    lights: false,
    shadowmap: false,
    fog: false
  };
  return function(root, material) {
    if (!(material instanceof shaders_UberMaterial)) {
      return;
    }
    traverseMeshes(root, [external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Mesh, external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.LineSegments], (mesh) => {
      mesh.material.setValues({
        prepassTransparancy: false,
        fakeOpacity: false
      });
      mesh.material.needsUpdate = true;
      mesh.layers.set(gfxutils.LAYERS.TRANSPARENT);
      const prepassTranspMesh = createDerivativeMesh(mesh, matValues, gfxutils.LAYERS.PREPASS_TRANSPARENT);
      mesh.parent.add(prepassTranspMesh);
    });
  };
}();
var processColFromPosMaterial = /* @__PURE__ */ function() {
  const matValues = {
    colorFromPos: true,
    transparent: false,
    colorFromDepth: false,
    lights: false,
    shadowmap: false,
    fog: false,
    overrideColor: false,
    fogTransparent: false,
    attrColor: false,
    attrColor2: false,
    attrAlphaColor: false,
    fakeOpacity: false
  };
  return function(root, material) {
    if (!(material instanceof shaders_UberMaterial)) {
      return;
    }
    traverseMeshes(root, [external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Mesh, external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.LineSegments], (mesh) => {
      const colFromPosMesh = createDerivativeMesh(mesh, matValues, gfxutils.LAYERS.COLOR_FROM_POSITION);
      mesh.parent.add(colFromPosMesh);
    });
  };
}();
var createShadowmapMaterial = /* @__PURE__ */ function() {
  const matValues = {
    colorFromDepth: true,
    orthoCam: true,
    lights: false,
    shadowmap: false,
    fog: false
  };
  return function(root, material) {
    if (!(material instanceof shaders_UberMaterial)) {
      return;
    }
    traverseMeshes(root, [external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Mesh, external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.LineSegments], (mesh) => {
      if (!mesh.receiveShadow && mesh.material.shadowmap) {
        mesh.material.setValues({
          shadowmap: false
        });
      }
      if (!mesh.material.lights) {
        return;
      }
      if (!mesh.castShadow) {
        return;
      }
      if (!gfxutils.belongToSelectLayers(mesh)) {
        return;
      }
      const shadowmapMesh = createDerivativeMesh(mesh, matValues, gfxutils.LAYERS.SHADOWMAP);
      shadowmapMesh.isShadowmapMesh = true;
      mesh.parent.add(shadowmapMesh);
    });
  };
}();
function removeShadowmapMaterial(root, material) {
  if (!(material instanceof shaders_UberMaterial)) {
    return;
  }
  traverseMeshes(root, [external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Mesh, external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.LineSegments], (mesh) => {
    if (mesh.isShadowmapMesh) {
      mesh.parent.remove(mesh);
    }
  });
}
function forEachMeshInGroup(group, process) {
  function processObj(object) {
    if (object instanceof external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Mesh) {
      process(object);
    }
    for (let i2 = 0, l2 = object.children.length; i2 < l2; i2++) {
      processObj(object.children[i2]);
    }
  }
  processObj(group);
}
function _countMeshTriangles(mesh) {
  const geom = mesh.geometry;
  if (geom instanceof external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.InstancedBufferGeometry) {
    const attribs = geom.attributes;
    for (const property in attribs) {
      if (attribs.hasOwnProperty(property) && attribs[property] instanceof external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.InstancedBufferAttribute) {
        const currAttr = attribs[property];
        const indexSize = geom.index ? geom.index.array.length / 3 : 0;
        return indexSize * currAttr.array.length / currAttr.itemSize;
      }
    }
    return 0;
  }
  if (geom instanceof external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.BufferGeometry) {
    return geom.index ? geom.index.array.length / 3 : 0;
  }
  return geom.faces ? geom.faces.length : 0;
}
function countTriangles(group) {
  let totalCount = 0;
  forEachMeshInGroup(group, (mesh) => {
    totalCount += _countMeshTriangles(mesh);
  });
  return totalCount;
}
var meshutils = {
  applyTransformsToMeshes,
  processTransparentMaterial,
  processColFromPosMaterial,
  createShadowmapMaterial,
  removeShadowmapMaterial,
  forEachMeshInGroup,
  countTriangles
};
var {
  selectors: Representation_selectors
} = chem;
var Representation = class {
  constructor(index, mode, colorer, selector) {
    const startMaterialValues = {
      clipPlane: settings.now.draft.clipPlane,
      fogTransparent: settings.now.bg.transparent,
      shadowmap: settings.now.shadow.on,
      shadowmapType: settings.now.shadow.type
    };
    this.index = index;
    this.mode = mode;
    this.colorer = colorer;
    this.selector = selector;
    this.selectorString = "";
    this.count = 0;
    this.material = new shaders_UberMaterial();
    this.material.setValues(startMaterialValues);
    this.material.setUberOptions({
      fogAlpha: settings.now.fogAlpha
    });
    this.materialPreset = gfx_materials.first;
    this.needsRebuild = true;
    this.visible = true;
    this.setMode(mode);
  }
  markAtoms(complex) {
    this.count = complex.markAtoms(this.selector, 1 << this.index);
    this.needsRebuild = true;
    return this.count;
  }
  unmarkAtoms(complex) {
    complex.clearAtomBits(1 << this.index);
    this.count = 0;
  }
  setMode(mode) {
    this.mode = mode;
  }
  setMaterialPreset(preset) {
    this.materialPreset = preset;
    this.material.setUberOptions(preset.uberOptions);
    this.material.setValues(preset.values);
  }
  reset() {
    this.geo = null;
    this.selectionGeo = null;
  }
  buildGeometry(complex) {
    this.reset();
    this.needsRebuild = false;
    if (settings.now.ao) {
      this.material.setValues({
        normalsToGBuffer: settings.now.ao
      });
    }
    this.geo = this.mode.buildGeometry(complex, this.colorer, 1 << this.index, this.material);
    if (this.material.uberOptions.opacity < 0.99 && settings.now.transparency === "prepass") {
      meshutils.processTransparentMaterial(this.geo, this.material);
    }
    this.geo.visible = this.visible;
    gfxutils.processObjRenderOrder(this.geo, this.materialPreset.id);
    meshutils.processColFromPosMaterial(this.geo, this.material);
    if (settings.now.shadow.on) {
      meshutils.createShadowmapMaterial(this.geo, this.material);
    }
    return this.geo;
  }
  buildSelectionGeometry(mask) {
    let sg = null;
    if (this.geo && "getSubset" in this.geo) {
      const meshes2 = this.geo.getSubset(mask);
      if (meshes2 && meshes2.length > 0) {
        sg = new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Group();
        sg.matrixAutoUpdate = false;
        sg.matrix = this.geo.matrix;
        for (let j = 0; j < meshes2.length; j++) {
          const m2 = meshes2[j];
          sg.add(m2);
        }
      }
    }
    if (sg) {
      sg.visible = this.visible;
    }
    this.selectionGeo = sg;
    return this.selectionGeo;
  }
  /**
   * Create object that represents difference between current and another rep
   * anotherRep could be undefined. In this case everything is reported.
   */
  compare(repSettings) {
    const diff = {};
    const selStr = String(this.selector);
    if (!repSettings || selStr.valueOf() !== String(repSettings.selector).valueOf()) {
      diff.selector = selStr;
    }
    const modeDiff = this.mode.identify();
    if (!repSettings || Array.isArray(modeDiff) || modeDiff !== repSettings.mode) {
      diff.mode = modeDiff;
    }
    const colorerDiff = this.colorer.identify();
    if (!repSettings || Array.isArray(colorerDiff) || colorerDiff !== repSettings.colorer) {
      diff.colorer = colorerDiff;
    }
    if (!repSettings || this.materialPreset.id !== repSettings.material) {
      diff.material = this.materialPreset.id;
    }
    return diff;
  }
  /**
   * Change representation. Write fields what was changed into new object, return it.
   */
  change(repSettings, complex, mode, color) {
    const diff = {};
    if (repSettings.selector) {
      const newSelectorObject = Representation_selectors.parse(repSettings.selector).selector;
      const newSelector = String(newSelectorObject);
      if (this.selectorString !== newSelector) {
        diff.selector = newSelector;
        this.selectorString = newSelector;
        this.selector = newSelectorObject;
        this.markAtoms(complex);
      }
    }
    if (repSettings.mode) {
      const newMode = repSettings.mode;
      if (!external_module_lodash_commonjs_lodash_commonjs2_lodash_amd_lodash_root_namespaceObject["default"].isEqual(this.mode.identify(), newMode)) {
        diff.mode = newMode;
        this.setMode(mode);
      }
    }
    if (repSettings.colorer) {
      const newColorer = repSettings.colorer;
      if (!external_module_lodash_commonjs_lodash_commonjs2_lodash_amd_lodash_root_namespaceObject["default"].isEqual(this.colorer.identify(), newColorer)) {
        diff.colorer = newColorer;
        this.colorer = color;
      }
    }
    if (repSettings.material) {
      const newMaterial = repSettings.material;
      if (!external_module_lodash_commonjs_lodash_commonjs2_lodash_amd_lodash_root_namespaceObject["default"].isEqual(this.materialPreset.id, newMaterial)) {
        diff.material = newMaterial;
        this.setMaterialPreset(gfx_materials.get(repSettings.material));
      }
    }
    return diff;
  }
  show(visible) {
    this.visible = visible;
    if (this.geo) {
      this.geo.visible = visible;
    }
    if (this.selectionGeo) {
      this.selectionGeo.visible = visible;
    }
  }
};
var gfx_Representation = Representation;
function _traverseComponentGroups(root, component, callback) {
  const {
    children
  } = root;
  if (!children) {
    return;
  }
  for (let i2 = 0, n = children.length; i2 < n; ++i2) {
    const child = children[i2];
    if (child._component === component) {
      callback(child);
    }
    if (child instanceof gfxutils.RCGroup) {
      _traverseComponentGroups(child, component, callback);
    }
  }
}
function ComplexEditor() {
}
var ComplexComponentEditor = class extends ComplexEditor {
  constructor(complexVisual) {
    super();
    this._complexVisual = complexVisual;
    this._inProgress = false;
  }
  begin() {
    const complex = this._complexVisual.getComplex();
    this._componentTransforms = [];
    for (let i2 = 0; i2 < complex._components.length; ++i2) {
      const component = complex._components[i2];
      this._componentTransforms[component._index] = new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Object3D();
    }
    this._inProgress = true;
    return true;
  }
  apply() {
    if (!this._inProgress) {
      return;
    }
    const complex = this._complexVisual.getComplex();
    for (let i2 = 0; i2 < complex._components.length; ++i2) {
      this._bakeComponentTransform(complex._components[i2]);
    }
    complex.onAtomPositionChanged();
    this._resetComponentTransform();
    this._complexVisual.finalizeEdit();
  }
  discard() {
    if (!this._inProgress) {
      return;
    }
    this._resetComponentTransform();
    this._complexVisual.finalizeEdit();
  }
  getAltObj() {
    const res = {
      objects: [],
      pivot: new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Vector3(0, 0, 0)
    };
    const visual = this._complexVisual;
    const component = visual.getSelectedComponent();
    if (component === null) {
      return res;
    }
    const selection = this._complexVisual.getSelectionGeo();
    const selectionMask = 1 << visual.getSelectionBit();
    let i2;
    let j;
    let reprNode;
    let geo;
    _traverseComponentGroups(visual, component, (child) => {
      res.objects.push(child);
    });
    for (i2 = 0; i2 < selection.children.length; ++i2) {
      reprNode = selection.children[i2];
      for (j = 0; j < reprNode.children.length; ++j) {
        geo = reprNode.children[j];
        if (geo.hasOwnProperty("_component") && geo._component === component) {
          res.objects.push(geo);
        }
      }
    }
    res.objects.push(this._componentTransforms[component._index]);
    const bbmin = new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Vector3(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE);
    const bbmax = new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Vector3(-Number.MAX_VALUE, -Number.MAX_VALUE, -Number.MAX_VALUE);
    component.forEachResidue((residue) => {
      const atoms = residue._atoms;
      for (j = 0; j < atoms.length; ++j) {
        if (atoms[j].mask & selectionMask) {
          bbmin.min(atoms[j].position);
          bbmax.max(atoms[j].position);
        }
      }
    });
    res.pivot.lerpVectors(bbmin, bbmax, 0.5);
    return res;
  }
  _bakeComponentTransform(component) {
    const t2 = this._componentTransforms[component._index];
    if (t2 && (!(t2.position.x === 0 && t2.position.y === 0 && t2.position.z === 0) || !(t2.quaternion.x === 0 && t2.quaternion.y === 0 && t2.quaternion.z === 0 && t2.quaternion.w === 1))) {
      t2.updateMatrix();
      component.forEachResidue((residue) => {
        const atoms = residue._atoms;
        for (let j = 0; j < atoms.length; ++j) {
          atoms[j].position.applyMatrix4(t2.matrix);
        }
      });
    }
  }
  _resetComponentTransform() {
    const visual = this._complexVisual;
    const selection = this._complexVisual.getSelectionGeo();
    let i2;
    let j;
    let reprNode;
    let geo;
    for (i2 = 0; i2 < this._componentTransforms.length; ++i2) {
      geo = this._componentTransforms[i2];
      geo.position.set(0, 0, 0);
      geo.quaternion.set(0, 0, 0, 1);
    }
    for (i2 = 0; i2 < visual.children.length; ++i2) {
      reprNode = visual.children[i2];
      for (j = 0; j < reprNode.children.length; ++j) {
        geo = reprNode.children[j];
        if (geo.hasOwnProperty("_component")) {
          geo.position.set(0, 0, 0);
          geo.quaternion.set(0, 0, 0, 1);
        }
      }
    }
    for (i2 = 0; i2 < selection.children.length; ++i2) {
      reprNode = selection.children[i2];
      for (j = 0; j < reprNode.children.length; ++j) {
        geo = reprNode.children[j];
        if (geo.hasOwnProperty("_component")) {
          geo.position.set(0, 0, 0);
          geo.quaternion.set(0, 0, 0, 1);
        }
      }
    }
  }
};
var ComplexFragmentEditor = class extends ComplexEditor {
  constructor(complexVisual) {
    super();
    this._complexVisual = complexVisual;
    this._inProgress = false;
  }
  begin() {
    const visual = this._complexVisual;
    const selection = this._complexVisual.getSelectionGeo();
    const atoms = this._getSelectionBorderAtoms();
    if (atoms.length < 1 || atoms.length > 2) {
      logger.error("Can only edit fragments with one or two bound atoms.");
      return false;
    }
    this._fragmentBoundAtoms = atoms;
    const selectionMask = 1 << visual.getSelectionBit();
    visual.disableSubset(selectionMask, true);
    for (let k2 = 0; k2 < selection.children.length; ++k2) {
      selection.children[k2].visible = false;
    }
    const pivotPos = atoms[0].position.clone();
    if (atoms.length === 2) {
      pivotPos.lerp(atoms[1].position, 0.5);
    }
    this._fragmentGeo = new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Group();
    visual.add(this._fragmentGeo);
    this._fragmentGeo.position.copy(pivotPos);
    this._fragmentSelectionGeo = new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Group();
    selection.add(this._fragmentSelectionGeo);
    this._fragmentSelectionGeo.position.copy(pivotPos);
    const offset = pivotPos.clone();
    offset.negate();
    for (let i2 = 0; i2 < visual.children.length; ++i2) {
      const g2 = visual.children[i2];
      if (!("getSubset" in g2)) {
        continue;
      }
      const vg = new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Group();
      this._fragmentGeo.add(vg);
      const sg = new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Group();
      this._fragmentSelectionGeo.add(sg);
      const meshes2 = g2.getSubset(selectionMask, true);
      for (let j = 0; j < meshes2.length; j++) {
        const m2 = meshes2[j];
        vg.add(m2);
        m2.position.copy(offset);
      }
      const smeshes = g2.getSubset(selectionMask, true);
      for (let h2 = 0; h2 < smeshes.length; h2++) {
        const sm = smeshes[h2];
        sg.add(sm);
        sm.position.copy(offset);
      }
    }
    gfxutils.applySelectionMaterial(this._fragmentSelectionGeo);
    this._inProgress = true;
    return true;
  }
  apply() {
    if (!this._inProgress) {
      return;
    }
    const visual = this._complexVisual;
    const selectionBit = visual.getSelectionBit();
    const p2 = this._fragmentGeo.position;
    const m2 = this._fragmentGeo.matrix.clone();
    m2.multiply(new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Matrix4().makeTranslation(-p2.x, -p2.y, -p2.z));
    this._bakeAtomTransform(m2, 1 << selectionBit);
    visual.enableSubset(1 << selectionBit, true);
    visual.getComplex().onAtomPositionChanged();
    visual.finalizeEdit();
  }
  discard() {
    if (!this._inProgress) {
      return;
    }
    const visual = this._complexVisual;
    const selection = this._complexVisual.getSelectionGeo();
    this._fragmentGeo.parent.remove(this._fragmentGeo);
    visual.enableSubset(1 << visual.getSelectionBit(), true);
    for (let i2 = 0; i2 < selection.children.length; ++i2) {
      const node = selection.children[i2];
      if (node.visible) {
        selection.remove(node);
      } else {
        node.visible = true;
      }
    }
    visual.finalizeEdit();
  }
  isFreeRotationAllowed() {
    return this._fragmentBoundAtoms.length < 2;
  }
  getAltObj() {
    const res = {
      objects: [],
      pivot: new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Vector3(0, 0, 0)
    };
    res.objects.push(this._fragmentGeo, this._fragmentSelectionGeo);
    const boundAtoms = this._fragmentBoundAtoms;
    if (boundAtoms.length === 1) {
      if (boundAtoms[0].bonds.length === 1) {
        const bond = boundAtoms[0].bonds[0];
        res.axis = new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Vector3().subVectors(bond._right.position, bond._left.position);
        res.axis.normalize();
        res.axis.transformDirection(this._complexVisual.matrixWorld);
      }
    } else if (boundAtoms.length === 2) {
      res.axis = new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Vector3().subVectors(boundAtoms[1].position, boundAtoms[0].position);
      res.axis.normalize();
      res.axis.transformDirection(this._complexVisual.matrixWorld);
    }
    return res;
  }
  _getSelectionBorderAtoms() {
    const complex = this._complexVisual.getComplex();
    const selectionMask = 1 << this._complexVisual.getSelectionBit();
    const atomHash = {};
    complex.forEachBond((bond) => {
      if (bond._left.mask & selectionMask) {
        if ((bond._right.mask & selectionMask) === 0) {
          atomHash[bond._left.index] = 1;
        }
      } else if (bond._right.mask & selectionMask) {
        atomHash[bond._right.index] = 1;
      }
    });
    const atoms = [];
    const keys = Object.keys(atomHash);
    for (let i2 = 0, n = keys.length; i2 < n; ++i2) {
      const idx = keys[i2];
      atoms.push(complex._atoms[idx]);
    }
    return atoms;
  }
  _bakeAtomTransform(matrix, mask) {
    this._complexVisual.getComplex().forEachAtom((atom) => {
      if (atom.mask & mask) {
        atom.position.applyMatrix4(matrix);
      }
    });
  }
};
var ComplexVisualEdit = {
  ComponentEditor: ComplexComponentEditor,
  FragmentEditor: ComplexFragmentEditor
};
var {
  selectors: ComplexVisual_selectors
} = chem;
function lookupAndCreate(entityList, specs) {
  if (!Array.isArray(specs)) {
    specs = [specs];
  }
  const [id2, opts] = specs;
  const Entity = entityList.get(id2) || entityList.first;
  return new Entity(opts);
}
var ComplexVisual = class _ComplexVisual extends src_Visual {
  constructor(name, dataSource) {
    super(name, dataSource);
    this._complex = dataSource;
    this._reprList = [];
    this._repr = null;
    this._reprListChanged = true;
    this._selectionBit = 0;
    this._reprUsedBits = 0;
    this._selectionCount = 0;
    this._selectionGeometry = new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Group();
  }
  getBoundaries() {
    return this._complex.getBoundaries();
  }
  release() {
    if (this._selectionGeometry.parent) {
      this._selectionGeometry.remove(this._selectionGeometry);
    }
    src_Visual.prototype.release.call(this);
  }
  getComplex() {
    return this._complex;
  }
  getSelectionCount() {
    return this._selectionCount;
  }
  getSelectionGeo() {
    return this._selectionGeometry;
  }
  getSelectionBit() {
    return this._selectionBit;
  }
  getEditor() {
    return this._editor;
  }
  resetReps(reps) {
    if (this._complex) {
      this._complex.clearAtomBits(~0);
    }
    this._reprListChanged = true;
    this._reprUsedBits = 0;
    this._reprList.length = reps.length;
    for (let i2 = 0, n = reps.length; i2 < n; ++i2) {
      const rep = reps[i2];
      let selector;
      let selectorString;
      if (typeof rep.selector === "string") {
        selectorString = rep.selector;
        ({
          selector
        } = ComplexVisual_selectors.parse(selectorString));
      } else if (typeof rep.selector === "undefined") {
        selectorString = settings.now.presets.default[0].selector;
        ({
          selector
        } = ComplexVisual_selectors.parse(selectorString));
      } else {
        ({
          selector
        } = rep);
        selectorString = selector.toString();
      }
      const mode = lookupAndCreate(gfx_modes, rep.mode);
      const colorer = lookupAndCreate(gfx_colorers, rep.colorer);
      const material = gfx_materials.get(rep.material) || gfx_materials.first;
      this._reprList[i2] = new gfx_Representation(i2, mode, colorer, selector);
      this._reprList[i2].setMaterialPreset(material);
      this._reprList[i2].selectorString = selectorString;
      if (this._complex) {
        this._complex.markAtoms(selector, 1 << i2);
      }
      this._reprUsedBits |= 1 << i2;
    }
    this._repr = reps.length > 0 ? this._reprList[0] : null;
    this._selectionBit = reps.length;
    this._reprUsedBits |= 1 << this._selectionBit;
    this._selectionCount = 0;
    if (this._complex) {
      this._complex.update();
    }
  }
  /**
   * Get number of representations created so far.
   * @returns {number} Number of reps.
   */
  repCount() {
    return this._reprList.length;
  }
  /**
   * Get or set the current representation index.
   * @param {number=} index - Zero-based index, up to {@link Miew#repCount()}. Defaults to the current one.
   * @returns {number} The current index.
   */
  repCurrent(index) {
    if (index >= 0 && index < this._reprList.length) {
      this._repr = this._reprList[index];
    } else {
      index = this._reprList.indexOf(this._repr);
    }
    return index;
  }
  /**
   * Get or set representation by index.
   * @param {number=} index - Zero-based index, up to {@link Miew#repCount()}. Defaults to the current one.
   * @param {object=} rep - Optional representation description.
   * @param {string=} rep.selector - Selector string.
   * @param {string=} rep.mode - Mode id.
   * @param {string=} rep.colorer - Colorer id.
   * @param {string=} rep.material - Material id.
   * @returns {Object} {desc, index, status} field desc contains rep description, index - index of correspondent rep,
   * status - one of three strings: 'created', 'changed', ''. 'created' means new rep was created during this function,
   * 'changed' - rep was changed during this function. '' - something else.
   */
  rep(index, rep) {
    if (!rep && (index === void 0 || index instanceof Object)) {
      rep = index;
      index = this.repCurrent();
    }
    if (index < 0 || index > this._reprList.length) {
      logger.error(`Rep ${index} does not exist!`);
      return null;
    }
    if (index === this._reprList.length) {
      const res = this.repAdd(rep);
      logger.warn(`Rep ${index} does not exist! New representation was created.`);
      return {
        desc: res.desc,
        index,
        status: "created"
      };
    }
    const target = this._reprList[index];
    const desc = {
      selector: target.selectorString,
      mode: target.mode.identify(),
      colorer: target.colorer.identify(),
      material: target.materialPreset.id
    };
    if (rep) {
      const diff = target.change(rep, this._complex, lookupAndCreate(gfx_modes, rep.mode), lookupAndCreate(gfx_colorers, rep.colorer));
      if (!external_module_lodash_commonjs_lodash_commonjs2_lodash_amd_lodash_root_namespaceObject["default"].isEmpty(diff)) {
        target.needsRebuild = true;
        for (const key in diff) {
          if (diff.hasOwnProperty(key)) {
            desc[key] = diff[key];
            logger.debug(`rep[${index}].${key} changed to ${diff[key]}`);
          }
        }
        if (diff.mode && target.mode.isSurface && (settings.now.resolution === "ultra" || settings.now.resolution === "high")) {
          logger.report('Surface resolution was changed to "medium" to avoid hang-ups.');
          settings.set("resolution", "medium");
        }
        return {
          desc,
          index,
          status: "changed"
        };
      }
    }
    return {
      desc,
      index,
      status: ""
    };
  }
  /**
   * Get representation (not just description) by index.
   * @param {number=} index - Zero-based index, up to {@link Miew#repCount()}. Defaults to the current one.
   * @returns {?object} Representation.
   */
  repGet(index) {
    if (index === void 0 || index instanceof Object) {
      index = this.repCurrent();
    }
    if (index < 0 || index >= this._reprList.length) {
      return null;
    }
    return this._reprList[index];
  }
  _getFreeReprIdx() {
    let bits = this._reprUsedBits;
    for (let i2 = 0; i2 <= _ComplexVisual.NUM_REPRESENTATION_BITS; ++i2, bits >>= 1) {
      if ((bits & 1) === 0) {
        return i2;
      }
    }
    return -1;
  }
  /**
   * Add new representation.
   * @param {object=} rep - Representation description.
   * @returns {Object} {desc, index} field desc contains added rep description, index - index of this rep.
   */
  repAdd(rep) {
    if (this._reprList.length >= _ComplexVisual.NUM_REPRESENTATION_BITS) {
      return null;
    }
    const newSelectionBit = this._getFreeReprIdx();
    if (newSelectionBit < 0) {
      return null;
    }
    const originalSelection = this.buildSelectorFromMask(1 << this._selectionBit);
    const def = settings.now.presets.default[0];
    const desc = external_module_lodash_commonjs_lodash_commonjs2_lodash_amd_lodash_root_namespaceObject["default"].merge({
      selector: def.selector,
      mode: def.mode,
      colorer: def.colorer,
      material: def.material
    }, rep);
    const selector = typeof desc.selector === "string" ? ComplexVisual_selectors.parse(desc.selector).selector : desc.selector;
    const target = new gfx_Representation(this._selectionBit, lookupAndCreate(gfx_modes, desc.mode), lookupAndCreate(gfx_colorers, desc.colorer), selector);
    target.selectorString = selector.toString();
    target.setMaterialPreset(gfx_materials.get(desc.material));
    target.markAtoms(this._complex);
    this._reprList.push(target);
    this._selectionBit = newSelectionBit;
    this._reprUsedBits |= 1 << this._selectionBit;
    this._complex.markAtoms(originalSelection, 1 << this._selectionBit);
    return {
      desc,
      index: this._reprList.length - 1
    };
  }
  /**
   * Remove representation.
   * @param {number=} index - Zero-based representation index.
   */
  repRemove(index) {
    if (index === void 0) {
      index = this.repCurrent();
    }
    let count = this._reprList.length;
    if (index < 0 || index >= count || count <= 1) {
      return;
    }
    const target = this._reprList[index];
    target.unmarkAtoms(this._complex);
    this._reprUsedBits &= ~(1 << target.index);
    this._reprList.splice(index, 1);
    if (target === this._repr) {
      --count;
      index = index < count ? index : count - 1;
      this._repr = this._reprList[index];
    }
    this._reprListChanged = true;
  }
  /**
   * Hide representation.
   * @param {number} index - Zero-based representation index.
   * @param {boolean=} hide - Specify false to make rep visible, true to hide (by default).
   */
  repHide(index, hide) {
    if (hide === void 0) {
      hide = true;
    }
    if (index < 0 || index >= this._reprList.length) {
      return;
    }
    const target = this._reprList[index];
    target.show(!hide);
  }
  /**
   * Select atoms with selector
   * @param {Selector} selector - selector
   * @param {boolean=} append - true to append selection atoms to current selection, false to rewrite selection
   */
  select(selector, append) {
    if (append) {
      this._selectionCount += this._complex.markAtomsAdditionally(selector, 1 << this._selectionBit);
    } else {
      this._selectionCount = this._complex.markAtoms(selector, 1 << this._selectionBit);
    }
    this._complex.updateStructuresMask();
    this.rebuildSelectionGeometry();
  }
  resetSelectionMask() {
    if (this._selectionCount !== 0) {
      this._selectionCount = 0;
      if (this._complex) {
        this._complex.clearAtomBits(1 << this._selectionBit);
      }
    }
  }
  updateSelectionMask(pickedObj) {
    const self2 = this;
    const {
      atom
    } = pickedObj;
    let {
      residue,
      chain,
      molecule
    } = pickedObj;
    const setMask = 1 << this._selectionBit;
    const clearMask = ~setMask;
    if (atom) {
      residue = atom.residue;
      chain = residue._chain;
      molecule = residue._molecule;
      if (atom.mask & setMask) {
        atom.mask &= clearMask;
        residue._mask &= clearMask;
        chain._mask &= clearMask;
        if (molecule) {
          molecule.mask &= clearMask;
        }
        this._selectionCount--;
      } else {
        atom.mask |= setMask;
        this._selectionCount++;
        residue.collectMask();
        chain.collectMask();
        if (molecule) {
          molecule.collectMask();
        }
      }
    } else if (residue) {
      chain = residue._chain;
      molecule = residue._molecule;
      if (residue._mask & setMask) {
        residue._mask &= clearMask;
        chain._mask &= clearMask;
        residue.forEachAtom((a2) => {
          if (a2.mask & setMask) {
            a2.mask &= clearMask;
            self2._selectionCount--;
          }
        });
      } else {
        residue._mask |= setMask;
        residue.forEachAtom((a2) => {
          if (!(a2.mask & setMask)) {
            a2.mask |= setMask;
            self2._selectionCount++;
          }
        });
        chain.collectMask();
        if (molecule) {
          molecule.collectMask();
        }
      }
    } else if (chain || molecule) {
      const obj = chain || molecule;
      if (obj._mask & setMask) {
        obj._mask &= clearMask;
        obj.forEachResidue((r2) => {
          if (r2._mask & setMask) {
            r2._mask &= clearMask;
            r2.forEachAtom((a2) => {
              if (a2.mask & setMask) {
                a2.mask &= clearMask;
                self2._selectionCount--;
              }
            });
            r2._mask &= clearMask;
          }
        });
      } else {
        obj._mask |= setMask;
        obj.forEachResidue((r2) => {
          if (!(r2._mask & setMask)) {
            r2._mask |= setMask;
            r2.forEachAtom((a2) => {
              if (!(a2.mask & setMask)) {
                a2.mask |= setMask;
                self2._selectionCount++;
              }
            });
            const otherObj = chain ? r2.getMolecule() : r2.getChain();
            if (otherObj) {
              otherObj.collectMask();
            }
          }
        });
      }
    } else {
      this.resetSelectionMask();
    }
  }
  expandSelection() {
    const self2 = this;
    const selectionMask = 1 << this._selectionBit;
    const tmpMask = 1 << 31;
    this._complex.forEachBond((bond) => {
      if (bond._left.mask & selectionMask) {
        if ((bond._right.mask & selectionMask) === 0) {
          bond._right.mask |= tmpMask;
        }
      } else if (bond._right.mask & selectionMask) {
        bond._left.mask |= tmpMask;
      }
    });
    const deselectionMask = ~tmpMask;
    this._complex.forEachAtom((atom) => {
      if (atom.mask & tmpMask) {
        atom.mask = atom.mask & deselectionMask | selectionMask;
        ++self2._selectionCount;
      }
    });
    this._complex.updateStructuresMask();
  }
  shrinkSelection() {
    const self2 = this;
    const selectionMask = 1 << this._selectionBit;
    const tmpMask = 1 << 31;
    this._complex.forEachBond((bond) => {
      if (bond._left.mask & selectionMask) {
        if ((bond._right.mask & selectionMask) === 0) {
          bond._left.mask |= tmpMask;
        }
      } else if (bond._right.mask & selectionMask) {
        bond._right.mask |= tmpMask;
      }
    });
    this._complex.forEachAtom((atom) => {
      if (atom.mask & selectionMask && atom.bonds.length === 1) {
        atom.mask |= tmpMask;
      }
    });
    const deselectionMask = ~(selectionMask | tmpMask);
    this._complex.forEachAtom((atom) => {
      if (atom.mask & tmpMask) {
        atom.mask &= deselectionMask;
        --self2._selectionCount;
      }
    });
    this._complex.updateStructuresMask();
  }
  getSelectedComponent() {
    const selectionMask = 1 << this._selectionBit;
    let component = null;
    let multiple = false;
    this._complex.forEachAtom((atom) => {
      if (atom.mask & selectionMask) {
        if (component === null) {
          component = atom.residue._component;
        } else if (component !== atom.residue._component) {
          multiple = true;
        }
      }
    });
    return multiple ? null : component;
  }
  getSelectionCenter(center, includesAtom, selRule) {
    center.set(0, 0, 0);
    let count = 0;
    this._complex.forEachAtom((atom) => {
      if (includesAtom(atom, selRule)) {
        center.add(atom.position);
        count++;
      }
    });
    if (count === 0) {
      return false;
    }
    center.divideScalar(count);
    center.applyMatrix4(this.matrix);
    return true;
  }
  needsRebuild() {
    if (this._reprListChanged) {
      return true;
    }
    const reprList = this._reprList;
    for (let i2 = 0, n = reprList.length; i2 < n; ++i2) {
      const repr = reprList[i2];
      if (repr.needsRebuild) {
        return true;
      }
    }
    return false;
  }
  /**
   * Rebuild molecule geometry asynchronously.
   */
  rebuild() {
    const self2 = this;
    gfxutils.clearTree(this);
    return new Promise((resolve) => {
      const complex = self2._complex;
      if (!complex) {
        resolve();
        return;
      }
      let errorOccured = false;
      setTimeout(() => {
        console.time("build");
        const reprList = self2._reprList;
        const palette2 = gfx_palettes.get(settings.now.palette) || gfx_palettes.first;
        let hasGeometry = false;
        for (let i2 = 0, n = reprList.length; i2 < n; ++i2) {
          const repr = reprList[i2];
          repr.colorer.palette = palette2;
          if (repr.needsRebuild) {
            repr.reset();
            try {
              repr.buildGeometry(complex);
            } catch (e2) {
              if (e2 instanceof utils.OutOfMemoryError) {
                repr.needsRebuild = false;
                repr.reset();
                logger.error(`Not enough memory to build geometry for representation ${repr.index + 1}`);
                errorOccured = true;
              } else {
                throw e2;
              }
            }
            if (false) {
            }
          }
          hasGeometry = errorOccured || hasGeometry || gfxutils.groupHasGeometryToRender(repr.geo);
          if (repr.geo) {
            self2.add(repr.geo);
          }
        }
        self2._reprListChanged = false;
        console.timeEnd("build");
        resolve();
      }, 10);
    });
  }
  setNeedsRebuild() {
    const reprList = this._reprList;
    for (let i2 = 0, n = reprList.length; i2 < n; ++i2) {
      reprList[i2].needsRebuild = true;
    }
  }
  rebuildSelectionGeometry() {
    const mask = 1 << this._selectionBit;
    gfxutils.clearTree(this._selectionGeometry);
    for (let i2 = 0, n = this._reprList.length; i2 < n; ++i2) {
      const repr = this._reprList[i2];
      const sg = repr.buildSelectionGeometry(mask);
      if (!sg) {
        continue;
      }
      this._selectionGeometry.add(sg);
      for (let j = 0; j < sg.children.length; j++) {
        const m2 = sg.children[j];
        if (this._editor && this._editor._componentTransforms) {
          const t2 = this._editor._componentTransforms[m2._component._index];
          if (t2) {
            m2.position.copy(t2.position);
            m2.quaternion.copy(t2.quaternion);
          }
        }
      }
      gfxutils.applySelectionMaterial(sg);
    }
  }
  _buildSelectorFromSortedLists(atoms, residues, chains) {
    const complex = this._complex;
    function optimizeList(list) {
      const result = [];
      let k2 = 0;
      let first = NaN;
      let last = NaN;
      for (let i2 = 0, n = list.length; i2 < n; ++i2) {
        const value = list[i2];
        if (value === last + 1) {
          last = value;
        } else {
          if (!Number.isNaN(first)) {
            result[k2++] = new ComplexVisual_selectors.Range(first, last);
          }
          first = last = value;
        }
      }
      if (!Number.isNaN(first)) {
        result[k2] = new ComplexVisual_selectors.Range(first, last);
      }
      return result;
    }
    let expression = null;
    if (chains.length === complex._chains.length) {
      expression = ComplexVisual_selectors.all();
    } else {
      let selector;
      if (chains.length > 0) {
        selector = ComplexVisual_selectors.chain(chains);
        expression = expression ? ComplexVisual_selectors.or(expression, selector) : selector;
      }
      if (Object.keys(residues).length > 0) {
        for (const ch in residues) {
          if (residues.hasOwnProperty(ch)) {
            selector = ComplexVisual_selectors.and(ComplexVisual_selectors.chain(ch), ComplexVisual_selectors.residx(optimizeList(residues[ch])));
            expression = expression ? ComplexVisual_selectors.or(expression, selector) : selector;
          }
        }
      }
      if (atoms.length > 0) {
        selector = ComplexVisual_selectors.serial(optimizeList(atoms));
        expression = expression ? ComplexVisual_selectors.or(expression, selector) : selector;
      }
      if (!expression) {
        expression = ComplexVisual_selectors.none();
      }
    }
    return expression;
  }
  buildSelectorFromMask(mask) {
    const complex = this._complex;
    const chains = [];
    const residues = {};
    const atoms = [];
    complex.forEachChain((chain) => {
      if (chain._mask & mask) {
        chains.push(chain._name);
      }
    });
    complex.forEachResidue((residue) => {
      if (residue._mask & mask && !(residue._chain._mask & mask)) {
        const c2 = residue._chain._name;
        if (!(c2 in residues)) {
          residues[c2] = [residue._index];
        } else {
          residues[c2].push(residue._index);
        }
      }
    });
    complex.forEachAtom((atom) => {
      if (atom.mask & mask && !(atom.residue._mask & mask)) {
        atoms.push(atom.serial);
      }
    });
    return this._buildSelectorFromSortedLists(atoms, residues, chains);
  }
  forSelectedResidues(process) {
    const selectionMask = 1 << this._selectionBit;
    this._complex.forEachResidue((residue) => {
      if (residue._mask & selectionMask) {
        process(residue);
      }
    });
  }
  beginComponentEdit() {
    if (this._editor) {
      return null;
    }
    const editor = new ComplexVisualEdit.ComponentEditor(this);
    if (!editor.begin()) {
      return null;
    }
    this._editor = editor;
    return editor;
  }
  beginFragmentEdit() {
    if (this._editor) {
      return null;
    }
    const editor = new ComplexVisualEdit.FragmentEditor(this);
    if (!editor.begin()) {
      return null;
    }
    this._editor = editor;
    return editor;
  }
  // should only be called by editors
  finalizeEdit() {
    this._editor = null;
  }
  setMaterialValues(values) {
    let needTraverse = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
    let process = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : void 0;
    for (let i2 = 0, n = this._reprList.length; i2 < n; ++i2) {
      const rep = this._reprList[i2];
      rep.material.setValues(values);
      if (needTraverse) {
        rep.geo.traverse((object) => {
          if (object instanceof external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Mesh) {
            object.material.setValues(values);
            if (process !== void 0) {
              process(object);
            }
            object.material.needsUpdate = true;
          }
        });
      }
    }
  }
  setUberOptions(values) {
    for (let i2 = 0, n = this._reprList.length; i2 < n; ++i2) {
      const rep = this._reprList[i2];
      rep.material.setUberOptions(values);
    }
  }
  /**
   * Build selector that contains all atoms within given distance from group of atoms
   * @param {Selector} selector - selector describing source group of atoms
   * @param {number} radius - distance
   * @returns {Selector} selector describing result group of atoms
   */
  within(selector, radius) {
    const vw = this._complex.getVoxelWorld();
    if (vw === null) {
      return false;
    }
    const selectionMask = 1 << this._selectionBit;
    this._complex.markAtoms(selector, selectionMask);
    if (vw) {
      vw.forEachAtomWithinDistFromMasked(this._complex, selectionMask, Number(radius), (atom) => {
        atom.mask |= selectionMask;
      });
    }
    this._selectionCount = this._complex.countAtomsByMask(selectionMask);
    this._complex.updateStructuresMask();
    return this.buildSelectorFromMask(selectionMask);
  }
};
ComplexVisual.NUM_REPRESENTATION_BITS = 30;
var src_ComplexVisual = ComplexVisual;
var VolumeFaces_namespaceObject = "varying vec3 pos;\r\n\r\nvoid main() {\r\n  // we're assuming local position is in [-0.5, 0.5]\r\n  // we need to offset it to be represented in RGB\r\n  pos = position.xyz + 0.5;\r\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\r\n}";
var gfx_shaders_VolumeFaces_namespaceObject = "varying vec3 pos;\r\n\r\nvoid main() {\r\n  gl_FragColor = vec4(pos, 0.5);\r\n}";
var shaders_Volume_namespaceObject = "varying vec4 screenSpacePos;\r\n\r\nvoid main() {\r\n  screenSpacePos = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\r\n  gl_Position = screenSpacePos;\r\n}";
var src_gfx_shaders_Volume_namespaceObject = "uniform mat4 projectionMatrix;\r\n\r\n// 3D volume texture\r\nuniform vec3 volumeDim;    // volume dimensions, pixels\r\nuniform sampler2D tileTex; // tiled texture containing all Z-slices of a 3D data\r\nuniform vec2 tileTexSize;  // size of tiled texture, pixels\r\nuniform vec2 tileStride;   // UV stride between slices in tile tex, pixels\r\n\r\nuniform vec3 boxAngles;//value of angles({x: alpha, y:beta, z:gamma}) types 1 - if angle is obtuse, 0 - if acute\r\nuniform vec3 delta; //Projection box delta's from non-orthogonal origin axes; {x: XY, y : XZ, z: YZ}\r\n\r\nuniform vec3 _isoLevel0;\r\nuniform float _flipV;\r\nuniform sampler2D _BFLeft;\r\nuniform sampler2D _BFRight;\r\nuniform sampler2D _FFLeft;\r\nuniform sampler2D _FFRight;\r\nuniform sampler2D _WFFLeft;\r\nuniform sampler2D _WFFRight;\r\n\r\nvarying vec4 screenSpacePos;\r\n\r\n#define NO_COLOR vec4(0., 0., 0., 0.)\r\n\r\nvec4 sample3DTexture(vec3 texCoord) {\r\n  // a pair of Z slices is determined by nearest slice border\r\n  float zSliceBorder = floor(texCoord.z * volumeDim.z + 0.5);\r\n  float zSliceNumber1 = max(zSliceBorder - 1.0, 0.0);\r\n  float zSliceNumber2 = min(zSliceBorder, volumeDim.z - 1.0);\r\n\r\n  float rowTiles = floor(tileTexSize.x / tileStride.x);\r\n\r\n  // calculate coords in tile texture for both slices\r\n  vec2 tileOffset = vec2(mod(zSliceNumber1, rowTiles), floor(zSliceNumber1 / rowTiles));\r\n  vec2 texCoordSlice1 = (texCoord.xy * volumeDim.xy + tileOffset * tileStride) / tileTexSize.xy;\r\n  tileOffset = vec2(mod(zSliceNumber2, rowTiles), floor(zSliceNumber2 / rowTiles));\r\n  vec2 texCoordSlice2 = (texCoord.xy * volumeDim.xy + tileOffset * tileStride) / tileTexSize.xy;\r\n\r\n  // bilinear filtering\r\n  vec4 colorSlice1 = texture2D(tileTex, texCoordSlice1);\r\n  vec4 colorSlice2 = texture2D(tileTex, texCoordSlice2);\r\n  float weightSlice2 = texCoord.z * volumeDim.z - (zSliceNumber1 + 0.5);\r\n  return mix(colorSlice1, colorSlice2, weightSlice2);\r\n}\r\n\r\nvec4 sample3DTextureInclined(vec3 boxCoord) { // delta:{ x: XY, y : XZ, z: YZ }\r\n  vec3 textCoord = boxCoord;\r\n  vec2 currDelta = mix(boxCoord.zz, vec2(1., 1.) - boxCoord.zz, boxAngles.yx) * delta.yz;\r\n\r\n  textCoord.y = (boxCoord.y  - currDelta.y) / (1. - delta.z);\r\n  if (textCoord.y < 0.0 || textCoord.y > 1.0)\r\n    return NO_COLOR;\r\n\r\n  currDelta.x += mix(textCoord.y, 1.0 - textCoord.y, boxAngles.z) * delta.x;\r\n\r\n  textCoord.x = (boxCoord.x - currDelta.x) / (1. - delta.x - delta.y);\r\n  if (textCoord.x < 0.0 || textCoord.x > 1.0)\r\n    return NO_COLOR;\r\n\r\n  return sample3DTexture(textCoord);\r\n}\r\n\r\nfloat CalcColor(vec3 iter, vec3 dir) {\r\n  float d = 1. / 128.;\r\n  vec3 dx = vec3(d, 0.0, 0.0);\r\n  vec3 dy = vec3(0.0, d, 0.0);\r\n  vec3 dz = vec3(0.0, 0.0, d);\r\n\r\n  // #Opt: coordInc.x:(iter + dx).x > 1. ? 0.: sample3DTextureInclined(iter + dx).x,\r\n  vec3 coordInc = mix(\r\n    vec3(\r\n      sample3DTextureInclined(iter + dx).x,\r\n      sample3DTextureInclined(iter + dy).x,\r\n      sample3DTextureInclined(iter + dz).x\r\n    ),\r\n    vec3(0. ,0. , 0.),\r\n    vec3(floor((iter + dx).x), floor((iter + dy).y), floor((iter + dz).z))\r\n  );\r\n\r\n  // #Opt: coordDec.x:(iter - dx).x < 0. ? 0.: sample3DTextureInclined(iter - dx).x,\r\n  vec3 coordDec = mix(\r\n    vec3(0. ,0. , 0.),\r\n    vec3(\r\n      sample3DTextureInclined(iter - dx).x,\r\n      sample3DTextureInclined(iter - dy).x,\r\n      sample3DTextureInclined(iter - dz).x\r\n    ),\r\n    vec3(ceil((iter - dx).x), ceil((iter - dy).y), ceil((iter - dz).z))\r\n  );\r\n\r\n  vec3 N = normalize(coordInc - coordDec);\r\n  float dif = max(0.0, dot(N, dir));\r\n  return dif;\r\n}\r\n\r\nvec3 AccuracyIso(vec3 left, vec3 right, float volLeft, float threshold) {\r\n  for (int i = 0; i < 5; i++) {\r\n    vec3 iterator = 0.5 * (left + right);\r\n    float vol = sample3DTextureInclined(iterator).r;\r\n    if ((volLeft - threshold) * (vol - threshold) < 0.)\r\n      right = iterator;\r\n    else\r\n      left = iterator;\r\n  }\r\n  return 0.5 * (left + right);\r\n}\r\n\r\nvec3 CorrectIso(vec3 left, vec3 right, float tr) {\r\n  for (int j = 0; j < 5; j++) {\r\n    vec3 iterator = 0.5 * (left + right);\r\n    float vol = sample3DTextureInclined(iterator).r;\r\n    if (vol < tr)\r\n      right = iterator;\r\n    else\r\n      left = iterator;\r\n  }\r\n  return 0.5 * (left + right);\r\n}\r\n\r\nvec4 GetIso1(vec3 start, vec3 back, float molDist, vec3 dir, float tr, int count) {\r\n  float vol, stepSize = (float(count) + 2.) / float(STEPS_COUNT);\r\n  vec3 step = stepSize * dir, iterator = start, left, right;\r\n  vec4 acc = NO_COLOR;\r\n\r\n  for (int i = 0; i < STEPS_COUNT; i++) {\r\n    iterator = iterator + step;\r\n    vol = sample3DTextureInclined(iterator).r;\r\n    if (length(iterator - back) <= stepSize || (vol > tr))\r\n      break;\r\n  }\r\n\r\n  if (vol > tr)\r\n    acc = vec4(CorrectIso(iterator, iterator - step, tr).xyz, 1.);\r\n\r\n  return acc;\r\n}\r\n\r\nfloat easeOut(float x0, float x1, float x) {\r\n  float t = clamp((x - x0) / (x1 - x0), 0.0, 1.0);\r\n  return 1.0 - (1.0 - t) * (1.0 - t);\r\n}\r\n\r\nfloat easeIn(float x0, float x1, float x) {\r\n  float t = clamp((x - x0) / (x1 - x0), 0.0, 1.0);\r\n  return t * t;\r\n}\r\n\r\nvec3 GetColSimple(float vol) {\r\n  float t = easeOut(_isoLevel0.x, _isoLevel0.y, vol);\r\n  float s = easeIn(_isoLevel0.y, _isoLevel0.z, vol);\r\n  return vec3(0.5, 0.6, 0.7) * (1.0 - t) + 2.0 * vec3(s, 0, 0);\r\n}\r\n\r\nvec4 VolRender(vec3 start, vec3 back, float molDist, vec3 dir) {\r\n  vec4 acc = NO_COLOR, iso;\r\n  vec3 iterator = start, sumColor = vec3(0., 0., 0.);\r\n  float stepSize, alpha, sumAlpha = 0.0, vol, curStepSize, molD;\r\n  vec3 step, col, colOld, right;\r\n  float tr0 = _isoLevel0.x;\r\n  float dif, r, kd, finish;\r\n  int count = 0, stopMol = 0;\r\n\r\n  for (int k = 0; k < 3; k++) {\r\n    stepSize = (float(k) + 2.) / float(STEPS_COUNT);\r\n    kd = 140. * tr0 * stepSize;\r\n    r = 1. - kd;\r\n    step = stepSize * dir;\r\n    iso = GetIso1(iterator, back, molDist, dir, tr0, k);\r\n    if (iso.a < 0.1 || length(iso.xyz - start) > molDist)\r\n      break;\r\n    iterator = iso.xyz;\r\n    dif = 1.;// CalcColor(iterator, dir);\r\n    colOld = GetColSimple(tr0);\r\n    curStepSize = stepSize;\r\n    for (int i = 0; i < STEPS_COUNT; i++) {\r\n      iterator = iterator + step;\r\n      molD = length(iterator - start);\r\n      vol = sample3DTextureInclined(iterator).r;\r\n      finish = distance(iterator, back) - stepSize;\r\n      if (finish < 0.0 || vol < tr0 || (sumAlpha > 0.97) || molD > molDist)\r\n        break;\r\n      alpha = (1. - r);\r\n      col = GetColSimple(vol);\r\n      vol = sample3DTextureInclined(iterator - 0.5 * step).r;\r\n      vec3 colMid = GetColSimple(vol);\r\n      sumColor += (1. - sumAlpha) * (colOld + 4.* colMid + col) * alpha / 6.;\r\n      sumAlpha += (1. - sumAlpha) * alpha;// *(1. - 1.0*dif*dif);\r\n      colOld = col;\r\n    } // for i\r\n\r\n    if (finish < 0.0 || sumAlpha > 0.97)\r\n      break;\r\n\r\n    if (molD > molDist) {\r\n      curStepSize = stepSize - (molD - molDist);\r\n      right = iterator - (molD - molDist) * dir;\r\n      vol = sample3DTextureInclined(right).r;\r\n    } else {\r\n      vec3 left = iterator - step;\r\n      right = CorrectIso(left, iterator, tr0);\r\n      curStepSize = distance(left, right);\r\n      vol = tr0;\r\n    }\r\n\r\n    alpha = (1. - r) * curStepSize / stepSize;\r\n    dif = 1.;// CalcColor(right, dir);\r\n    col = GetColSimple(vol);\r\n    vol = sample3DTextureInclined(iterator - 0.5 * curStepSize / stepSize * step).r;\r\n    vec3 colMid = GetColSimple(vol);\r\n    sumColor += (1. - sumAlpha) * (colOld + 4. * colMid + col) * alpha / 6.;\r\n    sumAlpha += (1. - sumAlpha) * alpha;// *(1. - 1.0*dif*dif);\r\n\r\n    if (molD > molDist)\r\n      break;\r\n  } // for k\r\n  acc.rgb = 1. * sumColor / sumAlpha;\r\n  acc.a = sumAlpha;\r\n  return acc;\r\n}\r\n\r\nvec4 VolRender1(vec3 start, vec3 back, float molDist, vec3 dir) {\r\n  float stepSize = 1.0 / float(STEPS_COUNT);\r\n  float len = length(back - start);\r\n  vec3 step = stepSize * dir;\r\n  vec3 iterator = start;\r\n  float acc = 0.0;\r\n\r\n  for (int i = 0; i < STEPS_COUNT; i++) {\r\n    if (float(i) * stepSize > len)\r\n      break;\r\n    iterator = iterator + step;\r\n    if (sample3DTextureInclined(iterator).r > _isoLevel0.x)\r\n      acc += 10. * sample3DTextureInclined(iterator).r / float(STEPS_COUNT);\r\n  }\r\n\r\n  return vec4(1.,1.,1., acc);\r\n}\r\n\r\nvec4 IsoRender(vec3 start, vec3 back, float molDist, vec3 dir) {\r\n  vec4 tst = GetIso1(start, back, 2., dir, _isoLevel0.x, 0);\r\n  vec4 col = NO_COLOR;\r\n\r\n  if (length(tst.xyz - start) < molDist && tst.a > 0.1) {\r\n    float dif =  CalcColor(tst.xyz, dir);\r\n    dif = 0.9 * dif * dif;\r\n    col = vec4(dif, dif, dif, 1);\r\n  }\r\n  return col;\r\n}\r\n\r\nvec4 VolRender2(vec3 start, vec3 back, float molDist, vec3 dir) {\r\n  return sample3DTexture(start);\r\n}\r\n\r\nvoid main() {\r\n  vec3 tc = screenSpacePos.xyz / screenSpacePos.w * 0.5 + 0.5;\r\n\r\n  if (_flipV > 0.0) {\r\n    tc.y = 1.0 - tc.y;\r\n  }\r\n\r\n  vec3 start;\r\n  vec3 back;\r\n  vec3 molBack;\r\n  if (projectionMatrix[0][2] < 0.0) {\r\n    start = texture2D(_FFLeft, tc.xy).xyz;\r\n    back = texture2D(_BFLeft, tc.xy).xyz;\r\n    molBack = texture2D(_WFFLeft, tc.xy).xyz;\r\n  } else {\r\n    start = texture2D(_FFRight, tc.xy).xyz;\r\n    back = texture2D(_BFRight, tc.xy).xyz;\r\n    molBack = texture2D(_WFFRight, tc.xy).xyz;\r\n  }\r\n\r\n  vec3 dir = normalize(back - start);\r\n\r\n  float molDist = 2.0;\r\n  if (length(molBack) > 0.001) {\r\n    molDist = distance(start, molBack);\r\n  }\r\n\r\n  #ifdef ISO_MODE\r\n    gl_FragColor = IsoRender(start, back, molDist, dir);\r\n  #else\r\n    gl_FragColor = VolRender(start, back, molDist, dir);\r\n  #endif\r\n}\r\n";
var VolumeFarPlane_namespaceObject = "varying vec4 volPos;\r\nuniform float aspectRatio;\r\nuniform float farZ;\r\nuniform float tanHalfFOV;\r\nuniform mat4  matWorld2Volume;\r\n\r\nvoid main() {\r\n  // rescale plane to fill in the whole far plane area seen from camera\r\n  vec3 pos = position.xyz;\r\n  pos.x = pos.x * tanHalfFOV * farZ * aspectRatio;\r\n  pos.y = pos.y * tanHalfFOV * farZ;\r\n  // common transformation\r\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(pos, 1.0);\r\n  // calc pos in volume CS\r\n  volPos = matWorld2Volume * modelMatrix * vec4(pos, 1.0);\r\n  // we're assuming local position is in [-0.5, 0.5]\r\n  // we need to offset it to be represented in RGB\r\n  volPos = volPos + 0.5;\r\n  volPos.w = 0.5;\r\n}\r\n";
var gfx_shaders_VolumeFarPlane_namespaceObject = "varying vec4 volPos;\r\n\r\nvoid main() {\r\n  gl_FragColor = volPos;\r\n}";
var volumeUniforms = external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.UniformsUtils.merge([{
  volumeDim: {
    type: "v3",
    value: new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Vector3(512, 512, 512)
  },
  tileTex: {
    type: "t",
    value: null
  },
  tileTexSize: {
    type: "v2",
    value: new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Vector2(512, 512)
  },
  tileStride: {
    type: "v2",
    value: new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Vector2(512, 512)
  },
  boxAngles: {
    type: "v3",
    value: new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Vector3(1, 1, 1)
  },
  delta: {
    type: "v3",
    value: new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Vector3(0, 0, 0)
  },
  _isoLevel0: {
    type: "v2",
    value: new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Vector3(0.5, 0.75, 1)
  },
  _flipV: {
    type: "f",
    value: 0
  },
  _BFLeft: {
    type: "t",
    value: null
  },
  _BFRight: {
    type: "t",
    value: null
  },
  _FFLeft: {
    type: "t",
    value: null
  },
  _FFRight: {
    type: "t",
    value: null
  },
  _WFFLeft: {
    type: "t",
    value: null
  },
  _WFFRight: {
    type: "t",
    value: null
  }
}]);
function overrideUniforms(params, defUniforms) {
  const uniforms = external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.UniformsUtils.clone(defUniforms);
  for (const p2 in params) {
    if (uniforms.hasOwnProperty(p2)) {
      uniforms[p2].value = params[p2];
    }
  }
  return uniforms;
}
function facesPosMaterialParams(params, sideType) {
  return {
    uniforms: overrideUniforms(params, {}),
    vertexShader: VolumeFaces_namespaceObject,
    fragmentShader: gfx_shaders_VolumeFaces_namespaceObject,
    transparent: false,
    depthTest: false,
    depthWrite: false,
    side: sideType
  };
}
var BackFacePosMaterial = class extends external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.ShaderMaterial {
  constructor(params) {
    const backFaceParams = facesPosMaterialParams(params, external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.BackSide);
    super(backFaceParams);
  }
};
var ShaderParams = class {
  constructor(params, uniforms, vertexShader, fragmentShader) {
    this.uniforms = overrideUniforms(params, uniforms);
    this.vertexShader = vertexShader;
    this.fragmentShader = fragmentShader;
    this.transparent = false;
    this.depthTest = false;
    this.depthWrite = false;
    this.side = external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.FrontSide;
  }
};
var BackFacePosMaterialFarPlane = class extends external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.ShaderMaterial {
  constructor(params) {
    const matUniforms = external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.UniformsUtils.merge([{
      aspectRatio: {
        type: "f",
        value: 0
      },
      farZ: {
        type: "f",
        value: 0
      },
      tanHalfFOV: {
        type: "f",
        value: 0
      },
      matWorld2Volume: {
        type: "4fv",
        value: new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Matrix4()
      }
    }]);
    const shaderParams = new ShaderParams(params, matUniforms, VolumeFarPlane_namespaceObject, gfx_shaders_VolumeFarPlane_namespaceObject);
    super(shaderParams);
  }
};
var FrontFacePosMaterial = class extends external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.ShaderMaterial {
  constructor(params) {
    const frontFaceParams = facesPosMaterialParams(params, external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.FrontSide);
    super(frontFaceParams);
  }
};
var VolumeMaterial = class extends external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.ShaderMaterial {
  constructor(params) {
    const shaderParams = new ShaderParams(params, volumeUniforms, shaders_Volume_namespaceObject, src_gfx_shaders_Volume_namespaceObject);
    shaderParams.transparent = true;
    shaderParams.depthTest = true;
    super(shaderParams);
    this.updateDefines();
  }
  updateDefines() {
    this.defines = {
      ISO_MODE: settings.now.modes.VD.isoMode,
      STEPS_COUNT: settings.now.modes.VD.polyComplexity[settings.now.resolution] * 100
    };
    this.needsUpdate = true;
  }
};
var shaders_VolumeMaterial = {
  BackFacePosMaterial,
  BackFacePosMaterialFarPlane,
  FrontFacePosMaterial,
  VolumeMaterial
};
var _VolumeMesh = class _VolumeMesh extends external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Mesh {
  // data for noise filter
  constructor() {
    const geo = new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.BufferGeometry();
    super(geo);
    __publicField(this, "volumeInfo", {});
    this.clipPlane = new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Plane();
    const size = new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Vector3(0.5, 0.5, 0.5);
    this.size = size;
    this.cullFlag = [true, true, true, true, true, true, true, true, false, false, false, false, false, false];
    this.faces = [{
      indices: [],
      norm: new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Vector3(0, 0, -1)
    }, {
      indices: [],
      norm: new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Vector3(0, 0, 1)
    }, {
      indices: [],
      norm: new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Vector3(0, -1, 0)
    }, {
      indices: [],
      norm: new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Vector3(0, 1, 0)
    }, {
      indices: [],
      norm: new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Vector3(-1, 0, 0)
    }, {
      indices: [],
      norm: new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Vector3(1, 0, 0)
    }, {
      indices: [],
      norm: new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Vector3(0, 0, 0)
    }];
    this.vertices = [
      new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Vector3(-size.x, -size.y, -size.z),
      new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Vector3(-size.x, size.y, -size.z),
      new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Vector3(size.x, -size.y, -size.z),
      new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Vector3(size.x, size.y, -size.z),
      new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Vector3(-size.x, -size.y, size.z),
      new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Vector3(-size.x, size.y, size.z),
      new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Vector3(size.x, -size.y, size.z),
      new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Vector3(size.x, size.y, size.z),
      new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Vector3(0, 0, 0),
      // Placeholder for section
      new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Vector3(0, 0, 0),
      new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Vector3(0, 0, 0),
      new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Vector3(0, 0, 0),
      new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Vector3(0, 0, 0),
      new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Vector3(0, 0, 0)
    ];
    geo.setAttribute("position", new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.BufferAttribute(new Float32Array(this.vertices.length * 3), 3));
    this.name = "VolumeMesh";
  }
  _updateVertices() {
    const corners = _VolumeMesh._corners;
    const edges = _VolumeMesh._edges;
    const edgeIntersections = _VolumeMesh._edgeIntersections;
    let i2;
    const norm = this.clipPlane.normal;
    const D = this.clipPlane.constant;
    const vert = this.vertices;
    const {
      size
    } = this;
    const cornerMark = [0, 0, 0, 0, 0, 0, 0, 0];
    const edgeMark = [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1];
    const curEdge = new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Vector3();
    let curEdgeInter = null;
    function CheckX() {
      if (norm.x === 0) return 0;
      const x3 = -(norm.dot(curEdge) + D) / norm.x;
      if (-size.x <= x3 && x3 <= size.x) {
        curEdgeInter.set(x3, curEdge.y, curEdge.z);
        if (x3 === size.x) return 2;
        if (x3 === -size.x) return -2;
        return 1;
      }
      return 0;
    }
    function CheckY() {
      if (norm.y === 0) return 0;
      const y2 = -(norm.dot(curEdge) + D) / norm.y;
      if (-size.y <= y2 && y2 <= size.y) {
        curEdgeInter.set(curEdge.x, y2, curEdge.z);
        if (y2 === size.y) return 2;
        if (y2 === -size.y) return -2;
        return 1;
      }
      return 0;
    }
    function CheckZ() {
      if (norm.z === 0) return 0;
      const z = -(norm.dot(curEdge) + D) / norm.z;
      if (-size.z <= z && z <= size.z) {
        curEdgeInter.set(curEdge.x, curEdge.y, z);
        if (z === size.z) return 2;
        if (z === -size.z) return -2;
        return 1;
      }
      return 0;
    }
    for (let curEdgeIdx = 0; curEdgeIdx < 12; ++curEdgeIdx) {
      const curEdgeSource = edges[curEdgeIdx];
      curEdgeInter = edgeIntersections[curEdgeIdx];
      curEdge.set(curEdgeSource[2], curEdgeSource[3], curEdgeSource[4]);
      curEdge.multiply(size);
      let flag = 0;
      if (curEdgeSource[2] === 0) flag = CheckX();
      if (curEdgeSource[3] === 0) flag = CheckY();
      if (curEdgeSource[4] === 0) flag = CheckZ();
      if (flag === -2) {
        cornerMark[curEdgeSource[0]] = 1;
      } else if (flag === 2) {
        cornerMark[curEdgeSource[1]] = 1;
      } else if (flag === 0) {
        edgeMark[curEdgeIdx] = 0;
      }
    }
    const face = {
      indices: [],
      norm: norm.clone().negate()
    };
    let nextVertex = 8;
    for (i2 = 0; i2 < 8; ++i2) {
      if (cornerMark[i2] === 1) {
        vert[nextVertex].set(corners[i2][0], corners[i2][1], corners[i2][2]).multiply(size);
        face.indices.push(nextVertex++);
        edgeMark[corners[i2][3]] = 0;
        edgeMark[corners[i2][4]] = 0;
        edgeMark[corners[i2][5]] = 0;
      }
    }
    for (i2 = 0; i2 < 12; ++i2) {
      if (edgeMark[i2] === 1) {
        vert[nextVertex].copy(edgeIntersections[i2]);
        face.indices.push(nextVertex++);
      }
    }
    this.faces[6] = face;
    const diff = new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Vector3();
    const coplanarPoint = new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Vector3();
    this.clipPlane.coplanarPoint(coplanarPoint);
    for (i2 = 0; i2 < vert.length; ++i2) {
      this.cullFlag[i2] = false;
      if (i2 < 8) {
        diff.subVectors(vert[i2], coplanarPoint);
        this.cullFlag[i2] = norm.dot(diff) >= 0;
      } else if (i2 < 8 + face.indices.length) {
        this.cullFlag[i2] = true;
      }
    }
    const positions = this.geometry.getAttribute("position");
    let idx = 0;
    for (i2 = 0; i2 < vert.length; ++i2) {
      positions.array[idx++] = vert[i2].x;
      positions.array[idx++] = vert[i2].y;
      positions.array[idx++] = vert[i2].z;
    }
    positions.needsUpdate = true;
  }
  _collectVertices(face, filter) {
    let i2;
    const vert = this.vertices;
    face.indices = [];
    for (i2 = 0; i2 < vert.length; ++i2) {
      if (this.cullFlag[i2] && filter(vert[i2])) {
        face.indices.push(i2);
      }
    }
  }
  _sortIndices(face, right) {
    let i2;
    let j;
    const vert = this.vertices;
    const angle = [];
    const dir = new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Vector3();
    for (i2 = 1; i2 < face.indices.length; ++i2) {
      dir.subVectors(vert[face.indices[i2]], vert[face.indices[0]]);
      dir.normalize();
      dir.cross(right);
      dir.negate();
      angle[i2] = face.norm.dot(dir);
    }
    for (i2 = 1; i2 < face.indices.length - 1; ++i2) {
      for (j = i2 + 1; j < face.indices.length; ++j) {
        if (angle[j] < angle[i2]) {
          let t2 = angle[i2];
          angle[i2] = angle[j];
          angle[j] = t2;
          t2 = face.indices[i2];
          face.indices[i2] = face.indices[j];
          face.indices[j] = t2;
        }
      }
    }
  }
  _updateIndices() {
    let i2;
    let faceIdx;
    let face;
    const vert = this.vertices;
    const {
      size
    } = this;
    this._collectVertices(this.faces[0], (vertex2) => vertex2.z === -size.z);
    this._collectVertices(this.faces[1], (vertex2) => vertex2.z === size.z);
    this._collectVertices(this.faces[2], (vertex2) => vertex2.y === -size.y);
    this._collectVertices(this.faces[3], (vertex2) => vertex2.y === size.y);
    this._collectVertices(this.faces[4], (vertex2) => vertex2.x === -size.x);
    this._collectVertices(this.faces[5], (vertex2) => vertex2.x === size.x);
    const vCenter = new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Vector3();
    const vRight = new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Vector3();
    const vDir = new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Vector3();
    for (faceIdx = 0; faceIdx < this.faces.length; ++faceIdx) {
      face = this.faces[faceIdx];
      if (face.indices.length === 0) continue;
      vCenter.set(0, 0, 0);
      for (i2 = 0; i2 < face.indices.length; ++i2) {
        vCenter.add(vert[face.indices[i2]]);
      }
      vCenter.multiplyScalar(1 / face.indices.length);
      vRight.subVectors(vert[face.indices[0]], vCenter);
      vRight.normalize();
      const rightProj = [];
      for (i2 = 0; i2 < face.indices.length; ++i2) {
        vDir.subVectors(vert[face.indices[i2]], vCenter);
        rightProj[i2] = vDir.dot(vRight);
      }
      for (i2 = 1; i2 < face.indices.length; ++i2) {
        if (rightProj[i2] < rightProj[0]) {
          let t2 = rightProj[0];
          rightProj[0] = rightProj[i2];
          rightProj[i2] = t2;
          [t2] = face.indices;
          face.indices[0] = face.indices[i2];
          face.indices[i2] = t2;
        }
      }
      this._sortIndices(face, vRight);
    }
    let numIndices = 0;
    for (faceIdx = 0; faceIdx < this.faces.length; ++faceIdx) {
      face = this.faces[faceIdx];
      if (face.indices.length >= 3) {
        numIndices += 3 * (face.indices.length - 2);
      }
    }
    let offset = 0;
    const indices = new Uint16Array(numIndices);
    for (faceIdx = 0; faceIdx < this.faces.length; ++faceIdx) {
      face = this.faces[faceIdx];
      for (i2 = 0; i2 < face.indices.length - 2; ++i2) {
        indices[offset] = face.indices[0];
        indices[offset + 1] = face.indices[i2 + 1];
        indices[offset + 2] = face.indices[i2 + 2];
        offset += 3;
      }
    }
    this.geometry.setIndex(new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.BufferAttribute(indices, 1));
  }
  setDataSource(dataSource) {
    const vm = new shaders_VolumeMaterial.VolumeMaterial();
    const dim = dataSource.getDimensions();
    const stride = dataSource.getTiledTextureStride();
    const texture = dataSource.buildTiledTexture();
    const bbox = dataSource.getBox();
    vm.uniforms.volumeDim.value.set(dim[0], dim[1], dim[2]);
    vm.uniforms.tileTex.value = texture;
    vm.uniforms.tileTexSize.value.set(texture.image.width, texture.image.height);
    vm.uniforms.tileStride.value.set(stride[0], stride[1]);
    Object.assign(this.volumeInfo, dataSource.getVolumeInfo());
    const volInfo = this.volumeInfo;
    vm.uniforms.delta.value.copy(volInfo.delta);
    vm.uniforms.boxAngles.value.set(volInfo.obtuseAngle[0], volInfo.obtuseAngle[1], volInfo.obtuseAngle[2]);
    this.material = vm;
    bbox.getSize(this.scale);
    bbox.getCenter(this.position);
  }
  _updateIsoLevel() {
    const {
      kSigma,
      kSigmaMed,
      kSigmaMax
    } = settings.now.modes.VD;
    const volInfo = this.volumeInfo;
    const mean = volInfo.dmean - volInfo.dmin;
    const span = volInfo.dmax - volInfo.dmin;
    const level = (k2) => (mean + k2 * volInfo.sd) / span;
    this.material.uniforms._isoLevel0.value.set(level(kSigma), level(kSigmaMed), level(kSigmaMax));
  }
  rebuild(camera) {
    const nearClipPlaneOffset = _VolumeMesh._nearClipPlaneOffset;
    const pos = _VolumeMesh._pos;
    const norm = _VolumeMesh._norm;
    const norm4D = _VolumeMesh._norm4D;
    const matrixWorldToLocal = _VolumeMesh._matrixWorldToLocal;
    const clipPlane = _VolumeMesh._clipPlane;
    this._updateIsoLevel();
    camera.getWorldDirection(norm);
    camera.getWorldPosition(pos);
    pos.addScaledVector(norm, camera.near + nearClipPlaneOffset);
    matrixWorldToLocal.copy(this.matrixWorld).invert();
    pos.applyMatrix4(matrixWorldToLocal);
    norm4D.set(norm.x, norm.y, norm.z, 0);
    norm4D.applyMatrix4(matrixWorldToLocal);
    norm.copy(norm4D);
    norm.normalize();
    clipPlane.setFromNormalAndCoplanarPoint(norm, pos);
    if (!this.clipPlane.equals(clipPlane)) {
      this.clipPlane = clipPlane.clone();
      this._updateVertices();
      this._updateIndices();
    }
  }
};
__publicField(_VolumeMesh, "_corners", /* @__PURE__ */ (() => [
  // x, y, z, edge1, edge2, edge3
  [-1, -1, -1, 0, 4, 8],
  [1, -1, -1, 0, 5, 9],
  [1, 1, -1, 1, 5, 10],
  [-1, 1, -1, 1, 4, 11],
  [-1, -1, 1, 2, 6, 8],
  [1, -1, 1, 2, 7, 9],
  [1, 1, 1, 3, 7, 10],
  [-1, 1, 1, 3, 6, 11]
])());
__publicField(_VolumeMesh, "_edges", /* @__PURE__ */ (() => [
  // corner1, corner2, center_x, center_y, center_z
  [0, 1, 0, -1, -1],
  [2, 3, 0, 1, -1],
  [4, 5, 0, -1, 1],
  [6, 7, 0, 1, 1],
  [0, 3, -1, 0, -1],
  [1, 2, 1, 0, -1],
  [4, 7, -1, 0, 1],
  [5, 6, 1, 0, 1],
  [0, 4, -1, -1, 0],
  [1, 5, 1, -1, 0],
  [2, 6, -1, 1, 0],
  [3, 7, 1, 1, 0]
])());
__publicField(_VolumeMesh, "_edgeIntersections", function() {
  const edgeIntersections = [];
  for (let j = 0; j < 12; ++j) {
    edgeIntersections.push(new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Vector3());
  }
  return edgeIntersections;
}());
__publicField(_VolumeMesh, "_nearClipPlaneOffset", 0.2);
__publicField(_VolumeMesh, "_pos", (() => new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Vector3())());
__publicField(_VolumeMesh, "_norm", (() => new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Vector3())());
__publicField(_VolumeMesh, "_norm4D", (() => new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Vector4())());
__publicField(_VolumeMesh, "_matrixWorldToLocal", (() => new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Matrix4())());
__publicField(_VolumeMesh, "_clipPlane", (() => new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Plane())());
var VolumeMesh = _VolumeMesh;
var gfx_VolumeMesh = VolumeMesh;
function _flattenArray(input) {
  const n = input.length;
  const output = new Float32Array(n * 3);
  for (let i2 = 0; i2 < n; ++i2) {
    const j = 3 * i2;
    const v2 = input[i2];
    output[j] = v2.x;
    output[j + 1] = v2.y;
    output[j + 2] = v2.z;
  }
  return output;
}
var _VolumeBounds = class _VolumeBounds {
  constructor(bBox, volInfo) {
    const {
      delta
    } = volInfo;
    const {
      obtuseAngle
    } = volInfo;
    const bSize = new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Vector3();
    bBox.getSize(bSize);
    bSize.multiplyScalar(0.5);
    const offsetVert = this._getBaseVertices(delta, obtuseAngle);
    const geometry = new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.BufferGeometry();
    const vertices = [];
    for (let i2 = 0; i2 < 4; i2++) {
      vertices.push(offsetVert[i2].clone().multiply(bSize));
      vertices.push(offsetVert[(i2 + 1) % 4].clone().multiply(bSize));
    }
    const translation = new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Vector3(2 * bSize.x * (1 - delta.x - delta.y), 0, 0);
    for (let i2 = 0; i2 < 8; i2++) {
      vertices.push(vertices[i2].clone().add(translation));
    }
    for (let i2 = 0; i2 < 4; i2++) {
      vertices.push(vertices[i2 * 2].clone());
      vertices.push(vertices[i2 * 2 + 8].clone());
    }
    const center = new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Vector3();
    bBox.getCenter(center);
    vertices.forEach((vertex2) => vertex2.add(center));
    const flatVertices = _flattenArray(vertices);
    geometry.setAttribute("position", new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.BufferAttribute(flatVertices, 3));
    this._lines = new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.LineSegments(geometry, new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.LineBasicMaterial({
      color: 16777215
    }));
    this._lines.layers.set(gfxutils.LAYERS.VOLUME);
  }
  // Set one edge (4 points) of frame, from which with parallel transfer  the rest of the frame points can be obtained
  _getBaseVertices(delta, obtuseAngle) {
    const projTable = _VolumeBounds._projectionTable;
    const proj = (index, inv) => {
      const currDelta = delta[projTable[index][0]];
      const angleValue = -0.5 * (inv - 1) + inv * obtuseAngle[projTable[index][1]];
      return angleValue * currDelta;
    };
    const offsetVert = [new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Vector3(-1 + 2 * (proj("XZ", 1) + proj("XY", 1)), -1 + 2 * proj("YZ", 1), -1), new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Vector3(-1 + 2 * (proj("XZ", -1) + proj("XY", 1)), -1 + 2 * proj("YZ", -1), 1), new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Vector3(-1 + 2 * (proj("XZ", -1) + proj("XY", -1)), 1 - 2 * proj("YZ", 1), 1), new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Vector3(-1 + 2 * (proj("XZ", 1) + proj("XY", -1)), 1 - 2 * proj("YZ", -1), -1)];
    return offsetVert;
  }
  getMesh() {
    return this._lines;
  }
};
__publicField(_VolumeBounds, "_projectionTable", {
  // corresponds between (origin axes and angles between them) and between saving vector coordinates
  XY: ["x", 2],
  XZ: ["y", 1],
  YZ: ["z", 0]
});
var VolumeBounds = _VolumeBounds;
var gfx_VolumeBounds = VolumeBounds;
var VolumeFarPlane = class {
  // create plane with unit corners coords (for future rescale in vshader according to camera properties)
  constructor(volume, width, height) {
    const planeGeo = this._initPlaneGeo(width, height);
    const mat = new shaders_VolumeMaterial.BackFacePosMaterialFarPlane();
    this._plane = new meshes.Mesh(planeGeo, mat);
    this._plane.frustumCulled = false;
    this._plane.doubleSided = true;
    const matWorldToVolume = new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Matrix4();
    this._plane._onBeforeRender = function(_renderer, _scene, camera, _geometry2, _material, _group) {
      const {
        material
      } = this;
      if (!volume || !material) {
        return;
      }
      const planeCamPos = new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Vector4(0, 0, -(camera.far - 0.1), 1);
      planeCamPos.applyMatrix4(camera.matrixWorld);
      this.matrix.identity();
      this.matrix.makeTranslation(planeCamPos.x, planeCamPos.y, planeCamPos.z);
      this.matrixWorld.copy(this.matrix);
      this.modelViewMatrix.multiplyMatrices(camera.matrixWorldInverse, this.matrixWorld);
      this.normalMatrix.getNormalMatrix(this.modelViewMatrix);
      const volumeMatrix = volume.matrixWorld;
      matWorldToVolume.copy(volumeMatrix).invert();
      material.uniforms.aspectRatio.value = camera.aspect;
      material.uniforms.farZ.value = camera.far;
      material.uniforms.tanHalfFOV.value = Math.tan(external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.MathUtils.DEG2RAD * 0.5 * camera.fov);
      material.uniforms.matWorld2Volume.value = matWorldToVolume;
    };
    this._plane.layers.set(gfxutils.LAYERS.VOLUME_BFPLANE);
  }
  _initPlaneGeo(width, height) {
    const planeGeo = new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.BufferGeometry();
    width = width || 1;
    height = height || 1;
    const vertices = new Float32Array([-0.5 * width, 0.5 * height, 0, 0.5 * width, 0.5 * height, 0, -0.5 * width, -0.5 * height, 0, 0.5 * width, -0.5 * height, 0]);
    planeGeo.setAttribute("position", new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.BufferAttribute(vertices, 3));
    planeGeo.setIndex([0, 2, 1, 2, 3, 1]);
    return planeGeo;
  }
  getMesh() {
    return this._plane;
  }
};
var gfx_VolumeFarPlane = VolumeFarPlane;
var VolumeVisual = class extends src_Visual {
  constructor(name, dataSource) {
    super(name, dataSource);
    this._mesh = new gfx_VolumeMesh();
    this._mesh.setDataSource(dataSource);
    this.add(this._mesh);
    this._frame = new gfx_VolumeBounds(this.getBoundaries().boundingBox, this._mesh.volumeInfo);
    this.add(this._frame.getMesh());
    this.showFrame(settings.now.modes.VD.frame);
    this._farPlane = new gfx_VolumeFarPlane(this._mesh, 2, 2);
    this.add(this._farPlane.getMesh());
  }
  getBoundaries() {
    const box = this._dataSource.getBox();
    const sphere = new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Sphere();
    box.getBoundingSphere(sphere);
    return {
      boundingBox: box,
      boundingSphere: sphere
    };
  }
  getMesh() {
    return this._mesh;
  }
  showFrame(needShow) {
    this._frame.getMesh().material.visible = needShow;
  }
};
var src_VolumeVisual = VolumeVisual;
var LoaderList = class extends utils_EntityList {
  /**
   * Create a list of loaders.
   * The loaders are indexed by supported source types (`.types` property of a Loader
   * subclass).
   * The loaders can be retrieved later by matching against specs (see {@link LoaderList#find}).
   *
   * @param {!Array<function(new:Loader)>=} someLoaders A list of {@link Loader} subclasses to
   *   automatically register at creation time.
   * @see LoaderList#register
   */
  constructor() {
    let someLoaders = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
    super(someLoaders, ["types"]);
  }
  /**
   * Find a suitable loader for a source type.
   *
   * @param {Object} specs Loader specifications.
   * @param {string=} specs.type Supported source type.
   * @param {*=} specs.source Source to load from.
   */
  find(specs) {
    let list = [];
    if (specs.type) {
      list = this._dict.types[specs.type.toLowerCase()] || [];
    } else if (specs.source) {
      return this._list.filter((SomeLoader) => SomeLoader.canProbablyLoad && SomeLoader.canProbablyLoad(specs.source));
    }
    return [...list];
  }
};
var loaders_LoaderList = LoaderList;
var Loader2 = class extends utils_EventDispatcher {
  constructor(source, options2) {
    super();
    this._source = source;
    this._options = options2 || {};
    this._abort = false;
    this._agent = null;
  }
  load() {
    return Promise.reject(new Error("Loading from this source is not implemented"));
  }
  abort() {
    this._abort = true;
    if (this._agent) {
      this._agent.abort();
    }
  }
  static extractName(_source) {
    return void 0;
  }
};
utils_makeContextDependent(Loader2.prototype);
var FileLoader2 = class extends Loader2 {
  constructor(source, options2) {
    super(source, options2);
    options2 = this._options;
    this._binary = options2.binary === true;
  }
  load() {
    return new Promise((resolve, reject) => {
      if (this._abort) {
        throw new Error("Loading aborted");
      }
      const blob = this._source;
      const reader = this._agent = new FileReader();
      reader.addEventListener("load", () => {
        resolve(reader.result);
      });
      reader.addEventListener("error", () => {
        reject(reader.error);
      });
      reader.addEventListener("abort", () => {
        reject(new Error("Loading aborted"));
      });
      reader.addEventListener("progress", (event) => {
        this.dispatchEvent(event);
      });
      if (this._binary) {
        reader.readAsArrayBuffer(blob);
      } else {
        reader.readAsText(blob);
      }
    });
  }
  static canProbablyLoad(source) {
    return File && source instanceof File || Blob && source instanceof Blob;
  }
  static extractName(source) {
    return source && source.name;
  }
};
FileLoader2.types = ["file", "blob"];
var urlStartRegexp = /^(https?|ftp):\/\//i;
var XHRLoader = class extends Loader2 {
  constructor(source, options2) {
    super(source, options2);
    options2 = this._options;
    this._binary = options2.binary === true;
  }
  load() {
    return new Promise((resolve, reject) => {
      if (this._abort) {
        throw new Error("Loading aborted");
      }
      const url = this._source;
      const request = this._agent = new XMLHttpRequest();
      request.addEventListener("load", () => {
        if (request.status === 200) {
          resolve(request.response);
        } else {
          reject(new Error(`HTTP ${request.status} while fetching ${url}`));
        }
      });
      request.addEventListener("error", () => {
        reject(new Error("HTTP request failed"));
      });
      request.addEventListener("abort", () => {
        reject(new Error("Loading aborted"));
      });
      request.addEventListener("progress", (event) => {
        this.dispatchEvent(event);
      });
      request.open("GET", url);
      if (this._binary) {
        request.responseType = "arraybuffer";
      } else {
        request.responseType = "text";
      }
      request.send();
    });
  }
  static canProbablyLoad(source) {
    return external_module_lodash_commonjs_lodash_commonjs2_lodash_amd_lodash_root_namespaceObject["default"].isString(source) && urlStartRegexp.test(source);
  }
  static extractName(source) {
    if (source) {
      const last = (source.indexOf("?") + 1 || source.lastIndexOf("#") + 1 || source.length + 1) - 1;
      return source.slice(source.lastIndexOf("/", last) + 1, last);
    }
    return void 0;
  }
};
XHRLoader.types = ["url"];
var ImmediateLoader = class extends Loader2 {
  load() {
    return new Promise((resolve) => {
      if (this._abort) {
        throw new Error("Loading aborted");
      }
      resolve(this._source);
    });
  }
  static canProbablyLoad(_source) {
    return false;
  }
};
ImmediateLoader.types = ["immediate"];
var loaders = new loaders_LoaderList([
  // note: order might be important
  FileLoader2,
  XHRLoader,
  ImmediateLoader
]);
var ParserList = class extends utils_EntityList {
  /**
   * Create a list of parsers.
   * The parsers are indexed by supported data formats and file extensions (`.formats` and
   * `.extensions` properties of a Parser subclass).
   * The parsers can be retrieved later by matching against specs (see {@link ParsrerList#find}).
   *
   * @param {!Array<function(new:Parser)>=} someParsers A list of {@link Parser} subclasses to
   *   automatically register at creation time.
   * @see ParserList#register
   */
  constructor() {
    let someParsers = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
    super(someParsers, ["formats", "extensions"]);
  }
  /**
   * Find a suitable parser for data.
   *
   * @param {Object} specs Parser specifications.
   * @param {string=} specs.format Supported data format.
   * @param {string=} specs.ext Supported filename extension.
   * @param {*=} specs.data Data to parse.
   */
  find(specs) {
    let list = [];
    if (specs.format) {
      list = this._dict.formats[specs.format.toLowerCase()] || [];
    } else if (specs.ext) {
      list = this._dict.extensions[specs.ext.toLowerCase()] || [];
    }
    if (list.length === 0 && !specs.format && specs.data) {
      return this._list.filter((SomeParser) => SomeParser.canProbablyParse && SomeParser.canProbablyParse(specs.data));
    }
    return [...list];
  }
};
var parsers_ParserList = ParserList;
var Parser = class {
  constructor(data, options2) {
    this._data = data;
    this._options = options2 || {};
    this._abort = false;
  }
  parseSync() {
    throw new Error("Parsing this type of data is not implemented");
  }
  parse() {
    return new Promise((resolve, reject) => {
      setTimeout(() => {
        try {
          if (this._abort) {
            return reject(new Error("Parsing aborted"));
          }
          return resolve(this.parseSync());
        } catch (error) {
          return reject(error);
        }
      });
    });
  }
  // only for volume Parsers
  getModel() {
    this.model._parseHeader(this._data);
    return this.model;
  }
  abort() {
    this._abort = true;
  }
};
utils_makeContextDependent(Parser.prototype);
var Remark290 = class {
  constructor() {
    this.matrices = [];
    this._matrix = null;
    this._matrixIndex = -1;
  }
  /**
   * Parse a single line of a stream.
   * @param {PDBStream} stream - stream to parse
   */
  parse(stream) {
    let matrix = this._matrix;
    if (stream.readString(12, 18) === "  SMTRY") {
      const matrixRow = stream.readCharCode(19) - 49;
      const matrixData = stream.readString(20, 80).trim().split(/\s+/);
      const matrixIndex = parseInt(matrixData[0], 10);
      if (this._matrix === null || matrixIndex !== this._matrixIndex) {
        this._matrixIndex = matrixIndex;
        this._matrix = matrix = new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Matrix4();
        this.matrices[this.matrices.length] = matrix;
      }
      const {
        elements
      } = matrix;
      elements[matrixRow] = parseFloat(matrixData[1]);
      elements[matrixRow + 4] = parseFloat(matrixData[2]);
      elements[matrixRow + 8] = parseFloat(matrixData[3]);
      elements[matrixRow + 12] = parseFloat(matrixData[4]);
    }
  }
};
Remark290.prototype.id = 290;
var pdb_Remark290 = Remark290;
var {
  Assembly: Remark350_Assembly
} = chem;
var Remark350 = class {
  constructor(complex) {
    this._complex = complex;
    this.assemblies = [];
    this._assembly = null;
    this._matrix = null;
    this._matrixIndex = -1;
  }
  /**
   * Parse a single line of a stream.
   * @param {PDBStream} stream - stream to parse
   */
  parse(stream) {
    let assembly = this._assembly;
    let matrix = this._matrix;
    if (assembly && stream.readString(12, 18) === "  BIOMT") {
      const matrixRow = stream.readCharCode(19) - 49;
      const matrixData = stream.readString(20, 80).trim().split(/\s+/);
      const matrixIndex = parseInt(matrixData[0], 10);
      if (this._matrix === null || matrixIndex !== this._matrixIndex) {
        this._matrixIndex = matrixIndex;
        this._matrix = matrix = new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Matrix4();
        assembly.addMatrix(matrix);
      }
      const {
        elements
      } = matrix;
      elements[matrixRow] = parseFloat(matrixData[1]);
      elements[matrixRow + 4] = parseFloat(matrixData[2]);
      elements[matrixRow + 8] = parseFloat(matrixData[3]);
      elements[matrixRow + 12] = parseFloat(matrixData[4]);
    } else if (assembly && stream.readString(35, 41) === "CHAINS:") {
      const entries = stream.readString(42, 80).split(",");
      for (let i2 = 0, n = entries.length; i2 < n; ++i2) {
        const chain = entries[i2].trim();
        if (chain.length > 0) {
          assembly.addChain(chain);
        }
      }
    } else if (stream.readString(12, 23) === "BIOMOLECULE:") {
      this._matrix = null;
      this._matrixIndex = -1;
      this._assembly = assembly = new Remark350_Assembly(this._complex);
      this.assemblies.push(assembly);
    }
  }
};
Remark350.prototype.id = 350;
var pdb_Remark350 = Remark350;
var PDBStream = class {
  /**
   * Create a stream
   * @param {String} data Input data
   */
  constructor(data) {
    this._data = data;
    this._start = 0;
    this._nextCR = -1;
    this._nextLF = -1;
    this._next = -1;
    this._end = data.length;
    this.next();
  }
  /**
   * Reading next line.
   * @returns {String} Next line in data (ending with LF or CR)
   */
  readLine() {
    return this._data.slice(this._start, this._next);
  }
  /**
   * Reading character from position.
   * @param {Number} pos - Position in current line.
   * @returns {String} Character from position
   */
  readChar(pos) {
    pos = this._start + pos - 1;
    return pos < this._next ? this._data[pos] : " ";
  }
  /**
   * Reading character code from position.
   * @param {Number} pos - Position in current line.
   * @returns {Number} Character code from position
   */
  readCharCode(pos) {
    pos = this._start + pos - 1;
    return pos < this._next ? this._data.charCodeAt(pos) : 32;
  }
  /**
   * Reading string from begin to end points.
   * For a reason unknown, numbering assumed not to start from 0, but from 1.
   * @param {Number} begin - Begin point in current line.
   * @param {Number} end - End point in current line.
   * @returns {String} String from begin to end
   */
  readString(begin, end) {
    const from = this._start + begin - 1;
    const to = this._start + end;
    return this._data.slice(from, to < this._next ? to : this._next);
  }
  /**
   * Reading integer from begin to end points.
   * @param {Number} begin - Begin point in current line.
   * @param {Number} end - End point in current line.
   * @returns {Number} Integer from begin to end
   */
  readInt(begin, end) {
    return parseInt(this.readString(begin, end), 10);
  }
  /**
   * Reading float from begin to end points.
   * @param {Number} begin - Begin point in current line.
   * @param {Number} end - End point in current line.
   * @returns {Number} Float from begin to end
   */
  readFloat(begin, end) {
    return parseFloat(this.readString(begin, end));
  }
  /**
   * Checking for end of data.
   * @returns {boolean} True if data is ended, false otherwise
   */
  end() {
    return this._start >= this._end;
  }
  /**
   * Procedure to re-arrange current pointers in data.
   */
  next() {
    const start = this._next + 1;
    this._start = start < this._end ? start : this._end;
    if (this._start > this._nextCR) {
      this._nextCR = (this._data.indexOf("\r", this._start) + 1 || this._end + 1) - 1;
    }
    if (this._start > this._nextLF) {
      this._nextLF = (this._data.indexOf("\n", this._start) + 1 || this._end + 1) - 1;
    }
    this._next = this._nextCR + 1 < this._nextLF ? this._nextCR : this._nextLF;
  }
};
var parsers_PDBStream = PDBStream;
var {
  Complex: PDBParser_Complex,
  Element: PDBParser_Element,
  Helix: PDBParser_Helix,
  Sheet: PDBParser_Sheet,
  Strand: PDBParser_Strand,
  Bond: PDBParser_Bond,
  Molecule: PDBParser_Molecule
} = chem;
var TAG_LENGTH = 6;
function nameToElement(name) {
  const veryLong = name.trim().length === 4;
  return name.slice(0, veryLong ? 1 : 2).trim();
}
var pdbStartRegexp = /^(HEADER\s|COMPND\s|REMARK\s|ATOM {2}|HETATM|MODEL )/i;
var remarkParsers = {
  // NOTE: please forget the idea to build the method name in runtime, it can be obfuscated.
  290: pdb_Remark290,
  350: pdb_Remark350
};
var _PDBParser = class _PDBParser extends Parser {
  constructor(data, options2) {
    super(data, options2);
    this._complex = null;
    this._chain = null;
    this._residue = null;
    this._sheet = null;
    this._serialAtomMap = null;
    this._modelId = 1;
    this._compaundFound = false;
    this._biomoleculeFound = false;
    this._allowedChainsIDs = null;
    this._lastMolId = -1;
    this._remarks = {};
    this._remark = null;
    this._molecules = [];
    this._molecule = null;
    this._compndCurrToken = "";
    this._options.fileType = "pdb";
  }
  static canProbablyParse(data) {
    return external_module_lodash_commonjs_lodash_commonjs2_lodash_amd_lodash_root_namespaceObject["default"].isString(data) && pdbStartRegexp.test(data);
  }
  _finalize() {
    this._fixBondsArray();
    this._fixChains();
    const remark290 = this._remarks[290];
    this._complex.symmetry = external_module_lodash_commonjs_lodash_commonjs2_lodash_amd_lodash_root_namespaceObject["default"].isUndefined(remark290) ? [] : remark290.matrices;
    const remark350 = this._remarks[350];
    this._complex.units = this._complex.units.concat(external_module_lodash_commonjs_lodash_commonjs2_lodash_amd_lodash_root_namespaceObject["default"].isUndefined(remark350) ? [] : remark350.assemblies);
    this._finalizeMolecules();
    this._complex.finalize({
      needAutoBonding: true,
      detectAromaticLoops: this.settings.now.aromatic,
      enableEditing: this.settings.now.editing,
      serialAtomMap: this._serialAtomMap
    });
  }
  _finalizeMolecules() {
    const chainDict = {};
    let i2;
    const chains = this._complex._chains;
    for (i2 = 0; i2 < chains.length; ++i2) {
      const chainObj = chains[i2];
      const chainName = chainObj._name;
      chainDict[chainName] = chainObj;
    }
    for (i2 = 0; i2 < this._molecules.length; i2++) {
      const m2 = this._molecules[i2];
      let residues = [];
      for (let j = 0; j < m2._chains.length; j++) {
        const name = m2._chains[j];
        const chain = chainDict[name];
        residues = residues.concat(chain._residues.slice());
      }
      const molecule = new PDBParser_Molecule(this._complex, m2._name, i2 + 1);
      molecule.residues = residues;
      this._complex._molecules[i2] = molecule;
    }
  }
  _fixChains() {
    const idChainMap = {};
    const complex = this._complex;
    for (let i2 = 0; i2 < complex._chains.length; i2++) {
      const chain = complex._chains[i2];
      idChainMap[chain._name.charCodeAt(0)] = chain;
    }
  }
  // FIXME: This function is redundant, CONECT records always follow ATOM and HETATM. Build the map online.
  _fixBondsArray() {
    const serialAtomMap = this._serialAtomMap = {};
    const complex = this._complex;
    const atoms = complex._atoms;
    for (let i2 = 0, ni = atoms.length; i2 < ni; ++i2) {
      const atom = atoms[i2];
      serialAtomMap[atom.serial] = atom;
    }
    const bonds = complex._bonds;
    const {
      logger: logger2
    } = this;
    for (let j = 0, nj = bonds.length; j < nj; ++j) {
      const bond = bonds[j];
      if (bond._right < bond._left) {
        logger2.debug("_fixBondsArray: Logic error.");
      }
      bond._left = serialAtomMap[bond._left] || null;
      bond._right = serialAtomMap[bond._right] || null;
    }
  }
  _parseATOM(stream) {
    if (this._modelId !== 1) {
      return;
    }
    const het = stream.readCharCode(1) === 72;
    const serial = het ? stream.readInt(7, 11) : stream.readInt(6, 11);
    let name = stream.readString(13, 16);
    const altLoc = stream.readChar(17);
    const resName = stream.readString(18, 20).trim();
    const chainID = stream.readChar(22);
    const resSeq = stream.readInt(23, 26);
    const iCode = stream.readChar(27);
    const x3 = stream.readFloat(31, 38);
    const y2 = stream.readFloat(39, 46);
    const z = stream.readFloat(47, 54);
    const occupancy = stream.readFloat(55, 60);
    const tempFactor = stream.readFloat(61, 66);
    const element = stream.readString(77, 78).trim() || nameToElement(name);
    const charge = stream.readInt(79, 80) || 0;
    if (this.settings.now.nowater) {
      if (resName === "HOH" || resName === "WAT") {
        return;
      }
    }
    name = name.trim();
    const type = PDBParser_Element.getByName(element);
    const role = PDBParser_Element.Role[name];
    let chain = this._chain;
    if (!chain || chain.getName() !== chainID) {
      this._chain = chain = this._complex.getChain(chainID) || this._complex.addChain(chainID);
      this._residue = null;
    }
    let residue = this._residue;
    if (!residue || residue.getSequence() !== resSeq || residue.getICode() !== iCode) {
      this._residue = residue = chain.addResidue(resName, resSeq, iCode);
    }
    const xyz = new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Vector3(x3, y2, z);
    residue.addAtom(name, type, xyz, role, het, serial, altLoc, occupancy, tempFactor, charge);
  }
  _parseENDMDL() {
    this._modelId += 1;
  }
  _parseCONECT(stream) {
    const serial0 = stream.readInt(7, 11);
    const serial1 = stream.readInt(12, 16);
    const serial2 = stream.readInt(17, 21);
    const serial3 = stream.readInt(22, 26);
    const serial4 = stream.readInt(27, 31);
    const complex = this._complex;
    if (serial1 && serial1 > serial0) {
      complex.addBond(serial0, serial1, 0, PDBParser_Bond.BondType.UNKNOWN, true);
    }
    if (serial2 && serial2 > serial0) {
      complex.addBond(serial0, serial2, 0, PDBParser_Bond.BondType.UNKNOWN, true);
    }
    if (serial3 && serial3 > serial0) {
      complex.addBond(serial0, serial3, 0, PDBParser_Bond.BondType.UNKNOWN, true);
    }
    if (serial4 && serial4 > serial0) {
      complex.addBond(serial0, serial4, 0, PDBParser_Bond.BondType.UNKNOWN, true);
    }
  }
  _parseCOMPND(stream) {
    const str = stream.readString(11, 80);
    const tokenIdx = str.indexOf(":");
    this._compndCurrToken = tokenIdx > 0 ? str.substring(0, tokenIdx).trim() : this._compndCurrToken;
    if (this._compndCurrToken === "MOL_ID") {
      this._molecule = {
        _index: "",
        _chains: []
      };
      this._molecule._index = parseInt(str.substring(tokenIdx + 1, str.indexOf(";")), 10);
      this._molecules.push(this._molecule);
    } else if (this._compndCurrToken === "MOLECULE" && this._molecule != null) {
      this._molecule._name = str.substring(tokenIdx + 1, str.indexOf(";")).trim();
    } else if (this._compndCurrToken === "CHAIN" && this._molecule != null) {
      let chainStr = str.substring(tokenIdx + 1, 80).trim();
      const lastChar = chainStr[chainStr.length - 1];
      if (lastChar === ";" || lastChar === ",") {
        chainStr = chainStr.slice(0, -1);
      }
      chainStr = chainStr.replace(/\s+/g, "");
      const chains = chainStr.split(",");
      this._molecule._chains = this._molecule._chains.concat(chains);
    }
  }
  _parseREMARK(stream) {
    const remarkNum = stream.readInt(8, 10);
    let remark = this._remarks[remarkNum];
    if (external_module_lodash_commonjs_lodash_commonjs2_lodash_amd_lodash_root_namespaceObject["default"].isUndefined(remark)) {
      const RemarkParser = remarkParsers[remarkNum];
      if (external_module_lodash_commonjs_lodash_commonjs2_lodash_amd_lodash_root_namespaceObject["default"].isFunction(RemarkParser)) {
        this._remarks[remarkNum] = remark = new RemarkParser(this._complex);
      }
    }
    if (!external_module_lodash_commonjs_lodash_commonjs2_lodash_amd_lodash_root_namespaceObject["default"].isUndefined(remark)) {
      remark.parse(stream);
    }
  }
  _parseHELIX(stream) {
    const fields = [20, 22, 32, 34];
    this._parseSTRUCTURE(stream, fields, (obj) => {
      this._complex.addHelix(obj);
      this._complex.structures.push(obj);
    });
  }
  _parseSHEET(stream) {
    const fields = [22, 23, 33, 34];
    this._parseSTRUCTURE(stream, fields, (obj) => {
      this._complex.addSheet(obj);
    });
  }
  _parseSTRUCTURE(stream, pars, adder) {
    const startId = 0;
    const startIndex = 1;
    const endId = 2;
    const endIndex = 3;
    const codeOfS = 83;
    const serialNumber = stream.readInt(8, 10);
    const structureName = stream.readString(12, 14).trim();
    const comment = stream.readString(41, 70).trim();
    const helLength = stream.readInt(72, 76);
    const helixClass = stream.readInt(39, 40);
    const shWidth = stream.readInt(15, 16);
    const shCur = stream.readInt(42, 45);
    const shPrev = stream.readInt(57, 60);
    const startChainID = stream.readString(pars[startId], pars[endId] + 1).charCodeAt(0);
    const endChainID = stream.readString(pars[endId], pars[endId] + 1).charCodeAt(0);
    const startSequenceNumber = stream.readInt(pars[startIndex], pars[startIndex] + 3);
    let iCodeStr = stream.readString(pars[startIndex] + 4, pars[startIndex] + 4);
    let startICode = 0;
    if (iCodeStr.length > 0) {
      startICode = iCodeStr.charCodeAt(0);
    }
    const endSequenceNumber = stream.readInt(pars[endIndex], pars[endIndex] + 3);
    iCodeStr = stream.readString(pars[endIndex] + 4, pars[endIndex] + 4);
    let endICode = 0;
    if (iCodeStr.length > 0) {
      endICode = iCodeStr.charCodeAt(0);
    }
    let obj;
    let cs = this._sheet;
    if (stream.readCharCode(1) === codeOfS) {
      if (cs !== null && cs.getName() !== structureName) {
        cs = null;
        this._sheet = null;
      }
      if (cs === null) {
        this._sheet = obj = new PDBParser_Sheet(structureName, shWidth);
        adder(obj);
      } else {
        obj = cs;
      }
      const strand = new PDBParser_Strand(obj, this._complex.getUnifiedSerial(startChainID, startSequenceNumber, startICode), this._complex.getUnifiedSerial(endChainID, endSequenceNumber, endICode), helixClass, shCur, shPrev);
      obj.addStrand(strand);
      this._complex.structures.push(strand);
    } else {
      obj = new PDBParser_Helix(helixClass, this._complex.getUnifiedSerial(startChainID, startSequenceNumber, startICode), this._complex.getUnifiedSerial(endChainID, endSequenceNumber, endICode), serialNumber, structureName, comment, helLength);
      adder(obj);
    }
  }
  _parseHEADER(stream) {
    const {
      metadata
    } = this._complex;
    metadata.classification = stream.readString(11, 50).trim();
    metadata.date = stream.readString(51, 59).trim();
    const id2 = stream.readString(63, 66).trim();
    metadata.id = id2;
    if (id2) {
      this._complex.name = id2;
    }
    metadata.format = "pdb";
  }
  _parseTITLE(stream) {
    const {
      metadata
    } = this._complex;
    metadata.title = metadata.title || [];
    const line = stream.readInt(9, 10) || 1;
    metadata.title[line - 1] = stream.readString(11, 80).trim();
  }
  parseSync() {
    const stream = new parsers_PDBStream(this._data);
    const result = this._complex = new PDBParser_Complex();
    while (!stream.end()) {
      const tag = stream.readString(1, TAG_LENGTH);
      const func = _PDBParser.tagParsers[tag];
      if (external_module_lodash_commonjs_lodash_commonjs2_lodash_amd_lodash_root_namespaceObject["default"].isFunction(func)) {
        func.call(this, stream);
      }
      stream.next();
    }
    this._finalize();
    this._serialAtomMap = null;
    this._sheet = null;
    this._residue = null;
    this._chain = null;
    this._complex = null;
    if (result.getAtomCount() === 0) {
      throw new Error("The data does not contain valid atoms");
    }
    return result;
  }
};
__publicField(_PDBParser, "tagParsers", (() => ({
  HEADER: _PDBParser.prototype._parseHEADER,
  "TITLE ": _PDBParser.prototype._parseTITLE,
  "ATOM  ": _PDBParser.prototype._parseATOM,
  HETATM: _PDBParser.prototype._parseATOM,
  ENDMDL: _PDBParser.prototype._parseENDMDL,
  CONECT: _PDBParser.prototype._parseCONECT,
  COMPND: _PDBParser.prototype._parseCOMPND,
  REMARK: _PDBParser.prototype._parseREMARK,
  // 'SOURCE': PDBParser.prototype._parseSOURCE,
  "HELIX ": _PDBParser.prototype._parseHELIX,
  "SHEET ": _PDBParser.prototype._parseSHEET,
  // nonstandard extension to allow range 100,000 - 999,999
  "ATOM 1": _PDBParser.prototype._parseATOM,
  "ATOM 2": _PDBParser.prototype._parseATOM,
  "ATOM 3": _PDBParser.prototype._parseATOM,
  "ATOM 4": _PDBParser.prototype._parseATOM,
  "ATOM 5": _PDBParser.prototype._parseATOM,
  "ATOM 6": _PDBParser.prototype._parseATOM,
  "ATOM 7": _PDBParser.prototype._parseATOM,
  "ATOM 8": _PDBParser.prototype._parseATOM,
  "ATOM 9": _PDBParser.prototype._parseATOM
}))());
var PDBParser = _PDBParser;
PDBParser.formats = ["pdb"];
PDBParser.extensions = [".pdb", ".ent"];
var parsers_PDBParser = PDBParser;
var {
  Complex: CMLParser_Complex,
  Element: CMLParser_Element,
  SGroup: CMLParser_SGroup,
  Bond: CMLParser_Bond
} = chem;
var cOrderCharCodes = {
  A: 0,
  S: 1,
  D: 2,
  T: 3
};
var cmlStartRegexp = /\s*<\?xml\b[^?>]*\?>\s*<(?:cml|molecule)\b/i;
var CMLParser = class extends Parser {
  constructor(data, options2) {
    super(data, options2);
    this._complex = null;
    this._residue = null;
    this._serialAtomMap = null;
    this._modelId = 1;
    this._lastMolId = -1;
    this._readOnlyOneMolecule = false;
    this._options.fileType = "cml";
  }
  static canProbablyParse(data) {
    return external_module_lodash_commonjs_lodash_commonjs2_lodash_amd_lodash_root_namespaceObject["default"].isString(data) && cmlStartRegexp.test(data);
  }
  _rebuidBondIndexes(atoms, bonds) {
    const count = atoms.length;
    for (let i2 = 0; i2 < count; i2++) {
      const atomId = atoms[i2].id;
      const countBonds = bonds.length;
      for (let j = 0; j < countBonds; j++) {
        const idxs = bonds[j].atomRefs2.split(" ");
        if (idxs[0] === atomId) {
          bonds[j].start = i2;
        }
        if (idxs[1] === atomId) {
          bonds[j].end = i2;
        }
      }
    }
  }
  _createSGroup(molecule, moleculeArr) {
    const newGroup = new CMLParser_SGroup(molecule.id, molecule.fieldData, new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Vector3(parseFloat(molecule.x), parseFloat(molecule.y), 0), molecule.atomRefs, molecule);
    if (molecule.placement === "Relative") {
      newGroup._center = new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Vector3(0, 0, 0);
    }
    if (molecule.fieldName === "MDLBG_FRAGMENT_CHARGE") {
      newGroup._charge = parseInt(molecule.fieldData, 10) || 0;
    }
    if (molecule.fieldName === "MDLBG_FRAGMENT_COEFFICIENT") {
      newGroup._repeat = parseInt(molecule.fieldData, 10) || 1;
    }
    moleculeArr.push(newGroup);
  }
  _extractSGroup(molecule, moleculeArr) {
    if (!Array.isArray(moleculeArr)) {
      moleculeArr = [];
    }
    if (molecule) {
      if (Array.isArray(molecule)) {
        const count = molecule.length;
        for (let i2 = 0; i2 < count; i2++) {
          if (molecule[i2].molecule) {
            moleculeArr = moleculeArr.concat(this._extractSGroup(molecule[i2].molecule));
          }
          this._createSGroup(molecule[i2], moleculeArr);
        }
      } else {
        if (molecule.molecule) {
          if (molecule.molecule) {
            moleculeArr = moleculeArr.concat(this._extractSGroup(molecule.molecule));
          }
        }
        this._createSGroup(molecule, moleculeArr);
      }
    }
    return moleculeArr;
  }
  _extractSGroups(molecule, atoms) {
    const moleculeArr = this._extractSGroup(molecule);
    const count = atoms.length;
    let i2;
    let j;
    for (i2 = 0; i2 < count; i2++) {
      const atomId = atoms[i2].id;
      for (j = 0; j < moleculeArr.length; j++) {
        const firstAtomRef = moleculeArr[j]._atoms.split(" ")[0];
        if (firstAtomRef === atomId) {
          if (!atoms[i2].sgroupRef) {
            atoms[i2].sgroupRef = [];
          }
          atoms[i2].sgroupRef.push(moleculeArr[j]);
        }
      }
    }
    let atomMap = {};
    let mapEntry = null;
    const nLimon = 1e8;
    const bLow = new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Vector3(nLimon, nLimon, nLimon);
    const bHight = new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Vector3(-nLimon, -nLimon, -nLimon);
    function cycleFuncInner(e2) {
      mapEntry = atomMap[e2];
      if (mapEntry) {
        moleculeArr[j]._atoms.push(mapEntry.a);
      }
    }
    function cycleFunc(e2) {
      mapEntry = atomMap[e2];
      if (mapEntry) {
        bLow.set(Math.min(bLow.x, mapEntry.x), Math.min(bLow.y, mapEntry.y), Math.min(bLow.z, mapEntry.z));
        bHight.set(Math.max(bHight.x, mapEntry.x), Math.max(bHight.y, mapEntry.y), Math.max(bHight.z, mapEntry.z));
        cycleFuncInner(e2);
      }
    }
    for (i2 = 0; i2 < atoms.length; i2++) {
      atomMap[atoms[i2].id] = {};
      atomMap[atoms[i2].id].x = atoms[i2].x2;
      if (atoms[i2].x3) {
        atomMap[atoms[i2].id].x = atoms[i2].x3;
      }
      atomMap[atoms[i2].id].x = parseFloat(atomMap[atoms[i2].id].x);
      atomMap[atoms[i2].id].y = atoms[i2].y2;
      if (atoms[i2].y3) {
        atomMap[atoms[i2].id].y = atoms[i2].y3;
      }
      atomMap[atoms[i2].id].y = parseFloat(atomMap[atoms[i2].id].y);
      atomMap[atoms[i2].id].z = "0.0";
      if (atoms[i2].z3) {
        atomMap[atoms[i2].id].z = atoms[i2].z3;
      }
      atomMap[atoms[i2].id].z = parseFloat(atomMap[atoms[i2].id].z);
      atomMap[atoms[i2].id].a = atoms[i2];
    }
    let atomsRef;
    for (j = 0; j < moleculeArr.length; j++) {
      if (moleculeArr[j]._center !== null) {
        bLow.set(nLimon, nLimon, nLimon);
        bHight.set(-nLimon, -nLimon, -nLimon);
        atomsRef = moleculeArr[j]._atoms.split(" ");
        moleculeArr[j]._atoms = [];
        atomsRef.forEach(cycleFunc);
        moleculeArr[j]._center.addVectors(bLow, bHight);
        moleculeArr[j]._center.multiplyScalar(0.5);
      } else {
        atomsRef = moleculeArr[j]._atoms.split(" ");
        moleculeArr[j]._atoms = [];
        atomsRef.forEach(cycleFuncInner);
      }
    }
    atomMap = null;
  }
  _traverseData(dom) {
    function isArray(o2) {
      return Object.prototype.toString.apply(o2) === "[object Array]";
    }
    function parseNode(xmlNode, result2) {
      if (xmlNode.nodeName === "#text" && xmlNode.nodeValue.trim() === "") {
        return;
      }
      const jsonNode = {};
      jsonNode.xmlNode = xmlNode;
      const existing = result2[xmlNode.nodeName];
      if (existing) {
        if (!isArray(existing)) {
          result2[xmlNode.nodeName] = [existing, jsonNode];
        } else {
          result2[xmlNode.nodeName].push(jsonNode);
        }
      } else {
        result2[xmlNode.nodeName] = jsonNode;
      }
      let length;
      let i2;
      if (xmlNode.attributes) {
        ({
          length
        } = xmlNode.attributes);
        for (i2 = 0; i2 < length; i2++) {
          const attribute = xmlNode.attributes[i2];
          jsonNode[attribute.nodeName] = attribute.nodeValue;
        }
      }
      ({
        length
      } = xmlNode.childNodes);
      for (i2 = 0; i2 < length; i2++) {
        parseNode(xmlNode.childNodes[i2], jsonNode);
      }
    }
    const result = {};
    if (dom.childNodes.length) {
      parseNode(dom.childNodes[0], result);
    }
    return result;
  }
  _findSuitableMolecule(data, molSet) {
    for (const key in data) {
      if (key === "xmlNode") {
        continue;
      } else if (key === "molecule") {
        if (data.molecule) {
          if (data.molecule.atomArray && data.molecule.atomArray.atom) {
            molSet.push(data);
          }
          if (Array.isArray(data.molecule)) {
            for (let i2 = 0; i2 < data.molecule.length; i2++) {
              if (data.molecule[i2].atomArray && data.molecule[i2].atomArray.atom) {
                molSet.push({
                  molecule: data.molecule[i2]
                });
              }
            }
          }
        }
      } else if (data[key] && data[key] !== null && typeof data[key] === "object") {
        this._findSuitableMolecule(data[key], molSet);
      }
    }
  }
  _selectComponents(text) {
    const parser = new DOMParser();
    const doc = parser.parseFromString(text, "application/xml");
    const traversedData = this._traverseData(doc);
    let rawData;
    const self2 = this;
    function prepareComponentCompound(data) {
      let atoms = [];
      if (data.molecule && data.molecule.atomArray && data.molecule.atomArray.atom) {
        if (!Array.isArray(data.molecule.atomArray.atom)) {
          atoms.push(data.molecule.atomArray.atom);
        } else {
          atoms = data.molecule.atomArray.atom;
        }
      } else if (!data.molecule) {
        const ret = {};
        ret.atomLabels = null;
        ret.labelsCount = 1;
        return ret;
      }
      if (data.molecule.molecule) {
        self2._extractSGroups(data.molecule.molecule, atoms);
      }
      let atom;
      let count = atoms.length;
      for (let i2 = 0; i2 < count; i2++) {
        atom = atoms[i2];
        atom.edges = [];
      }
      let localBond = [];
      if (data.molecule.bondArray && data.molecule.bondArray.bond) {
        if (!Array.isArray(data.molecule.bondArray.bond)) {
          localBond.push(data.molecule.bondArray.bond);
        } else {
          localBond = data.molecule.bondArray.bond;
        }
      }
      let bond;
      count = localBond.length;
      self2._rebuidBondIndexes(atoms, localBond);
      function addCurrBond(index) {
        bond = localBond[index];
        atom = atoms[bond.start];
        if (!atom) {
          return false;
        }
        atom.edges.push(bond.end);
        atom = atoms[bond.end];
        if (!atom) {
          return false;
        }
        atom.edges.push(bond.start);
        return true;
      }
      for (let i2 = 0; i2 < count; i2++) {
        if (!addCurrBond(i2)) {
          continue;
        }
        const orderAttr = bond.xmlNode.getAttribute("order");
        const tc = parseInt(orderAttr, 10);
        localBond[i2].order = 0;
        localBond[i2].type = CMLParser_Bond.BondType.UNKNOWN;
        if (tc > 1) {
          localBond[i2].order = tc;
        } else {
          const order = cOrderCharCodes[orderAttr];
          if (order !== void 0) {
            localBond[i2].order = order;
            if (orderAttr === "A") {
              localBond[i2].type = CMLParser_Bond.BondType.AROMATIC;
            }
          }
        }
      }
      count = atoms.length;
      for (let i2 = 0; i2 < count; i2++) {
        atom = atoms[i2];
        atom.edges.sort();
      }
      const labels = self2._breadWidthSearch(atoms, 0);
      const retStruct = {};
      retStruct.atoms = atoms;
      retStruct.bonds = localBond;
      retStruct.labels = labels.atomLabels;
      retStruct.count = Math.min(1, labels.labelsCount);
      retStruct.curr = -1;
      retStruct.originalCML = doc;
      return retStruct;
    }
    if (traversedData.cml) {
      rawData = traversedData.cml;
    } else {
      rawData = traversedData;
    }
    const retData = [];
    const filteredData = [];
    this._findSuitableMolecule(rawData, filteredData);
    if (this._readOnlyOneMolecule && filteredData.length > 1) {
      filteredData.splice(1, filteredData.length - 1);
    }
    filteredData.forEach((d2) => {
      const rd = prepareComponentCompound(d2);
      if (rd.atoms.length > 0) {
        retData.push(rd);
      }
    });
    return retData;
  }
  _packLabel(compId, molId) {
    const shift = 16;
    return (molId << shift) + compId;
  }
  _unpackLabel(l2) {
    const shift = 16;
    const mask = (1 << shift) - 1;
    return {
      molId: l2 >>> shift,
      compId: l2 & mask
    };
  }
  _breadWidthSearch(atoms, molID) {
    const atomLabels = new Array(atoms.length);
    let id2;
    for (id2 = 0; id2 < atomLabels.length; id2++) {
      atomLabels[id2] = this._packLabel(0, molID);
    }
    const breadthQueue = [];
    let componentID = 0;
    let labeledAtoms = atoms.length;
    while (labeledAtoms > 0) {
      componentID++;
      let startID = -1;
      for (id2 = 0; id2 < atomLabels.length; id2++) {
        if (this._unpackLabel(atomLabels[id2]).compId === 0) {
          startID = id2;
          break;
        }
      }
      if (startID < 0) {
        break;
      }
      breadthQueue.push(atoms[startID]);
      atomLabels[startID] = this._packLabel(componentID, molID);
      labeledAtoms--;
      while (breadthQueue.length > 0) {
        const curr = breadthQueue.shift();
        if (!curr) {
          continue;
        }
        for (let i2 = 0; i2 < curr.edges.length; i2++) {
          if (atomLabels[curr.edges[i2]] !== componentID) {
            breadthQueue.push(atoms[curr.edges[i2]]);
            atomLabels[curr.edges[i2]] = componentID;
            labeledAtoms--;
          }
        }
      }
    }
    const ret = {};
    ret.atomLabels = atomLabels;
    ret.labelsCount = componentID;
    return ret;
  }
  _parseBond(eAtom, mainAtom, order, type) {
    if (eAtom >= 0) {
      const h2 = [Math.min(eAtom, mainAtom), Math.max(eAtom, mainAtom)];
      this._complex.addBond(h2[0], h2[1], order, type, true);
    }
  }
  _fixBondsArray() {
    const serialAtomMap = this._serialAtomMap = {};
    const complex = this._complex;
    const atoms = complex._atoms;
    for (let i2 = 0, ni = atoms.length; i2 < ni; ++i2) {
      const atom = atoms[i2];
      serialAtomMap[atom.serial] = atom;
    }
    const bonds = complex._bonds;
    const {
      logger: logger2
    } = this;
    for (let j = 0, nj = bonds.length; j < nj; ++j) {
      const bond = bonds[j];
      if (bond._right < bond._left) {
        logger2.debug("_fixBondsArray: Logic error.");
      }
      bond._left = serialAtomMap[bond._left] || null;
      bond._right = serialAtomMap[bond._right] || null;
    }
  }
  _parseSet(varData) {
    const complex = this._complex = new CMLParser_Complex();
    const data = varData;
    const currentLabel = data.curr;
    const {
      atoms,
      labels
    } = data;
    let atom = null;
    let i2;
    let j;
    const count = atoms.length;
    function addFunc(a2) {
      a2.xmlNodeRef = atom;
      if (atom.x2) {
        atom.x3 = atom.x2;
        delete atom.x2;
      }
      if (atom.y2) {
        atom.y3 = atom.y2;
        delete atom.y2;
      }
      if (!atom.z3) {
        atom.z3 = "0.0";
      }
      atom.complexAtom = a2;
    }
    let chains = {};
    const reorder = [];
    for (i2 = 0; i2 < count; i2++) {
      reorder.push(i2);
    }
    reorder.sort((a2, b2) => labels[a2] - labels[b2]);
    for (i2 = 0; i2 < count; i2++) {
      const atomCharge = 0;
      const lLabel = labels[reorder[i2]];
      if (this._unpackLabel(lLabel).molId === this._unpackLabel(currentLabel).molId) {
        atom = atoms[reorder[i2]];
        const atomFullNameStruct = atom.elementType;
        if (atom.sgroupRef) {
          const countRef = atom.sgroupRef.length;
          for (let k2 = 0; k2 < countRef; ++k2) {
            complex._sgroups.push(atom.sgroupRef[k2]);
          }
        }
        if (atom.x3 || atom.x2) {
          const currAtomComp = this._unpackLabel(lLabel).compId;
          const chainID = " ";
          const resSeq = currAtomComp;
          const iCode = " ";
          let strLabel = currAtomComp.toString();
          if (strLabel.length === 1) {
            strLabel = `0${strLabel}`;
          }
          const resName = `N${strLabel}`;
          let chain = chains[chainID];
          if (!chain || chain.getName() !== chainID) {
            chains[chainID] = chain = this._complex.getChain(chainID) || this._complex.addChain(chainID);
            this._residue = null;
          }
          let residue = this._residue;
          if (!residue || residue.getSequence() !== resSeq || residue.getICode() !== iCode) {
            this._residue = residue = chain.addResidue(resName, resSeq, iCode);
          }
          let xyz = null;
          if (atom.x3) {
            xyz = new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Vector3(parseFloat(atom.x3), parseFloat(atom.y3), parseFloat(atom.z3));
          } else if (atom.x2) {
            xyz = new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Vector3(parseFloat(atom.x2), parseFloat(atom.y2), 0);
          }
          let element = CMLParser_Element.ByName[atom.elementType.toUpperCase()];
          if (!element) {
            element = JSON.parse(JSON.stringify(CMLParser_Element.ByName[Object.keys(CMLParser_Element.ByName)[Object.keys(CMLParser_Element.ByName).length - 1]]));
            element.number += 1;
            element.name = atom.elementType.toUpperCase();
            element.fullName = "Unknown";
            CMLParser_Element.ByName[atom.elementType.toUpperCase()] = element;
          }
          const atomSerial = parseInt(atom.id.replace(/[^0-9]/, ""), 10);
          const added = residue.addAtom(atomFullNameStruct, element, xyz, CMLParser_Element.Role.SG, true, atomSerial, " ", 1, 0, atomCharge);
          if (atom.hydrogenCount) {
            added.hydrogenCount = parseInt(atom.hydrogenCount, 10);
          }
          if (atom.mrvValence) {
            added.valence = parseInt(atom.mrvValence, 10);
          }
          addFunc(added);
        }
      }
    }
    chains = null;
    for (i2 = 0; i2 < data.bonds.length; i2++) {
      const cb = data.bonds[i2];
      if (this._unpackLabel(labels[cb.start]).molId === this._unpackLabel(currentLabel).molId && this._unpackLabel(labels[cb.end]).molId === this._unpackLabel(currentLabel).molId) {
        atom = atoms[cb.start];
        if (!atom || !atoms[cb.end]) {
          continue;
        }
        this._parseBond(parseInt(atom.id.replace(/[^0-9]/, ""), 10), parseInt(atoms[cb.end].id.replace(/[^0-9]/, ""), 10), cb.order, cb.type);
      }
    }
    for (i2 = 0; i2 < this._complex.getSGroupCount(); i2++) {
      const sGrp = this._complex.getSGroups()[i2];
      for (j = 0; j < sGrp._atoms.length; j++) {
        sGrp._atoms[j] = sGrp._atoms[j].complexAtom;
      }
    }
    for (i2 = 0; i2 < count; i2++) {
      if (this._unpackLabel(labels[i2]).molId === this._unpackLabel(currentLabel).molId) {
        atom = atoms[i2];
        atom.complexAtom = null;
        delete atom.complexAtom;
      }
    }
    this._complex.originalCML = data.originalCML;
    this._fixBondsArray();
    complex.finalize({
      needAutoBonding: false,
      detectAromaticLoops: this.settings.now.aromatic,
      enableEditing: this.settings.now.editing,
      serialAtomMap: this._serialAtomMap
    });
    this._serialAtomMap = null;
    this._complex = null;
    return complex;
  }
  parseSync() {
    const complexes = [];
    const self2 = this;
    const moleculaSet = this._selectComponents(this._data);
    moleculaSet.forEach((molSet) => {
      molSet.curr = 2;
      if (molSet.count === 0) {
        molSet.count = 1;
      }
      for (let i2 = 0; i2 < molSet.count; i2++) {
        molSet.curr = i2 + 1;
        complexes.push(self2._parseSet(molSet, false));
      }
    });
    let totalAtomsParsed = 0;
    complexes.forEach((c2) => {
      totalAtomsParsed += c2.getAtomCount();
    });
    if (totalAtomsParsed <= 0) {
      throw new Error("The data does not contain valid atoms");
    }
    if (complexes.length > 1) {
      const joinedComplex = new CMLParser_Complex();
      joinedComplex.joinComplexes(complexes);
      joinedComplex.originalCML = complexes[0].originalCML;
      return joinedComplex;
    }
    if (complexes.length === 1) {
      return complexes[0];
    }
    return new CMLParser_Complex();
  }
};
CMLParser.formats = ["cml"];
CMLParser.extensions = [".cml"];
var parsers_CMLParser = CMLParser;
var mmtf = __webpack_require__(660);
var mmtf_default = __webpack_require__.n(mmtf);
var {
  Complex: MMTFParser_Complex,
  Chain: MMTFParser_Chain,
  Atom: MMTFParser_Atom,
  Element: MMTFParser_Element,
  Helix: MMTFParser_Helix,
  Sheet: MMTFParser_Sheet,
  Strand: MMTFParser_Strand,
  Bond: MMTFParser_Bond,
  Assembly: MMTFParser_Assembly,
  Molecule: MMTFParser_Molecule
} = chem;
var ArrayComparator = class {
  constructor(original) {
    this._original = Array.from(original);
    this._original.sort();
    this._sum = 0;
    for (let i2 = 0; i2 < this._original.length; ++i2) {
      this._sum += this._original[i2];
    }
  }
  compare(candidate) {
    const len = candidate.length;
    if (len !== this._original.length) {
      return false;
    }
    let sum = 0;
    let i2;
    for (i2 = 0; i2 < len; ++i2) {
      sum += candidate[i2];
    }
    if (sum !== this._sum) {
      return false;
    }
    const sorted = Array.from(candidate);
    sorted.sort();
    for (i2 = 0; i2 < len; ++i2) {
      if (sorted[i2] !== this._original[i2]) {
        return false;
      }
    }
    return true;
  }
};
ArrayComparator.prototype.constructor = ArrayComparator;
var MMTFParser_StructuralElementType = chem_StructuralElement.Type;
var secStructToType = [
  MMTFParser_StructuralElementType.HELIX_PI,
  // 0
  MMTFParser_StructuralElementType.BEND,
  // 1
  MMTFParser_StructuralElementType.HELIX_ALPHA,
  // 2
  MMTFParser_StructuralElementType.STRAND,
  // 3
  MMTFParser_StructuralElementType.HELIX_310,
  // 4
  MMTFParser_StructuralElementType.BRIDGE,
  // 5
  MMTFParser_StructuralElementType.TURN,
  // 6
  MMTFParser_StructuralElementType.COIL
  // 7
];
function getFirstByte(buf) {
  const bytes = new Uint8Array(buf, 0, 1);
  return bytes[0];
}
var MMTFParser = class extends Parser {
  constructor(data, options2) {
    super(data, options2);
    this._options.fileType = "mmtf";
  }
  static canProbablyParse(data) {
    return external_module_lodash_commonjs_lodash_commonjs2_lodash_amd_lodash_root_namespaceObject["default"].isArrayBuffer(data) && (getFirstByte(data) | 1) === 223;
  }
  _onModel(_modelData) {
  }
  _onChain(chainData) {
    if (chainData.modelIndex !== 0) {
      return;
    }
    const chain = new MMTFParser_Chain(this._complex, chainData.chainName);
    this._complex._chains[chainData.chainIndex] = chain;
    chain._index = chainData.chainIndex;
  }
  _onGroup(groupData) {
    if (groupData.modelIndex !== 0) {
      return;
    }
    if (this.settings.now.nowater) {
      if (groupData.groupName === "HOH" || groupData.groupName === "WAT") {
        return;
      }
    }
    const chain = this._complex._chains[groupData.chainIndex];
    const icode = !groupData.insCode.charCodeAt(0) ? "" : groupData.insCode;
    const residue = chain.addResidue(groupData.groupName, groupData.groupId, icode);
    residue._index = groupData.groupIndex;
    this._updateSecStructure(this._complex, residue, groupData);
  }
  _onAtom(atomData) {
    if (atomData.modelIndex !== 0) {
      return;
    }
    const altLoc = !atomData.altLoc.charCodeAt(0) ? "" : atomData.altLoc;
    const atom = new MMTFParser_Atom(
      atomData.groupIndex,
      // we store residue index here to replace it later with actual reference
      atomData.atomName,
      MMTFParser_Element.getByName(atomData.element.toUpperCase()),
      new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Vector3(atomData.xCoord, atomData.yCoord, atomData.zCoord),
      MMTFParser_Element.Role[atomData.atomName],
      false,
      // hetero atoms will be marked later
      atomData.atomId,
      altLoc,
      atomData.occupancy,
      atomData.bFactor,
      atomData.formalCharge
    );
    this._complex._atoms[atomData.atomIndex] = atom;
    atom.index = atomData.atomIndex;
    this._serialAtomMap[atomData.atomId] = atom;
  }
  _onBond(bondData) {
    const right = Math.max(bondData.atomIndex1, bondData.atomIndex2);
    if (right >= this._complex._atoms.length) {
      return;
    }
    const left = Math.min(bondData.atomIndex1, bondData.atomIndex2);
    this._complex.addBond(this._complex._atoms[left], this._complex._atoms[right], bondData.bondOrder, MMTFParser_Bond.BondType.UNKNOWN, true);
  }
  _updateSecStructure(complex, residue, groupData) {
    const helixClasses = [3, -1, 1, -1, 5];
    if (!external_module_lodash_commonjs_lodash_commonjs2_lodash_amd_lodash_root_namespaceObject["default"].isUndefined(groupData) && groupData.secStruct === this._ssType) {
      residue._secondary = this._ssStruct;
      if (this._ssStruct) {
        this._ssStruct.term = residue;
      }
      return;
    }
    if (!external_module_lodash_commonjs_lodash_commonjs2_lodash_amd_lodash_root_namespaceObject["default"].isUndefined(groupData)) {
      const type = secStructToType[groupData.secStruct];
      this._ssType = groupData.secStruct;
      this._ssStart = residue;
      let struct = null;
      switch (this._ssType) {
        case -1:
        case 7:
          break;
        case 0:
        case 2:
        case 4:
          struct = new MMTFParser_Helix(helixClasses[this._ssType], residue, residue, 0, "", "", 0);
          complex._helices.push(struct);
          break;
        case 3: {
          const sheet = new MMTFParser_Sheet("", 0);
          complex._sheets.push(sheet);
          struct = new MMTFParser_Strand(sheet, residue, residue, 0, null, null);
          break;
        }
        default:
          if (type !== void 0) {
            struct = new chem_StructuralElement(type, residue, residue);
          }
          break;
      }
      this._ssStruct = struct;
      residue._secondary = struct;
      if (struct) {
        complex.structures.push(struct);
      }
    }
  }
  _updateMolecules(mmtfData) {
    const entities = mmtfData.entityList;
    if (!entities) {
      return;
    }
    const chainsInModel0 = mmtfData.chainsPerModel[0];
    for (let i2 = 0; i2 < entities.length; i2++) {
      const entity = entities[i2];
      const chains = entity.chainIndexList;
      let residues = [];
      for (let j = 0; j < chains.length; j++) {
        const chainIndex = chains[j];
        if (chainIndex >= chainsInModel0) {
          continue;
        }
        const chain = this._complex._chains[chainIndex];
        residues = residues.concat(chain._residues.slice());
      }
      const molecule = new MMTFParser_Molecule(this._complex, entity.description, i2 + 1);
      molecule.residues = residues;
      this._complex._molecules[i2] = molecule;
    }
  }
  // populate complex with chains, residues and atoms
  _traverse(mmtfData) {
    const self2 = this;
    const {
      metadata
    } = this._complex;
    metadata.id = mmtfData.structureId;
    metadata.title = [];
    metadata.title[0] = mmtfData.title;
    metadata.date = mmtfData.releaseDate;
    metadata.format = "mmtf";
    const eventCallbacks = {
      onModel(modelData) {
        self2._onModel(modelData);
      },
      onChain(chainData) {
        self2._onChain(chainData);
      },
      onGroup(groupData) {
        self2._onGroup(groupData);
      },
      onAtom(atomData) {
        self2._onAtom(atomData);
      },
      onBond(bondData) {
        self2._onBond(bondData);
      }
    };
    this._ssType = -1;
    this._ssStruct = null;
    this._ssStart = null;
    mmtf_default().traverse(mmtfData, eventCallbacks);
    this._updateSecStructure(this._complex);
    this._updateMolecules(mmtfData);
  }
  // During traversal atoms and residues don't come sequentially
  // so a residue for certain atom can be unavailable. Thus we
  // store residue index in atom.
  // This function being called after traversal replaces the index
  // with actual reference, and also populates atom lists in residues.
  _linkAtomsToResidues() {
    for (let i2 = 0; i2 < this._complex._atoms.length; ++i2) {
      const atom = this._complex._atoms[i2];
      const residue = this._complex._residues[atom.residue];
      atom.residue = residue;
      residue._atoms.push(atom);
    }
  }
  _findSynonymousChains() {
    const named = {};
    for (let i2 = 0; i2 < this._complex._chains.length; ++i2) {
      const chain = this._complex._chains[i2];
      const name = chain.getName();
      if (!named.hasOwnProperty(name)) {
        named[name] = [];
      }
      named[name].push(chain._index);
    }
    return named;
  }
  // NOTE: This function relies on original chain indices, so it must be called before any magic happens to chains.
  _parseAssemblyInfo(mmtfData) {
    let i2;
    let j;
    let k2;
    const assemblies = [];
    const {
      logger: logger2
    } = this;
    for (i2 = 0; i2 < mmtfData.bioAssemblyList.length; ++i2) {
      const baInfo = mmtfData.bioAssemblyList[i2];
      if (baInfo.transformList.length === 0) {
        continue;
      }
      const chains = baInfo.transformList[0].chainIndexList;
      const chainListCheck = new ArrayComparator(chains);
      const chainNames = {};
      for (j = 0; j < chains.length; ++j) {
        chainNames[this._complex._chains[chains[j]].getName()] = 1;
      }
      const allChains = [];
      let name;
      for (name in chainNames) {
        if (chainNames.hasOwnProperty(name)) {
          Array.prototype.push.apply(allChains, this._chainsByName[name]);
        }
      }
      if (!chainListCheck.compare(allChains)) {
        logger2.debug("MMTF: Assembly is missing some of the synonymous chains. Skipping...");
      }
      const a2 = new MMTFParser_Assembly(this._complex);
      for (name in chainNames) {
        if (chainNames.hasOwnProperty(name)) {
          a2.addChain(name);
        }
      }
      a2.addMatrix(new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Matrix4().fromArray(baInfo.transformList[0].matrix).transpose());
      for (j = 1; j < baInfo.transformList.length; ++j) {
        const transform = baInfo.transformList[j];
        if (!chainListCheck.compare(transform.chainIndexList)) {
          logger2.debug("MMTF: Chain lists differ for different transforms in one assembly. Skipping...");
          continue;
        }
        const m2 = new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Matrix4().fromArray(transform.matrix).transpose();
        for (k2 = 0; k2 < a2.matrices.length; ++k2) {
          if (a2.matrices[k2].equals(m2)) {
            break;
          }
        }
        if (k2 === a2.matrices.length) {
          a2.addMatrix(m2);
        }
      }
      a2.finalize();
      assemblies.push(a2);
    }
    return assemblies;
  }
  // NOTE: This function relies on original chain indices, so it must be called before any magic happens to chains.
  _markHeteroAtoms(mmtfData) {
    const chainsInModel0 = mmtfData.chainsPerModel[0];
    for (let i2 = 0; i2 < mmtfData.entityList.length; ++i2) {
      const entity = mmtfData.entityList[i2];
      if (entity.type !== "polymer") {
        for (let j = 0; j < entity.chainIndexList.length; ++j) {
          const chainIndex = entity.chainIndexList[j];
          if (chainIndex >= chainsInModel0) {
            continue;
          }
          const chain = this._complex._chains[chainIndex];
          for (let k2 = 0; k2 < chain._residues.length; ++k2) {
            const res = chain._residues[k2];
            for (let m2 = 0; m2 < res._atoms.length; ++m2) {
              res._atoms[m2].het = true;
            }
          }
        }
      }
    }
  }
  // joins chains with the same name into single chain
  _joinSynonymousChains() {
    let i2;
    let j;
    const primaryChainsArray = [];
    const primaryChainsHash = {};
    for (i2 = 0; i2 < this._complex._chains.length; ++i2) {
      const chain = this._complex._chains[i2];
      const name = chain.getName();
      if (!primaryChainsHash.hasOwnProperty(name)) {
        primaryChainsHash[name] = chain;
        chain._index = primaryChainsArray.length;
        primaryChainsArray.push(chain);
        continue;
      }
      const primary = primaryChainsHash[name];
      for (j = 0; j < chain._residues.length; ++j) {
        const residue = chain._residues[j];
        primary._residues.push(residue);
        residue._chain = primary;
      }
    }
    this._complex._chains = primaryChainsArray;
  }
  parseSync() {
    const mmtfData = mmtf_default().decode(this._data);
    this._complex = new MMTFParser_Complex();
    this._serialAtomMap = {};
    this._traverse(mmtfData);
    this._linkAtomsToResidues();
    this._markHeteroAtoms(mmtfData);
    this._chainsByName = this._findSynonymousChains();
    Array.prototype.push.apply(this._complex.units, this._parseAssemblyInfo(mmtfData));
    this._joinSynonymousChains();
    this._complex.finalize({
      needAutoBonding: false,
      detectAromaticLoops: this.settings.now.aromatic,
      enableEditing: this.settings.now.editing,
      serialAtomMap: this._serialAtomMap
    });
    return this._complex;
  }
};
MMTFParser.formats = ["mmtf"];
MMTFParser.extensions = [".mmtf"];
MMTFParser.binary = true;
var parsers_MMTFParser = MMTFParser;
var ParsingError = class _ParsingError extends Error {
  constructor(message, line, column) {
    super(`data:${line}:${column}: ${message}`);
    if (Error.captureStackTrace) {
      Error.captureStackTrace(this, _ParsingError);
    }
    this.name = "ParsingError";
    this.parseLine = line;
    this.parseColumn = column;
  }
};
var parsers_ParsingError = ParsingError;
function _isWhitespace(ch) {
  return ch === 32 || ch === 10 || ch === 13 || ch === 9;
}
function _inlineIndexOf(ch0, str, idx) {
  const len = str.length;
  let ch = -1;
  while (idx < len) {
    ch = str.charCodeAt(idx);
    if (ch === ch0 || ch === 10) {
      break;
    }
    ++idx;
  }
  return ch === ch0 ? idx : -1;
}
function readCIF(source) {
  let i2 = 0;
  let j = 0;
  const n = source.length;
  let code = NaN;
  let newline = true;
  let line = 1;
  let column = 1;
  let begin;
  let state = 0;
  const result = {};
  let block = {};
  let keys = [];
  let keysCount = 0;
  let key = "";
  let values = [];
  let valuesCount = 0;
  let value;
  function _parseValue() {
    let val;
    if ((code === 46 || code === 63) && (i2 + 1 >= n || _isWhitespace(source.charCodeAt(i2 + 1)))) {
      ++column;
      ++i2;
      return void 0;
    }
    if (newline && code === 59) {
      j = i2;
      let lines = 0;
      do {
        j = _inlineIndexOf(10, source, j + 1);
        if (j === -1) {
          throw new parsers_ParsingError("Unterminated text block found", line, column);
        }
        ++lines;
      } while (j + 1 < n && source.charCodeAt(j + 1) !== code || j + 1 >= n);
      val = source.substring(i2 + 1, j).replace(/\r/g, "");
      i2 = j + 2;
      line += lines;
      column = 1;
      newline = false;
      return val;
    }
    if (code === 39 || code === 34) {
      j = i2;
      do {
        j = _inlineIndexOf(code, source, j + 1);
        if (j === -1) {
          throw new parsers_ParsingError("Unterminated quoted string found", line, column);
        }
      } while (j + 1 < n && !_isWhitespace(source.charCodeAt(j + 1)));
      val = source.substring(i2 + 1, j);
      column += j - i2 + 1;
      i2 = j + 1;
      return val;
    }
    j = i2;
    while (j < n && !_isWhitespace(source.charCodeAt(j))) {
      ++j;
    }
    val = source.substring(i2, j);
    column += j - i2;
    i2 = j;
    const num = Number(val);
    if (!Number.isNaN(num)) {
      return num;
    }
    return val;
  }
  function _storeKey(tag) {
    keys[keysCount++] = tag;
  }
  function _storeValue(val) {
    const keyIndex = valuesCount % keysCount;
    values[keyIndex].push(val);
    ++valuesCount;
    return val;
  }
  while (i2 <= n) {
    code = source.charCodeAt(i2);
    if (code === 13) {
    } else if (code === 10) {
      newline = true;
      ++line;
      column = 1;
    } else {
      if (code === 32 || code === 9) {
      } else if (code === 35) {
        i2 = _inlineIndexOf(10, source, i2 + 1);
        if (i2 === -1) {
          break;
        } else {
          continue;
        }
      } else if (state === 0) {
        if ((code === 68 || code === 100) && source.substr(i2 + 1, 4).toLowerCase() === "ata_") {
          j = i2 + 5;
          begin = j;
          while (j < n && !_isWhitespace(source.charCodeAt(j))) {
            ++j;
          }
          column += j - i2;
          i2 = j;
          if (begin < i2) {
            result[source.substring(begin, i2)] = block = {};
            state = 1;
            continue;
          } else {
            throw new parsers_ParsingError("Data block name missing", line, column);
          }
        } else if (Number.isNaN(code)) {
          break;
        } else {
          throw new parsers_ParsingError(`Unexpected character in state ${state}`, line, column);
        }
      } else if (state === 1) {
        if ((code === 68 || code === 100) && source.substr(i2 + 1, 4).toLowerCase() === "ata_") {
          state = 0;
          continue;
        } else if (code === 95) {
          j = i2 + 1;
          begin = j;
          while (j < n && !_isWhitespace(source.charCodeAt(j))) {
            ++j;
          }
          column += j - i2;
          i2 = j;
          if (begin < i2) {
            key = source.substring(begin, i2);
            state = 2;
            continue;
          } else {
            throw new parsers_ParsingError("Tag name missing", line, column);
          }
        } else if ((code === 76 || code === 108) && source.substr(i2 + 1, 4).toLowerCase() === "oop_") {
          i2 += 5;
          column += 5;
          if (i2 < n && !_isWhitespace(source.charCodeAt(i2))) {
            throw new parsers_ParsingError(`Unexpected character in state ${state}`, line, column);
          } else {
            keys = [];
            keysCount = 0;
            values = [];
            valuesCount = 0;
            state = 3;
            continue;
          }
        } else if (Number.isNaN(code)) {
          break;
        } else {
          throw new parsers_ParsingError(`Unexpected character in state ${state}`, line, column);
        }
      } else if (state === 2) {
        if (Number.isNaN(code)) {
          break;
        }
        value = _parseValue();
        external_module_lodash_commonjs_lodash_commonjs2_lodash_amd_lodash_root_namespaceObject["default"].set(block, key, value);
        state = 1;
        continue;
      } else if (state === 3) {
        if (code === 95) {
          j = i2 + 1;
          begin = j;
          while (j < n && !_isWhitespace(source.charCodeAt(j))) {
            ++j;
          }
          column += j - i2;
          i2 = j;
          if (begin < i2) {
            _storeKey(source.substring(begin, i2));
            continue;
          } else {
            throw new parsers_ParsingError("Tag name missing", line, column);
          }
        } else {
          if (keysCount > 0) {
            for (let keyIndex = 0; keyIndex < keysCount; ++keyIndex) {
              value = [];
              values[keyIndex] = value;
              external_module_lodash_commonjs_lodash_commonjs2_lodash_amd_lodash_root_namespaceObject["default"].set(block, keys[keyIndex], value);
            }
            state = 4;
            continue;
          }
          throw new parsers_ParsingError("Data tags are missing inside a loop", line, column);
        }
      } else if (state === 4) {
        if ((code === 68 || code === 100) && source.substr(i2 + 1, 4).toLowerCase() === "ata_") {
          state = 0;
        } else if (code === 95) {
          state = 1;
        } else if ((code === 76 || code === 108) && source.substr(i2 + 1, 4).toLowerCase() === "oop_") {
          state = 1;
        } else if (Number.isNaN(code)) {
          state = 0;
        } else {
          _storeValue(_parseValue());
        }
        continue;
      } else {
        throw new parsers_ParsingError(`Unexpected internal state ${state}`, line, column);
      }
      newline = false;
      ++column;
    }
    ++i2;
  }
  if (state === 2) {
    throw new parsers_ParsingError(`Unexpected end of file in state ${state}`, line, column);
  }
  return result;
}
var {
  Complex: CIFParser_Complex,
  Element: CIFParser_Element,
  Helix: CIFParser_Helix,
  Sheet: CIFParser_Sheet,
  Strand: CIFParser_Strand,
  Assembly: CIFParser_Assembly,
  Molecule: CIFParser_Molecule
} = chem;
var cRequiredAtomFields = ["auth_seq_id", "Cartn_x", "Cartn_y", "Cartn_z", "label_atom_id"];
var cSecondaryCoding = {
  helx: "helix",
  turn: "turn",
  strn: "strand"
};
function getTypeFromId(string) {
  const typeId = /[A-Za-z]+/.exec(string);
  if (!typeId) {
    return null;
  }
  return cSecondaryCoding[typeId[0].toLowerCase()];
}
function arrize(arrayLikeObject) {
  if (arrayLikeObject === null || arrayLikeObject === void 0 || external_module_lodash_commonjs_lodash_commonjs2_lodash_amd_lodash_root_namespaceObject["default"].isArray(arrayLikeObject)) {
    return arrayLikeObject;
  }
  return [arrayLikeObject];
}
function CIFParser_nameToElement(name) {
  const veryLong = name.trim().length === 4;
  return name.slice(0, veryLong ? 1 : 2).trim();
}
var AtomDataError = class extends Error {
  constructor(message) {
    super();
    this.name = "AtomDataError";
    this.message = message;
  }
};
function _getOperations(operList) {
  if (!operList) {
    return null;
  }
  const idc = arrize(operList.id);
  const {
    matrix,
    vector
  } = operList;
  if (!idc || !matrix || !vector) {
    return null;
  }
  const ops = [];
  for (let i2 = 0, n = idc.length; i2 < n; ++i2) {
    const mtx = new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Matrix4();
    const {
      elements
    } = mtx;
    for (let row = 0; row < 3; ++row) {
      const matrixData = matrix[row + 1];
      elements[row] = arrize(matrixData[1])[i2];
      elements[row + 4] = arrize(matrixData[2])[i2];
      elements[row + 8] = arrize(matrixData[3])[i2];
      elements[row + 12] = arrize(vector[row + 1])[i2];
    }
    ops[idc[i2]] = mtx;
  }
  return ops;
}
function _extractOperations(assemblyGen, opsDict) {
  assemblyGen = external_module_lodash_commonjs_lodash_commonjs2_lodash_amd_lodash_root_namespaceObject["default"].isString(assemblyGen) ? assemblyGen : `${assemblyGen}`;
  const l2 = assemblyGen.replace(/\)\s*\(/g, "!").replace(/[()']/g, "");
  const groupStr = l2.split("!");
  const gps = [];
  for (let grIdx = 0, grCount = groupStr.length; grIdx < grCount; ++grIdx) {
    const gr = groupStr[grIdx].split(",");
    const gp = [];
    let idx = 0;
    for (let i2 = 0, n = gr.length; i2 < n; ++i2) {
      const s2 = gr[i2];
      if (s2.includes("-")) {
        const es = s2.split("-");
        let j = parseInt(es[0], 10);
        const m2 = parseInt(es[1], 10);
        for (; j <= m2; ++j) {
          gp[idx++] = opsDict[j];
        }
      } else {
        gp[idx++] = opsDict[s2];
      }
    }
    gps.push(gp);
  }
  const matrices = [];
  let cnt = 0;
  function traverse(level, mtx) {
    for (let ii = 0, nn = gps[level].length; ii < nn; ++ii) {
      const newMtx = mtx ? mtx.clone() : new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Matrix4();
      newMtx.multiplyMatrices(gps[level][ii], newMtx);
      if (level === 0) {
        matrices[cnt++] = newMtx;
      } else {
        traverse(level - 1, newMtx);
      }
    }
  }
  traverse(gps.length - 1);
  return matrices;
}
var CIFParser = class extends Parser {
  constructor(data, options2) {
    super(data, options2);
    this.asymDict = {};
    this.molecules = [];
    this._options.fileType = "cif";
  }
  static canProbablyParse(data) {
    return external_module_lodash_commonjs_lodash_commonjs2_lodash_amd_lodash_root_namespaceObject["default"].isString(data) && /^\s*data_/i.test(data);
  }
  parseSync() {
    this.logger.info("Parsing CIF file..");
    const data = readCIF(this._data);
    return this._toComplex(data);
  }
  /**
   * Convert intermediate structure into our valid Complex object
   * @param cifData intermediate CIF object
   * @returns {Complex} complex
   * @private
   */
  _toComplex(cifData) {
    const complex = new CIFParser_Complex();
    const complexData = cifData[Object.keys(cifData)[0]];
    this._extractAtoms(complex, complexData);
    this._extractSecondary(complex, complexData);
    this._extractAssemblies(complex, complexData);
    this._extractMolecules(complex, complexData);
    this._extractMetadata(complex, complexData);
    complex.finalize({
      needAutoBonding: true,
      detectAromaticLoops: this.settings.now.aromatic,
      enableEditing: this.settings.now.editing
    });
    return complex;
  }
  /**
   * Extract metadata
   * @param complex structure to fill
   * @param complexData complex data from CIF file
   * @private
   */
  _extractMetadata(complex, complexData) {
    const {
      metadata
    } = complex;
    metadata.id = complexData.entry.id;
    metadata.classification = complexData.struct_keywords.pdbx_keywords;
    const databaserev = complexData.database_PDB_rev;
    metadata.date = databaserev && databaserev.date_original ? databaserev.date_original : "";
    metadata.format = "cif";
    metadata.title = [];
    metadata.title[0] = complexData.struct.title;
  }
  /**
   * Extract molecules information from CIF structure (should be called strictly after _extractAtoms)
   * @param complexData complex data from CIF file
   * @private
   */
  _extractMolecules(complex, complexData) {
    const molData = complexData.entity;
    const names = arrize(molData.pdbx_description);
    const count = names.length;
    let i2;
    for (i2 = 0; i2 < count; i2++) {
      if (this.molecules[i2]) {
        this.molecules[i2].name = names[i2];
      } else {
        this.molecules[i2] = {
          name: names[i2],
          residues: []
        };
      }
    }
    const molecules = complex.getMolecules();
    for (i2 = 0; i2 < count; i2++) {
      const molecule = this.molecules[i2];
      molecules[i2] = new CIFParser_Molecule(complex, molecule.name, i2 + 1);
      molecules[i2].residues = molecule.residues;
    }
  }
  /**
   * Extract atom information from CIF structure and fill complex
   * @param {Complex} complex
   * @param complexData complex data from CIF file
   * @private
   */
  _extractAtoms(complex, complexData) {
    const atomData = complexData.atom_site;
    if (!atomData) {
      throw new AtomDataError("CIF parsing error: atom_site is not specified!");
    }
    for (let f2 = 0, n = cRequiredAtomFields.length; f2 < n; ++f2) {
      if (!atomData[cRequiredAtomFields[f2]]) {
        throw new AtomDataError(`CIF parsing error: requires field ${cRequiredAtomFields[f2]} not found!`);
      }
    }
    const {
      asymDict
    } = this;
    const resIdc = arrize(atomData.auth_seq_id);
    const x3 = arrize(atomData.Cartn_x);
    const y2 = arrize(atomData.Cartn_y);
    const z = arrize(atomData.Cartn_z);
    const names = arrize(atomData.label_atom_id);
    const count = names.length;
    const group = arrize(atomData.group_PDB) || [];
    const chainIdc = arrize(atomData.auth_asym_id) || [];
    const chainLabelIdc = arrize(atomData.label_asym_id) || [];
    const serials = arrize(atomData.id) || [];
    const iCodes = arrize(atomData.pdbx_PDB_ins_code) || [];
    const resNames = arrize(atomData.label_comp_id) || [];
    const elements = arrize(atomData.type_symbol) || [];
    const tempFactors = arrize(atomData.B_iso_or_equiv) || [];
    const occupancies = arrize(atomData.occupancy) || [];
    const charges = arrize(atomData.pdbx_formal_charge) || [];
    const altLocs = arrize(atomData.label_alt_id) || [];
    const models = arrize(atomData.pdbx_PDB_model_num) || [];
    const molecules = arrize(atomData.label_entity_id) || [];
    let chain = null;
    let residue = null;
    for (let i2 = 0; i2 < count; ++i2) {
      const model = models[i2] || 1;
      if (model !== 1) {
        continue;
      }
      const chainID = String(chainIdc[i2] || " ");
      if (!chain || chain.getName() !== chainID) {
        chain = complex.getChain(chainID) || complex.addChain(chainID);
      }
      asymDict[String(chainLabelIdc[i2] || " ")] = chainID;
      const resSeq = resIdc[i2];
      const iCode = String(iCodes[i2] || " ");
      const resName = String(resNames[i2] || "");
      if (!residue || residue.getSequence() !== resSeq || residue.getICode() !== iCode) {
        residue = chain.addResidue(resName, resSeq, iCode);
        const moleculeIdx = molecules[i2] - 1;
        let entity = this.molecules[moleculeIdx];
        if (!entity) {
          this.molecules[moleculeIdx] = {
            name: "",
            residues: []
          };
          entity = this.molecules[moleculeIdx];
        }
        entity.residues.push(residue);
      }
      const name = names[i2];
      const element = elements[i2] || CIFParser_nameToElement(name);
      const type = CIFParser_Element.getByName(element);
      const role = CIFParser_Element.Role[name.trim()];
      const xyz = new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Vector3(x3[i2], y2[i2], z[i2]);
      const het = group[i2] === "HETATM" || false;
      const serial = serials[i2] || i2;
      const tempFactor = tempFactors[i2] || 0;
      const occupancy = occupancies[i2] || 0;
      const altLoc = String(altLocs[i2] || "");
      const charge = charges[i2] || 0;
      residue.addAtom(name, type, xyz, role, het, serial, altLoc, occupancy, tempFactor, charge);
    }
  }
  /**
   * Extracts secondary structure information from CIF intermediate data
   * and adds it into complex
   * @param {Complex} complex - complex to fill
   * @param complexData - CIF complex data
   * @private
   */
  _extractSecondary(complex, complexData) {
    if (complexData.struct_conf) {
      this._extractConfs(complex, complexData.struct_conf);
    }
    if (complexData.struct_sheet_range) {
      this._extractSheets(complex, complexData.struct_sheet_range);
    }
  }
  /**
   * Extracts sheets information from CIF intermediate data
   * and adds it into complex
   * @param {Complex} complex
   * @param sheetData
   * @private
   */
  _extractSheets(complex, sheetData) {
    const {
      asymDict
    } = this;
    if (!sheetData.sheet_id || !sheetData.id || !sheetData.beg_label_seq_id || !sheetData.end_label_seq_id || !sheetData.beg_label_asym_id) {
      return;
    }
    const sheets = complex._sheets;
    function getSheet(name) {
      const n = sheets.length;
      for (let i2 = 0; i2 < n; ++i2) {
        if (sheets[i2]._name === name) {
          return sheets[i2];
        }
      }
      sheets[n] = new CIFParser_Sheet(name, 0);
      return sheets[n];
    }
    const sheetNames = arrize(sheetData.sheet_id);
    const strandNames = arrize(sheetData.id);
    const starts = arrize(sheetData.beg_auth_seq_id);
    const ends = arrize(sheetData.end_auth_seq_id);
    const chains = arrize(sheetData.beg_label_asym_id);
    const stICodes = arrize(sheetData.pdbx_beg_PDB_ins_code) || [];
    const endICodes = arrize(sheetData.pdbx_end_PDB_ins_code) || [];
    for (let i2 = 0, n = strandNames.length; i2 < n; ++i2) {
      const chain = complex.getChain(asymDict[chains[i2]]);
      const sheet = getSheet(sheetNames[i2]);
      const startIdx = starts[i2];
      const endIdx = ends[i2];
      const startICode = stICodes[i2] || " ";
      const endICode = endICodes[i2] || " ";
      const start = chain.findResidue(startIdx, startICode);
      const end = chain.findResidue(endIdx, endICode);
      if (!start || !end) {
        continue;
      }
      const strand = new CIFParser_Strand(sheet, start[0], end[0], 0, null, null);
      const residues = chain.getResidues();
      for (let r2 = start[1]; r2 <= end[1]; ++r2) {
        residues[r2]._secondary = strand;
      }
      sheet.addStrand(strand);
      complex.structures.push(strand);
    }
  }
  /**
   * Extracts helix/turn/strand(?) information from CIF intermediate data
   * and adds it into complex
   * @param {Complex} complex
   * @param helicesData
   * @private
   */
  _extractConfs(complex, helicesData) {
    const {
      asymDict
    } = this;
    if (!helicesData.conf_type_id || !helicesData.beg_label_seq_id || !helicesData.end_label_seq_id || !helicesData.beg_label_asym_id) {
      return;
    }
    const types = arrize(helicesData.conf_type_id);
    const starts = arrize(helicesData.beg_auth_seq_id);
    const stICodes = arrize(helicesData.pdbx_beg_PDB_ins_code) || [];
    const ends = arrize(helicesData.end_auth_seq_id);
    const endICodes = arrize(helicesData.pdbx_end_PDB_ins_code) || [];
    const comments = arrize(helicesData.details) || [];
    const lengths = arrize(helicesData.pdbx_PDB_helix_length) || [];
    const helixClasses = arrize(helicesData.pdbx_PDB_helix_class) || [];
    const names = arrize(helicesData.id) || [];
    const chains = arrize(helicesData.beg_label_asym_id);
    for (let i2 = 0, n = types.length; i2 < n; ++i2) {
      const type = getTypeFromId(types[i2]);
      if (!type) {
        continue;
      }
      const name = names[i2] || types[i2];
      const chain = complex.getChain(asymDict[chains[i2]]);
      const startIdx = starts[i2];
      const endIdx = ends[i2];
      const startICode = stICodes[i2] || " ";
      const endICode = endICodes[i2] || " ";
      const start = chain.findResidue(startIdx, startICode);
      const end = chain.findResidue(endIdx, endICode);
      if (!start || !end) {
        continue;
      }
      const comment = comments[i2] || "";
      const length = lengths[i2] || 0;
      const helixClass = helixClasses[i2] || " ";
      let struct;
      if (type === "helix") {
        const idx = complex._helices.length;
        struct = new CIFParser_Helix(helixClass, start[0], end[0], idx, name, comment, length);
        complex.addHelix(struct);
        complex.structures.push(struct);
      } else if (type === "turn") {
        struct = new chem_StructuralElement(chem_StructuralElement.Type.TURN, start[0], end[0]);
        complex.structures.push(struct);
      } else {
        struct = null;
      }
      if (!struct) {
        continue;
      }
      const residues = chain.getResidues();
      for (let r2 = start[1]; r2 <= end[1]; ++r2) {
        residues[r2]._secondary = struct;
      }
    }
  }
  /**
   * Extract biological assemblies information from CIF structure and fill complex
   * @param {Complex} complex
   * @param complexData complex data from CIF file
   * @private
   */
  _extractAssemblies(complex, complexData) {
    const {
      asymDict
    } = this;
    const asmGen = complexData.pdbx_struct_assembly_gen;
    if (!asmGen) {
      return;
    }
    const asmIdx = arrize(asmGen.assembly_id);
    const asmOper = arrize(asmGen.oper_expression);
    const asmList = arrize(asmGen.asym_id_list);
    if (!asmIdx || !asmOper || !asmList) {
      return;
    }
    const operList = _getOperations(complexData.pdbx_struct_oper_list);
    if (!operList) {
      return;
    }
    for (let i2 = 0, n = asmIdx.length; i2 < n; ++i2) {
      const asm = new CIFParser_Assembly(complex);
      const assemblyOps = _extractOperations(asmOper[i2], operList);
      const entries = asmList[i2].split(",");
      for (let ii = 0, nn = entries.length; ii < nn; ++ii) {
        const chain = entries[ii].trim();
        if (chain.length > 0) {
          asm.addChain(asymDict[chain]);
        }
      }
      asm.matrices = assemblyOps;
      complex.units.push(asm);
    }
  }
};
CIFParser.formats = ["cif", "mmcif"];
CIFParser.extensions = [".cif", ".mmcif"];
var parsers_CIFParser = CIFParser;
var valueType = {
  singular: 0,
  vector: 1,
  array: 2,
  buffer: 3
};
var VolumeModel = class {
  constructor() {
    __publicField(this, "_xyz2crs", []);
    __publicField(this, "_origin", (() => new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Vector3(0, 0, 0))());
    this._header = {};
    this._boxSize = new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Vector3();
    this._boxStart = new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Vector3();
    this._header.delta = {};
    this._header.extent = [];
    this._header.nstart = [];
    this._header.grid = [];
    this._header.crs2xyz = [];
    this._header.cellDims = new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Vector3();
    this._header.angles = [];
    this._header.origin = new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Vector3(0, 0, 0);
    this._header.dmin = 0;
    this._header.dmean = 0;
    this._header.dmax = 0;
  }
  _typedCheck() {
    if (external_module_lodash_commonjs_lodash_commonjs2_lodash_amd_lodash_root_namespaceObject["default"].isTypedArray(this._buff)) {
      this._buff = this._buff.buffer;
    } else if (!external_module_lodash_commonjs_lodash_commonjs2_lodash_amd_lodash_root_namespaceObject["default"].isArrayBuffer(this._buff)) {
      throw new TypeError("Expected ArrayBuffer or TypedArray");
    }
  }
  _fillHeader(headerFormat, arrays) {
    for (const key in headerFormat) {
      if (headerFormat.hasOwnProperty(key)) {
        switch (headerFormat[key][0]) {
          case valueType.singular:
            this._header[key] = arrays[headerFormat[key][1]][headerFormat[key][2]];
            break;
          case valueType.array:
            this._parseArray(this._header[key], arrays[headerFormat[key][1]], headerFormat[key][2]);
            break;
          case valueType.vector:
            this._parseVector(this._header[key], arrays[headerFormat[key][1]], headerFormat[key][2]);
            break;
          case valueType.buffer:
            this._header[key] = new Uint8Array(arrays[headerFormat[key][1]], [headerFormat[key][2]] * 4, [headerFormat[key][3]] * 4);
            break;
          default:
            break;
        }
      }
    }
  }
  _parseVector(vector, arr, pos) {
    [vector.x, vector.y, vector.z] = [arr[pos], arr[pos + 1], arr[pos + 2]];
  }
  _parseArray(vector, arr, pos) {
    vector[0] = arr[pos];
    vector[1] = arr[pos + 1];
    vector[2] = arr[pos + 2];
  }
  _parseHeader(_buffer) {
  }
  _setAxisIndices() {
  }
  _setOrigins() {
  }
  _getAxis() {
    const header = this._header;
    const xScale = header.cellDims.x / header.grid[0];
    const yScale = header.cellDims.y / header.grid[1];
    const zScale = header.cellDims.z / header.grid[2];
    const [alpha, beta, gamma] = header.angles;
    const z1 = Math.cos(beta);
    const z2 = (Math.cos(alpha) - Math.cos(beta) * Math.cos(gamma)) / Math.sin(gamma);
    const z3 = Math.sqrt(1 - z1 * z1 - z2 * z2);
    const xaxis = new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Vector3(xScale, 0, 0);
    const yaxis = new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Vector3(Math.cos(gamma) * yScale, Math.sin(gamma) * yScale, 0);
    const zaxis = new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Vector3(z1 * zScale, z2 * zScale, z3 * zScale);
    return [xaxis, yaxis, zaxis];
  }
  _getXYZdim() {
    return [this._header.extent[this._xyz2crs[0]], this._header.extent[this._xyz2crs[1]], this._header.extent[this._xyz2crs[2]]];
  }
  _getVolumeInfo() {
    const volInfo = external_module_lodash_commonjs_lodash_commonjs2_lodash_amd_lodash_root_namespaceObject["default"].pick(this._header, ["dmean", "dmin", "dmax", "sd", "delta"]);
    volInfo.obtuseAngle = this._header.angles.map((angle) => Number(angle >= Math.PI / 2));
    return volInfo;
  }
  _setBoxParams(xaxis, yaxis, zaxis) {
    let shiftX = 0;
    let shiftY = 0;
    const [alpha, beta, gamma] = this._header.angles;
    if (gamma >= Math.PI / 2) {
      shiftX += Math.abs(yaxis.x);
    }
    if (beta >= Math.PI / 2) {
      shiftX += Math.abs(zaxis.x);
    }
    if (alpha >= Math.PI / 2) {
      shiftY += Math.abs(zaxis.y);
    }
    this._boxStart = new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Vector3(this._origin.x - shiftX, this._origin.y - shiftY, this._origin.z);
    this._boxSize = new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Vector3(Math.abs(xaxis.x) + Math.abs(yaxis.x) + Math.abs(zaxis.x), Math.abs(yaxis.y) + Math.abs(zaxis.y), Math.abs(zaxis.z));
    const delta = (axe, proj) => Math.abs(axe[proj]) / this._boxSize[proj];
    this._header.delta.x = delta(yaxis, "x");
    this._header.delta.y = delta(zaxis, "x");
    this._header.delta.z = delta(zaxis, "y");
  }
  _getXYZbox() {
    return new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Box3(this._boxStart.clone(), this._boxStart.clone().add(this._boxSize));
  }
  _toXYZData() {
  }
  parse(data) {
    this._parseHeader(data);
    this._setOrigins();
    return new chem_Volume(Float32Array, this._getXYZdim(), this._getXYZbox(), 1, this._toXYZData(), this._getVolumeInfo());
  }
};
var parsers_VolumeModel = VolumeModel;
var CCP4Header = {
  extent: [valueType.array, "u32", 0],
  type: [valueType.singular, "u32", 3],
  nstart: [valueType.array, "i32", 4],
  grid: [valueType.array, "u32", 7],
  cellDims: [valueType.vector, "f32", 10],
  angles: [valueType.array, "f32", 13],
  crs2xyz: [valueType.array, "i32", 16],
  dmin: [valueType.singular, "f32", 19],
  dmax: [valueType.singular, "f32", 20],
  dmean: [valueType.singular, "f32", 21],
  ispg: [valueType.singular, "u32", 22],
  nsymbt: [valueType.singular, "u32", 23],
  lksflg: [valueType.singular, "u32", 24],
  customData: [valueType.buffer, "buffer", 25, 9],
  origin: [valueType.vector, "f32", 34],
  map: [valueType.buffer, "buffer", 52, 1],
  machine: [valueType.singular, "u32", 53],
  sd: [valueType.singular, "f32", 54],
  nlabel: [valueType.singular, "f32", 55],
  label: [valueType.buffer, "buffer", 56, 200]
};
var Ccp4Model = class extends parsers_VolumeModel {
  // read header (http://www.ccp4.ac.uk/html/maplib.html)
  _parseHeader(_buffer) {
    this._buff = _buffer;
    this._typedCheck();
    const arrays = {};
    arrays.u32 = new Uint32Array(this._buff, 0, 56);
    arrays.i32 = new Int32Array(this._buff, 0, 56);
    arrays.f32 = new Float32Array(this._buff, 0, 56);
    arrays.buffer = this._buff;
    const header = this._header;
    this._fillHeader(CCP4Header, arrays);
    header.angles.forEach((angle, i2, a2) => {
      a2[i2] *= Math.PI / 180;
    });
  }
  _setAxisIndices() {
    const header = this._header;
    if (header.cellDims.x === 0 && header.cellDims.y === 0 && header.cellDims.z === 0) {
      header.cellDims.set(1, 1, 1);
    }
    const {
      crs2xyz
    } = this._header;
    if (crs2xyz[0] === 0 && crs2xyz[1] === 0 && crs2xyz[2] === 0) {
      crs2xyz[0] = 1;
      crs2xyz[1] = 2;
      crs2xyz[2] = 3;
    }
    const xyz2crs = this._xyz2crs;
    xyz2crs[crs2xyz[0] - 1] = 0;
    xyz2crs[crs2xyz[1] - 1] = 1;
    xyz2crs[crs2xyz[2] - 1] = 2;
  }
  _setOrigins() {
    const [xaxis, yaxis, zaxis] = this._getAxis();
    this._setAxisIndices();
    const header = this._header;
    const xyz2crs = this._xyz2crs;
    if (header.origin.x === 0 && header.origin.y === 0 && header.origin.z === 0) {
      this._origin.addScaledVector(xaxis, header.nstart[xyz2crs[0]]);
      this._origin.addScaledVector(yaxis, header.nstart[xyz2crs[1]]);
      this._origin.addScaledVector(zaxis, header.nstart[xyz2crs[2]]);
    } else {
      this._origin = header.origin;
    }
    xaxis.multiplyScalar(header.extent[xyz2crs[0]] - 1);
    yaxis.multiplyScalar(header.extent[xyz2crs[1]] - 1);
    zaxis.multiplyScalar(header.extent[xyz2crs[2]] - 1);
    if (header.type === 2) {
      this._data = new Float32Array(this._buff, 1024 + header.nsymbt, header.extent[0] * header.extent[1] * header.extent[2]);
    } else {
      throw new Error(`CCP4: Unsupported format ${header.type}`);
    }
    this._setBoxParams(xaxis, yaxis, zaxis);
  }
  _toXYZData() {
    const header = this._header;
    const data = this._data;
    const xyz2crs = this._xyz2crs;
    const xyzData = new Float32Array(data.length);
    const dim = this._getXYZdim();
    const xSize = dim[0];
    const ySize = dim[1];
    let crsIdx = 0;
    const coord = [];
    let x3;
    let y2;
    let z;
    for (coord[2] = 0; coord[2] < header.extent[2]; coord[2]++) {
      for (coord[1] = 0; coord[1] < header.extent[1]; coord[1]++) {
        for (coord[0] = 0; coord[0] < header.extent[0]; coord[0]++, crsIdx++) {
          x3 = coord[xyz2crs[0]];
          y2 = coord[xyz2crs[1]];
          z = coord[xyz2crs[2]];
          xyzData[x3 + xSize * (y2 + ySize * z)] = data[crsIdx];
        }
      }
    }
    return xyzData;
  }
};
var CCP4Parser = class extends Parser {
  constructor(data, options2) {
    super(data, options2);
    this._options.fileType = "ccp4";
    this.model = new Ccp4Model();
  }
  static canProbablyParse(_data) {
    return false;
  }
  parseSync() {
    return this.model.parse(this._data);
  }
};
CCP4Parser.formats = ["ccp4"];
CCP4Parser.extensions = [".ccp4", ".map", ".mrc"];
CCP4Parser.binary = true;
var parsers_CCP4Parser = CCP4Parser;
var {
  Complex: XYZParser_Complex,
  Element: XYZParser_Element,
  Molecule: XYZParser_Molecule
} = chem;
var XYZParser = class extends Parser {
  constructor(data, options2) {
    super(data, options2);
    this._complex = null;
    this._atomsInf = null;
    this._options.fileType = "xyz";
    this._fileName = options2.name;
  }
  static canProbablyParse(data) {
    return external_module_lodash_commonjs_lodash_commonjs2_lodash_amd_lodash_root_namespaceObject["default"].isString(data) && /^\s*\d+ *\n[^\n]*\n\s*\w{1,3}\s+-?\d/.test(data);
  }
  _parseToAtomsInf(source) {
    const endnAtoms = source.indexOf("\n");
    const nAtoms = parseInt(source.substring(0, endnAtoms), 10);
    const endComment = source.indexOf("\n", endnAtoms + 1);
    let comment = source.slice(endnAtoms + 1, endComment).trim();
    if (comment.length === 0) {
      comment = this._fileName;
    }
    const startAtomsInf = endComment + source.substring(endComment).search(/\S/);
    this._atomsInf = source.substring(startAtomsInf).split(/[\s,]*\n[\s,]*/);
    if (!Number.isNaN(nAtoms) && this._atomsInf.length - 1 !== nAtoms) {
      this._complex.error = {
        message: "wrong number of atoms"
      };
      return;
    }
    this._complex.metadata.format = "xyz";
    this._complex.name = comment;
  }
  _parseAtomsInf() {
    const het = true;
    const altLoc = " ";
    const occupancy = 1;
    const tempFactor = 1;
    const charge = 0;
    const chain = this._complex.addChain("A");
    const residue = chain.addResidue("UNK", 1, " ");
    for (let i2 = 0; i2 < this._atomsInf.length - 1; i2++) {
      const words = this._atomsInf[i2].split(/[\s,]+/);
      if (words.length !== 4) {
        this._complex.error = {
          message: "missed parameters"
        };
        break;
      }
      const serial = i2 + 1;
      const name = words[0];
      const xyz = new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Vector3(parseFloat(words[1]), parseFloat(words[2]), parseFloat(words[3]));
      const type = XYZParser_Element.getByName(name);
      const role = void 0;
      residue.addAtom(name, type, xyz, role, het, serial, altLoc, occupancy, tempFactor, charge);
    }
    const molecule = new XYZParser_Molecule(this._complex, this._complex.name, 1);
    molecule.residues = residue;
    this._complex._molecules[0] = molecule;
  }
  parseSync() {
    const result = this._complex = new XYZParser_Complex();
    this._parseToAtomsInf(this._data);
    this._parseAtomsInf();
    this._complex.finalize({
      needAutoBonding: true,
      detectAromaticLoops: this.settings.now.aromatic,
      enableEditing: this.settings.now.editing,
      serialAtomMap: this._serialAtomMap
    });
    this._complex = null;
    this._atomsInf = null;
    if (result.error) {
      throw new Error(result.error.message);
    }
    return result;
  }
};
__publicField(XYZParser, "formats", ["xyz"]);
__publicField(XYZParser, "extensions", [".xyz"]);
var parsers_XYZParser = XYZParser;
var {
  Complex: PubChemParser_Complex,
  Element: PubChemParser_Element
} = chem;
var PubChemParser = class extends Parser {
  constructor(data, options2) {
    super(data, options2);
    this._options.fileType = "pubchem+json";
  }
  static canProbablyParse(data) {
    return external_module_lodash_commonjs_lodash_commonjs2_lodash_amd_lodash_root_namespaceObject["default"].isString(data) && data[0] === "{";
  }
  parseSync() {
    this.logger.info("Parsing PubChem JSON file...");
    return this._toComplex(JSON.parse(this._data));
  }
  _toComplex(jsonData) {
    const complex = new PubChemParser_Complex();
    const complexData = jsonData.PC_Compounds && jsonData.PC_Compounds[0];
    if (complexData) {
      this._extractAtoms(complex, complexData);
      complex.finalize({
        needAutoBonding: false,
        detectAromaticLoops: this.settings.now.aromatic,
        enableEditing: this.settings.now.editing
      });
    }
    return complex;
  }
  _extractAtoms(complex, complexData) {
    let aids = complexData.atoms && complexData.atoms.aid;
    let elements = aids && complexData.atoms.element;
    if (!elements || aids.length !== elements.length) {
      throw new Error("Unable to parse atom elements");
    }
    elements = external_module_lodash_commonjs_lodash_commonjs2_lodash_amd_lodash_root_namespaceObject["default"].fromPairs(external_module_lodash_commonjs_lodash_commonjs2_lodash_amd_lodash_root_namespaceObject["default"].zip(aids, elements));
    const atoms = {};
    const coords = complexData.coords && complexData.coords[0];
    const model = coords && coords.conformers && coords.conformers[0];
    const xs = model && model.x;
    const ys = model && model.y;
    const zs = model && model.z || [];
    aids = coords && coords.aid;
    if (!aids || !xs || !ys) {
      throw new Error("Coordinates are not found in the file");
    }
    const chain = complex.addChain(" ");
    const residue = chain.addResidue("UNK", 1, " ");
    for (let i2 = 0, n = aids.length; i2 < n; ++i2) {
      const aid = aids[i2];
      const element = PubChemParser_Element.ByAtomicNumber[elements[aid]];
      const xyz = new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Vector3(xs[i2], ys[i2], zs[i2] || 0);
      atoms[aid] = residue.addAtom(element.name, element, xyz, void 0, true, aid, " ", 1, 0, 0);
    }
    const aids1 = complexData.bonds && complexData.bonds.aid1;
    const aids2 = complexData.bonds && complexData.bonds.aid2;
    const orders = complexData.bonds && complexData.bonds.order || [];
    if (!aids1 || !aids2 || aids1.length !== aids2.length) {
      return;
    }
    for (let j = 0, m2 = aids1.length; j < m2; ++j) {
      complex.addBond(atoms[aids1[j]], atoms[aids2[j]], orders[j] || 1, 0, true);
    }
  }
};
PubChemParser.formats = ["pubchem", "pubchem+json", "pc"];
PubChemParser.extensions = [".json"];
var parsers_PubChemParser = PubChemParser;
var SDFStream = class {
  constructor(data) {
    this._strings = data.split(/\r?\n|\r/);
    this._currentStart = 0;
    this._currentStringIndx = 0;
  }
  setStart(start) {
    if (start >= this._strings.length) {
      this._currentStart = this._strings.length - 1;
      this._currentStringIndx = this._strings.length - 1;
    } else {
      this._currentStart = start;
      this._currentStringIndx = start;
    }
  }
  getNextString() {
    return this._strings[++this._currentStringIndx];
  }
  getCurrentString() {
    return this._strings[this._currentStringIndx];
  }
  getStringFromStart(numb) {
    this._currentStringIndx = this._currentStart + numb;
    return this._strings[this._currentStart + numb];
  }
  findNextDataItem() {
    let curStr = this.getNextString();
    let res = false;
    while (!external_module_lodash_commonjs_lodash_commonjs2_lodash_amd_lodash_root_namespaceObject["default"].isUndefined(curStr) && curStr.trim() !== "$$$$") {
      if (curStr.match(/>\s+<(.*)>/)) {
        res = true;
        break;
      }
      curStr = this.getNextString();
    }
    return res;
  }
  findNextCompoundStart() {
    let curStr = this.getCurrentString();
    while (!external_module_lodash_commonjs_lodash_commonjs2_lodash_amd_lodash_root_namespaceObject["default"].isUndefined(curStr) && curStr.trim() !== "$$$$") {
      curStr = this.getNextString();
    }
    this.setStart(++this._currentStringIndx);
    return this.probablyHaveDataToParse();
  }
  probablyHaveDataToParse() {
    return this._currentStringIndx < this._strings.length - 2;
  }
};
var {
  Complex: SDFParser_Complex,
  Element: SDFParser_Element,
  Bond: SDFParser_Bond,
  Molecule: SDFParser_Molecule
} = chem;
var chargeMap = [0, 3, 2, 1, 0, -1, -2, -3];
var orderMap = [0, 1, 2, 3, 1, 1, 1, 2];
var typeMap = [
  SDFParser_Bond.BondType.UNKNOWN,
  // 0 - error
  SDFParser_Bond.BondType.COVALENT,
  // 1 - single
  SDFParser_Bond.BondType.COVALENT,
  // 2 - double
  SDFParser_Bond.BondType.COVALENT,
  // 3 - triple
  SDFParser_Bond.BondType.AROMATIC,
  // 4 - aromatic
  SDFParser_Bond.BondType.UNKNOWN,
  // 5 - single or double
  SDFParser_Bond.BondType.AROMATIC,
  // 6 - single or aromatic
  SDFParser_Bond.BondType.AROMATIC
  // 7 - double or aromatic
  // 8 - any
  // 9 - coordination
  // 10 - hydrogen
];
var sdfAndMolRegexp = /.*(M\s\sEND).*|.*(^$$$$).*|.*>\s+<(.+)>.*/;
var sdfRegExp = /.*($$$$).*|.*>\s+<(.+)>.*/;
var fileFormat = {
  SDF: "sdf",
  MOL: "mol"
};
var possibleNameTags = ["PUBCHEM_IUPAC_TRADITIONAL_NAME", /PUBCHEM_(.+)_NAME/, /(.+)name/, /(.+)NAME/];
var possibleIDTags = ["PUBCHEM_COMPOUND_CID", "id", "ID", /.*CID/, /.*ID/, /.*id/];
var possibleTitleTags = ["msg", "MSG", "message", "title", "description", "desc"];
var tagsNames = ["name", "id", "title"];
var tags = {
  name: possibleNameTags,
  id: possibleIDTags,
  title: possibleTitleTags
};
function buildChainID(index) {
  if (!index) {
    return "A";
  }
  const codes = [];
  while (index) {
    codes.push(65 + index % 26);
    index = Math.trunc(index / 26);
  }
  if (codes.length > 1) {
    codes.reverse();
    codes[0] -= 1;
  }
  return String.fromCharCode(...codes);
}
var SDFParser = class extends Parser {
  constructor(data, options2) {
    super(data, options2);
    this._format = "sdf";
    this._complex = null;
    this._chain = null;
    this._residue = null;
    this._molecules = null;
    this._metadata = {};
    this._metadata.molecules = [];
    this._currentMolProps = {};
    this._compoundIndx = -1;
    this._assemblies = [];
    this._atomsParsed = 0;
    this._atomsIndexes = [];
  }
  canProbablyParse(data) {
    return external_module_lodash_commonjs_lodash_commonjs2_lodash_amd_lodash_root_namespaceObject["default"].isString(data) && sdfAndMolRegexp.test(data);
  }
  _parseHeader(stream) {
    const molecule = {};
    molecule.name = stream.getStringFromStart(0);
    const date = parseInt(stream.getStringFromStart(1).substr(10, 6).trim(), 10);
    molecule.date = date.toString() || "";
    molecule.title = stream.getStringFromStart(2);
    this._metadata.molecules.push(molecule);
  }
  _parseAtoms(stream, atomsNum) {
    let curStr;
    let serial = this._atomsParsed;
    const chainID = buildChainID(this._compoundIndx);
    const resName = "UNK";
    const resSeq = 1;
    this._chain = this._complex.getChain(chainID) || this._complex.addChain(chainID);
    this._residue = this._chain.addResidue(resName, resSeq, " ");
    for (let i2 = 0; i2 < atomsNum; i2++) {
      curStr = stream.getNextString();
      serial++;
      const x3 = parseFloat(curStr.substr(0, 10));
      const y2 = parseFloat(curStr.substr(10, 10));
      const z = parseFloat(curStr.substr(20, 10));
      const charge = chargeMap[parseInt(curStr.substr(36, 3), 10)];
      const xyz = new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Vector3(x3, y2, z);
      let name = curStr.substr(31, 3).trim().toUpperCase();
      const type = SDFParser_Element.getByName(name);
      if (!this._atomsIndexes[name]) {
        this._atomsIndexes[name] = 0;
      }
      this._atomsIndexes[name] += 1;
      name += this._atomsIndexes[name];
      this._residue.addAtom(name, type, xyz, void 0, true, serial, " ", 1, 0, charge);
    }
  }
  _parseBonds(stream, bondsNum) {
    let curStr;
    for (let i2 = 0; i2 < bondsNum; i2++) {
      curStr = stream.getNextString();
      let atom1 = parseInt(curStr.substr(0, 3), 10) + this._atomsParsed;
      let atom2 = parseInt(curStr.substr(3, 3), 10) + this._atomsParsed;
      const bondType = parseInt(curStr.substr(6, 3), 10);
      if (atom1 > atom2) {
        [atom1, atom2] = [atom2, atom1];
      }
      this._complex.addBond(atom1, atom2, orderMap[bondType] || 1, typeMap[bondType] || SDFParser_Bond.BondType.UNKNOWN, true);
    }
  }
  _parseMOL(stream) {
    this._compoundIndx++;
    this._parseHeader(stream);
    const countsLine = stream.getStringFromStart(3);
    const atomsNum = parseInt(countsLine.substr(0, 3), 10);
    const bondsNum = parseInt(countsLine.substr(3, 3), 10);
    this._parseAtoms(stream, atomsNum);
    this._parseBonds(stream, bondsNum);
    this._atomsParsed += atomsNum;
    this._metadata.molecules[this._compoundIndx]._residues = [];
    this._metadata.molecules[this._compoundIndx]._residues.push(this._residue);
  }
  _parseDataItem(stream) {
    const tag = stream.getCurrentString();
    let data = [];
    let curStr = stream.getNextString();
    while (curStr.trim() !== "") {
      data.push(curStr);
      curStr = stream.getNextString();
    }
    if (data.length === 1) {
      [data] = data;
    }
    this._currentMolProps[tag.replace(/[<>]/g, "").trim()] = data;
  }
  _parseCompound(stream) {
    this._parseMOL(stream);
    if (this._format === fileFormat.SDF) {
      this._currentMolProps = {};
      while (stream.findNextDataItem()) {
        this._parseDataItem(stream);
      }
      if (Object.keys(this._currentMolProps).length !== 0) {
        const molecule = this._metadata.molecules[this._compoundIndx];
        molecule.props = this._currentMolProps;
        this._tryToUpdateMoleculeData(molecule);
      }
    }
  }
  _fixBondsArray() {
    const serialAtomMap = this._serialAtomMap;
    const complex = this._complex;
    const bonds = complex._bonds;
    for (let j = 0; j < bonds.length; j++) {
      const bond = bonds[j];
      if (bond._right < bond._left) {
        console.log("_fixBondsArray: Logic error.");
      }
      bond._left = serialAtomMap[bond._left] || null;
      bond._right = serialAtomMap[bond._right] || null;
    }
  }
  _buildAssemblies() {
    const chains = this._complex._chains;
    if (chains.length === 1) {
      return this._assemblies;
    }
    for (let i2 = 0; i2 < chains.length; i2++) {
      const assembly = new chem_Assembly(this._complex);
      const matrix = new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Matrix4();
      assembly.addMatrix(matrix);
      assembly.addChain(chains[i2]._name);
      this._assemblies.push(assembly);
    }
    return this._assemblies;
  }
  _buildMolecules() {
    this._complex._molecules = [];
    const {
      molecules
    } = this._metadata;
    for (let i2 = 0; i2 < molecules.length; i2++) {
      const molecule = new SDFParser_Molecule(this._complex, molecules[i2].name, i2 + 1);
      molecule.residues = molecules[i2]._residues;
      this._complex._molecules[i2] = molecule;
    }
    return this._complex._molecules;
  }
  _searchTag(tag, props) {
    for (let i2 = 0; i2 < props.length; i2++) {
      if (tag instanceof RegExp && tag.test(props[i2].tag) || tag === props[i2].tag) {
        return props[i2].data;
      }
    }
    return void 0;
  }
  _tryToFind(tagsList, props) {
    for (let j = 0; j < tagsList.length; j++) {
      const res = this._searchTag(tagsList[j], props);
      if (res) {
        return res;
      }
    }
    return void 0;
  }
  _tryToUpdateMoleculeData(molecule) {
    let res = false;
    for (let i2 = 0; i2 < tagsNames.length; i2++) {
      const tagPossibleNames = tags[tagsNames[i2]];
      const data = this._tryToFind(tagPossibleNames, molecule.props);
      if (data) {
        molecule[tagsNames[i2]] = data;
        res = true;
      }
    }
    molecule.name = molecule.name || molecule.id;
    if (molecule.name.match(/^\d+$/)) {
      molecule.name = `CID: ${molecule.name}`;
    }
    return res;
  }
  _finalizeMetadata() {
    const {
      molecules
    } = this._metadata;
    const {
      metadata
    } = this._complex;
    const complex = this._complex;
    if (molecules.length === 1) {
      complex.name = molecules[0].name;
      metadata.title = molecules[0].title;
      metadata.date = molecules[0].date;
      metadata.properties = molecules[0].props;
    } else if (molecules.length > 1) {
      metadata.molecules = [];
      for (let i2 = 0; i2 < molecules.length; i2++) {
        metadata.molecules.push({
          name: molecules[i2].name,
          date: molecules[i2].date,
          title: molecules[i2].title,
          properties: molecules[i2].props
        });
      }
    }
  }
  _finalize() {
    const serialAtomMap = this._serialAtomMap = {};
    const atoms = this._complex._atoms;
    for (let i2 = 0; i2 < atoms.length; i2++) {
      const atom = atoms[i2];
      serialAtomMap[atom.serial] = atom;
    }
    this._complex._finalizeBonds();
    this._fixBondsArray();
    this._finalizeMetadata();
    this._buildAssemblies();
    this._complex.units = this._complex.units.concat(this._assemblies);
    this._buildMolecules();
    this._complex.finalize({
      needAutoBonding: false,
      detectAromaticLoops: false,
      enableEditing: false,
      serialAtomMap: this._serialAtomMap
    });
  }
  defineFormat(data) {
    let format;
    if (sdfRegExp.test(data)) {
      format = fileFormat.SDF;
    } else {
      format = fileFormat.MOL;
    }
    return format;
  }
  parseSync() {
    const result = this._complex = new SDFParser_Complex();
    const stream = new SDFStream(this._data);
    this._format = this.defineFormat(this._data);
    result.metadata.format = this._format;
    do {
      this._parseCompound(stream);
    } while (stream.findNextCompoundStart());
    this._finalize();
    return result;
  }
};
SDFParser.formats = ["mol", "sdf"];
SDFParser.extensions = [".mol", ".sdf"];
var DSN6Header = {
  nstart: [valueType.array, "i16", 0],
  extent: [valueType.array, "i16", 3],
  grid: [valueType.array, "i16", 6],
  cellDims: [valueType.vector, "i16", 9],
  angles: [valueType.array, "i16", 12],
  div: [valueType.singular, "i16", 15],
  adder: [valueType.singular, "i16", 16],
  scaleFactor: [valueType.singular, "i16", 17]
};
var DSN6Model = class extends parsers_VolumeModel {
  _parseHeader(_buffer) {
    this._buff = _buffer;
    this._typedCheck();
    const arrays = {};
    arrays.i16 = new Int16Array(this._buff);
    if (arrays.i16[18] !== 100) {
      for (let i2 = 0, n = arrays.i16.length; i2 < n; ++i2) {
        const val = arrays.i16[i2];
        arrays.i16[i2] = (val & 255) << 8 | val >> 8 & 255;
      }
    }
    if (arrays.i16[18] !== 100) {
      throw new Error("DSN6: Incorrect format ");
    }
    const header = this._header;
    this._fillHeader(DSN6Header, arrays);
    header.cellDims.multiplyScalar(1 / header.scaleFactor);
    header.angles.forEach((angle, i2, a2) => {
      a2[i2] *= Math.PI / 180 / header.scaleFactor;
    });
    header.div /= 100;
  }
  _setAxisIndices() {
    this._xyz2crs[0] = 0;
    this._xyz2crs[1] = 1;
    this._xyz2crs[2] = 2;
  }
  _setOrigins() {
    const header = this._header;
    const [xaxis, yaxis, zaxis] = this._getAxis();
    this._setAxisIndices();
    this._origin.addScaledVector(xaxis, header.nstart[0]);
    this._origin.addScaledVector(yaxis, header.nstart[1]);
    this._origin.addScaledVector(zaxis, header.nstart[2]);
    xaxis.multiplyScalar(header.extent[0]);
    yaxis.multiplyScalar(header.extent[1]);
    zaxis.multiplyScalar(header.extent[2]);
    this._setBoxParams(xaxis, yaxis, zaxis);
  }
  _pointCalculate(xyzData, byteBuffer, z, y2, x3, pos, i2) {
    const header = this._header;
    if (x3 < header.extent[0] && y2 < header.extent[1] && z < header.extent[2]) {
      const idx = x3 + header.extent[0] * (y2 + header.extent[1] * z);
      xyzData[idx] = (byteBuffer[pos.counter] - header.adder) / header.div;
      ++pos.counter;
    } else {
      pos.counter += 8 - i2;
      return false;
    }
    return true;
  }
  _blockCalculate(xyzData, byteBuffer, zBlock, yBlock, xBlock, pos) {
    for (let k2 = 0; k2 < 8; ++k2) {
      const z = 8 * zBlock + k2;
      for (let j = 0; j < 8; ++j) {
        const y2 = 8 * yBlock + j;
        let inRange = true;
        let i2 = 0;
        while (inRange && i2 < 8) {
          const x3 = 8 * xBlock + i2;
          inRange = this._pointCalculate(xyzData, byteBuffer, z, y2, x3, pos, i2);
          i2++;
        }
      }
    }
  }
  _toXYZData() {
    const header = this._header;
    const byteBuffer = new Uint8Array(this._buff);
    const xyzData = new Float32Array(header.extent[0] * header.extent[1] * header.extent[2]);
    const blocks = new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Vector3(header.extent[0] / 8, header.extent[1] / 8, header.extent[2] / 8);
    const pos = {};
    pos.counter = 512;
    for (let zBlock = 0; zBlock < blocks.z; ++zBlock) {
      for (let yBlock = 0; yBlock < blocks.y; ++yBlock) {
        for (let xBlock = 0; xBlock < blocks.x; ++xBlock) {
          this._blockCalculate(xyzData, byteBuffer, zBlock, yBlock, xBlock, pos);
        }
      }
    }
    this._calculateInfoParams(xyzData);
    return xyzData;
  }
  _calculateInfoParams(xyzData) {
    this._header.dmean /= xyzData.length;
    let dispersion = 0;
    let minDensity = xyzData[0];
    let maxDensity = xyzData[0];
    for (let j = 0; j < xyzData.length; j++) {
      dispersion += (this._header.dmean - xyzData[j]) ** 2;
      if (xyzData[j] < minDensity) {
        minDensity = xyzData[j];
      }
      if (xyzData[j] > maxDensity) {
        maxDensity = xyzData[j];
      }
    }
    this._header.sd = Math.sqrt(dispersion / xyzData.length);
    this._header.dmax = maxDensity;
    this._header.dmin = minDensity;
  }
};
var DSN6Parser = class extends Parser {
  constructor(data, options2) {
    super(data, options2);
    this._options.fileType = "dsn6";
    this.model = new DSN6Model();
  }
  static canParse(data, options2) {
    if (!data) {
      return false;
    }
    return data instanceof ArrayBuffer && Parser.checkDataTypeOptions(options2, "dsn6");
  }
  static canProbablyParse(_data) {
    return false;
  }
  parseSync() {
    return this.model.parse(this._data);
  }
};
DSN6Parser.formats = ["dsn6"];
DSN6Parser.extensions = [".dsn6", ".omap"];
DSN6Parser.binary = true;
var parsers_DSN6Parser = DSN6Parser;
var GROReader = class extends parsers_PDBStream {
  constructor(data) {
    super(data);
    this._next = -1;
    this.next();
  }
  /**
   * Getting end of string.
   * @returns {Number} Pointer to end of string
   */
  getNext() {
    return this._next;
  }
};
var parsers_GROReader = GROReader;
var {
  Complex: GROParser_Complex,
  Element: GROParser_Element,
  Molecule: GROParser_Molecule
} = chem;
var GROParser = class extends Parser {
  /**
   * Create parser for .gro file format
   *
   * @param {String} data Input file
   * @param {String} options Input options (optional field)
   */
  constructor(data, options2) {
    super(data, options2);
    this._time = null;
    this._numAtoms = null;
    this._residueNumber = null;
    this._residueName = "";
    this._atomName = "";
    this._atomNumber = null;
    this._atomPosition = [];
    this._atomVelocity = [];
    this._complex = null;
    this._molecules = [];
    this._molecule = null;
    this._options.filetype = "gro";
  }
  /**
   * General check for possibility of parsing.
   * @param {String} data - Input file
   * @returns {boolean} true if this file is in ascii, false otherwise
   */
  canProbablyParse(data) {
    return external_module_lodash_commonjs_lodash_commonjs2_lodash_amd_lodash_root_namespaceObject["default"].isString(this._data) && /^\s*[^\n]*\n\s*\d+ *\n\s*\d+[^\n\d]{3}\s*\w+\s*\d+\s*-?\d/.test(data);
  }
  /**
   * Parsing title of molecule complex.
   * NOTE: that names are ESTIMATES, there is no strict rules in Gromos87 standard for first line in input file.
   * @param {GROReader} line - Line containing title and time.
   */
  _parseTitle(line) {
    const {
      metadata
    } = this._complex;
    metadata.id = line.readLine().trim();
    metadata.name = metadata.id.slice(metadata.id.lastIndexOf("\\") + 1, metadata.id.lastIndexOf("."));
    metadata.format = "gro";
  }
  /**
   * Parsing line containing number of atoms information.
   * @param {GROReader} line - Line containing number of atoms.
   */
  _parseNumberOfAtoms(line) {
    this._numAtoms = line.readInt(0, line.getNext());
    if (Number.isNaN(this._numAtoms)) {
      throw new Error("Line 2 is not representing atom number. Consider checking input file");
    }
  }
  /**
   * Parsing line containing information about residues, atoms etc. Also information about box vectors.
   * Format of atoms MUST (by Gromos87 standard) be this: (note that numbering starts not from 0, but from 1!)
   * ResidueNumber[1 - 5]  ResidueName[6 - 10] AtomName[11 - 15] AtomNumber[16 - 20] Position[21 - 45] Velocity[46 - 69]
   * @param {GROReader} line - Line containing information about atom.
   */
  _parseAtom(line) {
    this._residueNumber = line.readInt(1, 5);
    this._residueName = line.readString(6, 10).trim();
    this._atomName = line.readString(11, 15).trim();
    this._atomNumber = line.readInt(16, 20);
    const positionX = line.readFloat(21, 28) * 10;
    const positionY = line.readFloat(29, 36) * 10;
    const positionZ = line.readFloat(37, 45) * 10;
    if (Number.isNaN(positionX) || Number.isNaN(positionY) || Number.isNaN(positionZ)) {
      this._complex.error = {
        message: `Atom position is invalid in "${line.readLine()}"`
      };
      return;
    }
    const type = GROParser_Element.getByName(this._atomName[0]);
    if (type.fullName === "Unknown") {
      this._complex.error = {
        message: `${this._atomName[0]} hasn't been recognised as an atom name.`
      };
      return;
    }
    const role = GROParser_Element.Role[this._atomName];
    let chain = this._chain;
    if (!chain) {
      this._chain = chain = this._complex.addChain("A");
    }
    let residue = this._residue;
    if (!residue || residue.getSequence() !== this._residueNumber) {
      this._residue = residue = chain.addResidue(this._residueName, this._residueNumber, " ");
    }
    this._atomPosition = new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Vector3(positionX, positionY, positionZ);
    const het = true;
    const altLoc = " ";
    const occupancy = 1;
    const tempFactor = 1;
    const charge = 0;
    residue.addAtom(this._atomName, type, this._atomPosition, role, het, this._atomNumber, altLoc, occupancy, tempFactor, charge);
  }
  /**
   * Some finalizing procedures. In '.gro' file format there is only 1 chain and 1 molecule.
   */
  _finalize() {
    const molecule = new GROParser_Molecule(this._complex, this._complex.metadata.name, 1);
    molecule.residues = this._chain._residues;
    molecule._chains = this._chain;
    this._complex._molecules[0] = molecule;
    this._molecules.push(molecule);
    this._complex.finalize({
      needAutoBonding: true,
      detectAromaticLoops: this.settings.now.aromatic,
      enableEditing: this.settings.now.editing,
      serialAtomMap: this._serialAtomMap
    });
  }
  /**
   * Main parsing procedure.
   * @returns {Complex} Complex structure for visualizing.
   */
  parseSync() {
    const result = this._complex = new GROParser_Complex();
    const reader = new parsers_GROReader(this._data);
    let counter = 0;
    this._parseTitle(reader);
    reader.next();
    this._parseNumberOfAtoms(reader);
    reader.next();
    for (counter = 0; counter < this._numAtoms; ++counter) {
      if (!reader.end()) {
        this._parseAtom(reader);
        reader.next();
      } else break;
    }
    if (counter < this._numAtoms) {
      this._complex.error = {
        message: "File ended unexpectedly."
      };
    }
    if (result.error) {
      throw new Error(result.error.message);
    }
    this._finalize();
    this._atomPosition = null;
    this._complex = null;
    this._molecules = null;
    this._molecule = null;
    return result;
  }
};
GROParser.formats = ["gro"];
GROParser.extensions = [".gro"];
var parsers_GROParser = GROParser;
var {
  Complex: MOL2Parser_Complex,
  Element: MOL2Parser_Element,
  Bond: MOL2Parser_Bond,
  Molecule: MOL2Parser_Molecule
} = chem;
var MOL2Parser_orderMap = {
  un: 0,
  1: 1,
  2: 2,
  3: 3,
  ar: 1,
  am: 1,
  nc: 0,
  du: 1
};
var MOL2Parser_typeMap = {
  un: MOL2Parser_Bond.BondType.UNKNOWN,
  // unknown (cannot be determined from the parameter tables)
  1: MOL2Parser_Bond.BondType.COVALENT,
  // single
  2: MOL2Parser_Bond.BondType.COVALENT,
  // double
  3: MOL2Parser_Bond.BondType.COVALENT,
  // triple
  ar: MOL2Parser_Bond.BondType.AROMATIC,
  // aromatic
  am: MOL2Parser_Bond.BondType.COVALENT,
  // amide
  nc: MOL2Parser_Bond.BondType.UNKNOWN,
  // not connected
  du: MOL2Parser_Bond.BondType.COVALENT
  // dummy
};
var resNumberRegex = /\d+$/;
var spacesRegex = /\s+/;
function splitToFields(str) {
  return str.trim().split(spacesRegex);
}
var MOL2Parser = class extends Parser {
  constructor(data, options2) {
    super(data, options2);
    this._complex = null;
    this._chain = null;
    this._residue = null;
    this._compoundIndx = -1;
    this._molecules = [];
    this._molecule = null;
    this._currPosIdx = 0;
    this._currStartIdx = 0;
    this._serialAtomMap = {};
    this._options.fileType = "mol2";
  }
  _parseRawStrings(data) {
    return data.split(/\r?\n|\r/);
  }
  _toStringFromStart(numb, MOL2Data) {
    const newPosIdx = this._currStartIdx + numb;
    this._currPosIdx = newPosIdx < MOL2Data.length ? newPosIdx : this._currStartIdx;
  }
  _toHeaderString(header, MOL2Data) {
    this._toStringFromStart(0, MOL2Data);
    while (this._currPosIdx < MOL2Data.length) {
      if (MOL2Data[this._currPosIdx].match(`@<TRIPOS>${header}`)) {
        return;
      }
      this._currPosIdx++;
    }
    this._toStringFromStart(0, MOL2Data);
  }
  _toStringFromHeader(header, numb, MOL2Data) {
    this._toHeaderString(header, MOL2Data);
    const newPosIdx = this._currPosIdx + numb;
    if (MOL2Data[this._currPosIdx].match(`@<TRIPOS>${header}`) && newPosIdx < MOL2Data.length) {
      this._currPosIdx = newPosIdx;
    }
  }
  _setStart(startPos, MOL2Data) {
    if (startPos >= MOL2Data.length) {
      this._currStartIdx = this._currPosIdx = MOL2Data.length - 1;
    } else {
      this._currStartIdx = this._currPosIdx = startPos;
    }
  }
  _probablyHaveDataToParse(MOL2Data) {
    return this._currPosIdx < MOL2Data.length - 2;
  }
  _findNextCompoundStart(MOL2Data) {
    while (this._currPosIdx < MOL2Data.length && MOL2Data[this._currPosIdx].trim() !== "@<TRIPOS>MOLECULE>") {
      this._currPosIdx++;
    }
    this._setStart(++this._currPosIdx, MOL2Data);
    return this._probablyHaveDataToParse(MOL2Data);
  }
  _parseMolecule(MOL2Data) {
    this._toHeaderString("MOLECULE", MOL2Data);
    const {
      metadata
    } = this._complex;
    metadata.name = MOL2Data[++this._currPosIdx];
    metadata.format = "mol2";
    this._molecule = {
      _index: "",
      _chains: []
    };
    this._molecule._index = this._compoundIndx + 1;
    this._molecules.push(this._molecule);
  }
  /* Atom format description:
   * atomId atomName x y z element [resSeq [resName [charge [statusBit]]]]
   * statusBits is the internal SYBYL status bits associated with the atom.
   * These should never be set by the user.
   * Source: http://chemyang.ccnu.edu.cn/ccb/server/AIMMS/mol2.pdf
   */
  _parseAtoms(atomsNum, MOL2Data) {
    this._toHeaderString("ATOM", MOL2Data);
    for (let i2 = 0; i2 < atomsNum; i2++) {
      const parsedStr = splitToFields(MOL2Data[++this._currPosIdx]);
      if (parsedStr.length < 6) {
        throw new Error("MOL2 parsing error: Not enough information to create atom!");
      }
      const atomId = parseInt(parsedStr[0], 10);
      const atomName = parsedStr[1];
      const x3 = parseFloat(parsedStr[2]);
      const y2 = parseFloat(parsedStr[3]);
      const z = parseFloat(parsedStr[4]);
      const element = parsedStr[5].split(".")[0].toUpperCase();
      let charge = 0;
      if (parsedStr.length >= 9) {
        charge = parseFloat(parsedStr[8]) || 0;
      }
      let chain = this._chain;
      if (!chain) {
        this._chain = chain = this._complex.getChain("A") || this._complex.addChain("A");
        this._residue = null;
      }
      if (!this._setResidue(parsedStr)) {
        continue;
      }
      const het = false;
      const altLoc = " ";
      const occupancy = 1;
      const tempFactor = 0;
      const type = MOL2Parser_Element.getByName(element);
      const role = MOL2Parser_Element.Role[atomName];
      const xyz = new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Vector3(x3, y2, z);
      this._residue.addAtom(atomName, type, xyz, role, het, atomId, altLoc, occupancy, tempFactor, charge);
    }
  }
  _setResidue(parsedStr) {
    let resSeq = 1;
    let resName = "UNK";
    if (parsedStr.length >= 7) {
      resSeq = parseInt(parsedStr[6], 10);
    }
    if (parsedStr.length >= 8 && parsedStr[7] !== "<0>") {
      resName = parsedStr[7].replace(resNumberRegex, "");
    }
    if (this.settings.now.nowater) {
      if (resName === "HOH" || resName === "WAT") {
        return false;
      }
    }
    const residue = this._residue;
    const chain = this._chain;
    if (!residue || residue.getSequence() !== resSeq) {
      this._residue = chain.addResidue(resName, resSeq, "A");
    }
    return true;
  }
  /* Bond format description
   * bondId originAtomId targetAtomId bondType [statusBits]
   */
  _parseBonds(bondsNum, MOL2Data) {
    this._toHeaderString("BOND", MOL2Data);
    for (let i2 = 0; i2 < bondsNum; i2++) {
      const parsedStr = splitToFields(MOL2Data[++this._currPosIdx]);
      if (parsedStr.length < 3) {
        throw new Error("MOL2 parsing error: Missing information about bonds!");
      }
      let originAtomId = parseInt(parsedStr[1], 10);
      let targetAtomId = parseInt(parsedStr[2], 10);
      const bondType = parsedStr[3];
      if (originAtomId > targetAtomId) {
        [originAtomId, targetAtomId] = [targetAtomId, originAtomId];
      }
      this._complex.addBond(originAtomId, targetAtomId, MOL2Parser_orderMap[bondType] || 0, MOL2Parser_typeMap[bondType] || MOL2Parser_Bond.BondType.UNKNOWN, true);
    }
  }
  _fixSerialAtoms() {
    const atoms = this._complex._atoms;
    for (let i2 = 0; i2 < atoms.length; i2++) {
      const atom = atoms[i2];
      this._serialAtomMap[atom.serial] = atom;
    }
  }
  _fixBondsArray() {
    const serialAtomMap = this._serialAtomMap;
    const complex = this._complex;
    if (Object.keys(serialAtomMap).length === 0) {
      throw new Error("MOL2 parsing error: Missing atom information!");
    }
    const bonds = complex._bonds;
    for (let j = 0; j < bonds.length; j++) {
      const bond = bonds[j];
      bond._left = serialAtomMap[bond._left] || null;
      bond._right = serialAtomMap[bond._right] || null;
    }
  }
  _finalizeMolecules() {
    const chain = this._complex._chains[0];
    this._complex._molecules = [];
    for (let i2 = 0; i2 < this._molecules.length; i2++) {
      const currMolecule = this._molecules[i2];
      const molResidues = chain._residues;
      const molecule = new MOL2Parser_Molecule(this._complex, currMolecule._name, i2 + 1);
      molecule.residues = molResidues;
      this._complex._molecules[i2] = molecule;
    }
  }
  _finalize() {
    this._complex._finalizeBonds();
    this._fixSerialAtoms();
    this._fixBondsArray();
    this._finalizeMolecules();
    this._complex.finalize({
      needAutoBonding: false,
      detectAromaticLoops: this.settings.now.aromatic,
      enableEditing: this.settings.now.editing,
      serialAtomMap: this._serialAtomMap
    });
  }
  _parseCompound(MOL2Data) {
    this._compoundIndx++;
    this._parseMolecule(MOL2Data);
    this._toStringFromHeader("MOLECULE", 2, MOL2Data);
    const parsedStr = MOL2Data[this._currPosIdx].trim().split(spacesRegex);
    const atomsNum = parsedStr[0];
    const bondsNum = parsedStr[1];
    this._parseAtoms(atomsNum, MOL2Data);
    this._parseBonds(bondsNum, MOL2Data);
  }
  parseSync() {
    const result = this._complex = new MOL2Parser_Complex();
    const MOL2Data = this._parseRawStrings(this._data);
    do {
      this._parseCompound(MOL2Data);
    } while (this._findNextCompoundStart(MOL2Data));
    this._finalize();
    return result;
  }
};
MOL2Parser.formats = ["mol2"];
MOL2Parser.extensions = [".mol2", ".ml2", ".sy2"];
var parsers_MOL2Parser = MOL2Parser;
var parsers = new parsers_ParserList([
  // note: order might be important
  parsers_PDBParser,
  parsers_CIFParser,
  parsers_MMTFParser,
  parsers_XYZParser,
  parsers_CMLParser,
  parsers_PubChemParser,
  SDFParser,
  parsers_CCP4Parser,
  parsers_DSN6Parser,
  parsers_GROParser,
  parsers_MOL2Parser
]);
var ExporterList = class extends utils_EntityList {
  /**
   * Create a list of exporters.
   * The exporters are indexed by supported data formats (`.formats` and
   * `.extensions` properties of a Exporter subclass).
   * The Exporters can be retrieved later by matching against specs (see {@link ExporterList#find}).
   *
   * @param {!Array<function(new:Exporter)>=} someExporters A list of {@link Exporter} subclasses to
   *   automatically register at creation time.
   * @see ExporterList#register
   */
  constructor() {
    let someExporters = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
    super(someExporters, ["formats"]);
  }
  /**
   * Find a suitable exporter for data.
   *
   * @param {Object} specs Exporter specifications.
   * @param {string=} specs.format Supported data format.
   * @param {*=} specs.data Data to export.
   */
  find(specs) {
    let list = [];
    if (specs.format) {
      list = this._dict.formats[specs.format.toLowerCase()] || [];
    }
    return [...list];
  }
};
var exporters_ExporterList = ExporterList;
var Exporter = class {
  constructor(source, options2) {
    this._source = source;
    this._options = options2 || {};
    this._abort = false;
  }
  exportSync() {
    throw new Error("Exporting to this source is not implemented");
  }
  export() {
    return new Promise((resolve, reject) => {
      setTimeout(() => {
        try {
          if (this._abort) {
            return reject(new Error("Export aborted"));
          }
          return resolve(this.exportSync());
        } catch (error) {
          return reject(error);
        }
      });
    });
  }
  abort() {
    this._abort = true;
  }
};
utils_makeContextDependent(Exporter.prototype);
var PDBResult = class {
  constructor() {
    this._resultArray = [];
    this._currentStr = -1;
    this._tag = null;
    this._fixedNumeration = false;
    this._numeration = false;
    this._tagStrNum = 0;
  }
  getResult() {
    this.writeString("\n", 81, 81);
    return this._resultArray.join("");
  }
  _currentStrLength() {
    const curStr = this._resultArray[this._currentStr];
    return curStr ? curStr.length : 0;
  }
  // numeration can be number or boolean
  // if numeration is number then just put this number to 8-10 pos in string
  // if numeration is boolean then increase number for all new strings
  newTag(tag, numeration) {
    if (!tag) {
      this._tag = null;
    } else {
      this._tag = tag;
    }
    if (!external_module_lodash_commonjs_lodash_commonjs2_lodash_amd_lodash_root_namespaceObject["default"].isUndefined(numeration)) {
      if (external_module_lodash_commonjs_lodash_commonjs2_lodash_amd_lodash_root_namespaceObject["default"].isNumber(numeration)) {
        this._tagStrNum = numeration;
        this._numeration = true;
        this._fixedNumeration = true;
      } else if (external_module_lodash_commonjs_lodash_commonjs2_lodash_amd_lodash_root_namespaceObject["default"].isBoolean(numeration)) {
        this._tagStrNum = 0;
        this._numeration = numeration;
        this._fixedNumeration = false;
      }
    } else {
      this._numeration = false;
      this._fixedNumeration = false;
      this._tagStrNum = 0;
    }
  }
  newString(tag) {
    this.writeString("\n", 81, 81);
    this._currentStr++;
    this._resultArray.push("");
    if (tag) {
      this.writeString(tag, 1, 6);
    } else if (this._tag) {
      this.writeString(this._tag, 1, 6);
    }
    if (this._numeration) {
      if (!this._fixedNumeration) {
        this._tagStrNum++;
      }
      if (this._tagStrNum !== 1) {
        this.writeString(this._tagStrNum.toString(), 10, 8);
      }
    }
  }
  writeEntireString(string, maxStrPos, concat) {
    if (!maxStrPos) {
      maxStrPos = 81;
    }
    for (let j = 0; j < string.length; j++) {
      if (this._currentStrLength() === maxStrPos && j !== string.length - 1) {
        this.newString();
        if (concat) {
          this.writeString(concat.tag, concat.begin, concat.end);
        }
      }
      if (string[j] === "\n") {
        this.newString();
      } else {
        this.writeString(string[j]);
      }
    }
  }
  writeString(string, begin, end) {
    let curStr = this._resultArray[this._currentStr];
    let str;
    const curStrLength = curStr ? curStr.length : 0;
    if (external_module_lodash_commonjs_lodash_commonjs2_lodash_amd_lodash_root_namespaceObject["default"].isUndefined(string)) {
      return;
    }
    if (!external_module_lodash_commonjs_lodash_commonjs2_lodash_amd_lodash_root_namespaceObject["default"].isNumber(begin)) {
      begin = curStrLength + 1;
    }
    if (!external_module_lodash_commonjs_lodash_commonjs2_lodash_amd_lodash_root_namespaceObject["default"].isNumber(end)) {
      end = curStrLength + string.length;
    }
    if (!external_module_lodash_commonjs_lodash_commonjs2_lodash_amd_lodash_root_namespaceObject["default"].isString(string)) {
      str = string.toString();
    } else {
      str = string;
    }
    const finish = begin < end ? end : begin;
    const start = begin < end ? begin : end;
    if (str.length > Math.abs(begin - end) + 1) {
      str = str.substr(0, Math.abs(begin - end + 1));
    }
    if (start > curStrLength + 1) {
      this._resultArray[this._currentStr] += " ".repeat(start - curStrLength - 1);
    } else if (start <= curStrLength) {
      const cStr = this._resultArray[this._currentStr];
      this._resultArray[this._currentStr] = cStr.slice(0, start - 1);
    }
    if (end < begin) {
      const len = begin - end + 1;
      str = " ".repeat(len - str.length) + str;
    }
    if (start === 11 && this._numeration && this._tagStrNum !== 1) {
      str = ` ${str}`;
    }
    this._resultArray[this._currentStr] += str;
    curStr = this._resultArray[this._currentStr];
    if (finish > curStr.length) {
      this._resultArray[this._currentStr] += " ".repeat(finish - curStr.length);
    }
  }
  writeBondsArray(bonds, atom) {
    const bondsArrays = this._getSubArrays(bonds, 4);
    for (let k2 = 0; k2 < bondsArrays.length; k2++) {
      this.newString();
      this.writeString(atom.serial, 11, 7);
      for (let j = 0; j < bondsArrays[k2].length; j++) {
        const serial = bondsArrays[k2][j]._left.serial === atom.serial ? bondsArrays[k2][j]._right.serial : bondsArrays[k2][j]._left.serial;
        this.writeString(serial, 16 + 5 * j, 12 + 5 * j);
      }
    }
  }
  _getSubArrays(arr, subArraySize) {
    const subArrays = [];
    for (let i2 = 0; i2 < arr.length; i2 += subArraySize) {
      subArrays.push(arr.slice(i2, i2 + subArraySize));
    }
    return subArrays;
  }
  // function for writing matrix in Remark290 and Remark350 tags
  // (see pdb file description)
  writeMatrix(matrix, matrixIndx, tag) {
    for (let j = 0; j < 3; j++) {
      this.newString();
      this.writeString(tag, 14, 18);
      this.writeString((j + 1).toString(), 19, 19);
      this.writeString(matrixIndx.toString(), 23, 20);
      for (let k2 = 0; k2 < 3; k2++) {
        const numb2 = parseFloat(matrix.elements[j * 4 + k2]).toFixed(6);
        this.writeString(numb2.toString(), 33 + k2 * 10, 24 + k2 * 10);
      }
      const numb = parseFloat(matrix.elements[j * 4 + 3]).toFixed(5);
      this.writeString(numb.toString(), 68, 55);
    }
  }
  writeMatrices(matrices, string) {
    if (!matrices) {
      return;
    }
    const matrix = new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Matrix4();
    for (let j = 0; j < matrices.length; j++) {
      matrix.copy(matrices[j]).transpose();
      this.writeMatrix(matrix, j + 1, string);
    }
  }
};
var PDBExporter = class extends Exporter {
  constructor(source, options2) {
    super(source, options2);
    this._tags = ["HEADER", "TITLE", "COMPND", "REMARK", "HELIX", "SHEET", "ATOM and HETATM", "CONECT"];
    this._result = null;
    this._tagExtractors = {
      HEADER: this._extractHEADER,
      TITLE: this._extractTITLE,
      "ATOM and HETATM": this._extractATOM,
      CONECT: this._extractCONECT,
      COMPND: this._extractCOMPND,
      REMARK: this._extractREMARK,
      HELIX: this._extractHELIX,
      SHEET: this._extractSHEET
    };
    this._stringForRemark350 = "COORDINATES FOR A COMPLETE MULTIMER REPRESENTING THE KNOWN\nBIOLOGICALLY SIGNIFICANT OLIGOMERIZATION STATE OF THE\nMOLECULE CAN BE GENERATED BY APPLYING BIOMT TRANSFORMATIONS\nGIVEN BELOW.  BOTH NON-CRYSTALLOGRAPHIC AND\nCRYSTALLOGRAPHIC OPERATIONS ARE GIVEN.";
    this._stringForRemark290 = "CRYSTALLOGRAPHIC SYMMETRY TRANSFORMATIONS\nTHE FOLLOWING TRANSFORMATIONS OPERATE ON THE ATOM/HETATM\nRECORDS IN THIS ENTRY TO PRODUCE CRYSTALLOGRAPHICALLY\nRELATED MOLECULES.";
  }
  exportSync() {
    const result = new PDBResult();
    if (!this._source) {
      return this._result;
    }
    for (let i2 = 0; i2 < this._tags.length; i2++) {
      const tag = this._tags[i2];
      const func = this._tagExtractors[tag];
      if (external_module_lodash_commonjs_lodash_commonjs2_lodash_amd_lodash_root_namespaceObject["default"].isFunction(func)) {
        func.call(this, result);
      }
    }
    this._result = result.getResult();
    return this._result;
  }
  _extractHEADER(result) {
    if (!this._source.metadata) {
      return;
    }
    const {
      metadata
    } = this._source;
    result.newTag("HEADER");
    result.newString();
    if (metadata.classification) {
      result.writeString(metadata.classification, 11, 50);
    }
    if (metadata.date) {
      result.writeString(metadata.date, 51, 59);
    }
    if (metadata.id) {
      result.writeString(metadata.id, 63, 66);
    }
  }
  _extractTITLE(result) {
    if (!this._source.metadata) {
      return;
    }
    const {
      metadata
    } = this._source;
    if (!metadata.title) {
      return;
    }
    result.newTag("TITLE", true);
    for (let i2 = 0; i2 < metadata.title.length; i2++) {
      result.newString();
      result.writeString(metadata.title[i2], 11, 80);
    }
  }
  _extractCONECT(result) {
    if (!this._source._atoms) {
      return;
    }
    const atoms = this._source._atoms;
    result.newTag("CONECT");
    for (let i2 = 0; i2 < atoms.length; i2++) {
      const fixedBonds = atoms[i2].bonds.filter((bond) => bond._fixed);
      if (fixedBonds.length !== 0) {
        result.writeBondsArray(fixedBonds.reverse(), atoms[i2]);
      }
    }
  }
  _extractSHEET(result) {
    if (!this._source._sheets) {
      return;
    }
    result.newTag("SHEET");
    const sheets = this._source._sheets;
    for (let i2 = 0; i2 < sheets.length; i2++) {
      if (sheets[i2]._strands) {
        const strands = sheets[i2]._strands;
        for (let j = 0; j < strands.length; j++) {
          result.newString();
          result.writeString(j + 1, 10, 8);
          result.writeString(sheets[i2]._name, 14, 12);
          result.writeString(strands.length, 16, 15);
          result.writeString(strands[j].init._type._name, 18, 20);
          result.writeString(strands[j].init._chain._name, 22, 22);
          result.writeString(strands[j].init._sequence, 26, 23);
          result.writeString(strands[j].init._icode, 27, 27);
          result.writeString(strands[j].term._type._name, 29, 31);
          result.writeString(strands[j].init._chain._name, 33, 33);
          result.writeString(strands[j].term._sequence, 37, 34);
          result.writeString(strands[j].term._icode, 38, 38);
          result.writeString(strands[j].sense, 40, 39);
        }
      }
    }
  }
  _extractHELIX(result) {
    if (!this._source._helices) {
      return;
    }
    result.newTag("HELIX");
    const helices = this._source._helices;
    for (let i2 = 0; i2 < helices.length; i2++) {
      const helix = helices[i2];
      const helixClass = external_module_lodash_commonjs_lodash_commonjs2_lodash_amd_lodash_root_namespaceObject["default"].invert(typeByPDBHelixClass);
      result.newString();
      result.writeString(helix.serial, 10, 8);
      result.writeString(helix.name, 14, 12);
      result.writeString(helix.init._type._name, 16, 18);
      result.writeString(helix.init._chain._name, 20, 20);
      result.writeString(helix.init._sequence, 25, 22);
      result.writeString(helix.init._icode, 26, 26);
      result.writeString(helix.term._type._name, 28, 30);
      result.writeString(helix.term._chain._name, 32, 32);
      result.writeString(helix.term._sequence, 37, 34);
      result.writeString(helix.term._icode, 38, 38);
      result.writeString(helixClass[helix.type], 40, 39);
      result.writeString(helix.comment, 41, 70);
      result.writeString(helix.length, 76, 72);
    }
  }
  _extractATOM(result) {
    if (!this._source._atoms) {
      return;
    }
    const atoms = this._source._atoms;
    for (let i2 = 0; i2 < atoms.length; i2++) {
      const tag = atoms[i2].het ? "HETATM" : "ATOM";
      result.newString(tag);
      const startIndx = atoms[i2].element.name.length > 1 || atoms[i2].name.length > 3 ? 13 : 14;
      result.writeString(atoms[i2].serial, 11, 7);
      result.writeString(atoms[i2].name, startIndx, 16);
      result.writeString(String.fromCharCode(atoms[i2].location), 17, 17);
      result.writeString(atoms[i2].residue._type._name, 20, 18);
      result.writeString(atoms[i2].residue._chain._name, 22, 22);
      result.writeString(atoms[i2].residue._sequence, 26, 23);
      result.writeString(atoms[i2].residue._icode, 27, 27);
      result.writeString(atoms[i2].position.x.toFixed(3), 38, 31);
      result.writeString(atoms[i2].position.y.toFixed(3), 46, 39);
      result.writeString(atoms[i2].position.z.toFixed(3), 54, 47);
      result.writeString(atoms[i2].occupancy.toFixed(2), 60, 55);
      result.writeString(atoms[i2].temperature.toFixed(2), 66, 61);
      result.writeString(atoms[i2].element.name, 78, 77);
      if (atoms[i2].charge) {
        result.writeString(atoms[i2].charge, 79, 80);
      }
    }
  }
  _extractCOMPND(result) {
    if (!this._source._molecules) {
      return;
    }
    const molecules = this._source._molecules;
    result.newTag("COMPND", true);
    for (let i2 = 0; i2 < molecules.length; i2++) {
      const chains = this._getMoleculeChains(molecules[i2]);
      result.newString();
      result.writeString(`MOL_ID: ${molecules[i2].index};`, 11, 80);
      result.newString();
      result.writeString(`MOLECULE: ${molecules[i2].name};`, 11, 80);
      result.newString();
      result.writeString("CHAIN: ", 11, 18);
      const chainsString = `${chains.join(", ")};`;
      result.writeEntireString(chainsString, 81);
    }
  }
  _extractREMARK(result) {
    this._Remark290(result);
    this._Remark350(result);
  }
  _Remark290(result) {
    if (!this._source.symmetry) {
      return;
    }
    if (this._source.symmetry.length !== 0) {
      const matrices = this._source.symmetry;
      result.newTag("REMARK", 290);
      result.newString();
      result.newString();
      result.writeEntireString(this._stringForRemark290);
      result.writeMatrices(matrices, "SMTRY");
      result.newString();
      result.newString();
      result.writeString("REMARK: NULL", 11, 80);
    }
  }
  _Remark350(result) {
    if (!this._source.units) {
      return;
    }
    const {
      units
    } = this._source;
    let biomolIndx = 0;
    result.newTag("REMARK", 350);
    result.newString();
    result.newString();
    result.writeEntireString(this._stringForRemark350);
    const assemblies = units.filter((unit) => unit instanceof chem_Assembly);
    for (let i2 = 0; i2 < assemblies.length; i2++) {
      result.newString();
      result.newString();
      biomolIndx++;
      result.writeString(`BIOMOLECULE: ${biomolIndx}`, 11, 80);
      const chains = assemblies[i2].chains.join(", ");
      result.newString();
      result.writeString("APPLY THE FOLLOWING TO CHAINS: ");
      result.writeEntireString(chains, 69, {
        tag: "AND CHAINS: ",
        begin: 31,
        end: 42
      });
      const {
        matrices
      } = assemblies[i2];
      result.writeMatrices(matrices, "BIOMT");
    }
  }
  _getMoleculeChains(molecule) {
    function getChainName(residue) {
      return residue._chain._name;
    }
    const chainNames = molecule.residues.map(getChainName);
    return chainNames.filter((item, pos) => chainNames.indexOf(item) === pos);
  }
};
PDBExporter.formats = ["pdb"];
PDBExporter.SourceClass = chem_Complex;
var FBX_POS_SIZE = 3;
var FBX_NORM_SIZE = 3;
var FBX_COL_SIZE = 4;
function copyFbxPoint3(src2, srcIdx, dst, dstIdx) {
  dst[dstIdx] = src2[srcIdx];
  dst[dstIdx + 1] = src2[srcIdx + 1];
  dst[dstIdx + 2] = src2[srcIdx + 2];
}
function copyFbxPoint4(src2, srcIdx, dst, dstIdx, value) {
  dst[dstIdx] = src2[srcIdx];
  dst[dstIdx + 1] = src2[srcIdx + 1];
  dst[dstIdx + 2] = src2[srcIdx + 2];
  dst[dstIdx + 3] = value;
}
var vector4 = new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Vector4();
function copyTransformedPoint3(src2, srcIdx, dst, dstIdx, opts) {
  vector4.set(src2[srcIdx], src2[srcIdx + 1], src2[srcIdx + 2], opts.w);
  vector4.applyMatrix4(opts.matrix);
  dst[dstIdx] = vector4.x;
  dst[dstIdx + 1] = vector4.y;
  dst[dstIdx + 2] = vector4.z;
}
function setSubArray(src2, dst, count, copyFunctor, functorOpts) {
  if ((dst.array.length - dst.start) / dst.stride < count || (src2.array.length - src2.start) / src2.stride < count) {
    return;
  }
  if (src2.stride === dst.stride) {
    dst.array.set(src2.array, dst.start);
  } else {
    let idx = dst.start;
    let arridx = src2.start;
    for (let i2 = 0; i2 < count; ++i2, idx += dst.stride, arridx += src2.stride) {
      copyFunctor(src2.array, arridx, dst.array, idx, functorOpts);
    }
  }
}
var FBXModel = class {
  constructor() {
    this.positions = null;
    this.normals = null;
    this.colors = null;
    this.indices = null;
    this.lastPos = 0;
    this.lastNorm = 0;
    this.lastCol = 0;
    this.lastIdx = 0;
  }
  init(vertsCount, indsCount) {
    this.positions = new Float32Array(vertsCount * FBX_POS_SIZE);
    this.normals = new Float32Array(vertsCount * FBX_NORM_SIZE);
    this.colors = new Float32Array(vertsCount * FBX_COL_SIZE);
    this.indices = new Int32Array(indsCount);
  }
  setPositions(array, start, count, stride) {
    const src2 = {
      array,
      start,
      stride
    };
    const dst = {
      array: this.positions,
      start: this.lastPos,
      stride: FBX_POS_SIZE
    };
    setSubArray(src2, dst, count, copyFbxPoint3);
    this.lastPos += count * FBX_POS_SIZE;
  }
  setTransformedPositions(array, start, count, stride, matrix) {
    let idx = this.lastPos;
    let arrIdx = start;
    const opts = {
      matrix,
      w: 1
    };
    for (let i2 = 0; i2 < count; ++i2, arrIdx += stride, idx += FBX_POS_SIZE) {
      copyTransformedPoint3(array, arrIdx, this.positions, idx, opts);
    }
    this.lastPos += count * FBX_POS_SIZE;
  }
  setNormals(array, start, count, stride) {
    const src2 = {
      array,
      start,
      stride
    };
    const dst = {
      array: this.normals,
      start: this.lastNorm,
      stride: FBX_NORM_SIZE
    };
    setSubArray(src2, dst, count, copyFbxPoint3);
    this.lastNorm += count * FBX_NORM_SIZE;
  }
  setTransformedNormals(array, start, count, stride, matrix) {
    let idx = this.lastNorm;
    let arrIdx = start;
    const opts = {
      matrix,
      w: 0
    };
    for (let i2 = 0; i2 < count; ++i2, arrIdx += stride, idx += FBX_NORM_SIZE) {
      copyTransformedPoint3(array, arrIdx, this.normals, idx, opts);
    }
    this.lastNorm += count * FBX_NORM_SIZE;
  }
  setColors(array, start, count, stride) {
    const src2 = {
      array,
      start,
      stride
    };
    const dst = {
      array: this.colors,
      start: this.lastCol,
      stride: FBX_COL_SIZE
    };
    setSubArray(src2, dst, count, copyFbxPoint4, 1);
    this.lastCol += count * FBX_COL_SIZE;
  }
  setIndices(array, start, count) {
    this.indices.set(array, this.lastIdx);
    this.lastIdx += count;
  }
  setShiftedIndices(array, count, shift) {
    const shifted = array.map((x3) => x3 + shift);
    this.setIndices(shifted, 0, count);
  }
  getVerticesNumber() {
    return this.lastPos / FBX_POS_SIZE;
  }
  addInstance(matrix, geo) {
    const currentCount = this.getVerticesNumber();
    this.setShiftedIndices(geo.indices, geo.indices.length, currentCount);
    const size = geo.itemSize;
    this.setTransformedPositions(geo.positions, 0, geo.vertsCount, size.position, matrix);
    this.setTransformedNormals(geo.normals, 0, geo.vertsCount, size.normal, matrix);
    this.setColors(geo.colors, 0, geo.vertsCount, size.color);
  }
};
var FBXGeometry = class {
  /**
   * Create a base geo with necessary members.
   */
  constructor() {
    this.positions = null;
    this.normals = null;
    this.colors = null;
    this.indices = null;
    this.vertsCount = 0;
    this.itemSize = null;
  }
  /**
   * Initialize base geo storing items info from attributes.
   * @param {Object} geo - THREE.BufferGeometry.
   */
  init(geo, _info) {
    const {
      attributes
    } = geo;
    this.itemSize = {
      position: attributes.position.itemSize,
      normal: attributes.normal.itemSize,
      color: attributes.color.itemSize
    };
  }
};
var FBX1CGeometry = class extends FBXGeometry {
  /**
   * Initialize geo storing positions, normals, indices and create colors.
   * @param {Object} geo - THREE.BufferGeometry.
   */
  init(geo, _info) {
    super.init(geo, _info);
    const {
      attributes: {
        position,
        normal
      },
      index
    } = geo;
    this.vertsCount = position.count;
    this.positions = position.array;
    this.normals = normal.array;
    this.colors = new Float32Array(this.vertsCount * this.itemSize.color);
    this.indices = index.array;
  }
  /**
   * Set defined color for all items in color attribute
   * @param {Object} color - THREE.Color.
   */
  setColors(color) {
    let offset = 0;
    for (let i2 = 0, l2 = this.colors.length, cl = this.itemSize.color; i2 < l2; i2 += cl) {
      this.colors[offset++] = color.r;
      this.colors[offset++] = color.g;
      this.colors[offset++] = color.b;
    }
  }
};
var FBX2CCylinder = class extends FBXGeometry {
  constructor() {
    super();
    this._cutRawStart = 0;
    this._cutRawEnd = 0;
    this._facesPerSlice = 0;
  }
  /**
   * Initialize geo by creating new attributes, because we extend number of vertices to make cylinder two-colored.
   * Indices remain the same. We process open- end close-ended cylinders and consider cylinders od 2 segments
   * in height ONLY.
   * NOTE: cylinder consists of 2 height segments and stores parts in the order: tube, topCap, bottomCap
   * @param {Object} geo - THREE.BufferGeometry.
   * @param {Object} info - information needed for geo extend
   */
  init(geo, info) {
    super.init(geo, info);
    const {
      attributes: {
        position
      },
      index
    } = geo;
    this.vertsCount = position.count + info.addPerCylinder;
    this._facesPerSlice = info.addPerCylinder;
    this.positions = new Float32Array(this.vertsCount * position.itemSize);
    this.normals = new Float32Array(this.vertsCount * this.itemSize.normal);
    this.colors = new Float32Array(this.vertsCount * this.itemSize.color);
    this._extendVertices(geo, info);
    this.indices = new Uint32Array(index.count);
    this._extendIndices(geo, info);
  }
  /** Extend vertex attributes to have one more slice to make sharp middle startColor-endColor line. */
  _extendVertices(geo, info) {
    const {
      position
    } = geo.attributes;
    const {
      normal
    } = geo.attributes;
    const geoParams = geo.getGeoParams();
    const cutRaw = 1;
    this._cutRawStart = cutRaw * geoParams.radialSegments;
    this._cutRawEnd = this._cutRawStart + info.addPerCylinder;
    {
      let temp = position.array.slice(0, this._cutRawEnd * position.itemSize);
      this.positions.set(temp, 0);
      temp = normal.array.slice(0, this._cutRawEnd * normal.itemSize);
      this.normals.set(temp, 0);
    }
    {
      let temp = position.array.slice(this._cutRawStart * position.itemSize, position.array.length);
      this.positions.set(temp, this._cutRawEnd * position.itemSize);
      temp = normal.array.slice(this._cutRawStart * normal.itemSize, normal.array.length);
      this.normals.set(temp, this._cutRawEnd * normal.itemSize);
    }
  }
  /** Shift values of second part (+caps) indices by newly added vertices count. Number of faces remains the same. */
  _extendIndices(geo, info) {
    const {
      index
    } = geo;
    const indicesPerQuad = 6;
    const startToShift = info.addPerCylinder * indicesPerQuad;
    const shift = info.addPerCylinder;
    let shifted = index.array.slice(startToShift, index.count);
    shifted = shifted.map((x3) => x3 + shift);
    this.indices.set(index.array, 0);
    this.indices.set(shifted, startToShift);
  }
  /**
   * Set defined colors: (first part + bottom cap), (second part + top cap)
   * @param {number} start - start color index
   * @param {number} end - start color index
   * @param {array} array - array of colors
   * @param {array} color - color value components
   */
  _setColorRange(start, end, array, color) {
    const colorSize = color.length;
    for (let i2 = start; i2 < end; i2 += colorSize) {
      array.set(color, i2);
    }
  }
  /**
   * Set defined colors: (first part + bottom cap), (second part + top cap)
   * @param {Object} color1 - THREE.Color.
   * @param {Object} color2 - THREE.Color.
   */
  setColors(color1, color2) {
    const colorSize = this.itemSize.color;
    const part1End = this._cutRawEnd * colorSize;
    const part2End = part1End * 2;
    this._setColorRange(0, part1End, this.colors, color1.toArray());
    this._setColorRange(part1End, part2End, this.colors, color2.toArray());
    if (part2End < this.colors.length) {
      const capSize = (this._facesPerSlice + 1) * colorSize;
      const cap1End = part2End + capSize;
      this._setColorRange(part2End, cap1End, this.colors, color2.toArray());
      const cap2End = cap1End + capSize;
      this._setColorRange(cap1End, cap2End, this.colors, color1.toArray());
    }
  }
};
var FBXInfoExtractor = class {
  constructor() {
    this._materials = [];
    this._models = [];
  }
  process(data) {
    this._extractModelsAndMaterials(data);
    const models = this._flattenModels();
    return {
      name: data.name,
      models,
      materials: this._materials
    };
  }
  /**
   * Extract fbx object information from ComplexVisual
   * @param {object} data - complexVisual to get geometry info from
   */
  _extractModelsAndMaterials(data) {
    const layersOfInterest = new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Layers();
    layersOfInterest.set(gfxutils.LAYERS.DEFAULT);
    layersOfInterest.enable(gfxutils.LAYERS.TRANSPARENT);
    data.traverse((object) => {
      if (object instanceof external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Mesh && object.layers.test(layersOfInterest) && this.checkExportAbility(object)) {
        if (object.geometry.type === "InstancedBufferGeometry") {
          this._collectInstancedGeoInfo(object);
        } else {
          this._collectGeoInfo(object);
        }
      }
    });
  }
  /**
   * Reworking indices buffer, see https://banexdevblog.wordpress.com/2014/06/23/a-quick-tutorial-about-the-fbx-ascii-format/
   * basically, every triangle in Miew has been represented hat way (e.g.) : 0,1,7, but we must (for FBX) rework that
   * into: 0,1,-8.
   * @param {array} indices - belongs to [0, maxVertIndex]
   */
  _reworkIndices(indices) {
    const faceSize = 3;
    for (let i2 = faceSize - 1; i2 < indices.length; i2 += faceSize) {
      indices[i2] *= -1;
      indices[i2]--;
    }
  }
  /**
   * Combine geometry from several models having the same material into one Model and finally prepare indices
    * @returns {array} models, combined by material id
   */
  _flattenModels() {
    let overallVertsCount = 0;
    function shift(x3) {
      return x3 + overallVertsCount;
    }
    const combined = [];
    for (let i2 = 0, n = this._models.length; i2 < n; i2++) {
      const models = this._models[i2];
      let indices = [];
      let positions = [];
      let normals = [];
      let colors = [];
      overallVertsCount = 0;
      for (let j = 0; j < models.length; j++) {
        const m2 = models[j];
        indices.push(m2.indices.map(shift));
        overallVertsCount += m2.getVerticesNumber();
        positions.push(m2.positions);
        normals.push(m2.normals);
        colors.push(m2.colors);
      }
      indices = utils.mergeTypedArraysUnsafe(indices);
      this._reworkIndices(indices);
      positions = utils.mergeTypedArraysUnsafe(positions);
      normals = utils.mergeTypedArraysUnsafe(normals);
      colors = utils.mergeTypedArraysUnsafe(colors);
      combined.push({
        indices,
        positions,
        normals,
        colors,
        verticesCount: overallVertsCount
      });
    }
    return combined;
  }
  /**
   * Check ability to export the kind of mesh.
   * @param {object} mesh - given mesh to check
   * @returns {boolean} result of check
   */
  checkExportAbility(mesh) {
    if (mesh.geometry.attributes.position.count === 0) {
      return false;
    }
    if (mesh instanceof meshes_ZSpriteMesh) {
      logger.warn("Currently we cannot export 'sprites' modes, like BS, WV, LC. Please turn of settings 'zSprites' and try again");
      return false;
    }
    if (mesh instanceof meshes_ThickLineMesh) {
      logger.warn("Currently we cannot export Lines mode");
      return false;
    }
    return true;
  }
  /**
   * Save geometry info from common mesh, like Surface or Cartoon
   */
  _collectGeoInfo(mesh) {
    const {
      geometry: {
        attributes: {
          position,
          color,
          normal
        },
        index
      },
      matrix
    } = mesh;
    const model = new FBXModel();
    const vertCount = position.count;
    model.init(vertCount, index.count);
    if (matrix.isIdentity()) {
      model.setPositions(position.array, 0, vertCount, position.itemSize);
      model.setNormals(normal.array, 0, vertCount, normal.itemSize);
    } else {
      model.setTransformedPositions(position.array, 0, vertCount, position.itemSize, matrix);
      model.setTransformedNormals(normal.array, 0, vertCount, normal.itemSize, matrix);
    }
    model.setColors(color.array, 0, vertCount, color.itemSize);
    model.setIndices(index.array, 0, index.count);
    const material = this._collectMaterialInfo(mesh);
    this._addToPool(model, material);
  }
  /**
   * Collect instanced spheres geometry and materials.
   * @param {object} mesh - mesh with instanced spheres info
   */
  _collectSpheresInfo(mesh) {
    const {
      geometry: {
        attributes: {
          position,
          color
        },
        index
      },
      matrix
    } = mesh;
    const model = new FBXModel();
    const instCount = mesh.geometry.instanceCount;
    const vertCount = position.count;
    const indsCount = index.count;
    model.init(instCount * vertCount, instCount * indsCount);
    const geo = new FBX1CGeometry();
    geo.init(mesh.geometry);
    const instMatrix = new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Matrix4();
    const objMatrix = new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Matrix4();
    const sphereColor = new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Color();
    for (let instanceIndex = 0; instanceIndex < instCount; ++instanceIndex) {
      const colorIdx = instanceIndex * color.itemSize;
      sphereColor.fromArray(color.array, colorIdx);
      geo.setColors(sphereColor);
      this._getSphereInstanceMatrix(mesh.geometry, instanceIndex, instMatrix);
      objMatrix.multiplyMatrices(matrix, instMatrix);
      model.addInstance(objMatrix, geo);
    }
    const material = this._collectMaterialInfo(mesh);
    this._addToPool(model, material);
  }
  /**
   * Getting all instanced cylinders from given mesh.
   * Divide cylinder (add additional vertexes) for prettiness therefore algorithm is a bit complicated
   * @param {object} mesh - given mesh with instanced cylinders
   */
  _collectCylindersInfo(mesh) {
    const {
      geometry: {
        attributes: {
          position,
          color,
          color2
        },
        index
      },
      matrix
    } = mesh;
    const model = new FBXModel();
    const instCount = mesh.geometry.instanceCount;
    const oneCCylinder = new FBX1CGeometry();
    oneCCylinder.init(mesh.geometry);
    const splittingInfo = this._gatherCylindersColoringInfo(mesh.geometry);
    let twoCCylinder = null;
    if (splittingInfo.needToSplit > 0) {
      twoCCylinder = new FBX2CCylinder();
      twoCCylinder.init(mesh.geometry, splittingInfo);
    }
    const additionalVertsCount = splittingInfo.addPerCylinder * splittingInfo.needToSplit;
    const vertCount = position.count;
    const indsCount = index.count;
    model.init(instCount * vertCount + additionalVertsCount, instCount * indsCount);
    const instMatrix = new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Matrix4();
    const objMatrix = new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Matrix4();
    const colorStart = new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Color();
    const colorEnd = new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Color();
    let geo = {};
    for (let instanceIndex = 0; instanceIndex < instCount; ++instanceIndex) {
      const colorIdx = instanceIndex * color.itemSize;
      if (splittingInfo.is2Colored[instanceIndex]) {
        colorStart.fromArray(color2.array, colorIdx);
        colorEnd.fromArray(color.array, colorIdx);
        if (twoCCylinder) {
          twoCCylinder.setColors(colorStart, colorEnd);
          geo = twoCCylinder;
        }
      } else {
        colorStart.fromArray(color.array, colorIdx);
        oneCCylinder.setColors(colorStart);
        geo = oneCCylinder;
      }
      this._getCylinderInstanceMatrix(mesh.geometry, instanceIndex, instMatrix);
      objMatrix.multiplyMatrices(matrix, instMatrix);
      model.addInstance(objMatrix, geo);
    }
    const material = this._collectMaterialInfo(mesh);
    this._addToPool(model, material);
  }
  /**
   * Adding model to pool of models or extend existing ones
   * @param {object} model - model to add
   * @param {object} material - material to add
   */
  _addToPool(model, material) {
    const materialIdx = this._checkExistingMaterial(material);
    if (materialIdx < 0) {
      this._models.push([model]);
      this._materials.push(material);
    } else {
      const models = this._models[materialIdx];
      models.push(model);
    }
  }
  /**
   * Checking if given material already was registered in materials pool (no need to create new one)
   * @param {object} material - given material
   * @returns {number} number of model-material pair
   */
  _checkExistingMaterial(material) {
    return external_module_lodash_commonjs_lodash_commonjs2_lodash_amd_lodash_root_namespaceObject["default"].findIndex(this._materials, (m2) => external_module_lodash_commonjs_lodash_commonjs2_lodash_amd_lodash_root_namespaceObject["default"].isEqual(m2, material));
  }
  _gatherCylindersColoringInfo(geo) {
    const instCount = geo.instanceCount;
    const color1 = geo.attributes.color.array;
    const color2 = geo.attributes.color2.array;
    const stride = geo.attributes.color.itemSize;
    const is2Colored = new Array(instCount);
    let needToSplit = 0;
    let colIdx = 0;
    for (let i2 = 0; i2 < instCount; i2++, colIdx += stride) {
      const differs = Math.abs(color1[colIdx] - color2[colIdx]) > 1e-7 || Math.abs(color1[colIdx + 1] - color2[colIdx + 1]) > 1e-7 || Math.abs(color1[colIdx + 2] - color2[colIdx + 2]) > 1e-7;
      is2Colored[i2] = differs;
      needToSplit += differs;
    }
    const geoParams = geo.getGeoParams();
    const addPerCylinder = geoParams.radialSegments;
    return {
      is2Colored,
      needToSplit,
      addPerCylinder
    };
  }
  /**
   * Collect instanced models and materials.
   * @param {object} mesh - given mesh with instanced something (spheres or cylinders)
   */
  _collectInstancedGeoInfo(mesh) {
    if (mesh.geometry instanceof geometries_InstancedSpheresGeometry) {
      this._collectSpheresInfo(mesh);
    } else if (mesh.geometry instanceof geometries_Instanced2CCylindersGeometry) {
      this._collectCylindersInfo(mesh);
    }
  }
  /**
   * Collect Material info from given mesh.
   * @param {object} mesh - given mesh with material info
   * @returns {object} material
   */
  _collectMaterialInfo(mesh) {
    const {
      uberOptions: uberOptions2
    } = mesh.material;
    return {
      diffuse: uberOptions2.diffuse.toArray(),
      opacity: uberOptions2.opacity,
      shininess: uberOptions2.shininess,
      specular: uberOptions2.specular.toArray()
    };
  }
  _getCylinderInstanceMatrix(geo, instIdx, matrix) {
    const matVector1 = geo.attributes.matVector1.array;
    const matVector2 = geo.attributes.matVector2.array;
    const matVector3 = geo.attributes.matVector3.array;
    const idxOffset = instIdx * 4;
    matrix.set(matVector1[idxOffset], matVector1[idxOffset + 1], matVector1[idxOffset + 2], matVector1[idxOffset + 3], matVector2[idxOffset], matVector2[idxOffset + 1], matVector2[idxOffset + 2], matVector2[idxOffset + 3], matVector3[idxOffset], matVector3[idxOffset + 1], matVector3[idxOffset + 2], matVector3[idxOffset + 3], 0, 0, 0, 1);
  }
  _getSphereInstanceMatrix(geo, instIdx, matrix) {
    const {
      offset
    } = geo.attributes;
    const idx = instIdx * offset.itemSize;
    const x3 = offset.array[idx];
    const y2 = offset.array[idx + 1];
    const z = offset.array[idx + 2];
    const scale = offset.array[idx + 3];
    matrix.set(scale, 0, 0, x3, 0, scale, 0, y2, 0, 0, scale, z, 0, 0, 0, 1);
  }
};
var defaultDefinitions = `
Definitions:  {
  Version: 100
  Count: 3
  ObjectType: "Model" {
    Count: 1
  }
  ObjectType: "Geometry" {
    Count: 1
  }
  ObjectType: "Material" {
    Count: 1
  }
  ObjectType: "Pose" {
    Count: 1
  }
  ObjectType: "GlobalSettings" {
    Count: 1
  }
} `;
var defaultProperties = `Properties60: {
      Property: "QuaternionInterpolate", "bool", "",0
      Property: "Visibility", "Visibility", "A",1
      Property: "Lcl Translation", "Lcl Translation", "A",0.000000000000000,0.000000000000000,-1789.238037109375000
      Property: "Lcl Rotation", "Lcl Rotation", "A",0.000009334667643,-0.000000000000000,0.000000000000000
      Property: "Lcl Scaling", "Lcl Scaling", "A",1.000000000000000,1.000000000000000,1.000000000000000
      Property: "RotationOffset", "Vector3D", "",0,0,0
      Property: "RotationPivot", "Vector3D", "",0,0,0
      Property: "ScalingOffset", "Vector3D", "",0,0,0
      Property: "ScalingPivot", "Vector3D", "",0,0,0
      Property: "TranslationActive", "bool", "",0
      Property: "TranslationMin", "Vector3D", "",0,0,0
      Property: "TranslationMax", "Vector3D", "",0,0,0
      Property: "TranslationMinX", "bool", "",0
      Property: "TranslationMinY", "bool", "",0
      Property: "TranslationMinZ", "bool", "",0
      Property: "TranslationMaxX", "bool", "",0
      Property: "TranslationMaxY", "bool", "",0
      Property: "TranslationMaxZ", "bool", "",0
      Property: "RotationOrder", "enum", "",0
      Property: "RotationSpaceForLimitOnly", "bool", "",0
      Property: "AxisLen", "double", "",10
      Property: "PreRotation", "Vector3D", "",0,0,0
      Property: "PostRotation", "Vector3D", "",0,0,0
      Property: "RotationActive", "bool", "",0
      Property: "RotationMin", "Vector3D", "",0,0,0
      Property: "RotationMax", "Vector3D", "",0,0,0
      Property: "RotationMinX", "bool", "",0
      Property: "RotationMinY", "bool", "",0
      Property: "RotationMinZ", "bool", "",0
      Property: "RotationMaxX", "bool", "",0
      Property: "RotationMaxY", "bool", "",0
      Property: "RotationMaxZ", "bool", "",0
      Property: "RotationStiffnessX", "double", "",0
      Property: "RotationStiffnessY", "double", "",0
      Property: "RotationStiffnessZ", "double", "",0
      Property: "MinDampRangeX", "double", "",0
      Property: "MinDampRangeY", "double", "",0
      Property: "MinDampRangeZ", "double", "",0
      Property: "MaxDampRangeX", "double", "",0
      Property: "MaxDampRangeY", "double", "",0
      Property: "MaxDampRangeZ", "double", "",0
      Property: "MinDampStrengthX", "double", "",0
      Property: "MinDampStrengthY", "double", "",0
      Property: "MinDampStrengthZ", "double", "",0
      Property: "MaxDampStrengthX", "double", "",0
      Property: "MaxDampStrengthY", "double", "",0
      Property: "MaxDampStrengthZ", "double", "",0
      Property: "PreferedAngleX", "double", "",0
      Property: "PreferedAngleY", "double", "",0
      Property: "PreferedAngleZ", "double", "",0
      Property: "InheritType", "enum", "",0
      Property: "ScalingActive", "bool", "",0
      Property: "ScalingMin", "Vector3D", "",1,1,1
      Property: "ScalingMax", "Vector3D", "",1,1,1
      Property: "ScalingMinX", "bool", "",0
      Property: "ScalingMinY", "bool", "",0
      Property: "ScalingMinZ", "bool", "",0
      Property: "ScalingMaxX", "bool", "",0
      Property: "ScalingMaxY", "bool", "",0
      Property: "ScalingMaxZ", "bool", "",0
      Property: "GeometricTranslation", "Vector3D", "",0,0,0
      Property: "GeometricRotation", "Vector3D", "",0,0,0
      Property: "GeometricScaling", "Vector3D", "",1,1,1
      Property: "LookAtProperty", "object", ""
      Property: "UpVectorProperty", "object", ""
      Property: "Show", "bool", "",1
      Property: "NegativePercentShapeSupport", "bool", "",1
      Property: "DefaultAttributeIndex", "int", "",0
      Property: "Color", "Color", "A+",0,0,0
      Property: "Size", "double", "",100
      Property: "Look", "enum", "",1
    }`;
var defaultMaterialLayer = `
    LayerElementMaterial: 0 {
      Version: 101
      Name: ""
      MappingInformationType: "AllSame"
      ReferenceInformationType: "Direct"
      Materials: 0
    }`;
var defaultLayerBlock = `
    Layer: 0 {
      Version: 100
      LayerElement:  {
        Type: "LayerElementNormal"
        TypedIndex: 0
      }
      LayerElement:  {
        Type: "LayerElementColor"
        TypedIndex: 0
      }
      LayerElement:  {
        Type: "LayerElementMaterial"
        TypedIndex: 0
      }
    }`;
var globalSettings = `GlobalSettings: {
    Version: 1000
    Properties60:  {
      Property: "UpAxis", "int", "",1
      Property: "UpAxisSign", "int", "",1
      Property: "FrontAxis", "int", "",2
      Property: "FrontAxisSign", "int", "",1
      Property: "CoordAxis", "int", "",0
      Property: "CoordAxisSign", "int", "",1
      Property: "UnitScaleFactor", "double", "",1
    }
  }`;
var FBXResult = class {
  constructor() {
    this._resultArray = [];
    this._info = null;
  }
  getResult(info) {
    this._info = info;
    this._resultArray.push(this._writeHeader());
    this._resultArray.push(this._writeDefinitions());
    this._resultArray.push(this._writeObjects(info.models, info.materials));
    this._resultArray.push(this._writeRelations());
    this._resultArray.push(this._writeConnections());
    this._info = null;
    return this._resultArray.join("");
  }
  /**
   * Add FBXHeader info to output file.
   * Some fields are really confusing, but it seems that all listed fields are very informative
   */
  _writeHeader() {
    const FBXHeaderVersion = 1003;
    const FBXVersion = 6100;
    const date = /* @__PURE__ */ new Date();
    const timeStampVersion = 1e3;
    const creator = `Miew FBX Exporter v${this._info.version}`;
    return `; FBX 6.1.0 project file
; Created by ${creator} Copyright (c) 2015-2024 EPAM Systems, Inc.
; For support please contact miew@epam.com
; ----------------------------------------------------

FBXHeaderExtension:  {
  FBXHeaderVersion: ${FBXHeaderVersion}
  FBXVersion: ${FBXVersion}
  CreationTimeStamp:  {
    Version: ${timeStampVersion}
    Year: ${date.getFullYear()}
    Month: ${date.getMonth() + 1}
    Day: ${date.getDate()}
    Hour: ${date.getHours()}
    Minute: ${date.getMinutes()}
    Second: ${date.getSeconds()}
    Millisecond: ${date.getMilliseconds()}
  }
  Creator: "${creator}"
  OtherFlags:  {
    FlagPLE: 0
  }
}
CreationTime: "${date}"
Creator: "${creator}"
`;
  }
  /**
   * Add Definitions info to output file.
   * Not exactly sure if this section is template section (as it is in 7.4+) or it should every time be like this
   */
  _writeDefinitions() {
    return `
; Object definitions
;------------------------------------------------------------------

${defaultDefinitions}
`;
  }
  /**
   * Adding gathered information about Models to resulting string.
   * Reminder - there may be more then 1 model in scene, but we must place materials after ALL models.
   * @returns {string} string containing all models (vertices, indices, colors, normals etc)
   */
  _models() {
    const modelVersion = 232;
    let allModels = "";
    const {
      models
    } = this._info;
    for (let i2 = 0; i2 < models.length; ++i2) {
      const model = models[i2];
      const vertCount = model.verticesCount;
      allModels += `
  Model: "Model::${this._info.name}_${i2}", "Mesh" {
    Version: ${modelVersion}
    ${defaultProperties}
    ${this._verticesIndices(model.positions, model.indices)}
    ${this._normalLayer(model.normals)}
    ${this._colorLayer(model.colors, vertCount)}
    ${defaultMaterialLayer}
    ${defaultLayerBlock}
  }`;
    }
    return allModels;
  }
  /**
   * Add Material info to result
   */
  _materials() {
    const materialVersion = 102;
    let allMaterials = "";
    const {
      materials: materials2
    } = this._info;
    for (let i2 = 0; i2 < materials2.length; ++i2) {
      const material = materials2[i2];
      allMaterials += `
  Material: "Material::${this._info.name}_${i2}_default", "" {
    Version: ${materialVersion}
    ShadingModel: "lambert"
    MultiLayer: 0
    ${this._materialProperties(material)}
  }`;
    }
    return allMaterials;
  }
  /**
   * Add Objects info to output file.
   */
  _writeObjects() {
    return `
; Object properties
;------------------------------------------------------------------

Objects:  {
  ${this._models()}
  ${this._materials()}
  ${globalSettings}
}
`;
  }
  /**
   * Add Relations info to output file.
   */
  _writeRelations() {
    let modelsList = "";
    for (let i2 = 0; i2 < this._info.models.length; ++i2) {
      modelsList += `
  Model: "Model::${this._info.name}_${i2}", "Mesh" {
  }`;
    }
    let materialList2 = "";
    for (let i2 = 0; i2 < this._info.materials.length; ++i2) {
      materialList2 += `
  Material: "Material::${this._info.name}_${i2}_default", "" {
  }`;
    }
    return `
; Object relations
;------------------------------------------------------------------

Relations:  {
  ${modelsList}
  Model: "Model::Producer Perspective", "Camera" {
  }
  Model: "Model::Producer Top", "Camera" {
  }
  Model: "Model::Producer Bottom", "Camera" {
  }
  Model: "Model::Producer Front", "Camera" {
  }
  Model: "Model::Producer Back", "Camera" {
  }
  Model: "Model::Producer Right", "Camera" {
  }
  Model: "Model::Producer Left", "Camera" {
  }
  Model: "Model::Camera Switcher", "CameraSwitcher" {
  }
  ${materialList2}
}`;
  }
  /**
   * Add Connections info to output file.
   */
  _writeConnections() {
    let modelsList = "";
    const {
      name
    } = this._info;
    for (let i2 = 0; i2 < this._info.models.length; ++i2) {
      modelsList += `
  Connect: "OO", "Model::${name}_${i2}", "Model::Scene"`;
    }
    let materialList2 = "";
    for (let i2 = 0; i2 < this._info.materials.length; ++i2) {
      materialList2 += `
  Connect: "OO", "Material::${name}_${i2}_default", "Model::${name}_${i2}"`;
    }
    return `
; Object connections
;------------------------------------------------------------------

Connections:  {
  ${modelsList}
  ${materialList2}
}`;
  }
  /**
   * Write float array to string with limited precision
   * @param {Float32Array} array - array to be fixed
   * @returns {String} String with fixed floats
   */
  _floatArrayToString(array) {
    const str = [];
    for (let i2 = 0; i2 < array.length; ++i2) {
      str[i2] = array[i2].toFixed(6);
    }
    return str.join(",");
  }
  /**
   * Adding color layer to resulting file
   * @param {Float32Array} colorArray attribute
   * @param {number} vertCount - number of vertices in the model
   * @returns {string} color layer info
   */
  _colorLayer(colorArray, vertCount) {
    const layerElementColorNumber = 0;
    const layerElementColorVersion = 101;
    const layerElementColorName = "";
    const colorsStr = this._floatArrayToString(colorArray);
    const colorIndices = [...Array(vertCount).keys()];
    return `
    LayerElementColor: ${layerElementColorNumber} {
      Version: ${layerElementColorVersion}
      Name: "${layerElementColorName}"
      MappingInformationType: "ByVertice"
      ReferenceInformationType: "Direct"
      Colors: ${colorsStr}
      ColorIndex: ${colorIndices}
    }`;
  }
  /**
   * Adding normal layer to resulting file
   * @param {Float32Array} normalArray attribute
   * @returns {string} normal layer info
   */
  _normalLayer(normalArray) {
    const layerElementNormalNumber = 0;
    const layerElementNormalVersion = 101;
    const layerElementNormalName = "";
    const normalsStr = this._floatArrayToString(normalArray);
    return `
    LayerElementNormal: ${layerElementNormalNumber} {
      Version: ${layerElementNormalVersion}
      Name: "${layerElementNormalName}"
      MappingInformationType: "ByVertice"
      ReferenceInformationType: "Direct"
      Normals: ${normalsStr}
    }`;
  }
  /**
   * Adding vertices and indices to resulting string
   * @return {string} resulting string in FBX notation
   */
  _verticesIndices(positions, indices) {
    const multiLayer = 0;
    const multiTake = 1;
    const shading = "Y";
    const culling = "CullingOff";
    const geometryVersion = 124;
    const vertStr = this._floatArrayToString(positions);
    return `MultiLayer: ${multiLayer}
    MultiTake: ${multiTake}
    Shading: ${shading}
    Culling: "${culling}"
    Vertices: ${vertStr}
    PolygonVertexIndex: ${indices}
    GeometryVersion: ${geometryVersion}`;
  }
  /**
   * Forming material properties block.
   * @param {Object} material - given material of model
   * @returns {String} material properties string
   */
  _materialProperties(material) {
    return `Properties60:  {
      Property: "ShadingModel", "KString", "", "Lambert"
      Property: "MultiLayer", "bool", "",0
      Property: "EmissiveColor", "ColorRGB", "",0,0,0
      Property: "EmissiveFactor", "double", "",0.0000
      Property: "AmbientColor", "ColorRGB", "",1,1,1
      Property: "AmbientFactor", "double", "",0.0000
      Property: "DiffuseColor", "ColorRGB", "",${material.diffuse}
      Property: "DiffuseFactor", "double", "",1.0000
      Property: "Bump", "Vector3D", "",0,0,0
      Property: "TransparentColor", "ColorRGB", "",1,1,1
      Property: "TransparencyFactor", "double", "",0.0000
      Property: "SpecularColor", "ColorRGB", "",${material.specular}
      Property: "SpecularFactor", "double", "",1.0000
      Property: "ShininessExponent", "double", "",${material.shininess}
      Property: "ReflectionColor", "ColorRGB", "",0,0,0
      Property: "ReflectionFactor", "double", "",1
      Property: "Ambient", "ColorRGB", "",1,1,1
      Property: "Diffuse", "ColorRGB", "",${material.diffuse}
      Property: "Specular", "ColorRGB", "",${material.specular}
      Property: "Shininess", "double", "",${material.shininess}
      Property: "Opacity", "double", "",${material.opacity}
      Property: "Reflectivity", "double", "",0
    }`;
  }
};
var FBXExporter = class extends Exporter {
  constructor(source, options2) {
    super(source, options2);
    this._data = source;
    this._version = options2.miewVersion || "0.0-UNSPECIFIED";
    this._extractor = new FBXInfoExtractor();
  }
  /**
   * Entry point to exporter.
   */
  exportSync() {
    const result = new FBXResult();
    if (!this._source) {
      return this._result;
    }
    const info = this._extractor.process(this._data);
    info.version = this._version;
    this._result = result.getResult(info);
    return this._result;
  }
};
FBXExporter.formats = ["fbx"];
FBXExporter.SourceClass = src_ComplexVisual;
var exporters = new exporters_ExporterList([PDBExporter, FBXExporter]);
var io = {
  loaders,
  parsers,
  exporters
};
var tempColor = new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Color();
var CSS2DRenderer = class {
  constructor() {
    this._width = 0;
    this._height = 0;
    this._widthHalf = 0;
    this._heightHalf = 0;
    this._vector = new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Vector3();
    this._viewMatrix = new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Matrix4();
    this._projectionMatrix = new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Matrix4();
    this._domElement = document.createElement("div");
    this._domElement.style.overflow = "hidden";
    this._domElement.style.position = "absolute";
    this._domElement.style.top = "0";
    this._domElement.style.zIndex = "0";
    this._domElement.style.pointerEvents = "none";
  }
  getElement() {
    return this._domElement;
  }
  reset() {
    const myNode = this.getElement();
    while (myNode.firstChild) {
      myNode.removeChild(myNode.firstChild);
    }
  }
  setSize(width, height) {
    this._width = width;
    this._height = height;
    this._widthHalf = this._width / 2;
    this._heightHalf = this._height / 2;
    this._domElement.style.width = `${width}px`;
    this._domElement.style.height = `${height}px`;
  }
  _renderObject(object, camera, scene) {
    function lerpColorAsHex(a2, b2, t2) {
      tempColor.setHex(a2);
      tempColor.lerp(b2, t2);
      return `#${tempColor.getHexString()}`;
    }
    function colorAsHex(a2) {
      tempColor.setHex(a2);
      return `#${tempColor.getHexString()}`;
    }
    if (object instanceof gfx_CSS2DObject) {
      this._vector.setFromMatrixPosition(object.matrixWorld);
      if (object.userData !== void 0 && object.userData.offset !== void 0) {
        const localOffset = new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Vector3(object.userData.offset.x, object.userData.offset.y, 0);
        this._vector.add(localOffset.multiplyScalar(object.matrixWorld.getMaxScaleOnAxis()));
      }
      this._vector.applyMatrix4(this._viewMatrix);
      const visibility = this._vector.z > -camera.near ? "hidden" : "visible";
      const zIndex = 1e4 * (camera.far - -this._vector.z) / (camera.far - camera.near);
      const element = object.getElement();
      if (typeof scene.fog === "undefined") {
        element.style.color = colorAsHex(object.userData.color);
        if (object.userData.background !== "transparent") {
          element.style.background = colorAsHex(object.userData.background);
        }
      } else {
        const fogFactor = external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.MathUtils.smoothstep(-this._vector.z, scene.fog.near, scene.fog.far);
        element.style.color = lerpColorAsHex(object.userData.color, scene.fog.color, fogFactor);
        if (object.userData.background !== "transparent") {
          element.style.background = lerpColorAsHex(object.userData.background, scene.fog.color, fogFactor);
        }
      }
      this._vector.applyMatrix4(this._projectionMatrix);
      const style = `${object.userData !== {} ? object.userData.translation : "translate(-50%, -50%) "}translate(${this._vector.x * this._widthHalf + this._widthHalf}px,${-this._vector.y * this._heightHalf + this._heightHalf}px)`;
      element.style.visibility = visibility;
      element.style.WebkitTransform = style;
      element.style.MozTransform = style;
      element.style.oTransform = style;
      element.style.transform = style;
      element.style.zIndex = Number(zIndex).toFixed(0);
      if (element.parentNode !== this._domElement) {
        this._domElement.appendChild(element);
      }
    }
    for (let i2 = 0, l2 = object.children.length; i2 < l2; i2++) {
      this._renderObject(object.children[i2], camera, scene);
    }
  }
  render(scene, camera) {
    scene.updateMatrixWorld();
    if (camera.parent === null) {
      camera.updateMatrixWorld();
    }
    camera.matrixWorldInverse.copy(camera.matrixWorld).invert();
    this._viewMatrix.copy(camera.matrixWorldInverse);
    this._projectionMatrix.copy(camera.projectionMatrix);
    this._renderObject(scene, camera, scene);
  }
};
var gfx_CSS2DRenderer = CSS2DRenderer;
function getTopWindow() {
  try {
    if (window.top.location.href !== void 0) {
      return window.top;
    }
  } catch (e2) {
  }
  return window;
}
var VK_LEFT = 37;
var VK_UP = 38;
var VK_RIGHT = 39;
var VK_DOWN = 40;
var STATE = {
  NONE: -1,
  ROTATE: 0,
  TRANSLATE: 1,
  SCALE: 2,
  TRANSLATE_PIVOT: 3
};
var FULL_STOP_THRESHOLD = 0.1;
var quaternion = new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Quaternion();
var matrix4 = new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Matrix4();
function ObjectHandler(objects, camera, pivot, options2) {
  this.objects = objects;
  [this.object] = objects;
  this.camera = camera;
  this.pivot = pivot;
  this.axis = new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Vector3(0, 0, 1);
  this.options = options2;
  this.lastRotation = {
    axis: new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Vector3(),
    angle: 0
  };
}
ObjectHandler.prototype._rotate = function() {
  const p2 = new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Vector3();
  const q = new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Quaternion();
  const s2 = new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Vector3();
  const m2 = new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Matrix4();
  return function(quat) {
    const zeroPivot = this.pivot.x === 0 && this.pivot.y === 0 && this.pivot.z === 0;
    m2.copy(this.object.matrix);
    if (zeroPivot) {
      m2.multiply(matrix4.makeRotationFromQuaternion(quat));
    } else {
      m2.multiply(matrix4.makeTranslation(this.pivot.x, this.pivot.y, this.pivot.z));
      m2.multiply(matrix4.makeRotationFromQuaternion(quat));
      m2.multiply(matrix4.makeTranslation(-this.pivot.x, -this.pivot.y, -this.pivot.z));
    }
    m2.decompose(p2, q, s2);
    if (!zeroPivot) {
      for (let i2 = 0; i2 < this.objects.length; ++i2) {
        this.objects[i2].position.copy(p2);
      }
    }
    for (let j = 0; j < this.objects.length; ++j) {
      this.objects[j].quaternion.copy(q);
      this.objects[j].updateMatrix();
    }
  };
}();
ObjectHandler.prototype.setObjects = function(objects) {
  this.objects = objects;
  [this.object] = objects;
};
ObjectHandler.prototype.rotate = function() {
  const rot = {
    axis: new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Vector3(),
    angle: 0
  };
  return function(quat, mousePrevPos, mouseCurPos, aboutAxis) {
    this.mouse2rotation(rot, mousePrevPos, mouseCurPos, aboutAxis);
    quat.setFromAxisAngle(rot.axis, rot.angle);
    if (rot.angle) {
      this._rotate(quat);
    }
    this.lastRotation = rot;
  };
}();
ObjectHandler.prototype.translate = function() {
  const dir = new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Vector3();
  const pivot = new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Vector3();
  return function(delta) {
    dir.set(delta.x / this.camera.projectionMatrix.elements[0], delta.y / this.camera.projectionMatrix.elements[5], 0);
    let dist = dir.length();
    dir.normalize();
    dir.transformDirection(matrix4.copy(this.object.matrixWorld).invert());
    pivot.copy(this.pivot);
    this.object.localToWorld(pivot);
    dist *= Math.abs(pivot.z - this.camera.position.z);
    dist /= this.object.matrixWorld.getMaxScaleOnAxis();
    for (let i2 = 0; i2 < this.objects.length; ++i2) {
      this.objects[i2].translateOnAxis(dir, dist);
    }
  };
}();
ObjectHandler.prototype.update = function() {
  const axis = new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Vector3();
  return function(timeSinceLastUpdate, timeSinceMove) {
    if (settings.now.autoRotation !== 0) {
      if (settings.now.autoRotationAxisFixed || this.lastRotation.axis.length() === 0) {
        axis.set(0, 1, 0).transformDirection(matrix4.copy(this.object.matrixWorld).invert());
      } else {
        axis.copy(this.lastRotation.axis);
      }
      this._rotate(quaternion.setFromAxisAngle(axis, settings.now.autoRotation * timeSinceLastUpdate));
      return true;
    }
    if (this.options.intertia && this.lastRotation.angle) {
      const angle = this.lastRotation.angle * (1 - this.options.dynamicDampingFactor) ** (40 * timeSinceMove);
      if (Math.abs(angle) <= this.options.intertiaThreshold) {
        this.lastRotation.angle = 0;
      } else {
        this._rotate(quaternion.setFromAxisAngle(this.lastRotation.axis, angle));
        return true;
      }
    }
    return false;
  };
}();
ObjectHandler.prototype.stop = function() {
  this.lastRotation.angle = 0;
};
ObjectHandler.prototype.mouse2rotation = function() {
  const center = new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Vector3();
  const eye = new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Vector3();
  const eyeDirection = new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Vector3();
  const cameraUpDirection = new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Vector3();
  const cameraSidewaysDirection = new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Vector3();
  const moveDirection = new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Vector3();
  const mouseDelta = new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Vector2();
  return function(rot, mousePrev, mouseCur, aboutAxis) {
    if (aboutAxis) {
      rot.axis.copy(this.axis);
      rot.angle = this.options.axisRotateFactor * (mouseCur.y - mousePrev.y);
    } else {
      mouseDelta.subVectors(mouseCur, mousePrev);
      const angle = mouseDelta.length();
      if (angle === 0) {
        return;
      }
      center.copy(this.pivot);
      this.object.localToWorld(center);
      eye.subVectors(this.camera.position, center);
      eyeDirection.copy(eye).normalize();
      cameraUpDirection.copy(this.camera.up).normalize();
      cameraSidewaysDirection.crossVectors(cameraUpDirection, eyeDirection).normalize();
      cameraUpDirection.setLength(mouseDelta.y);
      cameraSidewaysDirection.setLength(mouseDelta.x);
      moveDirection.copy(cameraUpDirection.add(cameraSidewaysDirection));
      rot.axis.crossVectors(moveDirection, eye);
      rot.angle = -angle * this.options.rotateFactor;
    }
    rot.axis.transformDirection(matrix4.copy(this.object.matrixWorld).invert());
    if (rot.angle < 0) {
      rot.axis.negate();
      rot.angle = -rot.angle;
    }
  };
}();
function ObjectControls(object, objectPivot, camera, domElement, getAltObj) {
  utils_EventDispatcher.call(this);
  const self2 = this;
  this.object = object;
  this.objectPivot = objectPivot;
  this.camera = camera;
  this.domElement = typeof domElement !== "undefined" ? domElement : document;
  this.getAltObj = getAltObj;
  this.enabled = true;
  this.hotkeysEnabled = true;
  this.screen = {
    left: 0,
    top: 0,
    width: 0,
    height: 0
  };
  this.options = {
    rotateFactor: Math.PI,
    // full screen slide (along short side) would roughly mean 180 deg. rotation
    axisRotateFactor: 4 * Math.PI,
    // full screen slide (along short side) would roughly mean 720 deg. rotation
    intertia: true,
    dynamicDampingFactor: 0.1,
    intertiaThreshold: 1e-3
  };
  this._state = STATE.NONE;
  this._mousePrevPos = new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Vector2();
  this._mouseCurPos = new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Vector2();
  this._mainObj = new ObjectHandler([this.object], this.camera, new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Vector3(0, 0, 0), this.options);
  this._altObj = new ObjectHandler([this.object], this.camera, new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Vector3(0, 0, 0), this.options);
  this._affectedObj = this._mainObj;
  this._isAltObjFreeRotationAllowed = true;
  this._isTranslationAllowed = true;
  this._isKeysTranslatingObj = false;
  this._pressedKeys = [];
  this._clock = new Timer();
  this._clock.start();
  this._lastUpdateTime = this._clock.getElapsedTime();
  this._listeners = [{
    obj: self2.domElement,
    type: "mousedown",
    handler(e2) {
      self2.mousedown(e2);
    }
  }, {
    obj: self2.domElement,
    type: "mouseup",
    handler(e2) {
      self2.mouseup(e2);
    }
  }, {
    obj: self2.domElement,
    type: "mousemove",
    handler(e2) {
      self2.mousemove(e2);
    }
  }, {
    obj: self2.domElement,
    type: "mousewheel",
    handler(e2) {
      self2.mousewheel(e2);
    }
  }, {
    obj: self2.domElement,
    type: "DOMMouseScroll",
    handler(e2) {
      self2.mousewheel(e2);
    }
  }, {
    obj: self2.domElement,
    type: "mouseout",
    handler(e2) {
      self2.mouseup(e2);
    }
  }, {
    obj: self2.domElement,
    type: "touchstart",
    handler(e2) {
      self2.touchstartend(e2);
    }
  }, {
    obj: self2.domElement,
    type: "touchend",
    handler(e2) {
      self2.touchstartend(e2);
    }
  }, {
    obj: self2.domElement,
    type: "touchmove",
    handler(e2) {
      self2.touchmove(e2);
    }
  }, {
    obj: self2.getKeyBindObject(),
    type: "keydown",
    handler(e2) {
      self2.keydownup(e2);
    }
  }, {
    obj: self2.getKeyBindObject(),
    type: "keyup",
    handler(e2) {
      self2.keydownup(e2);
    }
  }, {
    obj: window,
    type: "resize",
    handler() {
      self2.handleResize();
    }
  }, {
    obj: window,
    type: "blur",
    handler() {
      self2.resetKeys();
    }
  }, {
    obj: self2.domElement,
    type: "contextmenu",
    handler(e2) {
      self2.contextmenu(e2);
    }
  }];
  for (let i2 = 0; i2 < this._listeners.length; i2++) {
    const l2 = this._listeners[i2];
    l2.obj.addEventListener(l2.type, l2.handler);
  }
  this.handleResize();
  this.resetKeys();
  this.update();
}
ObjectControls.prototype = Object.create(utils_EventDispatcher.prototype);
ObjectControls.prototype.constructor = ObjectControls;
ObjectControls.prototype.resetKeys = function() {
  this._pressedKeys[VK_LEFT] = false;
  this._pressedKeys[VK_UP] = false;
  this._pressedKeys[VK_RIGHT] = false;
  this._pressedKeys[VK_DOWN] = false;
};
ObjectControls.prototype.contextmenu = function(e2) {
  e2.stopPropagation();
  e2.preventDefault();
};
ObjectControls.prototype.handleResize = function() {
  if (this.domElement === document) {
    this.screen.left = 0;
    this.screen.top = 0;
    this.screen.width = window.innerWidth;
    this.screen.height = window.innerHeight;
  } else {
    const box = this.domElement.getBoundingClientRect();
    const d2 = this.domElement.ownerDocument.documentElement;
    this.screen.left = box.left + window.pageXOffset - d2.clientLeft;
    this.screen.top = box.top + window.pageYOffset - d2.clientTop;
    this.screen.width = box.width;
    this.screen.height = box.height;
  }
};
ObjectControls.prototype.enable = function(enable) {
  this.enabled = enable;
};
ObjectControls.prototype.enableHotkeys = function(enable) {
  this.hotkeysEnabled = enable;
};
ObjectControls.prototype.allowTranslation = function(allow) {
  this._isTranslationAllowed = allow;
};
ObjectControls.prototype.allowAltObjFreeRotation = function(allow) {
  this._isAltObjFreeRotationAllowed = allow;
};
ObjectControls.prototype.keysTranslateObj = function(on) {
  this._isKeysTranslatingObj = on;
};
ObjectControls.prototype.isEditingAltObj = function() {
  return (this._state === STATE.ROTATE || this._state === STATE.TRANSLATE) && this._affectedObj === this._altObj;
};
ObjectControls.prototype.convertMouseToOnCircle = function(coords, pageX, pageY) {
  const screenSize = Math.min(this.screen.width, this.screen.height);
  if (screenSize === 0) {
    coords.set(0, 0);
    return;
  }
  coords.set((pageX - this.screen.width * 0.5 - this.screen.left) / screenSize, (0.5 * this.screen.height + this.screen.top - pageY) / screenSize);
};
ObjectControls.prototype.convertMouseToViewport = function(coords, pageX, pageY) {
  if (this.screen.width === 0 || this.screen.height === 0) {
    coords.set(0, 0);
    return;
  }
  coords.set(2 * (pageX - this.screen.width * 0.5 - this.screen.left) / this.screen.width, 2 * (0.5 * this.screen.height + this.screen.top - pageY) / this.screen.height);
};
ObjectControls.prototype.stop = function() {
  this._mainObj.stop();
  this._altObj.stop();
};
ObjectControls.prototype.rotateByMouse = function() {
  const quat = new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Quaternion();
  return function(aboutZAxis) {
    this._affectedObj.rotate(quat, this._mousePrevPos, this._mouseCurPos, aboutZAxis);
    this.dispatchEvent({
      type: "change",
      action: "rotate",
      quaternion: quat
    });
  };
}();
ObjectControls.prototype.rotate = function(quat) {
  this.object.quaternion.multiply(quat);
  this.dispatchEvent({
    type: "change",
    action: "rotate",
    quaternion: quat
  });
};
ObjectControls.prototype.getOrientation = function() {
  return this.object.quaternion;
};
ObjectControls.prototype.setOrientation = function(quat) {
  this.object.quaternion.copy(quat);
};
ObjectControls.prototype.translate = function() {
  const delta = new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Vector2();
  return function() {
    delta.subVectors(this._mouseCurPos, this._mousePrevPos);
    this._affectedObj.translate(delta);
    this.dispatchEvent({
      type: "change",
      action: "translate"
    });
  };
}();
ObjectControls.prototype.getScale = function() {
  return this.object.scale.x;
};
ObjectControls.prototype.setScale = function(scale) {
  this.object.scale.set(scale, scale, scale);
};
ObjectControls.prototype.scale = function(factor) {
  if (factor <= 0) {
    return;
  }
  this.setScale(this.object.scale.x * factor);
  this.dispatchEvent({
    type: "change",
    action: "zoom",
    factor
  });
};
ObjectControls.prototype.update = function() {
  const shift = new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Vector2();
  return function() {
    const curTime = this._clock.getElapsedTime();
    const timeSinceLastUpdate = curTime - this._lastUpdateTime;
    if (this._state === STATE.NONE) {
      const timeSinceMove = curTime - this._lastMouseMoveTime;
      if (this._mainObj.update(timeSinceLastUpdate, timeSinceMove) || this._altObj.update(timeSinceLastUpdate, timeSinceMove)) {
        this.dispatchEvent({
          type: "change",
          action: "auto"
        });
      }
    }
    if (this._isKeysTranslatingObj) {
      const speedX = Number(this._pressedKeys[VK_RIGHT]) - Number(this._pressedKeys[VK_LEFT]);
      const speedY = Number(this._pressedKeys[VK_UP]) - Number(this._pressedKeys[VK_DOWN]);
      if (speedX !== 0 || speedY !== 0) {
        const delta = timeSinceLastUpdate;
        const altObj = this.getAltObj();
        if (altObj.objects.length > 0) {
          this._altObj.setObjects(altObj.objects);
          this._altObj.pivot = altObj.pivot;
          if ("axis" in altObj) {
            this._altObj.axis = altObj.axis.clone();
          } else {
            this._altObj.axis.set(0, 0, 1);
          }
          shift.set(delta * speedX, delta * speedY);
          this._altObj.translate(shift);
          this.dispatchEvent({
            type: "change",
            action: "translate"
          });
        }
      }
    }
    this._lastUpdateTime = curTime;
  };
}();
ObjectControls.prototype.reset = function() {
  this._state = STATE.NONE;
  this.object.quaternion.copy(quaternion.set(0, 0, 0, 1));
};
ObjectControls.prototype.mousedown = function(event) {
  if (this.enabled === false || this._state !== STATE.NONE) {
    return;
  }
  event.preventDefault();
  event.stopPropagation();
  if (this._state === STATE.NONE) {
    if (event.button === 0) {
      this._affectedObj.stop();
      let workWithAltObj = false;
      if (event.altKey) {
        const altObj = this.getAltObj();
        workWithAltObj = altObj.objects.length > 0;
        if (workWithAltObj) {
          this._altObj.setObjects(altObj.objects);
          this._altObj.pivot = altObj.pivot;
          if ("axis" in altObj) {
            this._altObj.axis = altObj.axis.clone();
          } else {
            this._altObj.axis.set(0, 0, 1);
          }
        }
      }
      this._affectedObj = workWithAltObj ? this._altObj : this._mainObj;
      this._state = workWithAltObj && event.ctrlKey && this._isTranslationAllowed ? STATE.TRANSLATE : STATE.ROTATE;
    } else if (event.button === 2) {
      this._state = STATE.TRANSLATE_PIVOT;
    }
  }
  if (this._state === STATE.ROTATE) {
    this.convertMouseToOnCircle(this._mouseCurPos, event.pageX, event.pageY);
    this._mousePrevPos.copy(this._mouseCurPos);
  }
  if (this._state === STATE.TRANSLATE || this._state === STATE.TRANSLATE_PIVOT) {
    this.convertMouseToViewport(this._mouseCurPos, event.pageX, event.pageY);
    this._mousePrevPos.copy(this._mouseCurPos);
  }
};
ObjectControls.prototype.mousemove = function(event) {
  if (this.enabled === false || this._state === STATE.NONE) {
    return;
  }
  event.preventDefault();
  event.stopPropagation();
  switch (this._state) {
    case STATE.ROTATE:
      this._mousePrevPos.copy(this._mouseCurPos);
      this.convertMouseToOnCircle(this._mouseCurPos, event.pageX, event.pageY);
      this.rotateByMouse(event.altKey && !this._isAltObjFreeRotationAllowed || event.shiftKey);
      this._lastMouseMoveTime = this._clock.getElapsedTime();
      break;
    case STATE.TRANSLATE:
      this._mousePrevPos.copy(this._mouseCurPos);
      this.convertMouseToViewport(this._mouseCurPos, event.pageX, event.pageY);
      this.translate();
      break;
    case STATE.TRANSLATE_PIVOT:
      this._mousePrevPos.copy(this._mouseCurPos);
      this.convertMouseToViewport(this._mouseCurPos, event.pageX, event.pageY);
      this.translatePivotByMouse();
      break;
    default:
      break;
  }
};
ObjectControls.prototype.mousewheel = function(event) {
  if (this.enabled === false || !settings.now.zooming || this._state !== STATE.NONE || event.shiftKey) {
    return;
  }
  event.preventDefault();
  let delta = 0;
  if (event.wheelDelta) {
    delta = event.wheelDelta / 40;
  } else if (event.detail) {
    delta = -event.detail / 3;
  }
  let factor = 1 + delta * 0.05;
  factor = Math.max(factor, 0.01);
  this.scale(factor);
};
ObjectControls.prototype.mouseup = function(event) {
  if (this.enabled === false || this._state === STATE.NONE) {
    return;
  }
  event.preventDefault();
  event.stopPropagation();
  this._state = STATE.NONE;
  if (this._clock.getElapsedTime() - this._lastMouseMoveTime > FULL_STOP_THRESHOLD) {
    this._affectedObj.stop();
  }
};
ObjectControls.prototype.touchstartend = function(event) {
  if (this.enabled === false) {
    return;
  }
  event.preventDefault();
  event.stopPropagation();
  switch (event.touches.length) {
    case 1:
      this._state = STATE.ROTATE;
      this.convertMouseToOnCircle(this._mouseCurPos, event.touches[0].pageX, event.touches[0].pageY);
      this._mousePrevPos.copy(this._mouseCurPos);
      break;
    case 2: {
      this._mainObj.stop();
      this._altObj.stop();
      this._state = STATE.SCALE;
      const dx = event.touches[0].pageX - event.touches[1].pageX;
      const dy = event.touches[0].pageY - event.touches[1].pageY;
      this._touchDistanceCur = this._touchDistanceStart = Math.sqrt(dx * dx + dy * dy);
      this._scaleStart = this.object.scale.x;
      break;
    }
    default:
      this._state = STATE.NONE;
  }
};
ObjectControls.prototype.touchmove = function(event) {
  if (this.enabled === false || this._state === STATE.NONE) {
    return;
  }
  event.preventDefault();
  event.stopPropagation();
  switch (this._state) {
    case STATE.ROTATE:
      this._mousePrevPos.copy(this._mouseCurPos);
      this.convertMouseToOnCircle(this._mouseCurPos, event.touches[0].pageX, event.touches[0].pageY);
      this.rotateByMouse(false);
      this._lastMouseMoveTime = this._clock.getElapsedTime();
      break;
    case STATE.SCALE:
      if (settings.now.zooming) {
        const dx = event.touches[0].pageX - event.touches[1].pageX;
        const dy = event.touches[0].pageY - event.touches[1].pageY;
        this._touchDistanceCur = Math.sqrt(dx * dx + dy * dy);
        const newScale = this._scaleStart * this._touchDistanceCur / this._touchDistanceStart;
        const factor = newScale / this.object.scale.x;
        this.scale(factor);
      }
      break;
    default:
  }
};
ObjectControls.prototype.keydownup = function(event) {
  if (this.enabled === false || this.hotkeysEnabled === false) {
    return;
  }
  switch (event.keyCode) {
    case VK_LEFT:
    case VK_UP:
    case VK_RIGHT:
    case VK_DOWN:
      this._pressedKeys[event.keyCode] = event.type === "keydown";
      event.preventDefault();
      event.stopPropagation();
      break;
    default:
  }
};
ObjectControls.prototype.getKeyBindObject = function() {
  return getTopWindow();
};
ObjectControls.prototype.dispose = function() {
  for (let i2 = 0; i2 < this._listeners.length; i2++) {
    const l2 = this._listeners[i2];
    l2.obj.removeEventListener(l2.type, l2.handler);
  }
};
ObjectControls.prototype.translatePivotByMouse = function() {
  const delta = new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Vector2();
  return function() {
    delta.subVectors(this._mouseCurPos, this._mousePrevPos);
    this.translatePivotInWorld(settings.now.translationSpeed * delta.x, settings.now.translationSpeed * delta.y, 0);
  };
}();
ObjectControls.prototype.translatePivotInWorld = function(x3, y2, z) {
  const pos = this.objectPivot.position;
  pos.applyMatrix4(this.object.matrixWorld);
  pos.setX(pos.x + x3);
  pos.setY(pos.y + y2);
  pos.setZ(pos.z + z);
  pos.applyMatrix4(matrix4.copy(this.object.matrixWorld).invert());
  this.dispatchEvent({
    type: "change",
    action: "translatePivot"
  });
};
ObjectControls.prototype.translatePivot = function(x3, y2, z) {
  const pos = this.objectPivot.position;
  pos.setX(pos.x + x3);
  pos.setY(pos.y + y2);
  pos.setZ(pos.z + z);
  this.dispatchEvent({
    type: "change",
    action: "translatePivot"
  });
};
ObjectControls.prototype.setPivot = function(newPivot) {
  this.objectPivot.position.copy(newPivot);
  this.dispatchEvent({
    type: "change",
    action: "translatePivot"
  });
};
var ui_ObjectControls = ObjectControls;
function Picker(gfxObj, camera, domElement) {
  utils_EventDispatcher.call(this);
  const self2 = this;
  this.gfxObj = gfxObj;
  this.camera = camera;
  this.domElement = typeof domElement !== "undefined" ? domElement : document;
  this.screen = {
    left: 0,
    top: 0,
    width: 0,
    height: 0
  };
  this._lastMousePos = new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Vector2(0, 0);
  this._mouseTotalDist = 0;
  this._lastClickBeginTime = -1e3;
  this._lastClickPos = new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Vector2(0, 0);
  this._clickBeginTime = 0;
  this._clock = new Timer();
  this._clock.start();
  this._listeners = [{
    obj: self2.domElement,
    type: "mousedown",
    handler(e2) {
      self2.mousedown(e2);
    }
  }, {
    obj: self2.domElement,
    type: "mouseup",
    handler(e2) {
      self2.mouseup(e2);
    }
  }, {
    obj: self2.domElement,
    type: "mousemove",
    handler(e2) {
      self2.mousemove(e2);
    }
  }, {
    obj: self2.domElement,
    type: "touchstart",
    handler(e2) {
      self2.touchstart(e2);
    }
  }, {
    obj: self2.domElement,
    type: "touchend",
    handler(e2) {
      self2.touchend(e2);
    }
  }, {
    obj: window,
    type: "resize",
    handler() {
      self2.handleResize();
    }
  }];
  for (let i2 = 0; i2 < this._listeners.length; i2++) {
    const l2 = this._listeners[i2];
    l2.obj.addEventListener(l2.type, l2.handler);
  }
  this.handleResize();
}
Picker.prototype = Object.create(utils_EventDispatcher.prototype);
Picker.prototype.constructor = Picker;
Picker.prototype.reset = function() {
  this.picked = {};
  this.dispatchEvent({
    type: "newpick",
    obj: {}
  });
};
Picker.prototype.handleResize = function() {
  if (this.domElement === document) {
    this.screen.left = 0;
    this.screen.top = 0;
    this.screen.width = window.innerWidth;
    this.screen.height = window.innerHeight;
  } else {
    const box = this.domElement.getBoundingClientRect();
    const d2 = this.domElement.ownerDocument.documentElement;
    this.screen.left = box.left + window.pageXOffset - d2.clientLeft;
    this.screen.top = box.top + window.pageYOffset - d2.clientTop;
    this.screen.width = box.width;
    this.screen.height = box.height;
  }
};
Picker.prototype.pickObject = function(screenPos) {
  if (!this.gfxObj) {
    this.picked = {};
    this.dispatchEvent({
      type: "newpick",
      obj: {}
    });
    return;
  }
  const {
    gfxObj
  } = this;
  const rayCaster = new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Raycaster();
  rayCaster.ray.origin.setFromMatrixPosition(this.camera.matrixWorld);
  rayCaster.ray.direction.set(screenPos.x, screenPos.y, 0.5).unproject(this.camera).sub(rayCaster.ray.origin).normalize();
  const clipPlane = settings.now.draft.clipPlane && this.clipPlaneValue ? this.clipPlaneValue : Infinity;
  const fogFarPlane = settings.now.fog && this.fogFarValue ? this.fogFarValue : Infinity;
  const point = rayCaster.intersectVisibleObject(gfxObj, this.camera, clipPlane, fogFarPlane);
  if (!point) {
    this.picked = {};
    this.dispatchEvent({
      type: "newpick",
      obj: {}
    });
    return;
  }
  let picked = {};
  if (point.residue || point.atom) {
    const residue = point.residue || point.atom.residue;
    if (settings.now.pick === "chain") {
      picked = {
        chain: residue.getChain()
      };
    } else if (settings.now.pick === "molecule") {
      picked = {
        molecule: residue.getMolecule()
      };
    } else if (point.residue || settings.now.pick === "residue") {
      picked = {
        residue
      };
    } else if (point.atom) {
      picked = {
        atom: point.atom
      };
    }
  }
  this.picked = picked;
  this.dispatchEvent({
    type: "newpick",
    obj: picked
  });
};
Picker.prototype.getMouseInViewport = function(pageX, pageY) {
  return new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Vector2((pageX - this.screen.left) / this.screen.width * 2 - 1, -(pageY - this.screen.top) / this.screen.height * 2 + 1);
};
Picker.prototype.mousedown = function(event) {
  event.preventDefault();
  event.stopPropagation();
  if (event.button === 0) {
    this._lastMousePos = this.getMouseInViewport(event.pageX, event.pageY);
    this._mouseTotalDist = 0;
    this._clickBeginTime = this._clock.getElapsedTime();
  }
};
Picker.prototype.mousemove = function(event) {
  event.preventDefault();
  event.stopPropagation();
  const pos = this.getMouseInViewport(event.pageX, event.pageY);
  this._mouseTotalDist += pos.sub(this._lastMousePos).length();
};
Picker.prototype.mouseup = function(event) {
  const self2 = this;
  event.preventDefault();
  event.stopPropagation();
  if (event.button === 0) {
    if (this._mouseTotalDist < 0.01) {
      const curTime = this._clock.getElapsedTime();
      const curPos = this.getMouseInViewport(event.pageX, event.pageY);
      const timeSinceLastClickBegin = curTime - this._lastClickBeginTime;
      if (timeSinceLastClickBegin < 0.7) {
        const clickDist = new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Vector2().subVectors(curPos, this._lastClickPos);
        if (clickDist.length() < 0.01) {
          this.dispatchEvent({
            type: "dblclick",
            obj: this.picked
          });
          this._lastClickPos = curPos;
          this._lastClickBeginTime = -1e3;
          return;
        }
      }
      setTimeout(() => {
        self2.pickObject(curPos);
      }, 0);
      this._lastClickPos = curPos;
      this._lastClickBeginTime = this._clickBeginTime;
    }
  }
};
Picker.prototype.touchstart = function(event) {
  event.preventDefault();
  event.stopPropagation();
  if (event.touches.length === 1) {
    this._lastTouchdownPos = this.getMouseInViewport(event.touches[0].pageX, event.touches[0].pageY);
  }
};
Picker.prototype.touchend = function(event) {
  const self2 = this;
  event.preventDefault();
  event.stopPropagation();
  if (event.touches.length === 0 && event.changedTouches.length === 1) {
    const pos = this.getMouseInViewport(event.changedTouches[0].pageX, event.changedTouches[0].pageY);
    const dist = pos.sub(this._lastTouchdownPos).length();
    if (dist < 0.01) {
      setTimeout(() => {
        self2.pickObject(self2._lastTouchdownPos);
      }, 0);
    }
  }
};
Picker.prototype.dispose = function() {
  for (let i2 = 0; i2 < this._listeners.length; i2++) {
    const l2 = this._listeners[i2];
    l2.obj.removeEventListener(l2.type, l2.handler);
  }
};
var ui_Picker = Picker;
var Axes = class {
  constructor(target, targetCamera) {
    this._target = target;
    this._targetCamera = targetCamera;
    this._camera = new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.PerspectiveCamera(targetCamera.fov, targetCamera.aspect, 1, 100);
    this._object = new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.AxesHelper(1);
    this._scene = new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Scene();
    this._scene.add(this._object);
    this._full = new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Vector2();
    this._update();
  }
  _update() {
    const {
      fov: fov2
    } = this._targetCamera;
    const camera = this._camera;
    camera.aspect = this._targetCamera.aspect;
    camera.setMinimalFov(fov2);
    camera.setDistanceToFit(1, fov2);
    camera.updateProjectionMatrix();
    this._object.quaternion.copy(this._target.quaternion);
  }
  render(renderer) {
    this._update();
    renderer.getSize(this._full);
    const width = this._full.width * 0.25;
    const height = this._full.height * 0.25;
    const {
      autoClear
    } = renderer;
    renderer.autoClear = false;
    renderer.setViewport(0, 0, width, height);
    renderer.clear(false, true, false);
    renderer.render(this._scene, this._camera);
    renderer.setViewport(0, 0, this._full.width, this._full.height);
    renderer.autoClear = autoClear;
  }
};
var gfx_Axes = Axes;
var cDataOffset = 12;
var cFirstMask = 268435200;
var cFirstShift = 8;
var cSecMask1 = 255;
var cSecShift1 = 12;
var cSecMask2 = 4293918720;
var cSecShift2 = 20;
var cThirdMask = 1048575;
var cStrMask = 4026531840;
var cStrShift = 28;
var c219 = 1 << 19;
var c220 = 1 << 20;
var cHelixIdx = 1;
var cSheetIdx = 2;
var secTypes = ["helix", "strand"];
var cSecNames = ["fs", "ps", "ns", "us"];
function _createSecondary(strArray, complex) {
  const residues = complex._residues;
  const nRes = residues.length;
  const resid = new Uint8Array(nRes);
  const atoms = complex._atoms;
  for (let i2 = 0, n = strArray.length; i2 < n; ++i2) {
    const atom = atoms[i2];
    resid[atom.residue._index] = strArray[i2];
  }
  const secondary = [];
  let rIdx = 0;
  while (rIdx < nRes) {
    if (resid[rIdx] !== 0) {
      const start = rIdx;
      const val = resid[rIdx];
      while (rIdx < nRes - 1 && resid[rIdx + 1] === val && residues[rIdx].isConnected(residues[rIdx + 1])) {
        ++rIdx;
      }
      secondary.push({
        start,
        end: rIdx,
        type: secTypes[val - 1]
      });
    }
    ++rIdx;
  }
  return secondary;
}
function fromUInt20ToInt20(uint20) {
  return uint20 >= c219 ? uint20 - c220 : uint20;
}
var _FrameInfo = class _FrameInfo {
  constructor(complex, payload, callbacks) {
    this._complex = complex;
    this._secondary = null;
    this.isLoading = false;
    this._framesRange = {
      start: 0,
      end: -1
    };
    this.frameIsReady = false;
    this._buffer = null;
    this._frameRequest = null;
    this._callbacks = callbacks;
    if (typeof payload === "function") {
      this._framesRequestLength = 1;
      this._downloadDataFn = payload;
    } else {
      this.parseBinaryData(payload, true);
    }
    this.reset();
    this.setFrame(0);
  }
  _prepareBuffer(framesStart, framesEnd) {
    if (framesStart === void 0 || framesStart === null) {
      framesStart = 0;
    }
    if (framesEnd === void 0 || framesEnd === null) {
      framesEnd = framesStart + this._framesRequestLength;
    }
    if (this._framesCount !== void 0) {
      framesEnd = Math.min(this._framesCount - 1, framesEnd);
    }
    if (this._downloadDataFn) {
      const self2 = this;
      const onDone = function(data) {
        self2.isLoading = false;
        if (self2._callbacks && typeof self2._callbacks.onLoadStatusChanged === "function") {
          self2._callbacks.onLoadStatusChanged();
        }
        self2._buffer = {
          data,
          state: "ready",
          start: framesStart,
          end: framesEnd
        };
        if (self2._frameRequest !== null) {
          const idx = self2._frameRequest;
          self2._frameRequest = null;
          self2.setFrame(idx);
        }
      };
      const onFail = function() {
        self2.isLoading = false;
        if (self2._callbacks && typeof self2._callbacks.onError === "function") {
          self2._callbacks.onError("Streaming failed");
        }
      };
      if (!this._buffer) {
        this._buffer = {};
      }
      this._buffer.state = "downloading";
      this.isLoading = true;
      if (self2._callbacks && typeof self2._callbacks.onLoadStatusChanged === "function") {
        self2._callbacks.onLoadStatusChanged();
      }
      this._downloadDataFn({
        start: framesStart,
        end: framesEnd + 1
      }, onDone, onFail);
    }
  }
  _parseBuffer() {
    if (this._buffer && this._buffer.state === "ready") {
      this._framesRange = {
        start: this._buffer.start,
        end: this._buffer.end
      };
      this.parseBinaryData(this._buffer.data, false);
      let _bufferRequestStart = (this._buffer.end + 1) % this._framesCount;
      if (_bufferRequestStart >= this._framesCount) {
        _bufferRequestStart = 0;
      }
      this._buffer = {
        state: "none"
      };
      this._prepareBuffer(_bufferRequestStart, _bufferRequestStart + this._framesRequestLength);
      if (this._frameRequest !== null) {
        const idx = this._frameRequest;
        this._frameRequest = null;
        this.setFrame(idx);
      }
    }
  }
  parseBinaryData(arrayBuffer) {
    const dataView = new DataView(arrayBuffer);
    let offset = 0;
    const atomsCount = dataView.getUint32(offset, true);
    offset += 4;
    const framesCount = dataView.getUint32(offset, true);
    this._framesCount = framesCount;
    this._framesRange.end = this._framesRange.end > 0 ? Math.min(this._framesRange.end, framesCount - 1) : framesCount - 1;
    offset += 4;
    this._atomsCount = atomsCount;
    const maxSize = 1024 * 1024;
    this._framesRequestLength = Math.ceil(maxSize / (atomsCount * 8));
    const chunkedFramesCount = this._framesRange.end - this._framesRange.start + 1;
    if (atomsCount !== this._complex._atoms.length || arrayBuffer.byteLength !== cDataOffset + chunkedFramesCount * atomsCount * 8) {
      throw new Error();
    }
    const complex = this._complex;
    let timeStep = dataView.getUint32(offset, true);
    let iName = 0;
    while (timeStep > 1e3 && iName < cSecNames.length - 1) {
      timeStep /= 1e3;
      ++iName;
    }
    this._timeStep = `${timeStep.toString()} ${cSecNames[iName]}`;
    offset += 4;
    const secondary = [];
    const posData = new Float32Array(chunkedFramesCount * atomsCount * 3);
    let coordIdx = 0;
    const secondaryArr = new Int8Array(atomsCount);
    for (let j = 0; j < chunkedFramesCount; ++j) {
      for (let i2 = 0; i2 < atomsCount; ++i2) {
        const hiWord = dataView.getUint32(offset, true);
        offset += 4;
        const loWord = dataView.getUint32(offset, true);
        offset += 4;
        const str = (loWord & cStrMask) >>> cStrShift;
        const x3 = fromUInt20ToInt20((loWord & cFirstMask) >>> cFirstShift >> 0);
        const y2 = fromUInt20ToInt20(((loWord & cSecMask1) << cSecShift1 | (hiWord & cSecMask2) >>> cSecShift2) >> 0);
        const z = fromUInt20ToInt20((hiWord & cThirdMask) >> 0);
        secondaryArr[i2] = 0;
        if (str > 0 && str < 4) {
          secondaryArr[i2] = cHelixIdx;
        } else if (str === 4) {
          secondaryArr[i2] = cSheetIdx;
        }
        posData[coordIdx++] = x3 / 100;
        posData[coordIdx++] = y2 / 100;
        posData[coordIdx++] = z / 100;
      }
      secondary.push(_createSecondary(secondaryArr, complex));
    }
    this._secondaryData = secondary;
    this._data = posData;
  }
  nextFrame() {
    this.setFrame((this._currFrame + 1) % this._framesCount);
  }
  needsColorUpdate(colorer) {
    return colorer instanceof colorers_SecondaryStructureColorer;
  }
  getAtomColor(colorer, atom) {
    return colorer.getResidueColor(this._residues[atom.residue._index], this._complex);
  }
  getResidueColor(colorer, residue) {
    return colorer.getResidueColor(this._residues[residue._index], this._complex);
  }
  _updateSecondary() {
    let i2;
    const myResidues = this._residues;
    let n = myResidues.length;
    for (i2 = 0; i2 < n; ++i2) {
      myResidues[i2]._secondary = null;
    }
    const sec = this._secondaryData[this._currFrame - this._framesRange.start];
    for (i2 = 0, n = sec.length; i2 < n; ++i2) {
      const oldSec = sec[i2];
      const {
        start,
        end
      } = oldSec;
      const nSec = {
        _start: myResidues[start],
        _end: myResidues[end],
        type: oldSec.type,
        generic: oldSec.generic
      };
      for (let j = start; j <= end; ++j) {
        myResidues[j]._secondary = nSec;
      }
    }
  }
  reset() {
    const compRes = this._complex._residues;
    const n = compRes.length;
    this._residues = new Array(n);
    const myResidues = this._residues;
    const getSec = function() {
      return this._secondary;
    };
    for (let i2 = 0; i2 < n; ++i2) {
      myResidues[i2] = {
        _type: compRes[i2]._type,
        _isValid: compRes[i2]._isValid,
        _controlPoint: null,
        _wingVector: null,
        _secondary: null,
        getSecondary: getSec
      };
    }
  }
  setFrame(frameIdx) {
    this.frameIsReady = false;
    if (frameIdx >= this._framesRange.start && frameIdx <= this._framesRange.end) {
      this._currFrame = frameIdx;
      this._cachedResidues = false;
      this._updateSecondary();
      this.frameIsReady = true;
    } else {
      this._frameRequest = frameIdx;
      if (!this._buffer) {
        this._prepareBuffer(frameIdx);
      } else {
        const self2 = this;
        switch (this._buffer.state) {
          case "none":
            this._prepareBuffer(frameIdx);
            break;
          case "ready":
            self2._parseBuffer();
            break;
          default:
            break;
        }
      }
    }
  }
  disableEvents() {
    this._callbacks = null;
  }
  getAtomPos(atomIdx) {
    const vec = _FrameInfo._vec;
    const self2 = this;
    const data = self2._data;
    const idx = (self2._atomsCount * (self2._currFrame - self2._framesRange.start) + atomIdx) * 3;
    vec.set(data[idx], data[idx + 1], data[idx + 2]);
    return vec;
  }
  getResidues() {
    if (this._cachedResidues) {
      return this._residues;
    }
    this._complex.updateToFrame(this);
    return this._residues;
  }
};
/**
 * Returns link to atom pos vector, clone it if needed
 */
__publicField(_FrameInfo, "_vec", (() => new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Vector3())());
var FrameInfo = _FrameInfo;
var gfx_FrameInfo = FrameInfo;
var SceneObject = class _SceneObject {
  constructor(params, opts) {
    if (this.constructor === _SceneObject) {
      throw new Error("Can not instantiate abstract class!");
    }
    this.params = params;
    this.opts = external_module_lodash_commonjs_lodash_commonjs2_lodash_amd_lodash_root_namespaceObject["default"].merge(utils.deriveDeep(settings.now.objects[this.type], true), opts);
    this.needsRebuild = false;
    this._mesh = null;
    this.id = null;
  }
  /**
   * Get object identification, probably with options.
   *  @returns {Object} field type contains type information, params - object's formal parameters,
   * opts - changed options
   * Options are returned if they were changed during or after object creation.
   */
  identify() {
    const result = {
      type: this.type,
      params: this.params
    };
    const diff = utils.objectsDiff(this.opts, settings.now.modes[this.id]);
    if (!external_module_lodash_commonjs_lodash_commonjs2_lodash_amd_lodash_root_namespaceObject["default"].isEmpty(diff)) {
      result.opts = diff;
    }
    return result;
  }
  toString() {
    const paramsStr = `o=${this.type},${this.params.join(",")}`;
    const optsStr = utils.compareOptionsWithDefaults(this.opts, settings.defaults.objects[this.type]);
    return paramsStr + optsStr;
  }
  getGeometry() {
    return this._mesh;
  }
  destroy() {
    if (this._mesh) {
      gfxutils.destroyObject(this._mesh);
    }
  }
};
SceneObject.prototype.type = "__";
var objects_SceneObject = SceneObject;
var LinesObj = class extends objects_SceneObject {
  constructor(params, opts) {
    super(params, opts);
    if (params.length < 2) {
      throw new Error("Wrong number of argumets on line object creation!");
    }
    [this._id1, this._id2] = params;
  }
  _getAtomFromName(complex, atomId) {
    const err = " - Wrong atom format it must be '#CHAIN_NAME.#RESIDUE_NUMBER.#ATOM_NAME' (e.g. 'A.38.CO1')";
    const atom1 = complex.getAtomByFullname(atomId);
    if (!atom1) {
      throw new Error(atomId + err);
    }
    return atom1;
  }
  build(complex) {
    const geom = new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.BufferGeometry();
    this._atom1 = this._getAtomFromName(complex, this._id1);
    this._atom2 = this._getAtomFromName(complex, this._id2);
    const p1 = this._atom1.position;
    const p2 = this._atom2.position;
    const vertices = new Float32Array([p1.x, p1.y, p1.z, p2.x, p2.y, p2.z]);
    geom.setAttribute("position", new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.BufferAttribute(vertices, 3));
    geom.computeBoundingBox();
    this._line = new meshes.Line(geom, new shaders_UberMaterial({
      lights: false,
      overrideColor: true,
      dashedLine: true,
      fogTransparent: settings.now.bg.transparent
    }));
    this._line.computeLineDistances();
    this._line.material.setUberOptions({
      fixedColor: new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Color(this.opts.color),
      dashedLineSize: this.opts.dashSize,
      dashedLinePeriod: this.opts.dashSize + this.opts.gapSize
    });
    this._line.material.updateUniforms();
    this._line.raycast = function(_raycaster, _intersects) {
    };
    this._mesh = this._line;
    const transforms = complex.getTransforms();
    if (transforms.length > 0) {
      this._mesh = new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Group();
      this._mesh.add(this._line);
      meshutils.applyTransformsToMeshes(this._mesh, transforms);
    }
  }
  updateToFrame(frameData) {
    if (!this._atom1 || !this._atom2 || !this._line) {
      return;
    }
    const geo = this._line.geometry;
    geo.vertices[0].copy(frameData.getAtomPos(this._atom1.index));
    geo.vertices[1].copy(frameData.getAtomPos(this._atom2.index));
    this._line.computeLineDistances();
    geo.computeBoundingSphere();
    geo.verticesNeedUpdate = true;
  }
};
LinesObj.prototype.constructor = LinesObj;
LinesObj.prototype.type = "line";
var objects_LinesObj = LinesObj;
var Outline_namespaceObject = "precision highp float;\r\n\r\nuniform sampler2D srcTex;\r\nuniform vec2 srcTexSize;\r\nuniform vec2 thickness;\r\nvarying vec2 vUv;\r\n\r\n#ifdef DEPTH_OUTLINE\r\n  uniform sampler2D srcDepthTex; //depthTexture\r\n  uniform vec3 color;\r\n  uniform float threshold;\r\n#endif\r\n\r\nvoid main() {\r\n\r\n  vec2 pixelSize = thickness / srcTexSize;\r\n\r\n  #ifdef DEPTH_OUTLINE\r\n    float c00 = texture2D(srcDepthTex, vUv + vec2(-pixelSize.x,-pixelSize.y)).x;\r\n    float c01 = texture2D(srcDepthTex, vUv + vec2(0,-pixelSize.y)).x;\r\n    float c02 = texture2D(srcDepthTex, vUv + vec2(pixelSize.x,-pixelSize.y)).x;\r\n    float c10 = texture2D(srcDepthTex, vUv + vec2(-pixelSize.x,0)).x;\r\n    float c12 = texture2D(srcDepthTex, vUv + vec2(pixelSize.x,0)).x;\r\n    float c20 = texture2D(srcDepthTex, vUv + vec2(-pixelSize.x,pixelSize.y)).x;\r\n    float c21 = texture2D(srcDepthTex, vUv + vec2(0,pixelSize.y)).x;\r\n    float c22 = texture2D(srcDepthTex, vUv + vec2(pixelSize.x,pixelSize.y)).x;\r\n\r\n    float horizEdge = - c00 - 2.0 * c01 - c02 + c20 + 2.0 * c21 + c22;\r\n    float vertEdge  = - c00 - 2.0 * c10 - c20 + c02 + 2.0 * c12 + c22;\r\n\r\n    float grad = sqrt(horizEdge * horizEdge + vertEdge * vertEdge);\r\n\r\n    gl_FragColor = ( grad > threshold ) ? vec4(color.rgb, 1.0) : gl_FragColor = texture2D(srcTex, vUv);\r\n\r\n  #else\r\n    vec4 c00 = texture2D(srcTex, vUv + vec2(-pixelSize.x,-pixelSize.y));\r\n    vec4 c01 = texture2D(srcTex, vUv + vec2(0,-pixelSize.y));\r\n    vec4 c02 = texture2D(srcTex, vUv + vec2(pixelSize.x,-pixelSize.y));\r\n    vec4 c10 = texture2D(srcTex, vUv + vec2(-pixelSize.x,0));\r\n    vec4 c12 = texture2D(srcTex, vUv + vec2(pixelSize.x,0));\r\n    vec4 c20 = texture2D(srcTex, vUv + vec2(-pixelSize.x,pixelSize.y));\r\n    vec4 c21 = texture2D(srcTex, vUv + vec2(0,pixelSize.y));\r\n    vec4 c22 = texture2D(srcTex, vUv + vec2(pixelSize.x,pixelSize.y));\r\n\r\n    vec4 horizEdge = - c00 - 2.0 * c01 - c02 + c20 + 2.0 * c21 + c22;\r\n    vec4 vertEdge  = - c00 - 2.0 * c10 - c20 + c02 + 2.0 * c12 + c22;\r\n\r\n    vec4 grad = sqrt(horizEdge * horizEdge + vertEdge * vertEdge);\r\n    gl_FragColor = grad;\r\n  #endif\r\n}\r\n";
var OutlineMaterial = class extends external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.RawShaderMaterial {
  constructor(params) {
    super(params);
    const settings2 = {
      uniforms: {
        srcTex: {
          type: "t",
          value: null
        },
        srcDepthTex: {
          type: "t",
          value: null
        },
        srcTexSize: {
          type: "v2",
          value: new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Vector2(512, 512)
        },
        color: {
          type: "v3",
          value: null
        },
        threshold: {
          type: "f",
          value: null
        },
        opacity: {
          type: "f",
          value: 1
        },
        thickness: {
          type: "v2",
          value: new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Vector2(1, 1)
        }
      },
      vertexShader: ScreenQuad_namespaceObject,
      fragmentShader: Outline_namespaceObject,
      transparent: true,
      depthTest: false,
      depthWrite: false
    };
    this.setValues(settings2);
  }
  copy(source) {
    super.copy(source);
    this.depth = source.depth;
  }
  setValues(values) {
    if (typeof values === "undefined") {
      return;
    }
    super.setValues(values);
    const defines = {};
    if (this.depth) {
      defines.DEPTH_OUTLINE = 1;
    }
    this.defines = defines;
  }
};
OutlineMaterial.prototype.depth = false;
var shaders_OutlineMaterial = OutlineMaterial;
var FXAA_namespaceObject = "precision highp float;\r\n\r\n// edge end finding algorithm parameters\r\n#define FXAA_QUALITY_PS 8\r\n#define FXAA_QUALITY_P0 1.0\r\n#define FXAA_QUALITY_P1 1.5\r\n#define FXAA_QUALITY_P2 2.0\r\n#define FXAA_QUALITY_P3 2.0\r\n#define FXAA_QUALITY_P4 2.0\r\n#define FXAA_QUALITY_P5 2.0\r\n#define FXAA_QUALITY_P6 4.0\r\n#define FXAA_QUALITY_P7 12.0\r\n// constants\r\nfloat fxaaQualityEdgeThreshold = 0.125;\r\nfloat fxaaQualityEdgeThresholdMin = 0.0625;\r\nfloat fxaaQualitySubpix = 0.7; //0.65;\r\n// global params\r\nuniform sampler2D srcTex;\r\nuniform vec2 srcTexelSize;\r\nuniform vec3 bgColor;\r\n// from vs\r\nvarying vec2 vUv;\r\n//=====================================================================//\r\n// calc luminance from rgb\r\n//'float FxaaLuma(vec3 rgb) {return rgb.y * (0.587/0.299) + rgb.x; } // Lotte's idea about game luminance\r\nfloat FxaaLuma(vec3 rgb) {return dot(rgb, vec3(0.299, 0.587, 0.114)); } // real luminance calculation\r\n                                                                           // for non-real scene rendering\r\n// texture sampling by pixel position(coords) and offset(in pixels)\r\n vec3 FxaaTex(sampler2D tex, vec2 pos, vec2 off,  vec2 res ) {\r\n  #ifdef BG_TRANSPARENT\r\n    vec4 color = texture2D( tex, pos + off * res );\r\n    return mix(color.rgb, bgColor, 1.0 - color.a);\r\n  #else\r\n    return texture2D( tex, pos + off * res ).xyz;\r\n  #endif\r\n}\r\nvec3 FxaaTexTop(sampler2D tex, vec2 pos) {\r\n  #ifdef BG_TRANSPARENT\r\n    vec4 color = texture2D( tex, pos );\r\n    return mix(color.rgb, bgColor, 1.0 - color.a);\r\n  #else\r\n    return texture2D( tex, pos).xyz;\r\n  #endif\r\n}\r\nvec4 FxaaTexTopAlpha(sampler2D tex, vec2 pos) {\r\n  return texture2D( tex, pos);\r\n}\r\n\r\n//=====================================================================//\r\nvoid main() {\r\n  // renaming\r\n  vec2 posM = vUv;\r\n  // get luminance for neighbours\r\n  float lumaS = FxaaLuma(FxaaTex(srcTex, posM, vec2( 0.0, 1.0 ), srcTexelSize));\r\n  float lumaE = FxaaLuma(FxaaTex(srcTex, posM, vec2( 1.0, 0.0 ), srcTexelSize));\r\n  float lumaN = FxaaLuma(FxaaTex(srcTex, posM, vec2( 0.0, -1.0 ), srcTexelSize));\r\n  float lumaW = FxaaLuma(FxaaTex(srcTex, posM, vec2( -1.0, 0.0 ), srcTexelSize));\r\n  float lumaM = FxaaLuma(FxaaTexTop(srcTex, posM));\r\n  // find max and min luminance\r\n  float rangeMax = max(max(lumaN, lumaW), max(lumaE, max(lumaS, lumaM)));\r\n  float rangeMin = min(min(lumaN, lumaW), min(lumaE, min(lumaS, lumaM)));\r\n  // calc maximum non-edge range\r\n  float rangeMaxScaled = rangeMax * fxaaQualityEdgeThreshold;\r\n  float range = rangeMax - rangeMin;\r\n  float rangeMaxClamped = max(fxaaQualityEdgeThresholdMin, rangeMaxScaled);\r\n  // exit when luma contrast is small (is not edge)\r\n  if(range < rangeMaxClamped){\r\n    gl_FragColor = FxaaTexTopAlpha(srcTex, posM);\r\n    return;\r\n  }\r\n  float subpixRcpRange = 1.0/range;\r\n  // note: the sampling coordinates can be calculated in vertex shader but the approach doesn't affect performance\r\n  // visibly, thus we decided to leave calculation here for better readability.\r\n  // calc other neighbours luminance\r\n  float lumaNE = FxaaLuma(FxaaTex(srcTex, posM, vec2(  1.0, -1.0 ), srcTexelSize));\r\n  float lumaSW = FxaaLuma(FxaaTex(srcTex, posM, vec2( -1.0,  1.0 ), srcTexelSize));\r\n  float lumaSE = FxaaLuma(FxaaTex(srcTex, posM, vec2(  1.0,  1.0 ), srcTexelSize));\r\n  float lumaNW = FxaaLuma(FxaaTex(srcTex, posM, vec2( -1.0, -1.0 ), srcTexelSize));\r\n/*--------------span calculation and subpix amount calulation-----------------*/\r\n  float lumaNS = lumaN + lumaS;\r\n  float lumaWE = lumaW + lumaE;\r\n  float subpixNSWE = lumaNS + lumaWE;\r\n  float edgeHorz1 = (-2.0 * lumaM) + lumaNS;\r\n  float edgeVert1 = (-2.0 * lumaM) + lumaWE;\r\n/*--------------------------------------------------------------------------*/\r\n  float lumaNESE = lumaNE + lumaSE;\r\n  float lumaNWNE = lumaNW + lumaNE;\r\n  float edgeHorz2 = (-2.0 * lumaE) + lumaNESE;\r\n  float edgeVert2 = (-2.0 * lumaN) + lumaNWNE;\r\n/*--------------------------------------------------------------------------*/\r\n  float lumaNWSW = lumaNW + lumaSW;\r\n  float lumaSWSE = lumaSW + lumaSE;\r\n  float edgeHorz4 = (abs(edgeHorz1) * 2.0) + abs(edgeHorz2);\r\n  float edgeVert4 = (abs(edgeVert1) * 2.0) + abs(edgeVert2);\r\n  float edgeHorz3 = (-2.0 * lumaW) + lumaNWSW;\r\n  float edgeVert3 = (-2.0 * lumaS) + lumaSWSE;\r\n  float edgeHorz = abs(edgeHorz3) + edgeHorz4;\r\n  float edgeVert = abs(edgeVert3) + edgeVert4;\r\n/*--------------------subpix amount calulation------------------------------*/\r\n  float subpixNWSWNESE = lumaNWSW + lumaNESE;\r\n  float lengthSign = srcTexelSize.x;\r\n  bool horzSpan = edgeHorz >= edgeVert;\r\n   // debug  code edge span visualization\r\n/*'  if (horzSpan)\r\n      gl_FragColor = vec4(0.0, 0.0, 1.0, 1.0);\r\n  else\r\n    gl_FragColor = vec4(1.0, 0.0, 0.0, 1.0);\r\n  return;*/\r\n  float subpixA = subpixNSWE * 2.0 + subpixNWSWNESE;\r\n/*--------------------------------------------------------------------------*/\r\n  if(!horzSpan) lumaN = lumaW;\r\n  if(!horzSpan) lumaS = lumaE;\r\n  if(horzSpan) lengthSign = srcTexelSize.y;\r\n  float subpixB = (subpixA * (1.0/12.0)) - lumaM;\r\n/*--------------------------------------------------------------------------*/\r\n  float gradientN = lumaN - lumaM;\r\n  float gradientS = lumaS - lumaM;\r\n  float lumaNN = lumaN + lumaM;\r\n  float lumaSS = lumaS + lumaM;\r\n  bool pairN = abs(gradientN) >= abs(gradientS);\r\n  float gradient = max(abs(gradientN), abs(gradientS));\r\n  if(pairN) lengthSign = -lengthSign;\r\n  float subpixC = clamp(abs(subpixB) * subpixRcpRange, 0.0, 1.0);\r\n/*--------------------------------------------------------------------------*/\r\n  vec2 posB;\r\n  posB = posM;\r\n  vec2 offNP;\r\n  offNP.x = (!horzSpan) ? 0.0 : srcTexelSize.x;\r\n  offNP.y = ( horzSpan) ? 0.0 : srcTexelSize.y;\r\n  if(!horzSpan) posB.x += lengthSign * 0.5;\r\n  if( horzSpan) posB.y += lengthSign * 0.5;\r\n/*--------------------------------------------------------------------------*/\r\n  vec2 posN;\r\n  posN = posB - offNP * FXAA_QUALITY_P0;\r\n  vec2 posP;\r\n  posP = posB + offNP * FXAA_QUALITY_P0;\r\n  float subpixD = ((-2.0)*subpixC) + 3.0;\r\n  float lumaEndN = FxaaLuma(FxaaTexTop(srcTex, posN));\r\n  float subpixE = subpixC * subpixC;\r\n  float lumaEndP = FxaaLuma(FxaaTexTop(srcTex, posP));\r\n/*--------------------------------------------------------------------------*/\r\n  if(!pairN) lumaNN = lumaSS;\r\n  float gradientScaled = gradient * 1.0/4.0;\r\n  float lumaMM = lumaM - lumaNN * 0.5;\r\n  float subpixF = subpixD * subpixE;\r\n  bool lumaMLTZero = lumaMM < 0.0;\r\n/*---------------------looped edge-end search-------------------------------*/\r\n  lumaEndN -= lumaNN * 0.5;\r\n  lumaEndP -= lumaNN * 0.5;\r\n  bool doneN = abs(lumaEndN) >= gradientScaled;\r\n  bool doneP = abs(lumaEndP) >= gradientScaled;\r\n  if(!doneN) posN -= offNP * FXAA_QUALITY_P1;\r\n  bool doneNP = (!doneN) || (!doneP);\r\n  if(!doneP) posP += offNP * FXAA_QUALITY_P1;\r\n/*--------------------------------------------------------------------------*/\r\n  if(doneNP) {\r\n    if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(srcTex, posN.xy));\r\n    if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(srcTex, posP.xy));\r\n    if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;\r\n    if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;\r\n    doneN = abs(lumaEndN) >= gradientScaled;\r\n    doneP = abs(lumaEndP) >= gradientScaled;\r\n    if(!doneN) posN -= offNP * FXAA_QUALITY_P2;\r\n    doneNP = (!doneN) || (!doneP);\r\n    if(!doneP) posP += offNP * FXAA_QUALITY_P2;\r\n/*--------------------------------------------------------------------------*/\r\n    #if (FXAA_QUALITY_PS > 3)\r\n      if(doneNP) {\r\n        if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(srcTex, posN.xy));\r\n        if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(srcTex, posP.xy));\r\n        if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;\r\n        if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;\r\n        doneN = abs(lumaEndN) >= gradientScaled;\r\n        doneP = abs(lumaEndP) >= gradientScaled;\r\n        if(!doneN) posN -= offNP * FXAA_QUALITY_P3;\r\n        doneNP = (!doneN) || (!doneP);\r\n        if(!doneP) posP += offNP * FXAA_QUALITY_P3;\r\n/*--------------------------------------------------------------------------*/\r\n        #if (FXAA_QUALITY_PS > 4)\r\n          if(doneNP) {\r\n            if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(srcTex, posN.xy));\r\n            if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(srcTex, posP.xy));\r\n            if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;\r\n            if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;\r\n            doneN = abs(lumaEndN) >= gradientScaled;\r\n            doneP = abs(lumaEndP) >= gradientScaled;\r\n            if(!doneN) posN -= offNP * FXAA_QUALITY_P4;\r\n            doneNP = (!doneN) || (!doneP);\r\n            if(!doneP) posP += offNP * FXAA_QUALITY_P4;\r\n/*--------------------------------------------------------------------------*/\r\n            #if (FXAA_QUALITY_PS > 5)\r\n               if(doneNP) {\r\n                 if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(srcTex, posN.xy));\r\n                 if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(srcTex, posP.xy));\r\n                 if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;\r\n                 if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;\r\n                 doneN = abs(lumaEndN) >= gradientScaled;\r\n                 doneP = abs(lumaEndP) >= gradientScaled;\r\n                 if(!doneN) posN -= offNP * FXAA_QUALITY_P5;\r\n                 doneNP = (!doneN) || (!doneP);\r\n                 if(!doneP) posP += offNP * FXAA_QUALITY_P5;\r\n/*--------------------------------------------------------------------------*/\r\n                 #if (FXAA_QUALITY_PS > 6)\r\n                   if(doneNP) {\r\n                     if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(srcTex, posN.xy));\r\n                     if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(srcTex, posP.xy));\r\n                     if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;\r\n                     if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;\r\n                     doneN = abs(lumaEndN) >= gradientScaled;\r\n                     doneP = abs(lumaEndP) >= gradientScaled;\r\n                     if(!doneN) posN -= offNP * FXAA_QUALITY_P6;\r\n                     doneNP = (!doneN) || (!doneP);\r\n                     if(!doneP) posP += offNP * FXAA_QUALITY_P6;\r\n/*--------------------------------------------------------------------------*/\r\n                     #if (FXAA_QUALITY_PS > 7)\r\n                       if(doneNP) {\r\n                         if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(srcTex, posN.xy));\r\n                         if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(srcTex, posP.xy));\r\n                         if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;\r\n                         if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;\r\n                         doneN = abs(lumaEndN) >= gradientScaled;\r\n                         doneP = abs(lumaEndP) >= gradientScaled;\r\n                         if(!doneN) posN -= offNP * FXAA_QUALITY_P7;\r\n                         doneNP = (!doneN) || (!doneP);\r\n                         if(!doneP) posP += offNP * FXAA_QUALITY_P7;\r\n/*--------------------------------------------------------------------------*/\r\n                       }\r\n                     #endif\r\n                   }\r\n                 #endif\r\n               }\r\n             #endif\r\n           }\r\n         #endif\r\n      }\r\n    #endif\r\n  }\r\n/*----------------calculate subpix offset due to edge ends-------------------*/\r\n  float dstN = posM.x - posN.x;\r\n  float dstP = posP.x - posM.x;\r\n  if(!horzSpan) dstN = posM.y - posN.y;\r\n  if(!horzSpan) dstP = posP.y - posM.y;\r\n/*--------------------------------------------------------------------------*/\r\n  bool goodSpanN = (lumaEndN < 0.0) != lumaMLTZero;\r\n  float spanLength = (dstP + dstN);\r\n  bool goodSpanP = (lumaEndP < 0.0) != lumaMLTZero;\r\n  float spanLengthRcp = 1.0 / spanLength;\r\n/*--------------------------------------------------------------------------*/\r\n  bool directionN = dstN < dstP;\r\n  float dst = min(dstN, dstP);\r\n  bool goodSpan = directionN ? goodSpanN : goodSpanP;\r\n  float subpixG = subpixF * subpixF;\r\n  float pixelOffset = (dst * (-spanLengthRcp)) + 0.5;\r\n  float subpixH = subpixG * fxaaQualitySubpix;\r\n/*-----------------calc texture offest using subpix-------------------------*/\r\n  float pixelOffsetGood = goodSpan ? pixelOffset : 0.0;\r\n  float pixelOffsetSubpix = max(pixelOffsetGood, subpixH);\r\n\r\n  float offset = pixelOffsetSubpix * lengthSign;\r\n  #ifdef BG_TRANSPARENT\r\n    // get original texel\r\n    vec4 rgbaA = FxaaTexTopAlpha(srcTex, posM);\r\n    // calc step to blended texel\r\n    vec2 step = sign((!horzSpan) ? vec2 (offset, 0.0) : vec2 (0.0, offset));\r\n    // get neighboring texel\r\n    vec4 rgbaB = FxaaTexTopAlpha(srcTex, posM + step * srcTexelSize);\r\n    //  calc blend factor from offset\r\n    float f = (!horzSpan) ? offset / srcTexelSize.x : offset / srcTexelSize.y;\r\n    f = abs(f);\r\n    // calc alpha (special formula to emulate blending with bg)\r\n    gl_FragColor.a = 1.0 - mix(1.0 - rgbaA.a, 1.0 - rgbaB.a, f);\r\n    // calc color (special formula to emulate blending with bg)\r\n    gl_FragColor.rgb = mix(rgbaA.rgb * rgbaA.a, rgbaB.rgb * rgbaB.a, f) / gl_FragColor.a;\r\n  #else\r\n    if(!horzSpan) {\r\n       posM.x += offset;\r\n    } else {\r\n       posM.y += offset;\r\n    }\r\n    gl_FragColor = FxaaTexTopAlpha(srcTex, posM);\r\n  #endif\r\n  return;\r\n}\r\n";
var FXAAMaterial = class extends external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.RawShaderMaterial {
  constructor(params) {
    super(params);
    this.setValues.call(this, {
      uniforms: {
        srcTex: {
          type: "t",
          value: null
        },
        srcTexelSize: {
          type: "v2",
          value: new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Vector2(1 / 512, 1 / 512)
        },
        bgColor: {
          type: "c",
          value: new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Color(16777215)
        }
      },
      vertexShader: ScreenQuad_namespaceObject,
      fragmentShader: FXAA_namespaceObject,
      transparent: false,
      depthTest: false,
      depthWrite: false
    });
    this.setValues(params);
  }
  copy(source) {
    super.copy(source);
    this.depth = source.depth;
  }
  setValues(values) {
    if (typeof values === "undefined") {
      return;
    }
    super.setValues(values);
    const defines = {};
    if (this.bgTransparent) {
      defines.BG_TRANSPARENT = 1;
    }
    this.defines = defines;
  }
};
FXAAMaterial.prototype.bgTransparent = false;
var shaders_FXAAMaterial = FXAAMaterial;
var AO_namespaceObject = "precision highp float;\r\n#define EPSILON 0.0000001\r\n\r\n#define MAX_SAMPLES_COUNT 32\r\nuniform vec3 samplesKernel[MAX_SAMPLES_COUNT];\r\nuniform sampler2D noiseTexture;\r\nuniform vec2      noiseTexelSize;\r\nuniform sampler2D diffuseTexture;\r\nuniform sampler2D depthTexture;\r\nuniform sampler2D normalTexture;\r\nuniform vec2      srcTexelSize;\r\nuniform vec2      camNearFar;\r\nuniform mat4      projMatrix;\r\n\r\nuniform float aspectRatio;\r\nuniform float tanHalfFOV;\r\n\r\nuniform float kernelRadius;\r\nuniform float depthThreshold;\r\nuniform float factor;\r\n\r\nvarying vec2 vUv;\r\n\r\nfloat CalcViewZ(vec2 screenPos)\r\n{\r\n  float depth = texture2D(depthTexture, screenPos).x;\r\n  // [0, 1]->[-1, 1]\r\n  float clipedZ = 2.0 * depth - 1.0;\r\n  // see THREE.js camera.makeFrustum for projection details\r\n  return (-projMatrix[3][2] / (clipedZ + projMatrix[2][2]));\r\n}\r\n\r\nvec3 ViewPosFromDepth(vec2 screenPos)\r\n{\r\n  vec3 viewPos;\r\n  viewPos.z = CalcViewZ(screenPos);\r\n  //[0, 1]->[-1, 1]\r\n  vec2 projPos = 2.0 * screenPos - 1.0;\r\n  // reconstruct viewposition in right-handed sc with z to viewer\r\n  viewPos.xy = vec2(\r\n                    projPos.x * aspectRatio * tanHalfFOV * abs(viewPos.z),\r\n                    projPos.y * tanHalfFOV * abs(viewPos.z)\r\n                   );\r\n  return viewPos;\r\n}\r\n\r\nvoid main() {\r\n  vec3 viewPos = ViewPosFromDepth(vUv);\r\n  // remap coordinates to prevent noise exture rescale\r\n  vec2 vUvNoise = vUv / srcTexelSize * noiseTexelSize;\r\n  vec4 normalData = texture2D(normalTexture, vUv);\r\n  // return for background fragments (their normals are zero vectors)\r\n  if (length(normalData.rgb) < EPSILON) {\r\n    // 0.0 in alpha component means that it is background fragment\r\n    gl_FragColor = vec4(0.0, 0.0, 0.0, 0.0);\r\n    return;\r\n  }\r\n  //[0, 1] -> [-1, 1]\r\n  vec3 normal = (normalData.rgb * 2.0 - 1.0);\r\n  // normalData.a store 1.0 if normal was build for frontfaced surface\r\n  // and 0.0 in other case\r\n  if (normalData.a < EPSILON) {\r\n    normal *= -1.0;\r\n  }\r\n  // get random vector for sampling sphere rotation\r\n  vec3 randN = texture2D(noiseTexture, vUvNoise).rgb * 2.0 - 1.0;\r\n  randN = normalize(randN);\r\n  // build TBN (randomly rotated around normal)\r\n  vec3 tangent   = normalize(randN - normal * dot(randN, normal));\r\n  vec3 bitangent = cross(tangent, normal);\r\n  mat3 TBN = mat3(tangent, bitangent, normal);\r\n  // calc AO value\r\n  float AO = 0.0;\r\n  for (int i = 0 ; i < MAX_SAMPLES_COUNT ; i++) {\r\n    // rotate sampling kernel around normal\r\n    vec3 reflectedSample = TBN * samplesKernel[i];\r\n    // get sample\r\n    vec3 samplePos = viewPos + reflectedSample * kernelRadius;\r\n\r\n    // project sample to screen to get sample's screen pos\r\n    vec4 SampleScrPos = vec4(samplePos, 1.0);\r\n    // eye -> clip\r\n    SampleScrPos = projMatrix * SampleScrPos;\r\n    // normalize\r\n    SampleScrPos.xy /= SampleScrPos.w;\r\n    //[-1, 1] -> [0, 1]\r\n    SampleScrPos.xy = (SampleScrPos.xy + vec2(1.0)) * 0.5;\r\n\r\n    // get view z for sample projected to the objct surface\r\n    float sampleDepth = CalcViewZ(SampleScrPos.xy);\r\n    // calc occlusion made by object surface at the sample\r\n    AO += step(samplePos.z, sampleDepth);\r\n  }\r\n  // calc result AO-map color\r\n  AO = 1.0 - max(0.0, AO / float(MAX_SAMPLES_COUNT) * factor);\r\n  // write value to AO-map\r\n  gl_FragColor = vec4(AO, AO, AO, 1.0);\r\n}\r\n";
var AOMaterial_samplesKernel = [
  // hemisphere samples adopted to sphere
  new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Vector3(0.295184, 0.077723, 0.068429),
  new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Vector3(-0.271976, -0.365221, 0.838363),
  new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Vector3(0.547713, 0.467576, 0.488515),
  new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Vector3(0.662808, -0.031733, 0.584758),
  new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Vector3(-0.025717, 0.218955, 0.657094),
  new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Vector3(-0.310153, -0.365223, 0.370701),
  new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Vector3(-0.101407, -6313e-6, 0.747665),
  new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Vector3(-0.769138, 0.360399, 0.086847),
  new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Vector3(-0.271988, -0.27514, 0.905353),
  new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Vector3(0.09674, -0.566901, 0.700151),
  new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Vector3(0.562872, -0.735136, 0.094647),
  new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Vector3(0.379877, 0.359278, 0.190061),
  new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Vector3(0.519064, -0.023055, 0.405068),
  new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Vector3(-0.301036, 0.114696, 0.088885),
  new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Vector3(-0.282922, 0.598305, 0.487214),
  new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Vector3(-0.181859, 0.25167, 0.679702),
  new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Vector3(-0.191463, -0.635818, 0.512919),
  new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Vector3(-0.293655, 0.427423, 0.078921),
  new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Vector3(-0.267983, 0.680534, 0.13288),
  new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Vector3(0.139611, 0.319637, 0.477439),
  new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Vector3(-0.352086, 0.31104, 0.653913),
  new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Vector3(0.321032, 0.805279, 0.487345),
  new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Vector3(0.073516, 0.820734, 0.414183),
  new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Vector3(-0.155324, 0.589983, 0.41146),
  new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Vector3(0.335976, 0.170782, 0.527627),
  new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Vector3(0.46346, -0.355658, 0.167689),
  new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Vector3(0.222654, 0.59655, 0.769406),
  new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Vector3(0.922138, -0.04207, 0.147555),
  new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Vector3(-0.72705, -0.329192, 0.369826),
  new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Vector3(-0.090731, 0.53382, 0.463767),
  new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Vector3(-0.323457, -0.876559, 0.238524),
  new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Vector3(-0.663277, -0.372384, 0.342856)
];
var AOMaterial = class extends external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.RawShaderMaterial {
  constructor() {
    super();
    this.setValues.call(this, {
      uniforms: {
        noiseTexture: {
          type: "t",
          value: gfx_noiseTexture.noiseTexture
        },
        noiseTexelSize: {
          type: "v2",
          value: new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Vector2(1 / gfx_noiseTexture.noiseWidth, 1 / gfx_noiseTexture.noiseHeight)
        },
        diffuseTexture: {
          type: "t",
          value: null
        },
        normalTexture: {
          type: "t",
          value: null
        },
        depthTexture: {
          type: "t",
          value: null
        },
        srcTexelSize: {
          type: "v2",
          value: new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Vector2(1 / 512, 1 / 512)
        },
        camNearFar: {
          type: "v2",
          value: new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Vector2(1, 10)
        },
        projMatrix: {
          type: "mat4",
          value: new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Matrix4()
        },
        aspectRatio: {
          type: "f",
          value: 0
        },
        tanHalfFOV: {
          type: "f",
          value: 0
        },
        samplesKernel: {
          type: "v3v",
          value: AOMaterial_samplesKernel
        },
        kernelRadius: {
          type: "f",
          value: 1
        },
        depthThreshold: {
          type: "f",
          value: 1
        },
        factor: {
          type: "f",
          value: 1
        }
      },
      vertexShader: ScreenQuad_namespaceObject,
      fragmentShader: AO_namespaceObject,
      transparent: false,
      depthTest: false,
      depthWrite: false
    });
  }
};
var shaders_AOMaterial = AOMaterial;
var AOHorBlur_namespaceObject = "precision highp float;\r\n#define EPSILON 0.0000001\r\n\r\n#define MAX_SAMPLES_COUNT 5\r\nuniform float samplesOffsets[MAX_SAMPLES_COUNT];\r\nuniform sampler2D aoMap;\r\nuniform sampler2D depthTexture;\r\nuniform vec2      srcTexelSize;\r\n\r\nvarying vec2 vUv;\r\n\r\nvoid main() {\r\n  float x = vUv.x;\r\n  float y = vUv.y;\r\n  vec4 res = vec4(0.0);\r\n  res.a = texture2D(aoMap, vec2(x, y )).a;\r\n  // return for background fragments (0.0 in alpha component means that it is background fragment)\r\n  if (res.a < EPSILON) {\r\n    gl_FragColor = res;\r\n    return;\r\n  }\r\n\r\n  float pixelDepth = texture2D(depthTexture, vec2(x, y)).x;\r\n  float weightSum = 0.0;\r\n  for (int i = 0; i < MAX_SAMPLES_COUNT; ++i) {\r\n    if (texture2D(aoMap, vec2(x + samplesOffsets[i] * srcTexelSize.x, y )).a < EPSILON) {\r\n      continue;\r\n    }\r\n    vec2 samplePos = vec2(x + samplesOffsets[i] * srcTexelSize.x, y);\r\n    float depth = texture2D(depthTexture, samplePos).x;\r\n    float weight = (1.0 / (0.0001 + abs(depth - pixelDepth)));\r\n    res.rgb += texture2D(aoMap, vec2(x + samplesOffsets[i] * srcTexelSize.x, y )).rgb * weight;\r\n    weightSum += weight;\r\n  }\r\n  res.rgb = res.rgb / weightSum;\r\n  gl_FragColor = res;\r\n}\r\n";
var _kernelOffsets = [-2, -1, 0, 1, 2];
var AOHorBlurMaterial = class extends external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.RawShaderMaterial {
  constructor() {
    super();
    this.setValues.call(this, {
      uniforms: {
        depthTexture: {
          type: "t",
          value: null
        },
        srcTexelSize: {
          type: "v2",
          value: new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Vector2(1 / 512, 1 / 512)
        },
        aoMap: {
          type: "t",
          value: null
        },
        samplesOffsets: {
          type: "fv1",
          value: _kernelOffsets
        }
      },
      vertexShader: ScreenQuad_namespaceObject,
      fragmentShader: AOHorBlur_namespaceObject,
      transparent: false,
      depthTest: false,
      depthWrite: false
    });
  }
};
var shaders_AOHorBlurMaterial = AOHorBlurMaterial;
var AOVertBlurWithBlend_namespaceObject = "precision highp float;\r\n#define EPSILON 0.0000001\r\n\r\n#define MAX_SAMPLES_COUNT 5\r\nuniform float samplesOffsets[MAX_SAMPLES_COUNT];\r\nuniform sampler2D diffuseTexture;\r\nuniform sampler2D aoMap;\r\nuniform sampler2D depthTexture;\r\nuniform vec2      srcTexelSize;\r\n\r\nuniform mat4  projMatrix;\r\nuniform float aspectRatio;\r\nuniform float tanHalfFOV;\r\n\r\n#ifdef USE_FOG\r\n  uniform vec2 fogNearFar;\r\n  uniform vec4 fogColor;\r\n#endif\r\nvarying vec2 vUv;\r\n\r\nfloat CalcViewZ(vec2 screenPos)\r\n{\r\n  float depth = texture2D(depthTexture, screenPos).x;\r\n  // [0, 1]->[-1, 1]\r\n  float clipedZ = 2.0 * depth - 1.0;\r\n  // see THREE.js camera.makeFrustum for projection details\r\n  return (-projMatrix[3][2] / (clipedZ + projMatrix[2][2]));\r\n}\r\n\r\nvec3 ViewPosFromDepth(vec2 screenPos)\r\n{\r\n  vec3 viewPos;\r\n  viewPos.z = CalcViewZ(screenPos);\r\n  //[0, 1]->[-1, 1]\r\n  vec2 projPos = 2.0 * screenPos - 1.0;\r\n  // reconstruct viewposition in right-handed sc with z to viewer\r\n  viewPos.xy = vec2(\r\n  projPos.x * aspectRatio * tanHalfFOV * abs(viewPos.z),\r\n  projPos.y * tanHalfFOV * abs(viewPos.z)\r\n  );\r\n  return viewPos;\r\n}\r\n\r\nvoid main() {\r\n  vec3 viewPos = ViewPosFromDepth(vUv);\r\n  float x = vUv.x;\r\n  float y = vUv.y;\r\n  vec4 color = texture2D(diffuseTexture, vec2(x, y));\r\n  vec4 res = vec4(0.0);\r\n  res.a = texture2D(aoMap, vec2(x, y )).a;\r\n  // return for background fragments (0.0 in alpha component means that it is background fragment)\r\n  if (res.a < EPSILON) {\r\n    gl_FragColor = color;\r\n    return;\r\n  }\r\n\r\n  float pixelDepth = texture2D(depthTexture, vec2(x, y)).x;\r\n  float weightSum = 0.0;\r\n  for (int i = 0; i < MAX_SAMPLES_COUNT; ++i) {\r\n    if (texture2D(aoMap, vec2(x, y + samplesOffsets[i] * srcTexelSize.y)).a < EPSILON) {\r\n      continue;\r\n    }\r\n    vec2 samplePos = vec2(x, y + samplesOffsets[i] * srcTexelSize.y);\r\n    float depth = texture2D(depthTexture, samplePos).x;\r\n    float weight = (1.0 / (0.0001 + abs(depth - pixelDepth)));\r\n    res.rgb += texture2D(aoMap, vec2(x, y + samplesOffsets[i] * srcTexelSize.y)).rgb * weight;\r\n    weightSum += weight;\r\n  }\r\n  res.rgb /= weightSum;\r\n\r\n  #if defined(USE_FOG) && !defined(FOG_TRANSPARENT)\r\n    // Add fog to the result value\r\n    // Proper way to get an image with fog and ao requires formula:\r\n    //          gl_FragColor = fragColor*AO*(1-fogFactor) + fogColor*fogFactor\r\n    // But we have already fogged molecule to add AO too. Let's split the straight formula into our real steps!\r\n    // We have:  AO, fogFactor, fogColor,\r\n    //          color = fragColor*(1-fogFactor) + fogColor*fogFactor (it comes from diffuseTexture,\r\n    //                                                                where molecule has been already drawn with fog)\r\n    // Transform:\r\n    //          fragColor*AO*(1-fogFactor) + fogColor*fogFactor =\r\n    //        = [fragColor*(1-fogFactor) = color - fogColor*fogFactor] =\r\n    //        = (color - fogColor*fogFactor)*AO + fogColor*fogFactor =\r\n    //        = color*AO + fogColor*fogFactor*(1 - AO)\r\n    // Result:  gl_FragColor = color*AO + fogColor*fogFactor*(1 - AO)\r\n    float fogFactor = smoothstep(fogNearFar.x, fogNearFar.y, - viewPos.z) * fogColor.a;\r\n    gl_FragColor.rgb = color.rgb * res.rgb + fogColor.rgb * fogFactor *(vec3(1.0, 1.0, 1.0) - res.rgb);\r\n  #else\r\n    gl_FragColor.rgb = color.rgb * res.rgb;\r\n  #endif\r\n  gl_FragColor.a = color.a;\r\n}\r\n";
var AOVertBlurWithBlendMaterial_kernelOffsets = [-2, -1, 0, 1, 2];
var AOVertBlurWithBlendMaterial = class extends external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.RawShaderMaterial {
  constructor(params) {
    super(params);
    this.setValues.call(this, {
      uniforms: {
        diffuseTexture: {
          type: "t",
          value: null
        },
        depthTexture: {
          type: "t",
          value: null
        },
        srcTexelSize: {
          type: "v2",
          value: new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Vector2(1 / 512, 1 / 512)
        },
        aoMap: {
          type: "t",
          value: null
        },
        samplesOffsets: {
          type: "fv1",
          value: AOVertBlurWithBlendMaterial_kernelOffsets
        },
        projMatrix: {
          type: "mat4",
          value: new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Matrix4()
        },
        aspectRatio: {
          type: "f",
          value: 0
        },
        tanHalfFOV: {
          type: "f",
          value: 0
        },
        fogNearFar: {
          type: "v2",
          value: new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Vector2(100, 100)
        },
        fogColor: {
          type: "v4",
          value: new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Vector4(0, 0.5, 0, 1)
        }
      },
      vertexShader: ScreenQuad_namespaceObject,
      fragmentShader: AOVertBlurWithBlend_namespaceObject,
      transparent: false,
      depthTest: false,
      depthWrite: false
    });
    this.setValues(params);
  }
  setValues(values) {
    if (typeof values === "undefined") {
      return;
    }
    super.setValues(values);
    const defines = {};
    if (this.useFog) {
      defines.USE_FOG = 1;
    }
    if (this.fogTransparent) {
      defines.FOG_TRANSPARENT = 1;
    }
    this.defines = defines;
  }
};
AOVertBlurWithBlendMaterial.prototype.useFog = true;
AOVertBlurWithBlendMaterial.prototype.fogTransparent = false;
var shaders_AOVertBlurWithBlendMaterial = AOVertBlurWithBlendMaterial;
var Anaglyph_namespaceObject = "precision highp float;\r\n\r\nuniform sampler2D srcL;\r\nuniform sampler2D srcR;\r\nvarying vec2 vUv;\r\n\r\nvoid main() {\r\n  vec4 l = texture2D(srcL, vUv);\r\n  vec4 r = texture2D(srcR, vUv);\r\n  gl_FragColor = vec4(l.r, r.g, r.b, 1.0);\r\n}\r\n";
var AnaglyphMaterial = class extends external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.RawShaderMaterial {
  constructor() {
    super();
    const settings2 = {
      uniforms: {
        srcL: {
          type: "t",
          value: null
        },
        srcR: {
          type: "t",
          value: null
        }
      },
      vertexShader: ScreenQuad_namespaceObject,
      fragmentShader: Anaglyph_namespaceObject,
      transparent: false,
      depthTest: false,
      depthWrite: false
    };
    this.setValues(settings2);
  }
};
var shaders_AnaglyphMaterial = AnaglyphMaterial;
var View = class {
  constructor() {
    this.position = new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Vector3(0, 0, 0);
    this.scale = 1;
    this.orientation = new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Quaternion(0, 0, 0, 1);
  }
  set(position, scale, orientation) {
    this.position = position;
    this.scale = scale;
    this.orientation = orientation;
  }
};
var _transitionTime = 1.5;
var ViewInterpolator = class {
  setup(startView, endView) {
    this._startTime = void 0;
    this._endTime = void 0;
    this._isPaused = false;
    this._srcView = startView;
    this._dstView = endView;
    this._isMoving = false;
  }
  isMoving() {
    return this._isMoving;
  }
  wasStarted() {
    return typeof this._startTime !== "undefined" && typeof this._endTime !== "undefined";
  }
  start() {
    this._startTime = Date.now();
    const transTime = settings.now.interpolateViews ? _transitionTime * 1e3 : 0;
    this._endTime = this._startTime + transTime;
    this._isMoving = true;
  }
  getCurrentView() {
    if (typeof this._srcView === "undefined" || typeof this._dstView === "undefined" || !this._isMoving || !this.wasStarted()) {
      return {
        success: false
      };
    }
    let view = this.createView();
    const time = Date.now();
    if (time > this._endTime) {
      view = this._dstView;
      this.reset();
      return {
        success: true,
        view
      };
    }
    const factor = (time - this._startTime) / (this._endTime - this._startTime);
    view.position.copy(this._srcView.position);
    view.position.lerp(this._dstView.position, factor);
    view.scale = (1 - factor) * this._srcView.scale + factor * this._dstView.scale;
    view.orientation.copy(this._srcView.orientation);
    view.orientation.slerp(this._dstView.orientation, factor);
    return {
      success: true,
      view
    };
  }
  reset() {
    this._startTime = this._endTime = 0;
    this._isMoving = false;
  }
  pause() {
    if (!this._isPaused) {
      this.setup(this.getCurrentView().view, this._dstView);
      this._isPaused = true;
    }
  }
  resume() {
    this._isPaused = false;
  }
  createView() {
    return new View();
  }
};
var MAX_COOKIE_LEN = 4e3;
var COUNT_SUFFIX = "Cnt";
function _chunkString(string, chunkLen) {
  const l2 = string.length;
  const chunks = [];
  for (let c2 = 0, lc = 0; lc < l2; c2++, lc += chunkLen) {
    chunks[c2] = string.slice(lc, lc + chunkLen);
  }
  return chunks;
}
function Cookies(context, opts) {
  this.context = context;
  this._opts = external_module_lodash_commonjs_lodash_commonjs2_lodash_amd_lodash_root_namespaceObject["default"].merge({
    path: "/"
  }, opts);
}
utils_makeContextDependent(Cookies.prototype);
Cookies.prototype.removeCookie = function(key) {
  const cntKey = this._toCount(key);
  let cntVal = this._getSimpleCookie(cntKey);
  if (!cntVal) {
    this._removeSimpleCookie(key);
    return;
  }
  this._removeSimpleCookie(cntKey);
  cntVal = parseInt(cntVal, 10);
  for (let i2 = 0; i2 < cntVal; ++i2) {
    this._removeSimpleCookie(key + i2);
  }
};
Cookies.prototype.setCookie = function(key, value) {
  this.removeCookie(key);
  value = encodeURIComponent(value);
  const values = _chunkString(value, MAX_COOKIE_LEN - key.length - 1);
  const cntVal = values.length;
  if (cntVal === 1) {
    this._setSimpleCookie(key, value);
    return;
  }
  const cntKey = this._toCount(key);
  this._setSimpleCookie(cntKey, cntVal.toString());
  for (let i2 = 0; i2 < cntVal; ++i2) {
    this._setSimpleCookie(key + i2, values[i2]);
  }
};
Cookies.prototype.getCookie = function(key) {
  const cntKey = this._toCount(key);
  let cntVal = this._getSimpleCookie(cntKey);
  if (!cntVal) {
    return this._getSimpleCookie(key);
  }
  cntVal = parseInt(cntVal, 10);
  const value = [];
  for (let i2 = 0; i2 < cntVal; ++i2) {
    value[i2] = this._getSimpleCookie(key + i2);
  }
  return value.join("");
};
Cookies.prototype._toCount = function(key) {
  return key + COUNT_SUFFIX;
};
Cookies.prototype._removeSimpleCookie = function(key) {
  document.cookie = `${key}=; expires=Thu, 01 Jan 1970 00:00:01 GMT;`;
};
Cookies.prototype._getExpirationDate = function() {
  const today = /* @__PURE__ */ new Date();
  const EXP_PERIOD_YEARS = 10;
  today.setFullYear(today.getFullYear() + EXP_PERIOD_YEARS);
  return today;
};
Cookies.prototype._setSimpleCookie = function(key, value) {
  document.cookie = `${key}=${value};expires=${this._getExpirationDate().toUTCString()};path=${this._opts.path}`;
};
Cookies.prototype._getSimpleCookie = function(key) {
  const matches = document.cookie.match(new RegExp(`(?:^|; )${key}=([^;]*)`));
  return matches ? decodeURIComponent(matches[1]) : "";
};
Cookies.prototype._exists = function(key) {
  return document.cookie.match(new RegExp(`(?:^|; )${key}=([^;]*)`));
};
var utils_Cookies = Cookies;
function createWebVRButton(webVRPoC) {
  function showEnterVR(button) {
    button.style.display = "";
    button.style.cursor = "pointer";
    button.style.left = "calc(50% - 50px)";
    button.style.width = "100px";
    button.textContent = "ENTER VR";
    let currentSession = null;
    function onSessionEnded() {
      currentSession.removeEventListener("end", onSessionEnded);
      button.textContent = "ENTER VR";
      currentSession = null;
    }
    function onSessionStarted(session) {
      session.addEventListener("end", onSessionEnded);
      webVRPoC._gfx.renderer.xr.setReferenceSpaceType("local");
      webVRPoC._gfx.renderer.xr.setSession(session);
      button.textContent = "EXIT VR";
      currentSession = session;
    }
    button.onmouseenter = function() {
      button.style.opacity = "1.0";
    };
    button.onmouseleave = function() {
      button.style.opacity = "0.5";
    };
    button.onclick = function() {
      if (currentSession === null) {
        const sessionInit = {
          optionalFeatures: ["local-floor", "bounded-floor"]
        };
        navigator.xr.requestSession("immersive-vr", sessionInit).then(onSessionStarted);
        webVRPoC.moveSceneBehindHeadset();
      } else {
        currentSession.end();
      }
    };
  }
  function showWebXRNotFound(button) {
    button.style.display = "";
    button.style.cursor = "auto";
    button.style.left = "calc(50% - 75px)";
    button.style.width = "150px";
    button.textContent = "VR NOT FOUND";
    button.onmouseenter = null;
    button.onmouseleave = null;
    button.onclick = null;
  }
  function stylizeElement(element) {
    element.style.position = "absolute";
    element.style.bottom = "20px";
    element.style.padding = "12px 6px";
    element.style.border = "1px solid #fff";
    element.style.borderRadius = "4px";
    element.style.background = "transparent";
    element.style.color = "#fff";
    element.style.font = "normal 13px sans-serif";
    element.style.textAlign = "center";
    element.style.opacity = "0.5";
    element.style.outline = "none";
    element.style.zIndex = "999";
  }
  if ("xr" in navigator) {
    const button = document.createElement("button");
    button.style.display = "none";
    stylizeElement(button);
    navigator.xr.isSessionSupported("immersive-vr").then((supported) => supported ? showEnterVR(button) : showWebXRNotFound(button));
    return button;
  }
  const message = document.createElement("a");
  message.href = "https://webvr.info";
  message.innerHTML = "WEBXR NOT SUPPORTED";
  message.style.left = "calc(50% - 90px)";
  message.style.width = "180px";
  message.style.textDecoration = "none";
  stylizeElement(message);
  return message;
}
var WebVRPoC = class {
  constructor(onToggle) {
    this._mainCamera = new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.PerspectiveCamera();
    this._button = null;
    this._onToggle = onToggle;
    this._molContainer = new gfxutils.RCGroup();
    this._user = new gfxutils.RCGroup();
    this._scalingPivot = new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Object3D();
    this._user.add(this._scalingPivot);
    this._controller1 = null;
    this._controller2 = null;
    this._pressedGripsCounter = 0;
    this._distance = 0;
    this._gfx = null;
  }
  startScalingByControllers() {
    this._distance = this._controller1.position.distanceTo(this._controller2.position);
    gfxutils.getMiddlePoint(this._controller1.position, this._controller2.position, this._scalingPivot.position);
    this._scalingPivot.scale.set(1, 1, 1);
    this._scalingPivot.updateMatrix();
    this._scalingPivot.updateMatrixWorld();
    this._scalingPivot.addSavingWorldTransform(this._molContainer);
  }
  stopScalingByControllers() {
    this._gfx.scene.addSavingWorldTransform(this._molContainer);
  }
  handleGripsDown(event) {
    this._pressedGripsCounter++;
    if (this._pressedGripsCounter === 2) {
      this.startScalingByControllers();
    } else if (this._pressedGripsCounter === 1) {
      event.target.addSavingWorldTransform(this._molContainer);
    }
  }
  handleGripsUp(event) {
    this._pressedGripsCounter--;
    if (this._pressedGripsCounter === 1) {
      this.stopScalingByControllers();
      const anotherController = event.target === this._controller1 ? this._controller2 : this._controller1;
      anotherController.addSavingWorldTransform(this._molContainer);
    } else if (this._pressedGripsCounter === 0) {
      this._gfx.scene.addSavingWorldTransform(this._molContainer);
    }
  }
  enable(gfx) {
    if (!gfx) {
      logger.warn("WebVR couldn't be enabled, because gfx is not defined");
      return;
    }
    this._gfx = gfx;
    const {
      renderer,
      camera
    } = gfx;
    if (!renderer) {
      throw new Error("No renderer is available to toggle WebVR");
    }
    if (!camera) {
      throw new Error("No camera is available to toggle WebVR");
    }
    renderer.xr.enabled = true;
    if (!this._button) {
      this._button = createWebVRButton(this);
      document.body.appendChild(this._button);
    } else {
      this._button.style.display = "block";
    }
    this._mainFog = settings.now.fog;
    settings.set("fog", false);
    this._plugVRNodesIntoScene(gfx, renderer);
    this._setControllersListeners();
    if (this._onToggle) {
      this._onToggle(true);
    }
  }
  _plugVRNodesIntoScene(gfx, renderer) {
    this._mainCamera.copy(gfx.camera);
    gfx.scene.add(this._user);
    gfx.scene.add(this._molContainer);
    this._molContainer.add(gfx.root);
    this._controller1 = renderer.xr.getController(0);
    this._controller2 = renderer.xr.getController(1);
    const mesh = this._createControllerMesh();
    this._controller1.add(mesh);
    this._controller2.add(mesh.clone());
    this._user.add(this._controller1);
    this._user.add(this._controller2);
  }
  _setControllersListeners() {
    this._controller1.addEventListener("selectstart", (event) => {
      this.handleGripsDown(event);
    });
    this._controller1.addEventListener("selectend", (event) => {
      this.handleGripsUp(event);
    });
    this._controller2.addEventListener("selectstart", (event) => {
      this.handleGripsDown(event);
    });
    this._controller2.addEventListener("selectend", (event) => {
      this.handleGripsUp(event);
    });
    this._controller1.addEventListener("squeezestart", (event) => {
      this.handleGripsDown(event);
    });
    this._controller1.addEventListener("squeezeend", (event) => {
      this.handleGripsUp(event);
    });
    this._controller2.addEventListener("squeezestart", (event) => {
      this.handleGripsDown(event);
    });
    this._controller2.addEventListener("squeezeend", (event) => {
      this.handleGripsUp(event);
    });
  }
  disable() {
    if (!this._gfx) {
      return;
    }
    const {
      renderer,
      camera
    } = this._gfx;
    if (!renderer) {
      throw new Error("No renderer is available to toggle WebVR");
    }
    renderer.setAnimationLoop(null);
    const session = renderer.xr.getSession();
    if (session) {
      session.end();
    }
    renderer.xr.enabled = false;
    if (this._button) {
      this._button.style.display = "none";
    }
    settings.set("fog", this._mainFog);
    this._unplugVRNodesFromScene(camera);
    if (this._onToggle) {
      this._onToggle(false);
    }
  }
  _unplugVRNodesFromScene(camera) {
    if (this._mainCamera && camera) {
      camera.copy(this._mainCamera);
    }
    const root = this._molContainer.children[0];
    if (root) {
      this._gfx.scene.add(root);
    }
    this._molContainer.parent.remove(this._molContainer);
    if (this._user) {
      this._gfx.scene.remove(this._user);
    }
    this._molContainer = null;
    this._user = null;
    this._scalingPivot = null;
    this._user = null;
    this._controller1 = null;
    this._controller2 = null;
  }
  _createControllerMesh() {
    const geometry = new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.CylinderGeometry(0.04, 0.04, 0.3);
    const material = new shaders_UberMaterial({
      lights: false,
      overrideColor: true
    });
    material.setUberOptions({
      fixedColor: new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Color(4474111)
    });
    material.updateUniforms();
    const cylinder = new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Mesh(geometry, material);
    cylinder.rotateX(-Math.PI / 2);
    return cylinder;
  }
  updateMoleculeScale() {
    if (!this._controller1 || !this._controller2) {
      return;
    }
    const self2 = this;
    if (self2._pressedGripsCounter === 2) {
      gfxutils.getMiddlePoint(self2._controller1.position, self2._controller2.position, self2._scalingPivot.position);
      const dist = self2._controller1.position.distanceTo(self2._controller2.position);
      const scaler = dist / self2._distance;
      self2._scalingPivot.scale.multiplyScalar(scaler);
      self2._distance = dist;
    }
  }
  /**
   * Reposition molecule right before the camera.
   * @note The proper way is to initiate headset in the place of common Miew's camera.
   * But threejs limitations on setting new XRReferenceSpace enforce the molecule repositioning
   * Hope, something will change.
   */
  moveSceneBehindHeadset() {
    const gfx = this._gfx;
    const {
      camera
    } = gfx;
    const container = this._molContainer;
    container.matrix.identity();
    container.position.set(0, 0, -4);
    container.updateMatrix();
    container.matrixWorld.multiplyMatrices(camera.matrixWorld, container.matrix);
    gfx.scene.addSavingWorldTransform(container);
    if (this._onToggle) {
      this._onToggle(true);
    }
  }
  getCanvas() {
    const gfx = this._gfx;
    return gfx && gfx.renderer ? gfx.renderer.domElement : null;
  }
};
var ScreenQuadFromDistortionTex_namespaceObject = "precision highp float;\r\n\r\nvarying vec2 vUv;\r\nuniform sampler2D srcTex;\r\nuniform vec3 aberration;\r\n\r\nvoid main() {\r\n  vec2 uv = vUv * 2.0 - 1.0;\r\n  \r\n  gl_FragColor.r = texture2D(srcTex, 0.5 * (uv * aberration[0] + 1.0)).r;\r\n  gl_FragColor.g = texture2D(srcTex, 0.5 * (uv * aberration[1] + 1.0)).g;\r\n  gl_FragColor.b = texture2D(srcTex, 0.5 * (uv * aberration[2] + 1.0)).b;\r\n  gl_FragColor.a = 1.0;\r\n}";
var {
  selectors: Miew_selectors,
  Atom: Miew_Atom,
  Residue: Miew_Residue,
  Chain: Miew_Chain,
  Molecule: Miew_Molecule
} = chem;
var EDIT_MODE = {
  COMPLEX: 0,
  COMPONENT: 1,
  FRAGMENT: 2
};
var LOADER_NOT_FOUND = "Could not find suitable loader for this source";
var PARSER_NOT_FOUND = "Could not find suitable parser for this source";
external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.ColorManagement.enabled = false;
var {
  createElement: Miew_createElement
} = utils;
function updateFogRange(fog, center, radius) {
  fog.near = center - radius * settings.now.fogNearFactor;
  fog.far = center + radius * settings.now.fogFarFactor;
}
function removeExtension(fileName) {
  const dot = fileName.lastIndexOf(".");
  if (dot >= 0) {
    fileName = fileName.substr(0, dot);
  }
  return fileName;
}
function hasValidResidues(complex) {
  let hasValidRes = false;
  complex.forEachComponent((component) => {
    component.forEachResidue((residue) => {
      if (residue._isValid) {
        hasValidRes = true;
      }
    });
  });
  return hasValidRes;
}
function reportProgress(log, action, percent) {
  const TOTAL_PERCENT = 100;
  if (percent !== void 0) {
    log.debug(`${action}... ${Math.floor(percent * TOTAL_PERCENT)}%`);
  } else {
    log.debug(`${action}...`);
  }
}
function chooseFogColor() {
  return settings.now.fogColorEnable ? settings.now.fogColor : settings.now.bg.color;
}
function Miew(opts) {
  utils_EventDispatcher.call(this);
  this._opts = external_module_lodash_commonjs_lodash_commonjs2_lodash_amd_lodash_root_namespaceObject["default"].merge({
    settingsCookie: "settings",
    cookiePath: "/"
  }, opts);
  this._gfx = null;
  this._interpolator = new ViewInterpolator();
  this._container = opts && opts.container || document.getElementById("miew-container") || external_module_lodash_commonjs_lodash_commonjs2_lodash_amd_lodash_root_namespaceObject["default"].head(document.getElementsByClassName("miew-container")) || document.body;
  this._containerRoot = this._container;
  this._running = false;
  this._halting = false;
  this._building = false;
  this._needRender = true;
  this._hotKeysEnabled = true;
  this.settings = settings;
  const log = logger;
  log.console = false;
  log.level = false ? 0 : "info";
  this.logger = log;
  this._cookies = new utils_Cookies(this);
  this.restoreSettings();
  if (opts && opts.settings) {
    this.settings.set(opts.settings);
  }
  this._spinner = null;
  this._loading = [];
  this._animInterval = null;
  this._visuals = {};
  this._curVisualName = null;
  this._objects = [];
  this._sourceWindow = null;
  this.reset();
  if (this._repr) {
    log.debug(`Selected ${this._repr.mode.name} mode with ${this._repr.colorer.name} colorer.`);
  }
  const self2 = this;
  Miew.registeredPlugins.forEach((plugin) => {
    plugin.call(self2);
  });
  this._initOnSettingsChanged();
}
Miew.prototype = Object.create(utils_EventDispatcher.prototype);
Miew.prototype.constructor = Miew;
Miew.prototype.getMaxRepresentationCount = function() {
  return src_ComplexVisual.NUM_REPRESENTATION_BITS;
};
function _setContainerContents(container, element) {
  const parent = container;
  while (parent.firstChild) {
    parent.removeChild(parent.firstChild);
  }
  parent.appendChild(element);
}
Miew.prototype._updateShadowCamera = function() {
  const shadowMatrix = new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Matrix4();
  const direction2 = new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Vector3();
  const OBB = {
    center: new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Vector3(),
    halfSize: new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Vector3()
  };
  return function() {
    this._gfx.scene.updateMatrixWorld();
    for (let i2 = 0; i2 < this._gfx.scene.children.length; i2++) {
      if (this._gfx.scene.children[i2].type === "DirectionalLight") {
        const light = this._gfx.scene.children[i2];
        shadowMatrix.copy(light.shadow.camera.matrixWorldInverse);
        this.getOBB(shadowMatrix, OBB);
        direction2.subVectors(light.target.position, light.position);
        light.position.subVectors(OBB.center, direction2);
        light.target.position.copy(OBB.center);
        light.shadow.bias = 0.09;
        light.shadow.camera.bottom = -OBB.halfSize.y;
        light.shadow.camera.top = OBB.halfSize.y;
        light.shadow.camera.right = OBB.halfSize.x;
        light.shadow.camera.left = -OBB.halfSize.x;
        light.shadow.camera.near = direction2.length() - OBB.halfSize.z;
        light.shadow.camera.far = direction2.length() + OBB.halfSize.z;
        light.shadow.camera.updateProjectionMatrix();
      }
    }
  };
}();
Miew.prototype.init = function() {
  const container = this._container;
  const elem = utils.createElement("div", {
    class: "miew-canvas"
  });
  _setContainerContents(container, elem);
  this._container = elem;
  const frag = document.createDocumentFragment();
  frag.appendChild(this._msgMode = Miew_createElement("div", {
    class: "mode-message overlay"
  }, Miew_createElement("p", {}, "COMPONENT EDIT MODE")));
  frag.appendChild(this._msgAtomInfo = Miew_createElement("div", {
    class: "atom-info overlay"
  }, Miew_createElement("p", {}, "")));
  container.appendChild(frag);
  if (this._gfx !== null) {
    return true;
  }
  const self2 = this;
  this._showMessage("Viewer is being initialized...");
  try {
    this._initGfx();
    this._initListeners();
    this._spinner = new Spinner({
      lines: 13,
      length: 28,
      width: 14,
      radius: 42,
      color: "#fff",
      zIndex: 700
    });
    const target = getTopWindow();
    target.addEventListener("keydown", (event) => {
      self2._onKeyDown(event);
    });
    target.addEventListener("keyup", (event) => {
      self2._onKeyUp(event);
    });
    this._objectControls = new ui_ObjectControls(this._gfx.root, this._gfx.pivot, this._gfx.camera, this._gfx.renderer.domElement, () => self2._getAltObj());
    this._objectControls.addEventListener("change", (e2) => {
      if (settings.now.shadow.on) {
        self2._updateShadowCamera();
      }
      switch (e2.action) {
        case "rotate":
          self2.dispatchEvent({
            type: "rotate",
            quaternion: e2.quaternion
          });
          break;
        case "zoom":
          self2.dispatchEvent({
            type: "zoom",
            factor: e2.factor
          });
          break;
        default:
          self2.dispatchEvent({
            type: e2.action
          });
      }
      self2.dispatchEvent({
        type: "transform"
      });
      self2._needRender = true;
    });
    const gfx = this._gfx;
    this._picker = new ui_Picker(gfx.root, gfx.camera, gfx.renderer.domElement);
    this._picker.addEventListener("newpick", (event) => {
      self2._onPick(event);
    });
    this._picker.addEventListener("dblclick", (event) => {
      self2.center(event);
    });
  } catch (error) {
    if (error.name === "TypeError" && error.message === "Cannot read property 'getExtension' of null") {
      this._showMessage("Could not create WebGL context.");
    } else if (error.message.search(/webgl/i) > 1) {
      this._showMessage(error.message);
    } else {
      this._showMessage("Viewer initialization failed.");
      throw error;
    }
    return false;
  }
  const file = this._opts && this._opts.load;
  if (file) {
    const type = this._opts && this._opts.type;
    this.load(file, {
      fileType: type,
      keepRepsInfo: true
    });
  }
  return true;
};
Miew.prototype.term = function() {
  this._showMessage("Viewer has been terminated.");
  this._loading.forEach((job) => {
    job.cancel();
  });
  this._loading.length = 0;
  this.halt();
  this._gfx = null;
};
Miew.prototype._showMessage = function(msg) {
  const element = document.createElement("div");
  element.setAttribute("class", "miew-message");
  element.appendChild(document.createElement("p")).appendChild(document.createTextNode(msg));
  _setContainerContents(this._container, element);
};
Miew.prototype._showCanvas = function() {
  _setContainerContents(this._container, this._gfx.renderer.domElement);
};
Miew.prototype._requestAnimationFrame = function(callback) {
  const {
    xr
  } = this._gfx.renderer;
  if (xr && xr.enabled) {
    this._gfx.renderer.setAnimationLoop(callback);
    return;
  }
  requestAnimationFrame(callback);
};
function arezSpritesSupported(context) {
  return context.getExtension("EXT_frag_depth");
}
function isAOSupported(context) {
  return context.getExtension("WEBGL_depth_texture") && context.getExtension("WEBGL_draw_buffers");
}
Miew.prototype._initGfx = function() {
  const gfx = {
    width: this._container.clientWidth,
    height: this._container.clientHeight
  };
  const webGLOptions = {
    preserveDrawingBuffer: true,
    alpha: true,
    premultipliedAlpha: false
  };
  if (settings.now.antialias) {
    webGLOptions.antialias = true;
  }
  gfx.renderer2d = new gfx_CSS2DRenderer();
  gfx.renderer = new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.WebGL1Renderer(webGLOptions);
  gfx.renderer.shadowMap.enabled = settings.now.shadow.on;
  gfx.renderer.shadowMap.autoUpdate = false;
  gfx.renderer.shadowMap.type = external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.PCFShadowMap;
  capabilities.init(gfx.renderer);
  if (!arezSpritesSupported(gfx.renderer.getContext())) {
    settings.set("zSprites", false);
  }
  if (!isAOSupported(gfx.renderer.getContext())) {
    settings.set("ao", false);
  }
  gfx.renderer.autoClear = false;
  gfx.renderer.setPixelRatio(window.devicePixelRatio);
  gfx.renderer.setSize(gfx.width, gfx.height);
  gfx.renderer.setClearColor(settings.now.bg.color, Number(!settings.now.bg.transparent));
  gfx.renderer.clearColor();
  gfx.renderer2d.setSize(gfx.width, gfx.height);
  gfx.camera = new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.PerspectiveCamera(settings.now.camFov, gfx.width / gfx.height, settings.now.camNear, settings.now.camFar);
  gfx.camera.setMinimalFov(settings.now.camFov);
  gfx.camera.position.z = settings.now.camDistance;
  gfx.camera.updateProjectionMatrix();
  gfx.camera.layers.set(gfxutils.LAYERS.DEFAULT);
  gfx.camera.layers.enable(gfxutils.LAYERS.VOLUME);
  gfx.camera.layers.enable(gfxutils.LAYERS.VOLUME_BFPLANE);
  gfx.stereoCam = new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.StereoCamera();
  gfx.scene = new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Scene();
  const color = chooseFogColor();
  gfx.scene.fog = new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Fog(color, settings.now.camNear, settings.now.camFar);
  gfx.root = new gfxutils.RCGroup();
  gfx.scene.add(gfx.root);
  gfx.pivot = new gfxutils.RCGroup();
  gfx.root.add(gfx.pivot);
  gfx.selectionScene = new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Scene();
  gfx.selectionRoot = new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Group();
  gfx.selectionRoot.matrixAutoUpdate = false;
  gfx.selectionScene.add(gfx.selectionRoot);
  gfx.selectionPivot = new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Group();
  gfx.selectionPivot.matrixAutoUpdate = false;
  gfx.selectionRoot.add(gfx.selectionPivot);
  const light12 = new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.DirectionalLight(16777215, 0.45);
  light12.position.set(0, 0.414, 1);
  light12.layers.enable(gfxutils.LAYERS.TRANSPARENT);
  light12.castShadow = true;
  light12.shadow.bias = 0.09;
  light12.shadow.radius = settings.now.shadow.radius;
  light12.shadow.camera.layers.set(gfxutils.LAYERS.SHADOWMAP);
  const pixelRatio = gfx.renderer.getPixelRatio();
  const shadowMapSize = Math.max(gfx.width, gfx.height) * pixelRatio;
  light12.shadow.mapSize.width = shadowMapSize;
  light12.shadow.mapSize.height = shadowMapSize;
  light12.target.position.set(0, 0, 0);
  gfx.scene.add(light12);
  gfx.scene.add(light12.target);
  const light3 = new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.AmbientLight(6710886);
  light3.layers.enable(gfxutils.LAYERS.TRANSPARENT);
  gfx.scene.add(light3);
  gfx.axes = new gfx_Axes(gfx.root, gfx.camera);
  const deviceWidth = gfx.width * pixelRatio;
  const deviceHeight = gfx.height * pixelRatio;
  gfx.offscreenBuf = new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.WebGLRenderTarget(deviceWidth, deviceHeight, {
    minFilter: external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.LinearFilter,
    magFilter: external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.NearestFilter,
    format: external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.RGBAFormat,
    depthBuffer: true
  });
  if (gfx.renderer.getContext().getExtension("WEBGL_depth_texture")) {
    gfx.offscreenBuf.depthTexture = new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.DepthTexture();
    gfx.offscreenBuf.depthTexture.type = external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.UnsignedShortType;
  }
  gfx.offscreenBuf2 = new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.WebGLRenderTarget(deviceWidth, deviceHeight, {
    minFilter: external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.LinearFilter,
    magFilter: external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.LinearFilter,
    format: external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.RGBAFormat,
    depthBuffer: false
  });
  gfx.offscreenBuf3 = new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.WebGLRenderTarget(deviceWidth, deviceHeight, {
    minFilter: external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.LinearFilter,
    magFilter: external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.LinearFilter,
    format: external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.RGBAFormat,
    depthBuffer: false
  });
  gfx.offscreenBuf4 = new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.WebGLRenderTarget(deviceWidth, deviceHeight, {
    minFilter: external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.LinearFilter,
    magFilter: external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.LinearFilter,
    format: external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.RGBAFormat,
    depthBuffer: false
  });
  gfx.volBFTex = gfx.offscreenBuf3;
  gfx.volFFTex = gfx.offscreenBuf4;
  gfx.volWFFTex = gfx.offscreenBuf;
  if (gfx.renderer.getContext().getExtension("OES_texture_float")) {
    gfx.offscreenBuf5 = new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.WebGLRenderTarget(deviceWidth, deviceHeight, {
      minFilter: external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.LinearFilter,
      magFilter: external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.LinearFilter,
      format: external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.RGBAFormat,
      type: external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.FloatType,
      depthBuffer: false
    });
    gfx.offscreenBuf6 = new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.WebGLRenderTarget(deviceWidth, deviceHeight, {
      minFilter: external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.LinearFilter,
      magFilter: external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.LinearFilter,
      format: external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.RGBAFormat,
      type: external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.FloatType,
      depthBuffer: false
    });
    gfx.offscreenBuf7 = new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.WebGLRenderTarget(deviceWidth, deviceHeight, {
      minFilter: external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.LinearFilter,
      magFilter: external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.LinearFilter,
      format: external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.RGBAFormat,
      type: external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.FloatType,
      depthBuffer: true
    });
    gfx.volBFTex = gfx.offscreenBuf5;
    gfx.volFFTex = gfx.offscreenBuf6;
    gfx.volWFFTex = gfx.offscreenBuf7;
  } else {
    this.logger.warn("Device doesn't support OES_texture_float extension");
  }
  gfx.stereoBufL = new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.WebGLRenderTarget(deviceWidth, deviceHeight, {
    minFilter: external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.LinearFilter,
    magFilter: external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.LinearFilter,
    format: external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.RGBAFormat,
    depthBuffer: false
  });
  gfx.stereoBufR = new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.WebGLRenderTarget(deviceWidth, deviceHeight, {
    minFilter: external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.LinearFilter,
    magFilter: external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.LinearFilter,
    format: external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.RGBAFormat,
    depthBuffer: false
  });
  this._gfx = gfx;
  this._showCanvas();
  this._embedWebXR(settings.now.stereo === "WEBVR");
  this._container.appendChild(gfx.renderer2d.getElement());
  const stats = new gfx_Stats();
  stats.domElement.style.position = "absolute";
  stats.domElement.style.right = "0";
  stats.domElement.style.bottom = "0";
  this._container.appendChild(stats.domElement);
  this._fps = stats;
  this._fps.show(settings.now.fps);
};
Miew.prototype._initListeners = function() {
  const self2 = this;
  window.addEventListener("resize", () => {
    self2._onResize();
  });
};
Miew.prototype._makeUniqueVisualName = function(baseName) {
  if (!baseName) {
    return Math.random().toString();
  }
  let name = baseName;
  let suffix = 1;
  while (this._visuals.hasOwnProperty(name)) {
    name = `${baseName} (${suffix.toString()})`;
    suffix++;
  }
  return name;
};
Miew.prototype._addVisual = function(visual) {
  if (!visual) {
    return null;
  }
  const name = this._makeUniqueVisualName(visual.name);
  visual.name = name;
  this._visuals[name] = visual;
  this._gfx.pivot.add(visual);
  if (visual.getSelectionGeo) {
    this._gfx.selectionPivot.add(visual.getSelectionGeo());
  }
  return name;
};
Miew.prototype._removeVisual = function(visual) {
  let name = "";
  let obj = null;
  if (visual instanceof src_Visual) {
    ({
      name
    } = visual);
    obj = visual;
  } else if (typeof visual === "string") {
    name = visual;
    obj = this._visuals[name];
  }
  if (!obj || !this._visuals.hasOwnProperty(name) || this._visuals[name] !== obj) {
    return;
  }
  if (name === this._curVisualName) {
    this._curVisualName = void 0;
  }
  delete this._visuals[name];
  obj.release();
  this._needRender = true;
};
Miew.prototype._forEachVisual = function(callback) {
  for (const name in this._visuals) {
    if (this._visuals.hasOwnProperty(name)) {
      callback(this._visuals[name]);
    }
  }
};
Miew.prototype._releaseAllVisuals = function() {
  if (!this._gfx || !this._gfx.pivot) {
    return;
  }
  for (const name in this._visuals) {
    if (this._visuals.hasOwnProperty(name)) {
      this._visuals[name].release();
    }
  }
  this._visuals = {};
};
Miew.prototype._forEachComplexVisual = function(callback) {
  if (!this._gfx || !this._gfx.pivot) {
    return;
  }
  for (const name in this._visuals) {
    if (this._visuals.hasOwnProperty(name) && this._visuals[name] instanceof src_ComplexVisual) {
      callback(this._visuals[name]);
    }
  }
};
Miew.prototype._getComplexVisual = function(name) {
  name = name || this._curVisualName;
  let any = null;
  let named = null;
  this._forEachComplexVisual((visual) => {
    any = visual;
    if (visual.name === name) {
      named = visual;
    }
  });
  return named || any;
};
Miew.prototype._getVolumeVisual = function() {
  let any = null;
  this._forEachVisual((visual) => {
    if (visual instanceof src_VolumeVisual) {
      any = visual;
    }
  });
  return any;
};
Miew.prototype._getVisualForComplex = function(complex) {
  if (!complex) {
    return null;
  }
  let found = null;
  this._forEachComplexVisual((visual) => {
    if (visual.getComplex() === complex) {
      found = visual;
    }
  });
  return found;
};
Miew.prototype.getVisuals = function() {
  return Object.keys(this._visuals);
};
Miew.prototype.getComplexVisualsCount = function() {
  let count = 0;
  this._forEachComplexVisual(() => count++);
  return count;
};
Miew.prototype.getCurrentVisual = function() {
  return this._curVisualName;
};
Miew.prototype.setCurrentVisual = function(name) {
  if (!this._visuals[name]) {
    return;
  }
  this._curVisualName = name;
};
Miew.prototype.run = function() {
  if (!this._running) {
    this._running = true;
    if (this._halting) {
      this._halting = false;
      return;
    }
    this._objectControls.enable(true);
    this._interpolator.resume();
    this._requestAnimationFrame(() => this._onTick());
  }
};
Miew.prototype.halt = function() {
  if (this._running) {
    this._discardComponentEdit();
    this._discardFragmentEdit();
    this._objectControls.enable(false);
    this._interpolator.pause();
    this._halting = true;
  }
};
Miew.prototype.enableHotKeys = function(enabled) {
  this._hotKeysEnabled = enabled;
  this._objectControls.enableHotkeys(enabled);
};
Miew.prototype._onResize = function() {
  const gfx = this._gfx;
  if (!gfx) {
    return;
  }
  this._needRender = true;
  gfx.width = this._container.clientWidth;
  gfx.height = this._container.clientHeight;
  gfx.camera.aspect = gfx.width / gfx.height;
  gfx.camera.setMinimalFov(settings.now.camFov);
  gfx.camera.updateProjectionMatrix();
  gfx.renderer.setSize(gfx.width, gfx.height);
  gfx.renderer2d.setSize(gfx.width, gfx.height);
  this.dispatchEvent({
    type: "resize"
  });
};
Miew.prototype._resizeOffscreenBuffers = function(width, height, stereo) {
  const gfx = this._gfx;
  stereo = stereo || "NONE";
  const isAnaglyph = stereo === "NONE" || stereo === "ANAGLYPH";
  const multi = isAnaglyph ? 1 : 0.5;
  gfx.offscreenBuf.setSize(multi * width, height);
  gfx.offscreenBuf2.setSize(multi * width, height);
  gfx.offscreenBuf3.setSize(multi * width, height);
  gfx.offscreenBuf4.setSize(multi * width, height);
  if (gfx.offscreenBuf5) {
    gfx.offscreenBuf5.setSize(multi * width, height);
  }
  if (gfx.offscreenBuf6) {
    gfx.offscreenBuf6.setSize(multi * width, height);
  }
  if (gfx.offscreenBuf7) {
    gfx.offscreenBuf7.setSize(multi * width, height);
  }
  if (isAnaglyph) {
    gfx.stereoBufL.setSize(width, height);
    gfx.stereoBufR.setSize(width, height);
  }
};
Miew.prototype._onTick = function() {
  if (this._halting) {
    this._running = false;
    this._halting = false;
    return;
  }
  this._fps.update();
  this._requestAnimationFrame(() => this._onTick());
  this._onUpdate();
  if (this._needRender) {
    this._onRender();
    this._needRender = !settings.now.suspendRender || settings.now.stereo === "WEBVR";
  }
};
Miew.prototype._getBSphereRadius = function() {
  let radius = 0;
  this._forEachVisual((visual) => {
    radius = Math.max(radius, visual.getBoundaries().boundingSphere.radius);
  });
  return radius * this._objectControls.getScale();
};
Miew.prototype.getOBB = function() {
  const _bSphereForOneVisual = new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Sphere();
  const _bBoxForOneVisual = new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Box3();
  const _bBox = new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Box3();
  const _invMatrix = new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Matrix4();
  const _points2 = [new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Vector3(), new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Vector3(), new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Vector3(), new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Vector3()];
  return function(matrix, OBB) {
    _bBox.makeEmpty();
    this._forEachVisual((visual) => {
      _bSphereForOneVisual.copy(visual.getBoundaries().boundingSphere);
      _bSphereForOneVisual.applyMatrix4(visual.matrixWorld).applyMatrix4(matrix);
      _bSphereForOneVisual.getBoundingBox(_bBoxForOneVisual);
      _bBox.union(_bBoxForOneVisual);
    });
    _bBox.getCenter(OBB.center);
    _invMatrix.copy(matrix).invert();
    OBB.center.applyMatrix4(_invMatrix);
    const {
      min
    } = _bBox;
    const {
      max
    } = _bBox;
    _points2[0].set(min.x, min.y, min.z);
    _points2[1].set(max.x, min.y, min.z);
    _points2[2].set(min.x, max.y, min.z);
    _points2[3].set(min.x, min.y, max.z);
    for (let i2 = 0, l2 = _points2.length; i2 < l2; i2++) {
      _points2[i2].applyMatrix4(_invMatrix);
    }
    OBB.halfSize.set(Math.abs(_points2[0].x - _points2[1].x), Math.abs(_points2[0].y - _points2[2].y), Math.abs(_points2[0].z - _points2[3].z)).multiplyScalar(0.5);
  };
}();
Miew.prototype._updateFog = function() {
  const gfx = this._gfx;
  if (settings.now.fog) {
    if (typeof gfx.scene.fog === "undefined" || gfx.scene.fog === null) {
      const color = chooseFogColor();
      gfx.scene.fog = new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Fog(color);
      this._setUberMaterialValues({
        fog: settings.now.fog
      });
    }
    updateFogRange(gfx.scene.fog, gfx.camera.position.z, this._getBSphereRadius());
  } else if (gfx.scene.fog) {
    gfx.scene.fog = void 0;
    this._setUberMaterialValues({
      fog: settings.now.fog
    });
  }
};
Miew.prototype._onUpdate = function() {
  if (this.isScriptingCommandAvailable !== void 0 && this.isScriptingCommandAvailable() && !this._building) {
    this.callNextCmd();
  }
  this._objectControls.update();
  this._forEachComplexVisual((visual) => {
    visual.getComplex().update();
  });
  if (settings.now.autobuild && !this._loading.length && !this._building && this._needRebuild()) {
    this.rebuild();
  }
  if (!this._loading.length && !this._building && !this._needRebuild()) {
    this._updateView();
  }
  this._updateFog();
  if (this._gfx.renderer.xr.enabled) {
    this.webVR.updateMoleculeScale();
  }
};
Miew.prototype._onRender = function() {
  const gfx = this._gfx;
  gfx.scene.updateMatrixWorld();
  gfx.camera.updateMatrixWorld();
  this._clipPlaneUpdateValue(this._getBSphereRadius());
  this._fogFarUpdateValue();
  gfx.renderer.setRenderTarget(null);
  gfx.renderer.clear();
  this._renderFrame(settings.now.stereo);
};
Miew.prototype._renderFrame = function() {
  const _anaglyphMat = new shaders_AnaglyphMaterial();
  const _size = new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Vector2();
  return function(stereo) {
    const gfx = this._gfx;
    const {
      renderer
    } = gfx;
    renderer.getSize(_size);
    if (stereo !== "NONE") {
      gfx.camera.focus = gfx.camera.position.z;
      gfx.stereoCam.aspect = 1;
      if (stereo === "ANAGLYPH") {
        gfx.stereoCam.update(gfx.camera);
      } else {
        gfx.stereoCam.updateHalfSized(gfx.camera, settings.now.camFov);
      }
    }
    const pixelRatio = gfx.renderer.getPixelRatio();
    this._resizeOffscreenBuffers(_size.width * pixelRatio, _size.height * pixelRatio, stereo);
    this._renderShadowMap();
    switch (stereo) {
      case "WEBVR":
      case "NONE":
        this._renderScene(gfx.camera, false);
        break;
      case "SIMPLE":
      case "DISTORTED":
        renderer.setScissorTest(true);
        renderer.setScissor(0, 0, _size.width / 2, _size.height);
        renderer.setViewport(0, 0, _size.width / 2, _size.height);
        this._renderScene(this._gfx.stereoCam.cameraL, stereo === "DISTORTED");
        renderer.setScissor(_size.width / 2, 0, _size.width / 2, _size.height);
        renderer.setViewport(_size.width / 2, 0, _size.width / 2, _size.height);
        this._renderScene(this._gfx.stereoCam.cameraR, stereo === "DISTORTED");
        renderer.setScissorTest(false);
        break;
      case "ANAGLYPH":
        this._renderScene(this._gfx.stereoCam.cameraL, false, gfx.stereoBufL);
        this._renderScene(this._gfx.stereoCam.cameraR, false, gfx.stereoBufR);
        renderer.setRenderTarget(null);
        _anaglyphMat.uniforms.srcL.value = gfx.stereoBufL.texture;
        _anaglyphMat.uniforms.srcR.value = gfx.stereoBufR.texture;
        gfx.renderer.renderScreenQuad(_anaglyphMat);
        break;
      default:
    }
    gfx.renderer2d.render(gfx.scene, gfx.camera);
    if (settings.now.axes && gfx.axes && !gfx.renderer.xr.enabled) {
      gfx.axes.render(renderer);
    }
  };
}();
Miew.prototype._onBgColorChanged = function() {
  const gfx = this._gfx;
  const color = chooseFogColor();
  if (gfx) {
    if (gfx.scene.fog) {
      gfx.scene.fog.color.set(color);
    }
    gfx.renderer.setClearColor(settings.now.bg.color, Number(!settings.now.bg.transparent));
  }
  this._needRender = true;
};
Miew.prototype._onFogColorChanged = function() {
  const gfx = this._gfx;
  const color = chooseFogColor();
  if (gfx && gfx.scene.fog) {
    gfx.scene.fog.color.set(color);
  }
  this._needRender = true;
};
Miew.prototype._setUberMaterialValues = function(values) {
  this._gfx.root.traverse((obj) => {
    if ((obj instanceof external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Mesh || obj instanceof external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.LineSegments || obj instanceof external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Line) && obj.material instanceof shaders_UberMaterial) {
      obj.material.setValues(values);
      obj.material.needsUpdate = true;
    }
  });
};
Miew.prototype._enableMRT = function(on, renderBuffer, textureBuffer) {
  const gfx = this._gfx;
  const gl = gfx.renderer.getContext();
  const ext = gl.getExtension("WEBGL_draw_buffers");
  const {
    properties
  } = gfx.renderer;
  if (!on) {
    ext.drawBuffersWEBGL([gl.COLOR_ATTACHMENT0, null]);
    return;
  }
  gfx.renderer.setRenderTarget(textureBuffer);
  const tx8 = properties.get(textureBuffer.texture).__webglTexture;
  gl.bindTexture(gl.TEXTURE_2D, tx8);
  gfx.renderer.setRenderTarget(renderBuffer);
  const fb = properties.get(renderBuffer).__webglFramebuffer;
  const tx = properties.get(renderBuffer.texture).__webglTexture;
  gl.bindFramebuffer(gl.FRAMEBUFFER, fb);
  fb.width = renderBuffer.width;
  fb.height = renderBuffer.height;
  gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, tx, 0);
  gl.framebufferTexture2D(gl.FRAMEBUFFER, ext.COLOR_ATTACHMENT1_WEBGL, gl.TEXTURE_2D, tx8, 0);
  ext.drawBuffersWEBGL([gl.COLOR_ATTACHMENT0, ext.COLOR_ATTACHMENT1_WEBGL]);
};
Miew.prototype._renderScene = /* @__PURE__ */ function() {
  return function(camera, distortion, target) {
    distortion = distortion || false;
    target = target || null;
    const gfx = this._gfx;
    gfx.renderer.setClearColor(settings.now.bg.color, Number(!settings.now.bg.transparent));
    gfx.renderer.setRenderTarget(target);
    gfx.renderer.clear();
    if (gfx.renderer.xr.enabled) {
      gfx.renderer.render(gfx.scene, camera);
      return;
    }
    gfx.renderer.setClearColor(0, 0);
    gfx.renderer.setRenderTarget(gfx.offscreenBuf4);
    gfx.renderer.clearColor();
    gfx.renderer.setClearColor(settings.now.bg.color, Number(!settings.now.bg.transparent));
    gfx.renderer.setRenderTarget(gfx.offscreenBuf);
    gfx.renderer.clear();
    const bHaveComplexes = this._getComplexVisual() !== null;
    const volumeVisual = this._getVolumeVisual();
    const ssao = bHaveComplexes && settings.now.ao;
    if (ssao) {
      this._enableMRT(true, gfx.offscreenBuf, gfx.offscreenBuf4);
    }
    if (settings.now.transparency === "prepass") {
      this._renderWithPrepassTransparency(camera, gfx.offscreenBuf);
    } else if (settings.now.transparency === "standard") {
      gfx.renderer.setRenderTarget(gfx.offscreenBuf);
      gfx.renderer.render(gfx.scene, camera);
    }
    if (ssao) {
      this._enableMRT(false, null, null);
    }
    const outline = bHaveComplexes && settings.now.outline.on;
    const fxaa = bHaveComplexes && settings.now.fxaa;
    const volume = volumeVisual !== null && volumeVisual.getMesh().material != null;
    let dstBuffer = ssao || outline || volume || fxaa || distortion ? gfx.offscreenBuf2 : target;
    let srcBuffer = gfx.offscreenBuf;
    if (ssao) {
      this._performAO(srcBuffer, gfx.offscreenBuf4, gfx.offscreenBuf.depthTexture, dstBuffer, gfx.offscreenBuf3, gfx.offscreenBuf2);
      if (!fxaa && !distortion && !volume && !outline) {
        srcBuffer = dstBuffer;
        dstBuffer = target;
        gfx.renderer.setRenderTarget(dstBuffer);
        gfx.renderer.renderScreenQuadFromTex(srcBuffer.texture, 1);
      }
    } else {
      gfx.renderer.setRenderTarget(dstBuffer);
      gfx.renderer.renderScreenQuadFromTex(srcBuffer.texture, 1);
    }
    if (outline) {
      srcBuffer = dstBuffer;
      dstBuffer = volume || fxaa || distortion ? gfx.offscreenBuf3 : target;
      if (srcBuffer != null) {
        this._renderOutline(camera, gfx.offscreenBuf, srcBuffer, dstBuffer);
      }
    }
    this._renderSelection(camera, gfx.offscreenBuf, dstBuffer);
    if (volume) {
      gfx.renderer.setRenderTarget(gfx.offscreenBuf);
      gfx.renderer.renderScreenQuadFromTex(dstBuffer.texture, 1);
      dstBuffer = gfx.offscreenBuf;
      this._renderVolume(volumeVisual, camera, dstBuffer, gfx.volBFTex, gfx.volFFTex, gfx.volWFFTex);
      if (!fxaa && !distortion) {
        gfx.renderer.setRenderTarget(target);
        gfx.renderer.renderScreenQuadFromTex(dstBuffer.texture, 1);
      }
    }
    srcBuffer = dstBuffer;
    if (fxaa) {
      dstBuffer = distortion ? gfx.offscreenBuf4 : target;
      this._performFXAA(srcBuffer, dstBuffer);
      srcBuffer = dstBuffer;
    }
    if (distortion) {
      dstBuffer = target;
      this._performDistortion(srcBuffer, dstBuffer, true);
    }
  };
}();
Miew.prototype._performDistortion = function() {
  const _scene = new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Scene();
  const _camera2 = new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.OrthographicCamera(-1, 1, 1, -1, -500, 1e3);
  const _material = new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.RawShaderMaterial({
    uniforms: {
      srcTex: {
        type: "t",
        value: null
      },
      aberration: {
        type: "fv3",
        value: new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Vector3(1)
      }
    },
    vertexShader: ScreenQuad_namespaceObject,
    fragmentShader: ScreenQuadFromDistortionTex_namespaceObject,
    transparent: false,
    depthTest: false,
    depthWrite: false
  });
  const _geo = gfxutils.buildDistorionMesh(10, 10, settings.now.debug.stereoBarrel);
  _scene.add(new meshes.Mesh(_geo, _material));
  return function(srcBuffer, targetBuffer, mesh) {
    this._gfx.renderer.setRenderTarget(targetBuffer);
    this._gfx.renderer.clear();
    if (mesh) {
      _material.uniforms.srcTex.value = srcBuffer.texture;
      _material.uniforms.aberration.value.set(0.995, 1, 1.01);
      this._gfx.renderer.render(_scene, _camera2);
    } else {
      this._gfx.renderer.renderScreenQuadFromTexWithDistortion(srcBuffer, settings.now.debug.stereoBarrel);
    }
  };
}();
Miew.prototype._renderOutline = function() {
  const _outlineMaterial = new shaders_OutlineMaterial({
    depth: true
  });
  return function(camera, srcDepthBuffer, srcColorBuffer, targetBuffer) {
    const self2 = this;
    const gfx = self2._gfx;
    _outlineMaterial.uniforms.srcTex.value = srcColorBuffer.texture;
    _outlineMaterial.uniforms.srcDepthTex.value = srcDepthBuffer.depthTexture;
    _outlineMaterial.uniforms.srcTexSize.value.set(srcDepthBuffer.width, srcDepthBuffer.height);
    _outlineMaterial.uniforms.color.value = new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Color(settings.now.outline.color);
    _outlineMaterial.uniforms.threshold.value = settings.now.outline.threshold;
    _outlineMaterial.uniforms.thickness.value = new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Vector2(settings.now.outline.thickness, settings.now.outline.thickness);
    gfx.renderer.setRenderTarget(targetBuffer);
    gfx.renderer.renderScreenQuad(_outlineMaterial);
  };
}();
Miew.prototype._renderShadowMap = function() {
  const pars = {
    minFilter: external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.NearestFilter,
    magFilter: external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.NearestFilter,
    format: external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.RGBAFormat
  };
  return function() {
    if (!settings.now.shadow.on) {
      return;
    }
    const gfx = this._gfx;
    const currentRenderTarget = gfx.renderer.getRenderTarget();
    const activeCubeFace = gfx.renderer.getActiveCubeFace();
    const activeMipmapLevel = gfx.renderer.getActiveMipmapLevel();
    const _state = gfx.renderer.state;
    _state.setBlending(external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.NoBlending);
    _state.buffers.color.setClear(1, 1, 1, 1);
    _state.buffers.depth.setTest(true);
    _state.setScissorTest(false);
    for (let i2 = 0; i2 < gfx.scene.children.length; i2++) {
      if (gfx.scene.children[i2].type === "DirectionalLight") {
        const light = gfx.scene.children[i2];
        if (light.shadow.map == null) {
          light.shadow.map = new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.WebGLRenderTarget(light.shadow.mapSize.width, light.shadow.mapSize.height, pars);
          light.shadow.camera.updateProjectionMatrix();
        }
        light.shadow.updateMatrices(light);
        gfx.renderer.setRenderTarget(light.shadow.map);
        gfx.renderer.clear();
        gfx.renderer.render(gfx.scene, light.shadow.camera);
      }
    }
    gfx.renderer.setRenderTarget(currentRenderTarget, activeCubeFace, activeMipmapLevel);
  };
}();
Miew.prototype._hasSelectionToRender = function() {
  const selPivot = this._gfx.selectionPivot;
  for (let i2 = 0; i2 < selPivot.children.length; i2++) {
    const selPivotChild = selPivot.children[i2];
    if (selPivotChild.children.length > 0) {
      return true;
    }
  }
  return false;
};
Miew.prototype._renderSelection = function() {
  const _outlineMaterial = new shaders_OutlineMaterial();
  return function(camera, srcBuffer, targetBuffer) {
    const self2 = this;
    const gfx = self2._gfx;
    gfx.renderer.setClearColor("black", 0);
    gfx.renderer.setRenderTarget(srcBuffer);
    gfx.renderer.clear(true, false, false);
    if (self2._hasSelectionToRender()) {
      gfx.selectionRoot.matrix = gfx.root.matrix;
      gfx.selectionPivot.matrix = gfx.pivot.matrix;
      gfx.renderer.render(gfx.selectionScene, camera);
    } else {
      gfx.renderer.renderDummyQuad();
    }
    gfx.renderer.setRenderTarget(targetBuffer);
    gfx.renderer.renderScreenQuadFromTex(srcBuffer.texture, 0.6);
    _outlineMaterial.uniforms.srcTex.value = srcBuffer.texture;
    _outlineMaterial.uniforms.srcTexSize.value.set(srcBuffer.width, srcBuffer.height);
    gfx.renderer.renderScreenQuad(_outlineMaterial);
  };
}();
Miew.prototype._checkVolumeRenderingSupport = function(renderTarget) {
  if (!renderTarget) {
    return false;
  }
  const gfx = this._gfx;
  const oldRT = gfx.renderer.getRenderTarget();
  gfx.renderer.setRenderTarget(renderTarget);
  const context = gfx.renderer.getContext();
  const result = context.checkFramebufferStatus(context.FRAMEBUFFER);
  gfx.renderer.setRenderTarget(oldRT);
  if (result !== context.FRAMEBUFFER_COMPLETE) {
    this.logger.warn("Device doesn't support electron density rendering");
    return false;
  }
  return true;
};
Miew.prototype._renderVolume = function() {
  const volumeBFMat = new shaders_VolumeMaterial.BackFacePosMaterial();
  const volumeFFMat = new shaders_VolumeMaterial.FrontFacePosMaterial();
  const cubeOffsetMat = new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Matrix4().makeTranslation(0.5, 0.5, 0.5);
  const world2colorMat = new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Matrix4();
  let volumeRenderingSupported;
  return function(volumeVisual, camera, dstBuf, tmpBuf1, tmpBuf2, tmpBuf3) {
    const gfx = this._gfx;
    if (typeof volumeRenderingSupported === "undefined") {
      volumeRenderingSupported = this._checkVolumeRenderingSupport(tmpBuf1);
    }
    if (!volumeRenderingSupported) {
      return;
    }
    const mesh = volumeVisual.getMesh();
    mesh.rebuild(gfx.camera);
    gfx.renderer.setClearColor("black", 0);
    gfx.renderer.setRenderTarget(tmpBuf1);
    gfx.renderer.clear();
    gfx.renderer.setRenderTarget(tmpBuf2);
    gfx.renderer.clear();
    gfx.renderer.setRenderTarget(tmpBuf3);
    gfx.renderer.clear();
    gfx.renderer.setRenderTarget(tmpBuf1);
    camera.layers.set(gfxutils.LAYERS.VOLUME_BFPLANE);
    gfx.renderer.render(gfx.scene, camera);
    camera.layers.set(gfxutils.LAYERS.VOLUME);
    gfx.scene.overrideMaterial = volumeBFMat;
    gfx.renderer.render(gfx.scene, camera);
    gfx.renderer.setRenderTarget(tmpBuf2);
    camera.layers.set(gfxutils.LAYERS.VOLUME);
    gfx.scene.overrideMaterial = volumeFFMat;
    gfx.renderer.render(gfx.scene, camera);
    gfx.scene.overrideMaterial = null;
    camera.layers.set(gfxutils.LAYERS.DEFAULT);
    world2colorMat.copy(mesh.matrixWorld).invert();
    shaders_UberMaterial.prototype.uberOptions.world2colorMatrix.multiplyMatrices(cubeOffsetMat, world2colorMat);
    camera.layers.set(gfxutils.LAYERS.COLOR_FROM_POSITION);
    gfx.renderer.setRenderTarget(tmpBuf3);
    gfx.renderer.render(gfx.scene, camera);
    const vm = mesh.material;
    vm.uniforms._BFRight.value = tmpBuf1.texture;
    vm.uniforms._FFRight.value = tmpBuf2.texture;
    vm.uniforms._WFFRight.value = tmpBuf3.texture;
    camera.layers.set(gfxutils.LAYERS.VOLUME);
    gfx.renderer.setRenderTarget(dstBuf);
    gfx.renderer.render(gfx.scene, camera);
    camera.layers.set(gfxutils.LAYERS.DEFAULT);
  };
}();
Miew.prototype._renderWithPrepassTransparency = /* @__PURE__ */ function() {
  return function(camera, targetBuffer) {
    const gfx = this._gfx;
    gfx.renderer.setRenderTarget(targetBuffer);
    camera.layers.set(gfxutils.LAYERS.DEFAULT);
    gfx.renderer.render(gfx.scene, camera);
    camera.layers.set(gfxutils.LAYERS.PREPASS_TRANSPARENT);
    gfx.renderer.getContext().colorMask(false, false, false, false);
    gfx.renderer.render(gfx.scene, camera);
    gfx.renderer.getContext().colorMask(true, true, true, true);
    camera.layers.set(gfxutils.LAYERS.TRANSPARENT);
    gfx.renderer.render(gfx.scene, camera);
    camera.layers.set(gfxutils.LAYERS.DEFAULT);
  };
}();
Miew.prototype._performFXAA = function() {
  const _fxaaMaterial = new shaders_FXAAMaterial();
  return function(srcBuffer, targetBuffer) {
    if (typeof srcBuffer === "undefined" || typeof targetBuffer === "undefined") {
      return;
    }
    const gfx = this._gfx;
    gfx.renderer.setClearColor(settings.now.bg.color, Number(!settings.now.bg.transparent));
    gfx.renderer.setRenderTarget(targetBuffer);
    gfx.renderer.clear();
    _fxaaMaterial.uniforms.srcTex.value = srcBuffer.texture;
    _fxaaMaterial.uniforms.srcTexelSize.value.set(1 / srcBuffer.width, 1 / srcBuffer.height);
    _fxaaMaterial.uniforms.bgColor.value.set(settings.now.bg.color);
    if (_fxaaMaterial.bgTransparent !== settings.now.bg.transparent) {
      _fxaaMaterial.setValues({
        bgTransparent: settings.now.bg.transparent
      });
      _fxaaMaterial.needsUpdate = true;
    }
    gfx.renderer.renderScreenQuad(_fxaaMaterial);
  };
}();
Miew.prototype._performAO = function() {
  const _aoMaterial = new shaders_AOMaterial();
  const _horBlurMaterial = new shaders_AOHorBlurMaterial();
  const _vertBlurMaterial = new shaders_AOVertBlurWithBlendMaterial();
  const _scale2 = new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Vector3();
  return function(srcColorBuffer, normalBuffer, srcDepthTexture, targetBuffer, tempBuffer, tempBuffer1) {
    if (!srcColorBuffer || !normalBuffer || !srcDepthTexture || !targetBuffer || !tempBuffer || !tempBuffer1) {
      return;
    }
    const gfx = this._gfx;
    const tanHalfFOV = Math.tan(external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.MathUtils.DEG2RAD * 0.5 * gfx.camera.fov);
    _aoMaterial.uniforms.diffuseTexture.value = srcColorBuffer.texture;
    _aoMaterial.uniforms.depthTexture.value = srcDepthTexture;
    _aoMaterial.uniforms.normalTexture.value = normalBuffer.texture;
    _aoMaterial.uniforms.srcTexelSize.value.set(1 / srcColorBuffer.width, 1 / srcColorBuffer.height);
    _aoMaterial.uniforms.camNearFar.value.set(gfx.camera.near, gfx.camera.far);
    _aoMaterial.uniforms.projMatrix.value = gfx.camera.projectionMatrix;
    _aoMaterial.uniforms.aspectRatio.value = gfx.camera.aspect;
    _aoMaterial.uniforms.tanHalfFOV.value = tanHalfFOV;
    gfx.root.matrix.extractScale(_scale2);
    _aoMaterial.uniforms.kernelRadius.value = settings.now.debug.ssaoKernelRadius * _scale2.x;
    _aoMaterial.uniforms.depthThreshold.value = 2 * this._getBSphereRadius();
    _aoMaterial.uniforms.factor.value = settings.now.debug.ssaoFactor;
    gfx.renderer.setRenderTarget(tempBuffer1);
    gfx.renderer.renderScreenQuad(_aoMaterial);
    _horBlurMaterial.uniforms.aoMap.value = tempBuffer1.texture;
    _horBlurMaterial.uniforms.srcTexelSize.value.set(1 / tempBuffer1.width, 1 / tempBuffer1.height);
    _horBlurMaterial.uniforms.depthTexture.value = srcDepthTexture;
    gfx.renderer.setRenderTarget(tempBuffer);
    gfx.renderer.renderScreenQuad(_horBlurMaterial);
    _vertBlurMaterial.uniforms.aoMap.value = tempBuffer.texture;
    _vertBlurMaterial.uniforms.diffuseTexture.value = srcColorBuffer.texture;
    _vertBlurMaterial.uniforms.srcTexelSize.value.set(1 / tempBuffer.width, 1 / tempBuffer.height);
    _vertBlurMaterial.uniforms.depthTexture.value = srcDepthTexture;
    _vertBlurMaterial.uniforms.projMatrix.value = gfx.camera.projectionMatrix;
    _vertBlurMaterial.uniforms.aspectRatio.value = gfx.camera.aspect;
    _vertBlurMaterial.uniforms.tanHalfFOV.value = tanHalfFOV;
    const {
      fog
    } = gfx.scene;
    if (fog) {
      _vertBlurMaterial.uniforms.fogNearFar.value.set(fog.near, fog.far);
      _vertBlurMaterial.uniforms.fogColor.value.set(fog.color.r, fog.color.g, fog.color.b, settings.now.fogAlpha);
    }
    if (_vertBlurMaterial.useFog !== settings.now.fog || _vertBlurMaterial.fogTransparent !== settings.now.bg.transparent) {
      _vertBlurMaterial.setValues({
        useFog: settings.now.fog,
        fogTransparent: settings.now.bg.transparent
      });
      _vertBlurMaterial.needsUpdate = true;
    }
    gfx.renderer.setRenderTarget(targetBuffer);
    gfx.renderer.renderScreenQuad(_vertBlurMaterial);
  };
}();
Miew.prototype.reset = function() {
  if (this._picker) {
    this._picker.reset();
  }
  this._lastPick = null;
  this._releaseAllVisuals();
  this._setEditMode(EDIT_MODE.COMPLEX);
  this._resetObjects();
  if (this._gfx) {
    gfxutils.clearTree(this._gfx.pivot);
    this._gfx.renderer2d.reset();
  }
  this.setNeedRender();
};
Miew.prototype._resetScene = function() {
  this._objectControls.reset();
  this._objectControls.allowTranslation(true);
  this._objectControls.allowAltObjFreeRotation(true);
  this.resetReps();
  this.resetPivot();
  this.rebuildAll();
};
Miew.prototype.resetView = function() {
  if (this._picker) {
    this._picker.reset();
  }
  this._setEditMode(EDIT_MODE.COMPLEX);
  this._resetScene();
  this._forEachComplexVisual((visual) => {
    visual.updateSelectionMask({});
    visual.rebuildSelectionGeometry();
  });
};
Miew.prototype._export = function(format) {
  const TheExporter = external_module_lodash_commonjs_lodash_commonjs2_lodash_amd_lodash_root_namespaceObject["default"].head(io.exporters.find({
    format
  }));
  if (!TheExporter) {
    this.logger.error("Could not find suitable exporter for this source");
    return Promise.reject(new Error("Could not find suitable exporter for this source"));
  }
  this.dispatchEvent({
    type: "exporting"
  });
  if (this._visuals[this._curVisualName] instanceof src_ComplexVisual) {
    let dataSource = null;
    if (TheExporter.SourceClass === src_ComplexVisual) {
      dataSource = this._visuals[this._curVisualName];
    } else if (TheExporter.SourceClass === chem_Complex) {
      dataSource = this._visuals[this._curVisualName]._complex;
    }
    const exporter = new TheExporter(dataSource, {
      miewVersion: Miew.VERSION
    });
    return exporter.export().then((data) => data);
  }
  if (this._visuals[this._curVisualName] instanceof src_VolumeVisual) {
    return Promise.reject(new Error("Sorry, exporter for volume data not implemented yet"));
  }
  return Promise.reject(new Error("Unexpected format of data"));
};
var rePdbId = /^(?:(pdb|cif|ccp4|dsn6):\s*)?(\d[a-z\d]{3})$/i;
var rePubchem = /^(?:pc|pubchem):\s*([a-z]+)$/i;
var reUrlScheme = /^([a-z][a-z\d\-+.]*):/i;
function resolveSourceShortcut(source, opts) {
  if (!external_module_lodash_commonjs_lodash_commonjs2_lodash_amd_lodash_root_namespaceObject["default"].isString(source)) {
    return source;
  }
  const matchesPdbId = rePdbId.exec(source);
  if (matchesPdbId) {
    let [, format = "pdb", id2] = matchesPdbId;
    format = format.toLowerCase();
    id2 = id2.toUpperCase();
    switch (format) {
      case "pdb":
        source = `https://files.rcsb.org/download/${id2}.pdb`;
        break;
      case "cif":
        source = `https://files.rcsb.org/download/${id2}.cif`;
        break;
      case "ccp4":
        source = `https://www.ebi.ac.uk/pdbe/coordinates/files/${id2.toLowerCase()}.ccp4`;
        break;
      case "dsn6":
        source = `https://edmaps.rcsb.org/maps/${id2.toLowerCase()}_2fofc.dsn6`;
        break;
      default:
        throw new Error("Unexpected data format shortcut");
    }
    opts.fileType = format;
    opts.fileName = `${id2}.${format}`;
    opts.sourceType = "url";
    return source;
  }
  const matchesPubchem = rePubchem.exec(source);
  if (matchesPubchem) {
    const compound = matchesPubchem[1].toLowerCase();
    source = `https://pubchem.ncbi.nlm.nih.gov/rest/pug/compound/name/${compound}/JSON?record_type=3d`;
    opts.fileType = "pubchem";
    opts.fileName = `${compound}.json`;
    opts.sourceType = "url";
    return source;
  }
  if (opts.sourceType === "url" || opts.sourceType === void 0) {
    opts.sourceType = "url";
    if (!reUrlScheme.test(source)) {
      source = utils.resolveURL(source);
    }
  }
  return source;
}
function updateBinaryMode(opts) {
  let {
    binary
  } = opts;
  if (opts.fileType !== void 0) {
    const TheParser = external_module_lodash_commonjs_lodash_commonjs2_lodash_amd_lodash_root_namespaceObject["default"].head(io.parsers.find({
      format: opts.fileType
    }));
    if (TheParser) {
      binary = TheParser.binary || false;
    } else {
      throw new Error("Could not find suitable parser for this format");
    }
  }
  if (binary === void 0 && opts.fileExt !== void 0) {
    const TheParser = external_module_lodash_commonjs_lodash_commonjs2_lodash_amd_lodash_root_namespaceObject["default"].head(io.parsers.find({
      ext: opts.fileExt
    }));
    if (TheParser) {
      binary = TheParser.binary || false;
    }
  }
  if (opts.fileExt !== void 0 && opts.fileExt.toLowerCase() === ".man") {
    opts.binary = true;
    opts.animation = true;
  }
  if (binary !== void 0) {
    if (opts.binary !== void 0 && opts.binary !== binary) {
      opts.context.logger.warn("Overriding incorrect binary mode");
    }
  }
  opts.binary = binary || false;
}
function _fetchData(source, opts, job) {
  return new Promise((resolve) => {
    if (job.shouldCancel()) {
      throw new Error("Operation cancelled");
    }
    job.notify({
      type: "fetching"
    });
    source = resolveSourceShortcut(source, opts);
    const TheLoader = external_module_lodash_commonjs_lodash_commonjs2_lodash_amd_lodash_root_namespaceObject["default"].head(io.loaders.find({
      type: opts.sourceType,
      source
    }));
    if (!TheLoader) {
      throw new Error(LOADER_NOT_FOUND);
    }
    const fileName = opts.fileName || TheLoader.extractName(source);
    if (fileName) {
      const [name, fileExt] = utils.splitFileName(fileName);
      external_module_lodash_commonjs_lodash_commonjs2_lodash_amd_lodash_root_namespaceObject["default"].defaults(opts, {
        name,
        fileExt,
        fileName
      });
    }
    updateBinaryMode(opts);
    let newOptions = external_module_lodash_commonjs_lodash_commonjs2_lodash_amd_lodash_root_namespaceObject["default"].get(opts, "preset.expression");
    if (!external_module_lodash_commonjs_lodash_commonjs2_lodash_amd_lodash_root_namespaceObject["default"].isUndefined(newOptions)) {
      newOptions = JSON.parse(newOptions);
      if (newOptions && newOptions.settings) {
        const keys = ["singleUnit"];
        for (let keyIndex = 0, keyCount = keys.length; keyIndex < keyCount; ++keyIndex) {
          const key = keys[keyIndex];
          const value = external_module_lodash_commonjs_lodash_commonjs2_lodash_amd_lodash_root_namespaceObject["default"].get(newOptions.settings, key);
          if (!external_module_lodash_commonjs_lodash_commonjs2_lodash_amd_lodash_root_namespaceObject["default"].isUndefined(value)) {
            settings.set(key, value);
          }
        }
      }
    }
    const loader = new TheLoader(source, opts);
    loader.context = opts.context;
    job.addEventListener("cancel", () => loader.abort());
    loader.addEventListener("progress", (event) => {
      if (event.lengthComputable && event.total > 0) {
        reportProgress(loader.logger, "Fetching", event.loaded / event.total);
      } else {
        reportProgress(loader.logger, "Fetching");
      }
    });
    console.time("fetch");
    const promise = loader.load().then((data) => {
      console.timeEnd("fetch");
      opts.context.logger.info("Fetching finished");
      job.notify({
        type: "fetchingDone",
        data
      });
      return data;
    }).catch((error) => {
      console.timeEnd("fetch");
      opts.context.logger.debug(error.message);
      if (error.stack) {
        opts.context.logger.debug(error.stack);
      }
      opts.context.logger.error("Fetching failed");
      job.notify({
        type: "fetchingDone",
        error
      });
      throw error;
    });
    resolve(promise);
  });
}
function _parseData(data, opts, job) {
  if (job.shouldCancel()) {
    return Promise.reject(new Error("Operation cancelled"));
  }
  job.notify({
    type: "parsing"
  });
  const TheParser = external_module_lodash_commonjs_lodash_commonjs2_lodash_amd_lodash_root_namespaceObject["default"].head(io.parsers.find({
    format: opts.fileType,
    ext: opts.fileExt,
    data
  }));
  if (!TheParser) {
    return Promise.reject(new Error("Could not find suitable parser"));
  }
  const parser = new TheParser(data, opts);
  parser.context = opts.context;
  job.addEventListener("cancel", () => parser.abort());
  console.time("parse");
  return parser.parse().then((dataSet) => {
    console.timeEnd("parse");
    job.notify({
      type: "parsingDone",
      data: dataSet
    });
    return dataSet;
  }).catch((error) => {
    console.timeEnd("parse");
    opts.error = error;
    opts.context.logger.debug(error.message);
    if (error.stack) {
      opts.context.logger.debug(error.stack);
    }
    opts.context.logger.error("Parsing failed");
    job.notify({
      type: "parsingDone",
      error
    });
    throw error;
  });
}
Miew.prototype.load = function(source, opts) {
  opts = external_module_lodash_commonjs_lodash_commonjs2_lodash_amd_lodash_root_namespaceObject["default"].merge({}, opts, {
    context: this
  });
  if (!this.settings.now.use.multiFile) {
    if (this._loading.length) {
      this._loading.forEach((job2) => {
        job2.cancel();
      });
      this._loading.length = 0;
    }
    if (!opts.animation) {
      this.reset(true);
    }
  }
  this._interpolator.reset();
  this.dispatchEvent({
    type: "loading",
    options: opts,
    source
  });
  const job = new JobHandle();
  this._loading.push(job);
  job.addEventListener("notification", (e2) => {
    this.dispatchEvent(e2.slaveEvent);
  });
  this._spinner.spin(this._container);
  const onLoadEnd = (anything) => {
    const jobIndex = this._loading.indexOf(job);
    if (jobIndex !== -1) {
      this._loading.splice(jobIndex, 1);
    }
    this._spinner.stop();
    this._refreshTitle();
    job.notify({
      type: "loadingDone",
      anything
    });
    return anything;
  };
  return _fetchData(source, opts, job).then((data) => _parseData(data, opts, job)).then((object) => {
    const name = this._onLoad(object, opts);
    return onLoadEnd(name);
  }).catch((err) => {
    this.logger.error("Could not load data");
    this.logger.debug(err);
    throw onLoadEnd(err);
  });
};
Miew.prototype.unload = function(name) {
  this._removeVisual(name || this.getCurrentVisual());
  this.resetPivot();
  if (settings.now.shadow.on) {
    this._updateShadowCamera();
  }
};
Miew.prototype._startAnimation = function(fileData) {
  this._stopAnimation();
  const self2 = this;
  const visual = this._getComplexVisual();
  if (visual === null) {
    this.logger.error("Unable to start animation - no molecule is loaded.");
    return;
  }
  try {
    this._frameInfo = new gfx_FrameInfo(visual.getComplex(), fileData, {
      onLoadStatusChanged() {
        self2.dispatchEvent({
          type: "mdPlayerStateChanged",
          state: {
            isPlaying: self2._isAnimating,
            isLoading: self2._frameInfo ? self2._frameInfo.isLoading : true
          }
        });
      },
      onError(message) {
        self2._stopAnimation();
        self2.logger.error(message);
      }
    });
  } catch (e2) {
    this.logger.error("Animation file does not fit to current complex!");
    return;
  }
  this._continueAnimation();
};
Miew.prototype._pauseAnimation = function() {
  if (this._animInterval === null) {
    return;
  }
  this._isAnimating = false;
  clearInterval(this._animInterval);
  this._animInterval = null;
  if (this._frameInfo) {
    this.dispatchEvent({
      type: "mdPlayerStateChanged",
      state: {
        isPlaying: this._isAnimating,
        isLoading: this._frameInfo.isLoading
      }
    });
  }
};
Miew.prototype._continueAnimation = function() {
  this._isAnimating = true;
  let minFrameTime = 1e3 / settings.now.maxfps;
  minFrameTime = Number.isNaN(minFrameTime) ? 0 : minFrameTime;
  const self2 = this;
  const {
    pivot
  } = self2._gfx;
  const visual = this._getComplexVisual();
  if (visual) {
    visual.resetSelectionMask();
    visual.rebuildSelectionGeometry();
    this._msgAtomInfo.style.opacity = 0;
  }
  this._animInterval = setInterval(() => {
    self2.dispatchEvent({
      type: "mdPlayerStateChanged",
      state: {
        isPlaying: self2._isAnimating,
        isLoading: self2._frameInfo.isLoading
      }
    });
    if (self2._frameInfo.frameIsReady) {
      pivot.updateToFrame(self2._frameInfo);
      self2._updateObjsToFrame(self2._frameInfo);
      self2._refreshTitle(` Frame ${self2._frameInfo._currFrame} of ${self2._frameInfo._framesCount} time interval - ${self2._frameInfo._timeStep}`);
      try {
        self2._frameInfo.nextFrame();
      } catch (e2) {
        self2.logger.error("Error during animation");
        self2._stopAnimation();
        return;
      }
      self2._needRender = true;
    }
  }, minFrameTime);
};
Miew.prototype._stopAnimation = function() {
  if (this._animInterval === null) {
    return;
  }
  clearInterval(this._animInterval);
  this._frameInfo.disableEvents();
  this._frameInfo = null;
  this._animInterval = null;
  this.dispatchEvent({
    type: "mdPlayerStateChanged",
    state: null
  });
};
Miew.prototype._onLoad = function(dataSource, opts) {
  const gfx = this._gfx;
  let visualName = null;
  if (opts.animation) {
    this._refreshTitle();
    this._startAnimation(dataSource);
    return null;
  }
  this._stopAnimation();
  if (!opts || !opts.keepRepsInfo) {
    this._opts.reps = null;
    this._opts._objects = null;
  }
  if (dataSource.id === "Complex") {
    const complex = dataSource;
    if (opts.fileName) {
      complex.name = complex.name || removeExtension(opts.fileName).toUpperCase();
    } else if (opts.amberFileName) {
      complex.name = complex.name || removeExtension(opts.amberFileName).toUpperCase();
    } else {
      complex.name = `Dynamic ${opts.fileType} molecule`;
    }
    visualName = this._addVisual(new src_ComplexVisual(complex.name, complex));
    this._curVisualName = visualName;
    const desc = this.info();
    this.logger.info(`Parsed ${opts.fileName} (${desc.atoms} atoms, ${desc.bonds} bonds, ${desc.residues} residues, ${desc.chains} chains).`);
    if (external_module_lodash_commonjs_lodash_commonjs2_lodash_amd_lodash_root_namespaceObject["default"].isNumber(this._opts.unit)) {
      complex.setCurrentUnit(this._opts.unit);
    }
    if (opts.preset) {
    } else if (settings.now.autoPreset) {
      switch (opts.fileType) {
        case "cml":
          this.resetReps("small");
          break;
        case "pdb":
        case "mmtf":
        case "cif":
          if (hasValidResidues(complex)) {
            this.resetReps("macro");
          } else {
            this.resetReps("small");
          }
          break;
        default:
          this.resetReps("default");
          break;
      }
    } else {
      this.resetReps("default");
    }
  } else if (dataSource.id === "Volume") {
    this.resetEd();
    visualName = this._onLoadEd(dataSource);
  }
  gfx.camera.updateProjectionMatrix();
  this._updateFog();
  gfx.root.resetTransform();
  this.resetPivot();
  this._objectControls.setScale(settings.now.radiusToFit / this._getBSphereRadius());
  this._resetObjects();
  if (settings.now.autoResolution) {
    this._tweakResolution();
  }
  if (settings.now.shadow.on) {
    this._updateShadowCamera();
  }
  if (this._opts.view) {
    this.view(this._opts.view);
    delete this._opts.view;
  }
  this._refreshTitle();
  return visualName;
};
Miew.prototype.resetEd = function() {
  if (this._edLoader) {
    this._edLoader.abort();
    this._edLoader = null;
  }
  this._removeVisual(this._getVolumeVisual());
  this._needRender = true;
};
Miew.prototype.loadEd = function(source) {
  this.resetEd();
  const TheLoader = external_module_lodash_commonjs_lodash_commonjs2_lodash_amd_lodash_root_namespaceObject["default"].head(io.loaders.find({
    source
  }));
  if (!TheLoader) {
    this.logger.error(LOADER_NOT_FOUND);
    return Promise.reject(new Error(LOADER_NOT_FOUND));
  }
  const loader = this._edLoader = new TheLoader(source, {
    binary: true
  });
  loader.context = this;
  return loader.load().then((data) => {
    const TheParser = external_module_lodash_commonjs_lodash_commonjs2_lodash_amd_lodash_root_namespaceObject["default"].head(io.parsers.find({
      format: "ccp4"
    }));
    if (!TheParser) {
      throw new Error(PARSER_NOT_FOUND);
    }
    const parser = new TheParser(data);
    parser.context = this;
    return parser.parse().then((dataSource) => {
      this._onLoadEd(dataSource);
    });
  }).catch((error) => {
    this.logger.error("Could not load ED data");
    this.logger.debug(error);
  });
};
Miew.prototype._onLoadEd = function(dataSource) {
  dataSource.normalize();
  const volumeVisual = new src_VolumeVisual("volume", dataSource);
  volumeVisual.getMesh().layers.set(gfxutils.LAYERS.VOLUME);
  const visualName = this._addVisual(volumeVisual);
  this._needRender = true;
  return visualName;
};
Miew.prototype._needRebuild = function() {
  let needsRebuild = false;
  this._forEachComplexVisual((visual) => {
    needsRebuild = needsRebuild || visual.needsRebuild();
  });
  return needsRebuild;
};
Miew.prototype._rebuildObjects = function() {
  const self2 = this;
  const gfx = this._gfx;
  let i2;
  let n;
  const toRemove = [];
  for (i2 = 0; i2 < gfx.pivot.children.length; ++i2) {
    const child = gfx.pivot.children[i2];
    if (!(child instanceof src_Visual)) {
      toRemove.push(child);
    }
  }
  for (i2 = 0; i2 < toRemove.length; ++i2) {
    toRemove[i2].parent.remove(toRemove[i2]);
  }
  setTimeout(() => {
    const objList = self2._objects;
    for (i2 = 0, n = objList.length; i2 < n; ++i2) {
      const obj = objList[i2];
      if (obj.needsRebuild) {
        obj.build();
      }
      if (obj.getGeometry()) {
        gfx.pivot.add(obj.getGeometry());
      }
    }
  }, 10);
};
Miew.prototype.changeUnit = function(unitIdx, name) {
  const visual = this._getComplexVisual(name);
  if (!visual) {
    throw new Error("There is no complex to change!");
  }
  function currentUnitInfo() {
    const unit = visual ? visual.getComplex().getCurrentUnit() : 0;
    const type = unit > 0 ? `Bio molecule ${unit}` : "Asymmetric unit";
    return `Current unit: ${unit} (${type})`;
  }
  if (unitIdx === void 0) {
    return currentUnitInfo();
  }
  if (external_module_lodash_commonjs_lodash_commonjs2_lodash_amd_lodash_root_namespaceObject["default"].isString(unitIdx)) {
    unitIdx = Math.max(parseInt(unitIdx, 10), 0);
  }
  if (visual.getComplex().setCurrentUnit(unitIdx)) {
    this._resetScene();
    this._updateInfoPanel();
  }
  return currentUnitInfo();
};
Miew.prototype.rebuild = function() {
  if (this._building) {
    this.logger.warn("Miew.rebuild(): already building!");
    return;
  }
  this._building = true;
  this.dispatchEvent({
    type: "rebuilding"
  });
  this._rebuildObjects();
  this._gfx.renderer2d.reset();
  const rebuildActions = [];
  this._forEachComplexVisual((visual) => {
    if (visual.needsRebuild()) {
      rebuildActions.push(visual.rebuild().then(() => new Promise((resolve) => {
        visual.rebuildSelectionGeometry();
        resolve();
      })));
    }
  });
  const self2 = this;
  this._spinner.spin(this._container);
  Promise.all(rebuildActions).then(() => {
    self2._spinner.stop();
    self2._needRender = true;
    self2._refreshTitle();
    this.dispatchEvent({
      type: "buildingDone"
    });
    self2._building = false;
  });
};
Miew.prototype.rebuildAll = function() {
  this._forEachComplexVisual((visual) => {
    visual.setNeedsRebuild();
  });
};
Miew.prototype._refreshTitle = function(appendix) {
  let title;
  appendix = appendix === void 0 ? "" : appendix;
  const visual = this._getComplexVisual();
  if (visual) {
    title = visual.getComplex().name;
    const rep = visual.repGet(visual.repCurrent());
    title += rep ? ` – ${rep.mode.name} Mode` : "";
  } else {
    title = Object.keys(this._visuals).length > 0 ? "Unknown" : "No Data";
  }
  title += appendix;
  this.dispatchEvent({
    type: "titleChanged",
    data: title
  });
};
Miew.prototype.setNeedRender = function() {
  this._needRender = true;
};
Miew.prototype._extractRepresentation = function() {
  const changed = [];
  this._forEachComplexVisual((visual) => {
    if (visual.getSelectionCount() === 0) {
      return;
    }
    const selector = visual.buildSelectorFromMask(1 << visual.getSelectionBit());
    const defPreset = settings.now.presets.default;
    const res = visual.repAdd({
      selector,
      mode: defPreset[0].mode.id,
      colorer: defPreset[0].colorer.id,
      material: defPreset[0].material.id
    });
    if (!res) {
      if (visual.repCount() === src_ComplexVisual.NUM_REPRESENTATION_BITS) {
        this.logger.warn(`Number of representations is limited to ${src_ComplexVisual.NUM_REPRESENTATION_BITS}`);
      }
      return;
    }
    this.dispatchEvent({
      type: "repAdded",
      index: res.index,
      name: visual.name
    });
    visual.repCurrent(res.index);
    changed.push(visual.name);
  });
  if (changed.length > 0) {
    this.logger.report(`New representation from selection for complexes: ${changed.join(", ")}`);
  }
};
Miew.prototype._setReps = function(reps) {
  reps = reps || this._opts && this._opts.reps || [];
  this._forEachComplexVisual((visual) => visual.resetReps(reps));
};
Miew.prototype.applyPreset = function(preset) {
  const {
    presets
  } = settings.now;
  const presList = [preset || settings.defaults.preset, settings.defaults.preset, Object.keys(presets)[0]];
  let reps = null;
  for (let i2 = 0; !reps && i2 < presList.length; ++i2) {
    settings.set("preset", presList[i2]);
    reps = presets[settings.now.preset];
    if (!reps) {
      this.logger.warn(`Unknown preset "${settings.now.preset}"`);
    }
  }
  this._setReps(reps);
};
Miew.prototype.resetReps = function(preset) {
  const reps = this._opts && this._opts.reps;
  if (reps) {
    this._setReps(reps);
  } else {
    this.applyPreset(preset);
  }
};
Miew.prototype.repCount = function(name) {
  const visual = this._getComplexVisual(name);
  return visual ? visual.repCount() : 0;
};
Miew.prototype.repCurrent = function(index, name) {
  const visual = this._getComplexVisual(name);
  const newIdx = visual ? visual.repCurrent(index) : -1;
  if (index && newIdx !== index) {
    this.logger.warn(`Representation ${index} was not found. Current rep remains unchanged.`);
  }
  return newIdx;
};
Miew.prototype.rep = function(index, rep) {
  const visual = this._getComplexVisual("");
  if (!visual) {
    return null;
  }
  const res = visual.rep(index, rep);
  if (res.status === "created") {
    this.dispatchEvent({
      type: "repAdded",
      index: res.index,
      name: visual.name
    });
  } else if (res.status === "changed") {
    this.dispatchEvent({
      type: "repChanged",
      index: res.index,
      name: visual.name
    });
  }
  return res.desc;
};
Miew.prototype.repGet = function(index, name) {
  const visual = this._getComplexVisual(name);
  return visual ? visual.repGet(index) : null;
};
Miew.prototype.repAdd = function(rep, name) {
  const visual = this._getComplexVisual(name);
  if (!visual) {
    return -1;
  }
  const res = visual.repAdd(rep);
  if (res) {
    this.dispatchEvent({
      type: "repAdded",
      index: res.index,
      name
    });
    return res.index;
  }
  return -1;
};
Miew.prototype.repRemove = function(index, name) {
  const visual = this._getComplexVisual(name);
  if (!visual) {
    return;
  }
  visual.repRemove(index);
  this.dispatchEvent({
    type: "repRemoved",
    index,
    name
  });
};
Miew.prototype.repHide = function(index, hide, name) {
  this._needRender = true;
  const visual = this._getComplexVisual(name);
  return visual ? visual.repHide(index, hide) : null;
};
Miew.prototype._setEditMode = function(mode) {
  this._editMode = mode;
  const elem = this._msgMode;
  if (elem) {
    elem.style.opacity = mode === EDIT_MODE.COMPLEX ? 0 : 1;
    if (mode !== EDIT_MODE.COMPLEX) {
      const t2 = elem.getElementsByTagName("p")[0];
      t2.innerHTML = mode === EDIT_MODE.COMPONENT ? "COMPONENT EDIT MODE" : "FRAGMENT EDIT MODE";
    }
  }
  this.dispatchEvent({
    type: "editModeChanged",
    data: mode === EDIT_MODE.COMPLEX
  });
};
Miew.prototype._enterComponentEditMode = function() {
  if (this._editMode !== EDIT_MODE.COMPLEX) {
    return;
  }
  const editors = [];
  this._forEachComplexVisual((visual) => {
    const editor = visual.beginComponentEdit();
    if (editor) {
      editors.push(editor);
    }
  });
  if (editors === []) {
    return;
  }
  this._editors = editors;
  this.logger.info("COMPONENT EDIT MODE -- ON");
  this._setEditMode(EDIT_MODE.COMPONENT);
  this._objectControls.keysTranslateObj(true);
};
Miew.prototype._applyComponentEdit = function() {
  if (this._editMode !== EDIT_MODE.COMPONENT) {
    return;
  }
  this._objectControls.stop();
  this._objectControls.keysTranslateObj(false);
  for (let i2 = 0; i2 < this._editors.length; ++i2) {
    this._editors[i2].apply();
  }
  this._editors = [];
  this.logger.info("COMPONENT EDIT MODE -- OFF (applied)");
  this._setEditMode(EDIT_MODE.COMPLEX);
  this.rebuildAll();
};
Miew.prototype._discardComponentEdit = function() {
  if (this._editMode !== EDIT_MODE.COMPONENT) {
    return;
  }
  this._objectControls.stop();
  this._objectControls.keysTranslateObj(false);
  for (let i2 = 0; i2 < this._editors.length; ++i2) {
    this._editors[i2].discard();
  }
  this._editors = [];
  this.logger.info("COMPONENT EDIT MODE -- OFF (discarded)");
  this._setEditMode(EDIT_MODE.COMPLEX);
  this._needRender = true;
  this.rebuildAll();
};
Miew.prototype._enterFragmentEditMode = function() {
  if (this._editMode !== EDIT_MODE.COMPLEX) {
    return;
  }
  const selectedVisuals = [];
  this._forEachComplexVisual((visual) => {
    if (visual instanceof src_ComplexVisual && visual.getSelectionCount() > 0) {
      selectedVisuals.push(visual);
    }
  });
  if (selectedVisuals.length !== 1) {
    return;
  }
  const editor = selectedVisuals[0].beginFragmentEdit();
  if (!editor) {
    return;
  }
  this._editors = [editor];
  this.logger.info("FRAGMENT EDIT MODE -- ON (single bond)");
  this._setEditMode(EDIT_MODE.FRAGMENT);
  this._objectControls.allowTranslation(false);
  this._objectControls.allowAltObjFreeRotation(editor.isFreeRotationAllowed());
  this._needRender = true;
};
Miew.prototype._applyFragmentEdit = function() {
  if (this._editMode !== EDIT_MODE.FRAGMENT) {
    return;
  }
  this._objectControls.stop();
  for (let i2 = 0; i2 < this._editors.length; ++i2) {
    this._editors[i2].apply();
  }
  this._editors = [];
  this.logger.info("FRAGMENT EDIT MODE -- OFF (applied)");
  this._setEditMode(EDIT_MODE.COMPLEX);
  this._objectControls.allowTranslation(true);
  this._objectControls.allowAltObjFreeRotation(true);
  this.rebuildAll();
};
Miew.prototype._discardFragmentEdit = function() {
  if (this._editMode !== EDIT_MODE.FRAGMENT) {
    return;
  }
  this._objectControls.stop();
  for (let i2 = 0; i2 < this._editors.length; ++i2) {
    this._editors[i2].discard();
  }
  this._editors = [];
  this.logger.info("FRAGMENT EDIT MODE -- OFF (discarded)");
  this._setEditMode(EDIT_MODE.COMPLEX);
  this._objectControls.allowTranslation(true);
  this._objectControls.allowAltObjFreeRotation(true);
  this._needRender = true;
};
Miew.prototype._onPick = function(event) {
  if (!settings.now.picking) {
    return;
  }
  if (this._animInterval !== null) {
    return;
  }
  if (this._editMode === EDIT_MODE.FRAGMENT) {
    return;
  }
  if (this._objectControls.isEditingAltObj()) {
    return;
  }
  let complex = null;
  if (event.obj.atom) {
    complex = event.obj.atom.residue.getChain().getComplex();
    this._lastPick = event.obj.atom;
  } else if (event.obj.residue) {
    complex = event.obj.residue.getChain().getComplex();
    this._lastPick = event.obj.residue;
  } else if (event.obj.chain) {
    complex = event.obj.chain.getComplex();
    this._lastPick = event.obj.chain;
  } else if (event.obj.molecule) {
    complex = event.obj.molecule.complex;
    this._lastPick = event.obj.molecule;
  } else {
    this._lastPick = null;
  }
  function _updateSelection(visual) {
    visual.updateSelectionMask(event.obj);
    visual.rebuildSelectionGeometry();
  }
  if (complex) {
    const visual = this._getVisualForComplex(complex);
    if (visual) {
      _updateSelection(visual);
      this._needRender = true;
    }
  } else {
    this._forEachComplexVisual(_updateSelection);
    this._needRender = true;
  }
  this._updateInfoPanel();
  this.dispatchEvent(event);
};
Miew.prototype._onKeyDown = function(event) {
  if (!this._running || !this._hotKeysEnabled) {
    return;
  }
  if (settings.now.editing) {
    switch (event.code) {
      case "KeyC":
        this._enterComponentEditMode();
        break;
      case "KeyF":
        this._enterFragmentEditMode();
        break;
      case "KeyA":
        switch (this._editMode) {
          case EDIT_MODE.COMPONENT:
            this._applyComponentEdit();
            break;
          case EDIT_MODE.FRAGMENT:
            this._applyFragmentEdit();
            break;
          default:
            break;
        }
        break;
      case "KeyD":
        switch (this._editMode) {
          case EDIT_MODE.COMPONENT:
            this._discardComponentEdit();
            break;
          case EDIT_MODE.FRAGMENT:
            this._discardFragmentEdit();
            break;
          default:
            break;
        }
        break;
      default:
    }
  }
  switch (event.code) {
    case "NumpadAdd":
      if (event.altKey) {
        event.preventDefault();
        event.stopPropagation();
        this._forEachComplexVisual((visual) => {
          visual.expandSelection();
          visual.rebuildSelectionGeometry();
        });
        this._updateInfoPanel();
        this._needRender = true;
      }
      break;
    case "NumpadSubtract":
      if (event.altKey) {
        event.preventDefault();
        event.stopPropagation();
        this._forEachComplexVisual((visual) => {
          visual.shrinkSelection();
          visual.rebuildSelectionGeometry();
        });
        this._updateInfoPanel();
        this._needRender = true;
      }
      break;
    default:
  }
};
Miew.prototype._onKeyUp = function(event) {
  if (!this._running || !this._hotKeysEnabled) {
    return;
  }
  if (event.code === "KeyX") {
    this._extractRepresentation();
  }
};
Miew.prototype._updateInfoPanel = function() {
  const info = this._msgAtomInfo.getElementsByTagName("p")[0];
  let atom;
  let residue;
  let count = 0;
  this._forEachComplexVisual((visual) => {
    count += visual.getSelectionCount();
  });
  while (info.firstChild) {
    info.removeChild(info.firstChild);
  }
  if (count === 0) {
    this._msgAtomInfo.style.opacity = 0;
    return;
  }
  let firstLine = `${String(count)} atom${count !== 1 ? "s" : ""} selected`;
  if (this._lastPick !== null) {
    firstLine += ", the last pick:";
  }
  let secondLine = "";
  let aName = "";
  let coordLine = "";
  if (this._lastPick instanceof Miew_Atom) {
    atom = this._lastPick;
    residue = atom.residue;
    aName = atom.name;
    const location = atom.location !== 32 ? String.fromCharCode(atom.location) : "";
    secondLine = `${atom.element.fullName} #${atom.serial}${location}:       ${residue._chain._name}.${residue._type._name}${residue._sequence}${residue._icode.trim()}.`;
    secondLine += aName;
    coordLine = `Coord: (${atom.position.x.toFixed(2).toString()},     ${atom.position.y.toFixed(2).toString()},     ${atom.position.z.toFixed(2).toString()})`;
  } else if (this._lastPick instanceof Miew_Residue) {
    residue = this._lastPick;
    secondLine = `${residue._type._fullName}:       ${residue._chain._name}.${residue._type._name}${residue._sequence}${residue._icode.trim()}`;
  } else if (this._lastPick instanceof Miew_Chain) {
    secondLine = `chain ${this._lastPick._name}`;
  } else if (this._lastPick instanceof Miew_Molecule) {
    secondLine = `molecule ${this._lastPick._name}`;
  }
  info.appendChild(document.createTextNode(firstLine));
  if (secondLine !== "") {
    info.appendChild(document.createElement("br"));
    info.appendChild(document.createTextNode(secondLine));
  }
  if (coordLine !== "") {
    info.appendChild(document.createElement("br"));
    info.appendChild(document.createTextNode(coordLine));
  }
  this._msgAtomInfo.style.opacity = 1;
};
Miew.prototype._getAltObj = function() {
  if (this._editors) {
    let altObj = null;
    for (let i2 = 0; i2 < this._editors.length; ++i2) {
      const nextAltObj = this._editors[i2].getAltObj();
      if (nextAltObj.objects.length > 0) {
        if (altObj) {
          altObj = null;
          break;
        }
        altObj = nextAltObj;
      }
    }
    if (altObj) {
      return altObj;
    }
  }
  return {
    objects: [],
    pivot: new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Vector3(0, 0, 0)
  };
};
Miew.prototype.resetPivot = function() {
  const boundingBox = new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Box3();
  const center = new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Vector3();
  return function() {
    boundingBox.makeEmpty();
    this._forEachVisual((visual) => {
      boundingBox.union(visual.getBoundaries().boundingBox);
    });
    boundingBox.getCenter(center);
    this._objectControls.setPivot(center.negate());
    this.dispatchEvent({
      type: "transform"
    });
  };
}();
Miew.prototype.setPivotResidue = function() {
  const center = new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Vector3();
  return function(residue) {
    const visual = this._getVisualForComplex(residue.getChain().getComplex());
    if (!visual) {
      return;
    }
    if (residue._controlPoint) {
      center.copy(residue._controlPoint);
    } else {
      let x3 = 0;
      let y2 = 0;
      let z = 0;
      const amount = residue._atoms.length;
      for (let i2 = 0; i2 < amount; ++i2) {
        const p2 = residue._atoms[i2].position;
        x3 += p2.x / amount;
        y2 += p2.y / amount;
        z += p2.z / amount;
      }
      center.set(x3, y2, z);
    }
    center.applyMatrix4(visual.matrix).negate();
    this._objectControls.setPivot(center);
    this.dispatchEvent({
      type: "transform"
    });
  };
}();
Miew.prototype.setPivotAtom = function() {
  const center = new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Vector3();
  return function(atom) {
    const visual = this._getVisualForComplex(atom.residue.getChain().getComplex());
    if (!visual) {
      return;
    }
    center.copy(atom.position);
    center.applyMatrix4(visual.matrix).negate();
    this._objectControls.setPivot(center);
    this.dispatchEvent({
      type: "transform"
    });
  };
}();
Miew.prototype.getSelectionCenter = function() {
  const _centerInVisual = new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Vector3(0, 0, 0);
  return function(center, includesAtom, selector) {
    center.set(0, 0, 0);
    let count = 0;
    this._forEachComplexVisual((visual) => {
      if (visual.getSelectionCenter(_centerInVisual, includesAtom, selector || visual.getSelectionBit())) {
        center.add(_centerInVisual);
        count++;
      }
    });
    if (count === 0) {
      return false;
    }
    center.divideScalar(count);
    center.negate();
    return true;
  };
}();
Miew.prototype.setPivotSubset = function() {
  const _center2 = new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Vector3(0, 0, 0);
  function _includesInCurSelection(atom, selectionBit) {
    return atom.mask & 1 << selectionBit;
  }
  function _includesInSelector(atom, selector) {
    return selector.selector.includesAtom(atom);
  }
  return function(selector) {
    const includesAtom = selector ? _includesInSelector : _includesInCurSelection;
    if (this.getSelectionCenter(_center2, includesAtom, selector)) {
      this._objectControls.setPivot(_center2);
      this.dispatchEvent({
        type: "transform"
      });
    } else {
      this.logger.warn("selection is empty. Center operation not performed");
    }
  };
}();
Miew.prototype.screenshot = function(width, height) {
  const gfx = this._gfx;
  const deviceWidth = gfx.renderer.domElement.width;
  const deviceHeight = gfx.renderer.domElement.height;
  function fov2Tan(fov2) {
    return Math.tan(external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.MathUtils.degToRad(0.5 * fov2));
  }
  function tan2Fov(tan) {
    return external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.MathUtils.radToDeg(Math.atan(tan)) * 2;
  }
  function getDataURL() {
    let dataURL;
    const currBrowser = utils.getBrowser();
    if (currBrowser === utils.browserType.SAFARI) {
      const canvas = document.createElement("canvas");
      const canvasContext = canvas.getContext("2d");
      canvas.width = width === void 0 ? deviceWidth : width;
      canvas.height = height === void 0 ? deviceHeight : height;
      canvasContext.drawImage(gfx.renderer.domElement, 0, 0, canvas.width, canvas.height);
      dataURL = canvas.toDataURL("image/png");
    } else {
      dataURL = gfx.renderer.domElement.toDataURL("image/png");
    }
    return dataURL;
  }
  height = height || width;
  let screenshotURI;
  if (width === void 0 && height === void 0 || width === deviceWidth && height === deviceHeight) {
    screenshotURI = getDataURL();
  } else {
    const originalAspect = gfx.camera.aspect;
    const originalFov = gfx.camera.fov;
    const originalTanFov2 = fov2Tan(gfx.camera.fov);
    const areaOfInterestSize = Math.min(gfx.width, gfx.height);
    const areaOfInterestTanFov2 = originalTanFov2 * areaOfInterestSize / gfx.height;
    const shotAspect = width / height;
    gfx.renderer.setPixelRatio(1);
    gfx.camera.aspect = shotAspect;
    gfx.camera.fov = tan2Fov(areaOfInterestTanFov2 / Math.min(shotAspect, 1));
    gfx.camera.updateProjectionMatrix();
    gfx.renderer.setDrawingBufferSize(width, height, 1);
    this._renderFrame(settings.now.stereo);
    screenshotURI = getDataURL();
    gfx.renderer.setPixelRatio(window.devicePixelRatio);
    gfx.camera.aspect = originalAspect;
    gfx.camera.fov = originalFov;
    gfx.camera.updateProjectionMatrix();
    gfx.renderer.setDrawingBufferSize(gfx.width, gfx.height, window.devicePixelRatio);
    this._needRender = true;
  }
  return screenshotURI;
};
Miew.prototype.screenshotSave = function(filename, width, height) {
  const uri = this.screenshot(width, height);
  utils.shotDownload(uri, filename);
};
Miew.prototype.save = function(opts) {
  this._export(opts.fileType).then((dataString) => {
    const filename = this._visuals[this._curVisualName]._complex.name;
    utils.download(dataString, filename, opts.fileType);
    this._refreshTitle();
    this.dispatchEvent({
      type: "exportingDone"
    });
  }).catch((error) => {
    this.logger.error("Could not export data");
    this.logger.debug(error);
    this._refreshTitle();
    this.dispatchEvent({
      type: "exportingDone",
      error
    });
  });
};
Miew.prototype._tweakResolution = function() {
  const maxPerf = [["poor", 100], ["low", 500], ["medium", 1e3], ["high", 5e3], ["ultra", Number.MAX_VALUE]];
  let atomCount = 0;
  this._forEachComplexVisual((visual) => {
    atomCount += visual.getComplex().getAtomCount();
  });
  if (atomCount > 0) {
    const performance2 = this._gfxScore * 1e6 / atomCount;
    for (let i2 = 0; i2 < maxPerf.length; ++i2) {
      if (performance2 < maxPerf[i2][1]) {
        this._autoChangeResolution(maxPerf[i2][0]);
        break;
      }
    }
  }
};
Miew.prototype._autoChangeResolution = function(resolution) {
  if (resolution !== settings.now.resolution) {
    this.logger.report(`Your rendering resolution was changed to "${resolution}" for best performance.`);
  }
  settings.now.resolution = resolution;
};
Miew.prototype.saveSettings = function() {
  this._cookies.setCookie(this._opts.settingsCookie, JSON.stringify(this.settings.getDiffs(true)));
};
Miew.prototype.restoreSettings = function() {
  try {
    const cookie = this._cookies.getCookie(this._opts.settingsCookie);
    const diffs = cookie ? JSON.parse(cookie) : {};
    this.settings.applyDiffs(diffs, true);
  } catch (e2) {
    this.logger.error(`Cookies parse error: ${e2.message}`);
  }
};
Miew.prototype.resetSettings = function() {
  this.settings.reset();
};
Miew.prototype.setOptions = function(opts) {
  if (typeof opts === "string") {
    opts = Miew.options.fromAttr(opts);
  }
  if (opts.reps) {
    this._opts.reps = null;
  }
  external_module_lodash_commonjs_lodash_commonjs2_lodash_amd_lodash_root_namespaceObject["default"].merge(this._opts, opts);
  if (opts.settings) {
    this.set(opts.settings);
  }
  this._opts._objects = opts._objects;
  this._resetObjects();
  if (opts.load) {
    this.load(opts.load, {
      fileType: opts.type
    });
  }
  if (opts.preset) {
    settings.now.preset = opts.preset;
  }
  if (opts.reps) {
    this.resetReps(opts.preset);
  }
  if (this._opts.view) {
    this.view(this._opts.view);
    delete this._opts.view;
  }
  const visual = this._getComplexVisual();
  if (visual) {
    visual.getComplex().resetCurrentUnit();
    if (external_module_lodash_commonjs_lodash_commonjs2_lodash_amd_lodash_root_namespaceObject["default"].isNumber(opts.unit)) {
      visual.getComplex().setCurrentUnit(opts.unit);
    }
    this.resetView();
    this.rebuildAll();
  }
};
Miew.prototype.info = function(name) {
  const visual = this._getComplexVisual(name);
  if (!visual) {
    return {};
  }
  const complex = visual.getComplex();
  const {
    metadata
  } = complex;
  return {
    id: metadata.id || complex.name || "UNKNOWN",
    title: metadata.title && metadata.title.join(" ") || "UNKNOWN DATA",
    atoms: complex.getAtomCount(),
    bonds: complex.getBondCount(),
    residues: complex.getResidueCount(),
    chains: complex.getChainCount()
  };
};
Miew.prototype.addObject = function(objData, bThrow) {
  let Ctor = null;
  if (objData.type === objects_LinesObj.prototype.type) {
    Ctor = objects_LinesObj;
  }
  if (Ctor === null) {
    throw new Error(`Unknown scene object type - ${objData.type}`);
  }
  try {
    const newObj = new Ctor(objData.params, objData.opts);
    this._addSceneObject(newObj);
  } catch (error) {
    if (!bThrow) {
      this.logger.debug(`Error during scene object creation: ${error.message}`);
    } else {
      throw error;
    }
  }
  this._needRender = true;
};
Miew.prototype._addSceneObject = function(sceneObject) {
  const visual = this._getComplexVisual();
  if (sceneObject.build && visual) {
    sceneObject.build(visual.getComplex());
    this._gfx.pivot.add(sceneObject.getGeometry());
  }
  const objects = this._objects;
  objects[objects.length] = sceneObject;
};
Miew.prototype._updateObjsToFrame = function(frameData) {
  const objs = this._objects;
  for (let i2 = 0, n = objs.length; i2 < n; ++i2) {
    if (objs[i2].updateToFrame) {
      objs[i2].updateToFrame(frameData);
    }
  }
};
Miew.prototype._resetObjects = function() {
  const objs = this._opts._objects;
  this._objects = [];
  if (objs) {
    for (let i2 = 0, n = objs.length; i2 < n; ++i2) {
      this.addObject(objs[i2], false);
    }
  }
};
Miew.prototype.removeObject = function(index) {
  const obj = this._objects[index];
  if (!obj) {
    throw new Error(`Scene object with index ${index} does not exist`);
  }
  obj.destroy();
  this._objects.splice(index, 1);
  this._needRender = true;
};
Miew.prototype.getURL = function(opts) {
  return options.toURL(this.getState(external_module_lodash_commonjs_lodash_commonjs2_lodash_amd_lodash_root_namespaceObject["default"].defaults(opts, {
    compact: true,
    settings: false,
    view: false
  })));
};
Miew.prototype.getScript = function(opts) {
  return options.toScript(this.getState(external_module_lodash_commonjs_lodash_commonjs2_lodash_amd_lodash_root_namespaceObject["default"].defaults(opts, {
    compact: true,
    settings: true,
    view: true
  })));
};
Miew.prototype._compareReps = function(complexVisual, compareWithDefaults) {
  const ans = {};
  let repCount = 0;
  if (complexVisual) {
    repCount = complexVisual.repCount();
  }
  const currPreset = settings.defaults.presets[settings.now.preset];
  let compare = compareWithDefaults;
  if (currPreset === void 0 || currPreset.length > repCount) {
    compare = false;
    ans.preset = "empty";
  } else if (settings.now.preset !== settings.defaults.preset) {
    ans.preset = settings.now.preset;
  }
  const repsDiff = [];
  let emptyReps = true;
  for (let i2 = 0, n = repCount; i2 < n; ++i2) {
    repsDiff[i2] = complexVisual.repGet(i2).compare(compare ? currPreset[i2] : null);
    if (!external_module_lodash_commonjs_lodash_commonjs2_lodash_amd_lodash_root_namespaceObject["default"].isEmpty(repsDiff[i2])) {
      emptyReps = false;
    }
  }
  if (!emptyReps) {
    ans.reps = repsDiff;
  }
  return ans;
};
Miew.prototype.getState = function(opts) {
  const state = {};
  opts = external_module_lodash_commonjs_lodash_commonjs2_lodash_amd_lodash_root_namespaceObject["default"].defaults(opts, {
    compact: true,
    settings: false,
    view: false
  });
  const visual = this._getComplexVisual();
  if (visual !== null) {
    const complex = visual.getComplex();
    const {
      metadata
    } = complex;
    if (metadata.id) {
      const format = metadata.format ? `${metadata.format}:` : "";
      state.load = format + metadata.id;
    }
    const unit = complex.getCurrentUnit();
    if (unit !== 1) {
      state.unit = unit;
    }
  }
  const repsInfo = this._compareReps(visual, opts.compact);
  if (repsInfo.preset) {
    state.preset = repsInfo.preset;
  }
  if (repsInfo.reps) {
    state.reps = repsInfo.reps;
  }
  const objects = this._objects;
  const objectsState = [];
  for (let i2 = 0, n = objects.length; i2 < n; ++i2) {
    objectsState[i2] = objects[i2].identify();
  }
  if (objects.length > 0) {
    state._objects = objectsState;
  }
  if (opts.view) {
    state.view = this.view();
  }
  if (opts.settings) {
    const diff = this.settings.getDiffs(false);
    if (!external_module_lodash_commonjs_lodash_commonjs2_lodash_amd_lodash_root_namespaceObject["default"].isEmpty(diff)) {
      state.settings = diff;
    }
  }
  return state;
};
Miew.prototype.get = function(param, value) {
  return settings.get(param, value);
};
Miew.prototype._clipPlaneUpdateValue = function(radius) {
  const clipPlaneValue = Math.max(this._gfx.camera.position.z - radius * settings.now.draft.clipPlaneFactor, settings.now.camNear);
  const opts = {
    clipPlaneValue
  };
  this._forEachComplexVisual((visual) => {
    visual.setUberOptions(opts);
  });
  for (let i2 = 0, n = this._objects.length; i2 < n; ++i2) {
    const obj = this._objects[i2];
    if (obj._line) {
      obj._line.material.setUberOptions(opts);
    }
  }
  if (this._picker !== null) {
    this._picker.clipPlaneValue = clipPlaneValue;
  }
};
Miew.prototype._fogFarUpdateValue = function() {
  if (this._picker !== null) {
    if (this._gfx.scene.fog) {
      this._picker.fogFarValue = this._gfx.scene.fog.far;
    } else {
      this._picker.fogFarValue = void 0;
    }
  }
};
Miew.prototype._updateShadowmapMeshes = function(process) {
  this._forEachComplexVisual((visual) => {
    const reprList = visual._reprList;
    for (let i2 = 0, n = reprList.length; i2 < n; ++i2) {
      const repr = reprList[i2];
      process(repr.geo, repr.material);
    }
  });
};
Miew.prototype._updateMaterials = function(values) {
  let needTraverse = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
  let process = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : void 0;
  this._forEachComplexVisual((visual) => visual.setMaterialValues(values, needTraverse, process));
  for (let i2 = 0, n = this._objects.length; i2 < n; ++i2) {
    const obj = this._objects[i2];
    if (obj._line) {
      obj._line.material.setValues(values);
      obj._line.material.needsUpdate = true;
    }
  }
};
Miew.prototype._fogAlphaChanged = function() {
  this._forEachComplexVisual((visual) => {
    visual.setUberOptions({
      fogAlpha: settings.now.fogAlpha
    });
  });
};
Miew.prototype._embedWebXR = function() {
  if (settings.now.stereo !== "WEBVR") {
    if (this.webVR) {
      this.webVR.disable();
    }
    this.webVR = null;
    return;
  }
  if (!this.webVR) {
    this.webVR = new WebVRPoC(() => {
      this._requestAnimationFrame(() => this._onTick());
      this._needRender = true;
      this._onResize();
    });
  }
  this.webVR.enable(this._gfx);
};
Miew.prototype._initOnSettingsChanged = function() {
  const on = (props, func) => {
    props = external_module_lodash_commonjs_lodash_commonjs2_lodash_amd_lodash_root_namespaceObject["default"].isArray(props) ? props : [props];
    props.forEach((prop) => {
      this.settings.addEventListener(`change:${prop}`, func);
    });
  };
  on("modes.VD.frame", () => {
    const volume = this._getVolumeVisual();
    if (volume === null) return;
    volume.showFrame(settings.now.modes.VD.frame);
    this._needRender = true;
  });
  on("modes.VD.isoMode", () => {
    const volume = this._getVolumeVisual();
    if (volume === null) return;
    volume.getMesh().material.updateDefines();
    this._needRender = true;
  });
  on("bg.color", () => {
    this._onBgColorChanged();
  });
  on("ao", () => {
    if (settings.now.ao && !isAOSupported(this._gfx.renderer.getContext())) {
      this.logger.warn("Your device or browser does not support ao");
      settings.set("ao", false);
    } else {
      const values = {
        normalsToGBuffer: settings.now.ao
      };
      this._setUberMaterialValues(values);
    }
  });
  on("zSprites", () => {
    if (settings.now.zSprites && !arezSpritesSupported(this._gfx.renderer.getContext())) {
      this.logger.warn("Your device or browser does not support zSprites");
      settings.set("zSprites", false);
    }
    this.rebuildAll();
  });
  on("fogColor", () => {
    this._onFogColorChanged();
  });
  on("fogColorEnable", () => {
    this._onFogColorChanged();
  });
  on("bg.transparent", (evt) => {
    const gfx = this._gfx;
    if (gfx) {
      gfx.renderer.setClearColor(settings.now.bg.color, Number(!settings.now.bg.transparent));
    }
    this._updateMaterials({
      fogTransparent: evt.value
    });
    this.rebuildAll();
  });
  on("draft.clipPlane", (evt) => {
    this._updateMaterials({
      clipPlane: evt.value
    });
    this.rebuildAll();
  });
  on("shadow.on", (evt) => {
    const values = {
      shadowmap: evt.value,
      shadowmapType: settings.now.shadow.type
    };
    const gfx = this._gfx;
    if (gfx) {
      gfx.renderer.shadowMap.enabled = Boolean(values.shadowmap);
    }
    this._updateMaterials(values, true);
    if (values.shadowmap) {
      this._updateShadowCamera();
      this._updateShadowmapMeshes(meshutils.createShadowmapMaterial);
    } else {
      this._updateShadowmapMeshes(meshutils.removeShadowmapMaterial);
    }
    this._needRender = true;
  });
  on("shadow.type", (evt) => {
    if (settings.now.shadow.on) {
      this._updateMaterials({
        shadowmapType: evt.value
      }, true);
      this._needRender = true;
    }
  });
  on("shadow.radius", (evt) => {
    for (let i2 = 0; i2 < this._gfx.scene.children.length; i2++) {
      if (this._gfx.scene.children[i2].shadow !== void 0) {
        const light = this._gfx.scene.children[i2];
        light.shadow.radius = evt.value;
        this._needRender = true;
      }
    }
  });
  on("fps", () => {
    this._fps.show(settings.now.fps);
  });
  on(["fog", "fogNearFactor", "fogFarFactor"], () => {
    this._updateFog();
    this._needRender = true;
  });
  on("fogAlpha", () => {
    const {
      fogAlpha
    } = settings.now;
    if (fogAlpha < 0 || fogAlpha > 1) {
      this.logger.warn("fogAlpha must belong range [0,1]");
    }
    this._fogAlphaChanged();
    this._needRender = true;
  });
  on("autoResolution", (evt) => {
    if (evt.value && !this._gfxScore) {
      this.logger.warn("Benchmarks are missed, autoresolution will not work! Autoresolution should be set during miew startup.");
    }
  });
  on("stereo", () => {
    this._embedWebXR(settings.now.stereo === "WEBVR");
    this._needRender = true;
  });
  on(["transparency", "palette"], () => {
    this.rebuildAll();
  });
  on("resolution", () => {
    this.rebuildAll();
    const volume = this._getVolumeVisual();
    if (volume) {
      volume.getMesh().material.updateDefines();
      this._needRender = true;
    }
  });
  on(["axes", "fxaa", "ao", "outline.on", "outline.color", "outline.threshold", "outline.thickness"], () => {
    this._needRender = true;
  });
};
Miew.prototype.set = function(params, value) {
  settings.set(params, value);
};
Miew.prototype.select = function(expression, append) {
  const visual = this._getComplexVisual();
  if (!visual) {
    return;
  }
  let sel = expression;
  if (external_module_lodash_commonjs_lodash_commonjs2_lodash_amd_lodash_root_namespaceObject["default"].isString(expression)) {
    sel = Miew_selectors.parse(expression).selector;
  }
  visual.select(sel, append);
  this._lastPick = null;
  this._updateInfoPanel();
  this._needRender = true;
};
var VIEW_VERSION = "1";
Miew.prototype.view = function(expression) {
  const self2 = this;
  const {
    pivot
  } = this._gfx;
  let transform = [];
  const eulerOrder = "ZXY";
  function encode() {
    const pos = pivot.position;
    const scale = self2._objectControls.getScale() / settings.now.radiusToFit;
    const euler = new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Euler();
    euler.setFromQuaternion(self2._objectControls.getOrientation(), eulerOrder);
    transform = [pos.x, pos.y, pos.z, scale, euler.x, euler.y, euler.z];
    return VIEW_VERSION + utils.arrayToBase64(transform, Float32Array);
  }
  function decode() {
    if (expression.length === 40) {
      expression = `0${expression}`;
    }
    const version = expression[0];
    transform = utils.arrayFromBase64(expression.substr(1), Float32Array);
    if (version !== VIEW_VERSION) {
      if (version === "0") {
        transform[3] /= 8;
      } else {
        self2.logger.warn(`Encoded view version mismatch, stored as ${version} vs ${VIEW_VERSION} expected`);
        return;
      }
    }
    const interpolator = self2._interpolator;
    const srcView = interpolator.createView();
    srcView.position.copy(pivot.position);
    srcView.scale = self2._objectControls.getScale();
    srcView.orientation.copy(self2._objectControls.getOrientation());
    const dstView = interpolator.createView();
    dstView.position.set(transform[0], transform[1], transform[2]);
    if (self2._getComplexVisual()) {
      dstView.position.sub(self2._getComplexVisual().position);
    }
    dstView.scale = transform[3];
    dstView.orientation.setFromEuler(new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Euler(transform[4], transform[5], transform[6], eulerOrder));
    interpolator.setup(srcView, dstView);
  }
  if (typeof expression === "undefined") {
    return encode();
  }
  decode();
  return expression;
};
Miew.prototype._updateView = function() {
  const self2 = this;
  const {
    pivot
  } = this._gfx;
  const interpolator = this._interpolator;
  if (!interpolator.wasStarted()) {
    interpolator.start();
  }
  if (!interpolator.isMoving()) {
    return;
  }
  const res = interpolator.getCurrentView();
  if (res.success) {
    const curr = res.view;
    pivot.position.copy(curr.position);
    self2._objectControls.setScale(curr.scale * settings.now.radiusToFit);
    self2._objectControls.setOrientation(curr.orientation);
    this.dispatchEvent({
      type: "transform"
    });
    self2._needRender = true;
  }
};
Miew.prototype.translate = function(x3, y2, z) {
  this._objectControls.translatePivot(x3, y2, z);
  this.dispatchEvent({
    type: "transform"
  });
  this._needRender = true;
};
Miew.prototype.rotate = function(x3, y2, z) {
  this._objectControls.rotate(new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Quaternion().setFromEuler(new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Euler(x3, y2, z, "XYZ")));
  this.dispatchEvent({
    type: "transform"
  });
  this._needRender = true;
};
Miew.prototype.scale = function(factor) {
  if (factor <= 0) {
    throw new RangeError("Scale should be greater than zero");
  }
  this._objectControls.scale(factor);
  this.dispatchEvent({
    type: "transform"
  });
  this._needRender = true;
};
Miew.prototype.center = function(selector) {
  if (selector === void 0) {
    this.setPivotSubset();
    this._needRender = true;
    return;
  }
  if (selector.obj !== void 0 && ("atom" in selector.obj || "residue" in selector.obj)) {
    if ("atom" in selector.obj) {
      this.setPivotAtom(selector.obj.atom);
    } else {
      this.setPivotResidue(selector.obj.residue);
    }
    this._needRender = true;
    return;
  }
  if (selector.obj === void 0 && selector !== "") {
    const sel = Miew_selectors.parse(selector);
    if (sel.error === void 0) {
      this.setPivotSubset(sel);
      this._needRender = true;
      return;
    }
  }
  this.resetPivot();
  this._needRender = true;
};
Miew.prototype.within = function(selector, radius) {
  const visual = this._getComplexVisual();
  if (!visual) {
    return Miew_selectors.None();
  }
  if (selector instanceof String) {
    selector = Miew_selectors.parse(selector);
  }
  const res = visual.within(selector, radius);
  if (res) {
    visual.rebuildSelectionGeometry();
    this._needRender = true;
  }
  return res;
};
Miew.prototype.projected = function(fullAtomName, complexName) {
  const visual = this._getComplexVisual(complexName);
  if (!visual) {
    return false;
  }
  const atom = visual.getComplex().getAtomByFullname(fullAtomName);
  if (atom === null) {
    return false;
  }
  const pos = atom.position.clone();
  this._gfx.pivot.updateMatrixWorldRecursive();
  this._gfx.camera.updateMatrixWorldRecursive();
  this._gfx.pivot.localToWorld(pos);
  pos.project(this._gfx.camera);
  return {
    x: (pos.x + 1) * 0.5 * this._gfx.width,
    y: (1 - pos.y) * 0.5 * this._gfx.height
  };
};
Miew.prototype.dssp = function(complexName) {
  const visual = this._getComplexVisual(complexName);
  if (!visual) {
    return;
  }
  visual.getComplex().dssp();
  visual._reprList.forEach((rep) => {
    if (rep.mode.id === "CA" || rep.colorer.id === "SS") {
      rep.needsRebuild = true;
    }
  });
};
Miew.prototype.exportCML = function() {
  const self2 = this;
  function extractRotation(m2) {
    const xAxis = new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Vector3();
    const yAxis = new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Vector3();
    const zAxis = new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Vector3();
    m2.extractBasis(xAxis, yAxis, zAxis);
    xAxis.normalize();
    yAxis.normalize();
    zAxis.normalize();
    const retMat = new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Matrix4();
    retMat.identity();
    retMat.makeBasis(xAxis, yAxis, zAxis);
    return retMat;
  }
  function updateCMLData(complex2) {
    const {
      root
    } = self2._gfx;
    const mat = extractRotation(root.matrixWorld);
    const v4 = new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Vector4(0, 0, 0, 0);
    const vCenter = new external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject.Vector4(0, 0, 0, 0);
    let xml = null;
    let ap = null;
    complex2.forEachAtom((atom) => {
      if (atom.xmlNodeRef && atom.xmlNodeRef.xmlNode) {
        xml = atom.xmlNodeRef.xmlNode;
        ap = atom.position;
        v4.set(ap.x, ap.y, ap.z, 1);
        v4.applyMatrix4(mat);
        xml.setAttribute("x3", v4.x.toString());
        xml.setAttribute("y3", v4.y.toString());
        xml.setAttribute("z3", v4.z.toString());
        xml.removeAttribute("x2");
        xml.removeAttribute("y2");
      }
    });
    complex2.forEachSGroup((sGroup) => {
      if (sGroup.xmlNodeRef && sGroup.xmlNodeRef.xmlNode) {
        xml = sGroup.xmlNodeRef.xmlNode;
        ap = sGroup.getPosition();
        v4.set(ap.x, ap.y, ap.z, 1);
        const cp = sGroup.getCentralPoint();
        if (cp === null) {
          v4.applyMatrix4(mat);
        } else {
          vCenter.set(cp.x, cp.y, cp.z, 0);
          v4.add(vCenter);
          v4.applyMatrix4(mat);
          vCenter.set(cp.x, cp.y, cp.z, 1);
          vCenter.applyMatrix4(mat);
          v4.sub(vCenter);
        }
        xml.setAttribute("x", v4.x.toString());
        xml.setAttribute("y", v4.y.toString());
        xml.setAttribute("z", v4.z.toString());
      }
    });
  }
  const visual = self2._getComplexVisual();
  const complex = visual ? visual.getComplex() : null;
  if (complex && complex.originalCML) {
    updateCMLData(complex);
    const oSerializer = new XMLSerializer();
    return oSerializer.serializeToString(complex.originalCML);
  }
  return null;
};
Miew.prototype.motm = function() {
  settings.set({
    fogColorEnable: true,
    fogColor: 0,
    outline: {
      on: true,
      threshold: 0.01
    },
    bg: {
      color: 16777215
    }
  });
  this._forEachComplexVisual((visual) => {
    const rep = [];
    const complex = visual.getComplex();
    const palette2 = gfx_palettes.get(settings.now.palette);
    for (let i2 = 0; i2 < complex.getChainCount(); i2++) {
      const curChainName = complex._chains[i2]._name;
      const curChainColor = palette2.getChainColor(curChainName);
      rep[i2] = {
        selector: `chain ${curChainName}`,
        mode: "VW",
        colorer: ["CB", {
          color: curChainColor,
          factor: 0.9
        }],
        material: "FL"
      };
    }
    visual.resetReps(rep);
  });
};
Miew.prototype.VERSION = "0.11.1";
external_module_lodash_commonjs_lodash_commonjs2_lodash_amd_lodash_root_namespaceObject["default"].assign(
  Miew,
  /** @lends Miew */
  {
    VERSION: Miew.prototype.VERSION,
    registeredPlugins: [],
    // export namespaces // TODO: WIP: refactoring external interface
    chem,
    io,
    modes: gfx_modes,
    colorers: gfx_colorers,
    materials: gfx_materials,
    palettes: gfx_palettes,
    options,
    settings,
    utils,
    gfx: {
      Representation: gfx_Representation
    },
    /**
     * Third-party libraries packaged together with Miew.
     *
     * @property {object} lodash - [Lodash](https://lodash.com/), a modern JavaScript utility library delivering
     *   modularity, performance & extras.
     * @property {object} three - [three.js](https://threejs.org/), JavaScript 3D library.
     *
     * @example
     * var _ = Miew.thirdParty.lodash;
     * var opts = _.merge({ ... }, Miew.options.fromURL(window.location.search));
     * var miew = new Miew(opts);
     */
    thirdParty: {
      lodash: external_module_lodash_commonjs_lodash_commonjs2_lodash_amd_lodash_root_namespaceObject["default"],
      three: external_module_three_commonjs_three_commonjs2_three_amd_three_root_THREE_namespaceObject
    }
  }
);
var src_Miew = Miew;
var MiewCLIParser = __webpack_require__(89);
var modeIdDesc = {
  $help: ["Rendering mode shortcut", "    BS - balls and sticks mode", "    LN - lines mode", "    LC - licorice mode", "    VW - van der waals mode", "    TR - trace mode", "    TU - tube mode", "    CA - cartoon mode", "    SA - isosurface mode", "    QS - quick surface mode", "    SE - solvent excluded mode", "    TX - text mode"],
  BS: {
    $help: ["   Balls and sticks", "      aromrad = <number> #aromatic radius", "      atom = <number>    #atom radius", "      bond = <number>    #bond radius", "      multibond = <bool> #use multibond", "      showarom = <bool>  #show aromatic", "      space = <number>   #space value\n"]
  },
  CA: {
    $help: ["   Cartoon", "      arrow = <number>   #arrow size", "      depth = <number>   #depth of surface", "      heightSegmentsRatio = <number>", "      radius = <number>  #tube radius", "      tension = <number> #", "      width = <number>  #secondary width\n"]
  },
  LN: {
    $help: ["   Lines", "      atom = <number>    #atom radius", "      chunkarom = <number>", "      multibond = <bool> #use multibond", "      showarom = <bool>  #show aromatic", "      offsarom = <number>\n"]
  },
  LC: {
    $help: ["   Licorice", "      aromrad = <number> #aromatic radius", "      bond = <number>    #bond radius", "      multibond = <bool> #use multibond", "      showarom = <bool>  #show aromatic", "      space = <number>   #space value\n"]
  },
  VW: {
    $help: ["   Van der Waals", "      nothing\n"]
  },
  TR: {
    $help: ["   Trace", "      radius = <number>  #tube radius\n"]
  },
  TU: {
    $help: ["   Tube", "      heightSegmentsRatio = <number>", "      radius = <number>  #tube radius", "      tension = <number> \n"]
  },
  SA: {
    $help: ["   Surface", "      zClip = <bool> #clip z plane\n"]
  },
  QS: {
    $help: ["   Quick surface", "      isoValue = <number>", "      scale = <number>", "      wireframe = <bool>", "      zClip = <bool> #clip z plane\n"]
  },
  SE: {
    $help: ["   Solvent excluded surface", "      zClip = <bool> #clip z plane\n"]
  },
  TX: {
    $help: ["   Text mode", '      template = <format string> string that can include "{{ id }}"', "          it will be replaced by value, id can be one of next:", "          serial, name, type, sequence, residue, chain, hetatm, water\n", '      horizontalAlign = <string> {"left", "right", "center"}', '      verticalAlign = <string> {"top", "bottom", "middle"}', "      dx = <number> #offset along x", "      dy = <number> #offset along y", "      dz = <number> #offset along z", "      fg = <string> #text color modificator", "           could be keyword, named color or hex", "      fg = <string> #back color modificator", "           could be keyword, named color or hex", "      showBg = <bool> #if set show background", "           plate under text"]
  }
};
var colorDesc = {
  $help: ["Coloring mode shortcut", "    EL - color by element", "    CH - color by chain", "    SQ - color by sequence", "    RT - color by residue type", "    SS - color by secondary structure", "    UN - uniform"],
  UN: {
    $help: ["Parameters of coloring modes customization", "   Uniform", "      color = <number|color> #RGB->HEX->dec\n"],
    color: {
      $help: Object.keys(gfx_palettes.get(settings.now.palette).namedColors).sort().join("\n")
    }
  }
};
var materialDesc = {
  $help: ["Material shortcut", "    DF - diffuse", "    TR - transparent", "    SF - soft plastic", "    PL - glossy plastic", "    ME - metal", "    GL - glass"]
};
var addRepDesc = {
  $help: ["Short (packed) representation description as a set of variables", "    s=<EXPRESSION>", "        selector property", "    m=<MODE_ID>[!<PARAMETER>:<VALUE>[,...]]", "        render mode property", "    c=<COLORER_ID>[!<PARAMETER>:<VALUE>[,...]]", "        color mode property", "    mt=<MATERIAL_ID>", "        material property"],
  s: {
    $help: "Selection expression string as it is in menu->representations->selection"
  },
  m: modeIdDesc,
  c: colorDesc,
  mt: materialDesc
};
var setGetParameterDesc = {
  $help: ["Parameters of rendering modes customization: modes", "Parameters of colorer customization: colorers", "Autobuild: autobuild = (<number>|<bool>)"],
  modes: modeIdDesc,
  colorers: colorDesc
};
var help = {
  $help: ["help (<cmd name>| <path to property>)", "You can get detailed information about command options", '   using "help cmd.opt.opt.[...]"\n', "   you can use one line comments", "   everything started from (#|//) will be skipped", "   Example: >build //some comment\n", "List of available commands:"],
  reset: {
    $help: ["Reload current object, delete all representations", "    Nothing will work until load new object"]
  },
  load: {
    $help: ["load (<PDBID>|<URL>|-f [<*.NC FILE URL STRING>])", "    Load new pdb object from selected source"],
    PDBID: {
      $help: "pdb id in remote molecule database"
    },
    URL: {
      $help: "url to source file"
    },
    f: {
      $help: ["open file system dialog to fetch local file", "optionally you can determine trajectory file", "via URL for *.top model"]
    }
  },
  clear: {
    $help: "No args. Clear terminal"
  },
  add: {
    $help: ["add [<REP_NAME>] [<DESCRIPTION>]", "    Add new item to representation set with", "    default or <DESCRIPTION> params"],
    REP_NAME: {
      $help: "Identifier string [_,a-z,A-Z,0-9] can not start from digit"
    },
    DESCRIPTION: addRepDesc
  },
  rep: {
    $help: ["rep [<REP_NAME>|<REP_INDEX>] [<DESCRIPTION>]", "    set current representation by name or index", "    edit current representation by <DESCRIPTION>"],
    REP_NAME: {
      $help: ["Identifier string [_,a-z,A-Z,0-9] can not start from digit", "Must be declared before"]
    },
    REP_INDEX: {
      $help: "Index of available representation"
    },
    DESCRIPTION: addRepDesc
  },
  remove: {
    $help: ["remove (<REP_NAME>|<REP_INDEX>)", "Remove representation by name or index"],
    REP_NAME: {
      $help: ["Identifier string [_,a-z,A-Z,0-9] can not start from digit", "Must be declared before"]
    },
    REP_INDEX: {
      $help: "Index of available representation"
    }
  },
  selector: {
    $help: ["selector <EXPRESSION>", "   set selector from EXPRESSION to current representation"],
    EXPRESSION: {
      $help: "Selection expression string as it is in menu->representations->selection"
    }
  },
  mode: {
    $help: ["mode <MODE_ID> [<PARAMETER>=<VALUE>...]", "   set rendering mode and apply parameters to current representation"],
    MODE_ID: modeIdDesc
  },
  color: {
    $help: ["color <COLORER_ID> [<PARAMETER>=<VALUE>...]", "   set colorer and apply parameters to current representation"],
    COLORER_ID: colorDesc
  },
  material: {
    $help: ["material <MATERIAL_ID>", "   set material to current representation"],
    MATERIAL_ID: materialDesc
  },
  build: {
    $help: "build help str",
    add: {
      $help: "build.add",
      new: {
        $help: ["add.new", "add.new new line 1", "add.new new line 2", "add.new new line 3"]
      }
    },
    del: {
      $help: "build.del"
    }
  },
  list: {
    $help: ["list [-e|-s|<REP_NAME>|<REP_INDEX>]", "Print representations if no args print list of representations", "    -e expand list and show all representations", "    -s show all user-registered selectors", "    <REP_NAME>|<REP_INDEX> show only current representation"]
  },
  hide: {
    $help: ["hide (<REP_NAME>|<REP_INDEX>)", "Hide representation referenced in args"]
  },
  show: {
    $help: ["show (<REP_NAME>|<REP_INDEX>)", "Show representation referenced in args"]
  },
  get: {
    $help: ["get <PARAMETER>", "Print <PARAMETER> value", "    <PARAMETER> - path to option use get.PARAMETER to get more info"],
    PARAMETER: setGetParameterDesc
  },
  set: {
    $help: ["set <PARAMETER> <VALUE>", "Set <PARAMETER> with <VALUE>", "    <PARAMETER> - path to option use set.PARAMETER to get more info"],
    PARAMETER: setGetParameterDesc
  },
  set_save: {
    $help: ["set_save", "Save current settings to cookie"]
  },
  set_restore: {
    $help: ["set_restore", "Load and apply settings from cookie"]
  },
  set_reset: {
    $help: ["set_reset", "Reset current settings to the defaults"]
  },
  preset: {
    $help: ["preset [<PRESET>]", "Reset current representation or set preset to <PRESET>"],
    PRESET: {
      $help: ["default", "wire", "small", "macro"]
    }
  },
  unit: {
    $help: ["unit [<unit_id>]", "Change current biological structure view. Zero <unit_id> value means asymmetric unit,", "positive values set an assembly with corresponding number.", "Being called with no parameters command prints current unit information."]
  },
  view: {
    $help: ["view [<ENCODED_VIEW>]", "Get current encoded view or set if ENCODED_VIEW placed as argument"],
    ENCODED_VIEW: {
      $help: ["encoded view matrix string (binary code)"]
    }
  },
  rotate: {
    $help: ["rotate (x|y|z) [<DEGREES>] [(x|y|z) [<DEGREES>]]...", "Rotate scene"]
  },
  scale: {
    $help: ["scale <SCALE>", "Scale scene"]
  },
  select: {
    $help: ["select <SELECTOR_STRING> [as <SELECTOR_NAME>]", "Select atoms using selector defined in SELECTOR_STRING", "    and if SELECTOR_NAME is defined register it in viewer", "    you can use it later as a complex selector"]
  },
  within: {
    $help: ["within <DISTANCE> of <SELECTOR_STRING> as <SELECTOR_NAME>", "Build within named selector", "    DISTANCE        <number>", "    SELECTOR_STRING <string(selection language)>", "    SELECTOR_NAME   <identifier>"]
  },
  url: {
    $help: ["url [-s] [-v]", "Report URL encoded scene", "    if -s set that include settings in the URL", "    if -v set that include view in the URL"]
  },
  screenshot: {
    $help: ["screenshot [<WIDTH> [<HEIGHT>]]", "Make a screenshot of the scene", "    WIDTH  <number> in pixels", "    HEIGHT <number> in pixels, equal to WIDTH by default"]
  },
  line: {
    $help: ["line <first_atom_path> <second_atom_path> [<PARAMETER>=<VALUE>]", "Draw dashed line between two specified atoms"]
  },
  removeobj: {
    $help: ["removeobj <id>", "Remove scene object by its index. Indices could be obtained by <listobj> command"]
  },
  listobj: {
    $help: ["listobj", "Display the list of all existing scene objects"]
  }
};
var MiewCLIHelp = help;
var {
  chem: {
    selectors: Miew_cli_selectors
  },
  modes: Miew_cli_modes,
  colorers: Miew_cli_colorers,
  materials: Miew_cli_materials,
  palettes: Miew_cli_palettes,
  options: Miew_cli_options,
  settings: Miew_cli_settings
} = src_Miew;
function None() {
}
var NULL = function() {
  const obj = new None();
  return function() {
    return obj;
  };
}();
var RepresentationMap = class {
  constructor() {
    this.representationMap = {};
    this.representationID = {};
  }
  get(strId) {
    return this.representationMap[strId] || this.representationID[strId] || "<no name>";
  }
  add(strId, index) {
    if (strId === -1) {
      return "Can not create representation: there is no data";
    }
    if (index !== void 0) {
      if (!this.representationMap.hasOwnProperty(strId)) {
        this.representationMap[strId.toString()] = index;
        this.representationID[index] = strId.toString();
      } else {
        return "This name has already existed, registered without name";
      }
    }
    return `Representation ${strId} successfully added`;
  }
  remove(index) {
    if (index && this.representationID.hasOwnProperty(index)) {
      delete this.representationMap[this.representationID[index]];
      delete this.representationID[index];
    }
    const sortedKeys = Object.keys(this.representationID).sort();
    for (const i2 in sortedKeys) {
      if (sortedKeys.hasOwnProperty(i2)) {
        const id2 = sortedKeys[i2];
        if (id2 > index) {
          this.representationID[id2 - 1] = this.representationID[id2];
          this.representationMap[this.representationID[id2]] -= 1;
          delete this.representationID[id2];
        }
      }
    }
  }
  clear() {
    this.representationMap = {};
    this.representationID = {};
  }
};
var representationsStorage = new RepresentationMap();
function keyRemap(key) {
  const keys = {
    s: "selector",
    m: "mode",
    c: "colorer",
    mt: "material",
    mode: "modes",
    color: "colorers",
    colorer: "colorers",
    select: "selector",
    material: "materials",
    selector: "selector"
  };
  const ans = keys[key];
  return ans === void 0 ? key : ans;
}
var CLIUtils = class {
  list(miew, repMap, key) {
    let ret = "";
    if (miew && repMap !== void 0) {
      if (key === void 0 || key === "-e") {
        const count = miew.repCount();
        for (let i2 = 0; i2 < count; i2++) {
          ret += this.listRep(miew, repMap, i2, key);
        }
      }
    }
    return ret;
  }
  listRep(miew, repMap, repIndex2, key) {
    let ret = "";
    const rep = miew.repGet(repIndex2);
    if (!rep) {
      logger.warn(`Rep ${repIndex2} does not exist!`);
      return ret;
    }
    const index = repIndex2;
    const repName = repMap.get(index);
    const {
      mode,
      colorer
    } = rep;
    const selectionStr = rep.selectorString;
    const material = rep.materialPreset;
    ret += `#${index} : ${mode.name}${repName === "<no name>" ? "" : `, ${repName}`}
`;
    if (key !== void 0) {
      ret += `    selection : "${selectionStr}"
`;
      ret += `    mode      : (${mode.id}), ${mode.name}
`;
      ret += `    colorer   : (${colorer.id}), ${colorer.name}
`;
      ret += `    material  : (${material.id}), ${material.name}
`;
    }
    return ret;
  }
  listSelector(miew, context) {
    let ret = "";
    for (const k2 in context) {
      if (context.hasOwnProperty(k2)) {
        ret += `${k2} : "${context[k2]}"
`;
      }
    }
    return ret;
  }
  listObjs(miew) {
    const objs = miew._objects;
    if (!objs || !Array.isArray(objs) || objs.length === 0) {
      return "There are no objects on the scene";
    }
    const strList = [];
    for (let i2 = 0, n = objs.length; i2 < n; ++i2) {
      strList[i2] = `${i2}: ${objs[i2].toString()}`;
    }
    return strList.join("\n");
  }
  joinHelpStr(helpData) {
    if (helpData instanceof Array) {
      return helpData.join("\n");
    }
    return helpData;
  }
  help(path) {
    if (external_module_lodash_commonjs_lodash_commonjs2_lodash_amd_lodash_root_namespaceObject["default"].isUndefined(path)) {
      return `${this.joinHelpStr(MiewCLIHelp.$help)}
${external_module_lodash_commonjs_lodash_commonjs2_lodash_amd_lodash_root_namespaceObject["default"].slice(external_module_lodash_commonjs_lodash_commonjs2_lodash_amd_lodash_root_namespaceObject["default"].sortBy(external_module_lodash_commonjs_lodash_commonjs2_lodash_amd_lodash_root_namespaceObject["default"].keys(MiewCLIHelp)), 1).join(", ")}
`;
    }
    const helpItem = external_module_lodash_commonjs_lodash_commonjs2_lodash_amd_lodash_root_namespaceObject["default"].get(MiewCLIHelp, path);
    return external_module_lodash_commonjs_lodash_commonjs2_lodash_amd_lodash_root_namespaceObject["default"].isUndefined(helpItem) ? this.help() : `${this.joinHelpStr(helpItem.$help)}
`;
  }
  load(miew, arg) {
    if (miew === void 0 || arg === void 0 || arg === "-f") {
      return;
    }
    miew.awaitWhileCMDisInProcess();
    const finish = () => miew.finishAwaitingCMDInProcess();
    miew.load(arg).then(finish, finish);
  }
  checkArg(key, arg, modificate) {
    if (key !== void 0 && arg !== void 0) {
      if (keyRemap(key) === "selector") {
        const res = Miew_cli_selectors.parse(arg);
        if (res.error !== void 0) {
          const selExc = {
            message: res.error
          };
          throw selExc;
        }
        if (modificate !== void 0 && modificate) {
          return res.selector;
        }
        return arg;
      }
      const modificators = {
        colorers: Miew_cli_colorers,
        modes: Miew_cli_modes,
        materials: Miew_cli_materials
      };
      let modificator = key;
      let temp;
      while (modificator !== temp) {
        temp = modificator;
        modificator = keyRemap(temp);
      }
      if (modificators[modificator].get(arg) === void 0) {
        const exc = {
          message: `${arg} is not existed in ${modificator}`
        };
        throw exc;
      }
      return arg;
    }
    return NULL;
  }
  propagateProp(path, arg) {
    if (path !== void 0) {
      let argExc = {};
      const adapter = Miew_cli_options.adapters[typeof external_module_lodash_commonjs_lodash_commonjs2_lodash_amd_lodash_root_namespaceObject["default"].get(Miew_cli_settings.defaults, path)];
      if (adapter === void 0) {
        const pathExc = {
          message: `${path} is not existed`
        };
        throw pathExc;
      }
      if ((path.endsWith(".color") || path.endsWith(".baseColor") || path.endsWith(".EL.carbon")) && typeof arg !== "number") {
        arg = Miew_cli_palettes.get(Miew_cli_settings.now.palette).getNamedColor(arg);
      }
      if (path.endsWith(".fg") || path.endsWith(".bg")) {
        if (typeof arg !== "number") {
          const val = Miew_cli_palettes.get(Miew_cli_settings.now.palette).getNamedColor(arg, true);
          if (val !== void 0) {
            arg = `0x${val.toString(16)}`;
          }
        } else {
          arg = `0x${arg.toString(16)}`;
        }
      }
      if (path.endsWith(".template")) {
        arg = arg.replace(/\\n/g, "\n");
      }
      if (arg !== void 0 && adapter(arg) !== arg && adapter(arg) !== arg > 0) {
        argExc = {
          message: `${path} must be a "${typeof external_module_lodash_commonjs_lodash_commonjs2_lodash_amd_lodash_root_namespaceObject["default"].get(Miew_cli_settings.defaults, path)}"`
        };
        throw argExc;
      }
    }
    return arg;
  }
  unquoteString(value) {
    return utils.unquoteString(value);
  }
};
var utilFunctions = new CLIUtils();
function CreateObjectPair(a2, b2) {
  const obj = {};
  obj[a2] = b2;
  return obj;
}
function ArgList(arg) {
  if (arg instanceof this.constructor) {
    return arg;
  }
  if (arg instanceof Array) {
    this._values = arg.slice(0);
  } else if (arg) {
    this._values = [arg];
  } else {
    this._values = [];
  }
}
ArgList.prototype.append = function(value) {
  const values = this._values;
  values[values.length] = value;
  return this;
};
ArgList.prototype.remove = function(value) {
  const values = this._values;
  const index = values.indexOf(value);
  if (index >= 0) {
    values.splice(index, 1);
  }
  return this;
};
ArgList.prototype.toJSO = function(cliUtils, cmd, arg) {
  const res = {};
  const list = this._values;
  for (let i2 = 0, n = list.length; i2 < n; ++i2) {
    external_module_lodash_commonjs_lodash_commonjs2_lodash_amd_lodash_root_namespaceObject["default"].set(res, list[i2].id, cliUtils.propagateProp(`${keyRemap(cmd)}.${arg}.${list[i2].id}`, list[i2].val));
  }
  return res;
};
function Arg(_id2, _val) {
  this.id = _id2;
  this.val = _val;
}
var cliutils = /* @__PURE__ */ Object.create({});
cliutils.Arg = Arg;
cliutils.ArgList = ArgList;
cliutils.miew = null;
cliutils.echo = null;
cliutils.representations = representationsStorage;
cliutils.utils = utilFunctions;
cliutils._ = external_module_lodash_commonjs_lodash_commonjs2_lodash_amd_lodash_root_namespaceObject["default"];
cliutils.CreateObjectPair = CreateObjectPair;
cliutils.keyRemap = keyRemap;
cliutils.Context = Miew_cli_selectors.Context;
cliutils.ClearContext = Miew_cli_selectors.ClearContext;
cliutils.NULL = NULL;
cliutils.notimplemented = function() {
  return this.NULL;
};
src_Miew.prototype.script = function(script, _printCallback, _errorCallback) {
  MiewCLIParser.parser.yy.miew = this;
  MiewCLIParser.parser.yy.echo = _printCallback;
  MiewCLIParser.parser.yy.error = _errorCallback;
  if (this.cmdQueue === void 0) {
    this.cmdQueue = [];
  }
  if (this.commandInAction === void 0) {
    this.commandInAction = false;
  }
  this.cmdQueue = this.cmdQueue.concat(script.split("\n"));
};
src_Miew.prototype.awaitWhileCMDisInProcess = function() {
  this.commandInAction = true;
};
src_Miew.prototype.finishAwaitingCMDInProcess = function() {
  this.commandInAction = false;
};
src_Miew.prototype.isScriptingCommandAvailable = function() {
  return this.commandInAction !== void 0 && !this.commandInAction && this.cmdQueue !== void 0 && this.cmdQueue.length > 0;
};
src_Miew.prototype.callNextCmd = function() {
  if (this.isScriptingCommandAvailable()) {
    const cmd = this.cmdQueue.shift();
    const res = {};
    res.success = false;
    try {
      MiewCLIParser.parser.parse(cmd);
      res.success = true;
    } catch (e2) {
      res.error = e2.message;
      MiewCLIParser.parser.yy.error(res.error);
      this.finishAwaitingCMDInProcess();
    }
    return res;
  }
  return "";
};
MiewCLIParser.parser.yy = cliutils;
MiewCLIParser.parser.yy.parseError = MiewCLIParser.parser.parseError;
var src = src_Miew;
var __webpack_exports__default = __webpack_exports__.A;

// node_modules/miew-react/dist/index.modern.js
var e = __toESM(require_react());
var t = { 536: (n) => {
  n.exports = function(n2) {
    var e2 = [];
    return e2.toString = function() {
      return this.map(function(e3) {
        var t2 = "", r2 = void 0 !== e3[5];
        return e3[4] && (t2 += "@supports (".concat(e3[4], ") {")), e3[2] && (t2 += "@media ".concat(e3[2], " {")), r2 && (t2 += "@layer".concat(e3[5].length > 0 ? " ".concat(e3[5]) : "", " {")), t2 += n2(e3), r2 && (t2 += "}"), e3[2] && (t2 += "}"), e3[4] && (t2 += "}"), t2;
      }).join("");
    }, e2.i = function(n3, t2, r2, a2, o2) {
      "string" == typeof n3 && (n3 = [[null, n3, void 0]]);
      var i2 = {};
      if (r2) for (var s2 = 0; s2 < this.length; s2++) {
        var A2 = this[s2][0];
        null != A2 && (i2[A2] = true);
      }
      for (var c2 = 0; c2 < n3.length; c2++) {
        var l2 = [].concat(n3[c2]);
        r2 && i2[l2[0]] || (void 0 !== o2 && (void 0 === l2[5] || (l2[1] = "@layer".concat(l2[5].length > 0 ? " ".concat(l2[5]) : "", " {").concat(l2[1], "}")), l2[5] = o2), t2 && (l2[2] ? (l2[1] = "@media ".concat(l2[2], " {").concat(l2[1], "}"), l2[2] = t2) : l2[2] = t2), a2 && (l2[4] ? (l2[1] = "@supports (".concat(l2[4], ") {").concat(l2[1], "}"), l2[4] = a2) : l2[4] = "".concat(a2)), e2.push(l2));
      }
    }, e2;
  };
}, 784: (n) => {
  n.exports = function(n2) {
    var e2 = n2[1], t2 = n2[3];
    if (!t2) return e2;
    if ("function" == typeof btoa) {
      var r2 = btoa(unescape(encodeURIComponent(JSON.stringify(t2)))), a2 = "sourceMappingURL=data:application/json;charset=utf-8;base64,".concat(r2), o2 = "/*# ".concat(a2, " */");
      return [e2].concat([o2]).join("\n");
    }
    return [e2].join("\n");
  };
}, 32: (n, e2, t2) => {
  t2.d(e2, { A: () => A2, z: () => s2 });
  var r2 = t2(784), a2 = t2.n(r2), o2 = t2(536), i2 = t2.n(o2)()(a2());
  i2.push([n.id, ".DVOOardsIBZOO3FaW5Nw {\n  width: 100%;\n  height: 100%;\n}\n", "", { version: 3, sources: ["webpack://./src/Viewer.module.scss"], names: [], mappings: "AAAA;EACE,WAAW;EACX,YAAY;AACd", sourcesContent: [".root {\r\n  width: 100%;\r\n  height: 100%;\r\n}\r\n"], sourceRoot: "" }]);
  var s2 = "DVOOardsIBZOO3FaW5Nw";
  const A2 = i2;
}, 920: (n, e2, t2) => {
  t2.d(e2, { A: () => s2 });
  var r2 = t2(784), a2 = t2.n(r2), o2 = t2(536), i2 = t2.n(o2)()(a2());
  i2.push([n.id, "@keyframes spinner-line-fade-more {\n  0%, 100% {\n    opacity: 0; /* minimum opacity */\n  }\n  1% {\n    opacity: 1;\n  }\n}\n\n@keyframes spinner-line-fade-quick {\n  0%, 39%, 100% {\n    opacity: 0.25; /* minimum opacity */\n  }\n  40% {\n    opacity: 1;\n  }\n}\n\n@keyframes spinner-line-fade-default {\n  0%, 100% {\n    opacity: 0.22; /* minimum opacity */\n  }\n  1% {\n    opacity: 1;\n  }\n}\n\n@keyframes spinner-line-shrink {\n  0%, 25%, 100% {\n    /* minimum scale and opacity */\n    transform: scale(0.5);\n    opacity: 0.25;\n  }\n  26% {\n    transform: scale(1);\n    opacity: 1;\n  }\n}\n\n.miew-canvas > canvas {\n  display: block;\n  width: 100%;\n  height: 100%;\n}\n\n.miew-container,\n.miew-canvas {\n  width: 100%;\n  height: 100%;\n  overflow: hidden;\n  position: relative;\n}\n\n.miew-message {\n  /* trick for centered error-reporting*/\n  background-color: #ccc;\n  display: table;\n  width: 100%;\n  height: 100%;\n}\n\n.miew-message p {\n    display: table-cell;\n    vertical-align: middle;\n    text-align: center;\n    font-size: large;\n  }\n\n.mode-message {\n  position: absolute;\n  top: 10px;\n  right: 10px;\n  border-radius: 4px;\n  color: silver;\n  background-color: rgba(64, 64, 64, 0.75);\n  display: flex;\n  align-items: left;\n  justify-content: left;\n  opacity: 0;\n}\n\n.atom-info {\n  margin: 10px;\n  text-align: left;\n}\n\n.overlay {\n  pointer-events: none;\n}\n", "", { version: 3, sources: ["webpack://./../miew/dist/Miew.css"], names: [], mappings: "AAAA;EACE;IACE,UAAU,EAAE,oBAAoB;EAClC;EACA;IACE,UAAU;EACZ;AACF;;AAEA;EACE;IACE,aAAa,EAAE,oBAAoB;EACrC;EACA;IACE,UAAU;EACZ;AACF;;AAEA;EACE;IACE,aAAa,EAAE,oBAAoB;EACrC;EACA;IACE,UAAU;EACZ;AACF;;AAEA;EACE;IACE,8BAA8B;IAC9B,qBAAqB;IACrB,aAAa;EACf;EACA;IACE,mBAAmB;IACnB,UAAU;EACZ;AACF;;AAEA;EACE,cAAc;EACd,WAAW;EACX,YAAY;AACd;;AAEA;;EAEE,WAAW;EACX,YAAY;EACZ,gBAAgB;EAChB,kBAAkB;AACpB;;AAEA;EACE,sCAAsC;EACtC,sBAAsB;EACtB,cAAc;EACd,WAAW;EACX,YAAY;AACd;;AAEA;IACI,mBAAmB;IACnB,sBAAsB;IACtB,kBAAkB;IAClB,gBAAgB;EAClB;;AAEF;EACE,kBAAkB;EAClB,SAAS;EACT,WAAW;EACX,kBAAkB;EAClB,aAAa;EACb,wCAAwC;EACxC,aAAa;EACb,iBAAiB;EACjB,qBAAqB;EACrB,UAAU;AACZ;;AAEA;EACE,YAAY;EACZ,gBAAgB;AAClB;;AAEA;EACE,oBAAoB;AACtB", sourcesContent: ["@keyframes spinner-line-fade-more {\n  0%, 100% {\n    opacity: 0; /* minimum opacity */\n  }\n  1% {\n    opacity: 1;\n  }\n}\n\n@keyframes spinner-line-fade-quick {\n  0%, 39%, 100% {\n    opacity: 0.25; /* minimum opacity */\n  }\n  40% {\n    opacity: 1;\n  }\n}\n\n@keyframes spinner-line-fade-default {\n  0%, 100% {\n    opacity: 0.22; /* minimum opacity */\n  }\n  1% {\n    opacity: 1;\n  }\n}\n\n@keyframes spinner-line-shrink {\n  0%, 25%, 100% {\n    /* minimum scale and opacity */\n    transform: scale(0.5);\n    opacity: 0.25;\n  }\n  26% {\n    transform: scale(1);\n    opacity: 1;\n  }\n}\n\n.miew-canvas > canvas {\r\n  display: block;\r\n  width: 100%;\r\n  height: 100%;\r\n}\n\n.miew-container,\r\n.miew-canvas {\r\n  width: 100%;\r\n  height: 100%;\r\n  overflow: hidden;\r\n  position: relative;\r\n}\n\n.miew-message {\r\n  /* trick for centered error-reporting*/\r\n  background-color: #ccc;\r\n  display: table;\r\n  width: 100%;\r\n  height: 100%;\r\n}\n\n.miew-message p {\r\n    display: table-cell;\r\n    vertical-align: middle;\r\n    text-align: center;\r\n    font-size: large;\r\n  }\n\n.mode-message {\r\n  position: absolute;\r\n  top: 10px;\r\n  right: 10px;\r\n  border-radius: 4px;\r\n  color: silver;\r\n  background-color: rgba(64, 64, 64, 0.75);\r\n  display: flex;\r\n  align-items: left;\r\n  justify-content: left;\r\n  opacity: 0;\r\n}\n\n.atom-info {\r\n  margin: 10px;\r\n  text-align: left;\r\n}\n\n.overlay {\r\n  pointer-events: none;\r\n}\r\n"], sourceRoot: "" }]);
  const s2 = i2;
}, 591: (n) => {
  var e2 = [];
  function t2(n2) {
    for (var t3 = -1, r3 = 0; r3 < e2.length; r3++) if (e2[r3].identifier === n2) {
      t3 = r3;
      break;
    }
    return t3;
  }
  function r2(n2, r3) {
    for (var o2 = {}, i2 = [], s2 = 0; s2 < n2.length; s2++) {
      var A2 = n2[s2], c2 = r3.base ? A2[0] + r3.base : A2[0], l2 = o2[c2] || 0, u2 = "".concat(c2, " ").concat(l2);
      o2[c2] = l2 + 1;
      var p2 = t2(u2), d2 = { css: A2[1], media: A2[2], sourceMap: A2[3], supports: A2[4], layer: A2[5] };
      if (-1 !== p2) e2[p2].references++, e2[p2].updater(d2);
      else {
        var f2 = a2(d2, r3);
        r3.byIndex = s2, e2.splice(s2, 0, { identifier: u2, updater: f2, references: 1 });
      }
      i2.push(u2);
    }
    return i2;
  }
  function a2(n2, e3) {
    var t3 = e3.domAPI(e3);
    return t3.update(n2), function(e4) {
      if (e4) {
        if (e4.css === n2.css && e4.media === n2.media && e4.sourceMap === n2.sourceMap && e4.supports === n2.supports && e4.layer === n2.layer) return;
        t3.update(n2 = e4);
      } else t3.remove();
    };
  }
  n.exports = function(n2, a3) {
    var o2 = r2(n2 = n2 || [], a3 = a3 || {});
    return function(n3) {
      n3 = n3 || [];
      for (var i2 = 0; i2 < o2.length; i2++) {
        var s2 = t2(o2[i2]);
        e2[s2].references--;
      }
      for (var A2 = r2(n3, a3), c2 = 0; c2 < o2.length; c2++) {
        var l2 = t2(o2[c2]);
        0 === e2[l2].references && (e2[l2].updater(), e2.splice(l2, 1));
      }
      o2 = A2;
    };
  };
}, 128: (n) => {
  var e2 = {};
  n.exports = function(n2, t2) {
    var r2 = function(n3) {
      if (void 0 === e2[n3]) {
        var t3 = document.querySelector(n3);
        if (window.HTMLIFrameElement && t3 instanceof window.HTMLIFrameElement) try {
          t3 = t3.contentDocument.head;
        } catch (n4) {
          t3 = null;
        }
        e2[n3] = t3;
      }
      return e2[n3];
    }(n2);
    if (!r2) throw new Error("Couldn't find a style target. This probably means that the value for the 'insert' parameter is invalid.");
    r2.appendChild(t2);
  };
}, 51: (n) => {
  n.exports = function(n2) {
    var e2 = document.createElement("style");
    return n2.setAttributes(e2, n2.attributes), n2.insert(e2, n2.options), e2;
  };
}, 855: (n, e2, t2) => {
  n.exports = function(n2) {
    var e3 = t2.nc;
    e3 && n2.setAttribute("nonce", e3);
  };
}, 740: (n) => {
  n.exports = function(n2) {
    if ("undefined" == typeof document) return { update: function() {
    }, remove: function() {
    } };
    var e2 = n2.insertStyleElement(n2);
    return { update: function(t2) {
      !function(n3, e3, t3) {
        var r2 = "";
        t3.supports && (r2 += "@supports (".concat(t3.supports, ") {")), t3.media && (r2 += "@media ".concat(t3.media, " {"));
        var a2 = void 0 !== t3.layer;
        a2 && (r2 += "@layer".concat(t3.layer.length > 0 ? " ".concat(t3.layer) : "", " {")), r2 += t3.css, a2 && (r2 += "}"), t3.media && (r2 += "}"), t3.supports && (r2 += "}");
        var o2 = t3.sourceMap;
        o2 && "undefined" != typeof btoa && (r2 += "\n/*# sourceMappingURL=data:application/json;base64,".concat(btoa(unescape(encodeURIComponent(JSON.stringify(o2)))), " */")), e3.styleTagTransform(r2, n3, e3.options);
      }(e2, n2, t2);
    }, remove: function() {
      !function(n3) {
        if (null === n3.parentNode) return false;
        n3.parentNode.removeChild(n3);
      }(e2);
    } };
  };
}, 656: (n) => {
  n.exports = function(n2, e2) {
    if (e2.styleSheet) e2.styleSheet.cssText = n2;
    else {
      for (; e2.firstChild; ) e2.removeChild(e2.firstChild);
      e2.appendChild(document.createTextNode(n2));
    }
  };
} };
var r = {};
function a(n) {
  var e2 = r[n];
  if (void 0 !== e2) return e2.exports;
  var o2 = r[n] = { id: n, exports: {} };
  return t[n](o2, o2.exports, a), o2.exports;
}
a.n = (n) => {
  var e2 = n && n.__esModule ? () => n.default : () => n;
  return a.d(e2, { a: e2 }), e2;
}, a.d = (n, e2) => {
  for (var t2 in e2) a.o(e2, t2) && !a.o(n, t2) && Object.defineProperty(n, t2, { enumerable: true, get: e2[t2] });
}, a.o = (n, e2) => Object.prototype.hasOwnProperty.call(n, e2), a.nc = void 0;
var o = {};
a.d(o, { A: () => k });
var i = (s = { default: () => __webpack_exports__default }, A = {}, a.d(A, s), A);
var s;
var A;
var c = ((n) => {
  var e2 = {};
  return a.d(e2, n), e2;
})({ default: () => e.default, useLayoutEffect: () => e.useLayoutEffect, useRef: () => e.useRef });
var l = a(591);
var u = a.n(l);
var p = a(740);
var d = a.n(p);
var f = a(128);
var m = a.n(f);
var E = a(855);
var C = a.n(E);
var y = a(51);
var v = a.n(y);
var g = a(656);
var h = a.n(g);
var B = a(32);
var b = {};
b.styleTagTransform = h(), b.setAttributes = C(), b.insert = m().bind(null, "head"), b.domAPI = d(), b.insertStyleElement = v(), u()(B.A, b), B.A && B.A.locals && B.A.locals;
var w = a(920);
var x2 = {};
function k(n) {
  let { onInit: e2, options: t2 } = n;
  const r2 = (0, c.useRef)(), a2 = (0, c.useRef)();
  return (0, c.useLayoutEffect)(() => {
    const n2 = { axes: false, fps: false, ...t2 == null ? void 0 : t2.settings };
    return function(n3, e3, t3) {
      if (!n3.current) {
        const r3 = new i.default(e3);
        r3.init() && (n3.current = r3, r3.run(), "function" == typeof t3 && t3(r3));
      }
    }(r2, { ...t2, container: a2.current, settings: n2 }, e2), () => function(n3) {
      n3.current && n3.current.term(), n3.current = null;
    }(r2);
  }, [e2, t2]), c.default.createElement("div", { className: B.z, ref: a2 }, "Viewer");
}
x2.styleTagTransform = h(), x2.setAttributes = C(), x2.insert = m().bind(null, "head"), x2.domAPI = d(), x2.insertStyleElement = v(), u()(w.A, x2), w.A && w.A.locals && w.A.locals;
var I = o.A;
export {
  I as default
};
/*! Bundled license information:

lodash/lodash.js:
  (**
   * @license
   * Lodash <https://lodash.com/>
   * Copyright OpenJS Foundation and other contributors <https://openjsf.org/>
   * Released under MIT license <https://lodash.com/license>
   * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
   * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
   *)

three/build/three.module.js:
  (**
   * @license
   * Copyright 2010-2023 Three.js Authors
   * SPDX-License-Identifier: MIT
   *)

miew/dist/Miew.module.js:
  (*! Miew - 3D Molecular Viewer v0.11.1 Copyright (c) 2015-2025 EPAM Systems, Inc. *)
*/
//# sourceMappingURL=miew-react.js.map
